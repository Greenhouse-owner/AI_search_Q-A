var vr = Object.defineProperty;
var qn = (e) => {
  throw TypeError(e);
};
var kr = (e, t, r) => t in e ? vr(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var ft = (e, t, r) => kr(e, typeof t != "symbol" ? t + "" : t, r), rn = (e, t, r) => t.has(e) || qn("Cannot " + r);
var G = (e, t, r) => (rn(e, t, "read from private field"), r ? r.call(e) : t.get(e)), we = (e, t, r) => t.has(e) ? qn("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), Ie = (e, t, r, a) => (rn(e, t, "write to private field"), a ? a.call(e, r) : t.set(e, r), r), _e = (e, t, r) => (rn(e, t, "access private method"), r);
var Mt = (e, t, r, a) => ({
  set _(o) {
    Ie(e, t, o, r);
  },
  get _() {
    return G(e, t, a);
  }
});
const React = window.ms_globals.React, useState = window.ms_globals.React.useState, useEffect = window.ms_globals.React.useEffect, useRef = window.ms_globals.React.useRef, useMemo = window.ms_globals.React.useMemo, ReactDOM = window.ms_globals.ReactDOMClient, StyleProvider = window.ms_globals.antdCssinjs.StyleProvider, legacyLogicalPropertiesTransformer = window.ms_globals.antdCssinjs.legacyLogicalPropertiesTransformer, Button = window.ms_globals.antd.Button, Image$3 = window.ms_globals.antd.Image, Collapse = window.ms_globals.antd.Collapse, Spin = window.ms_globals.antd.Spin, Row = window.ms_globals.antd.Row, Col = window.ms_globals.antd.Col, Card = window.ms_globals.antd.Card, Radio = window.ms_globals.antd.Radio, Space = window.ms_globals.antd.Space, Checkbox = window.ms_globals.antd.Checkbox, ConfigProvider = window.ms_globals.antd.ConfigProvider, theme = window.ms_globals.antd.theme, CaretLeftOutlined = window.ms_globals.antdIcons.CaretLeftOutlined, CaretRightOutlined = window.ms_globals.antdIcons.CaretRightOutlined, FileOutlined = window.ms_globals.antdIcons.FileOutlined, CheckOutlined = window.ms_globals.antdIcons.CheckOutlined, CopyOutlined = window.ms_globals.antdIcons.CopyOutlined, FilePdfOutlined = window.ms_globals.antdIcons.FilePdfOutlined, FileImageOutlined = window.ms_globals.antdIcons.FileImageOutlined;
var freeGlobal = typeof global == "object" && global && global.Object === Object && global, freeSelf = typeof self == "object" && self && self.Object === Object && self, root$7 = freeGlobal || freeSelf || Function("return this")(), Symbol$1 = root$7.Symbol, objectProto$b = Object.prototype, hasOwnProperty$a = objectProto$b.hasOwnProperty, nativeObjectToString$1 = objectProto$b.toString, symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
function getRawTag(e) {
  var t = hasOwnProperty$a.call(e, symToStringTag$1), r = e[symToStringTag$1];
  try {
    e[symToStringTag$1] = void 0;
    var a = !0;
  } catch {
  }
  var o = nativeObjectToString$1.call(e);
  return a && (t ? e[symToStringTag$1] = r : delete e[symToStringTag$1]), o;
}
var objectProto$a = Object.prototype, nativeObjectToString = objectProto$a.toString;
function objectToString(e) {
  return nativeObjectToString.call(e);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag(e) {
  return e == null ? e === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(e) ? getRawTag(e) : objectToString(e);
}
function isObjectLike(e) {
  return e != null && typeof e == "object";
}
var isArray$1 = Array.isArray;
function isObject(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction(e) {
  if (!isObject(e))
    return !1;
  var t = baseGetTag(e);
  return t == funcTag$1 || t == genTag || t == asyncTag || t == proxyTag;
}
var coreJsData = root$7["__core-js_shared__"], maskSrcKey = function() {
  var e = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function isMasked(e) {
  return !!maskSrcKey && maskSrcKey in e;
}
var funcProto$1 = Function.prototype, funcToString$1 = funcProto$1.toString;
function toSource(e) {
  if (e != null) {
    try {
      return funcToString$1.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto = Function.prototype, objectProto$9 = Object.prototype, funcToString = funcProto.toString, hasOwnProperty$9 = objectProto$9.hasOwnProperty, reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$9).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(e) {
  if (!isObject(e) || isMasked(e))
    return !1;
  var t = isFunction(e) ? reIsNative : reIsHostCtor;
  return t.test(toSource(e));
}
function getValue(e, t) {
  return e == null ? void 0 : e[t];
}
function getNative(e, t) {
  var r = getValue(e, t);
  return baseIsNative(r) ? r : void 0;
}
var WeakMap$1 = getNative(root$7, "WeakMap"), MAX_SAFE_INTEGER$1 = 9007199254740991, reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(e, t) {
  var r = typeof e;
  return t = t ?? MAX_SAFE_INTEGER$1, !!t && (r == "number" || r != "symbol" && reIsUint.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function eq(e, t) {
  return e === t || e !== e && t !== t;
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= MAX_SAFE_INTEGER;
}
function isArrayLike(e) {
  return e != null && isLength(e.length) && !isFunction(e);
}
var objectProto$8 = Object.prototype;
function isPrototype(e) {
  var t = e && e.constructor, r = typeof t == "function" && t.prototype || objectProto$8;
  return e === r;
}
function baseTimes(e, t) {
  for (var r = -1, a = Array(e); ++r < e; )
    a[r] = t(r);
  return a;
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(e) {
  return isObjectLike(e) && baseGetTag(e) == argsTag$2;
}
var objectProto$7 = Object.prototype, hasOwnProperty$8 = objectProto$7.hasOwnProperty, propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable, isArguments = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(e) {
  return isObjectLike(e) && hasOwnProperty$8.call(e, "callee") && !propertyIsEnumerable$1.call(e, "callee");
};
function stubFalse() {
  return !1;
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module, moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1, Buffer$1 = moduleExports$1 ? root$7.Buffer : void 0, nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0, isBuffer = nativeIsBuffer || stubFalse, argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]", arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = !1;
function baseIsTypedArray(e) {
  return isObjectLike(e) && isLength(e.length) && !!typedArrayTags[baseGetTag(e)];
}
function baseUnary(e) {
  return function(t) {
    return e(t);
  };
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, freeProcess = moduleExports && freeGlobal.process, nodeUtil = function() {
  try {
    var e = freeModule && freeModule.require && freeModule.require("util").types;
    return e || freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch {
  }
}(), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray, objectProto$6 = Object.prototype, hasOwnProperty$7 = objectProto$6.hasOwnProperty;
function arrayLikeKeys(e, t) {
  var r = isArray$1(e), a = !r && isArguments(e), o = !r && !a && isBuffer(e), u = !r && !a && !o && isTypedArray(e), c = r || a || o || u, d = c ? baseTimes(e.length, String) : [], g = d.length;
  for (var b in e)
    hasOwnProperty$7.call(e, b) && !(c && // Safari 9 has enumerable `arguments.length` in strict mode.
    (b == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    o && (b == "offset" || b == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    u && (b == "buffer" || b == "byteLength" || b == "byteOffset") || // Skip index properties.
    isIndex(b, g))) && d.push(b);
  return d;
}
function overArg(e, t) {
  return function(r) {
    return e(t(r));
  };
}
var nativeKeys = overArg(Object.keys, Object), objectProto$5 = Object.prototype, hasOwnProperty$6 = objectProto$5.hasOwnProperty;
function baseKeys(e) {
  if (!isPrototype(e))
    return nativeKeys(e);
  var t = [];
  for (var r in Object(e))
    hasOwnProperty$6.call(e, r) && r != "constructor" && t.push(r);
  return t;
}
function keys$1(e) {
  return isArrayLike(e) ? arrayLikeKeys(e) : baseKeys(e);
}
var nativeCreate = getNative(Object, "create");
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
}
function hashDelete(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__", objectProto$4 = Object.prototype, hasOwnProperty$5 = objectProto$4.hasOwnProperty;
function hashGet(e) {
  var t = this.__data__;
  if (nativeCreate) {
    var r = t[e];
    return r === HASH_UNDEFINED$2 ? void 0 : r;
  }
  return hasOwnProperty$5.call(t, e) ? t[e] : void 0;
}
var objectProto$3 = Object.prototype, hasOwnProperty$4 = objectProto$3.hasOwnProperty;
function hashHas(e) {
  var t = this.__data__;
  return nativeCreate ? t[e] !== void 0 : hasOwnProperty$4.call(t, e);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(e, t) {
  var r = this.__data__;
  return this.size += this.has(e) ? 0 : 1, r[e] = nativeCreate && t === void 0 ? HASH_UNDEFINED$1 : t, this;
}
function Hash(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var a = e[t];
    this.set(a[0], a[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype.delete = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [], this.size = 0;
}
function assocIndexOf(e, t) {
  for (var r = e.length; r--; )
    if (eq(e[r][0], t))
      return r;
  return -1;
}
var arrayProto = Array.prototype, splice$1 = arrayProto.splice;
function listCacheDelete(e) {
  var t = this.__data__, r = assocIndexOf(t, e);
  if (r < 0)
    return !1;
  var a = t.length - 1;
  return r == a ? t.pop() : splice$1.call(t, r, 1), --this.size, !0;
}
function listCacheGet(e) {
  var t = this.__data__, r = assocIndexOf(t, e);
  return r < 0 ? void 0 : t[r][1];
}
function listCacheHas(e) {
  return assocIndexOf(this.__data__, e) > -1;
}
function listCacheSet(e, t) {
  var r = this.__data__, a = assocIndexOf(r, e);
  return a < 0 ? (++this.size, r.push([e, t])) : r[a][1] = t, this;
}
function ListCache(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var a = e[t];
    this.set(a[0], a[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype.delete = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root$7, "Map");
function mapCacheClear() {
  this.size = 0, this.__data__ = {
    hash: new Hash(),
    map: new (Map$1 || ListCache)(),
    string: new Hash()
  };
}
function isKeyable(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function getMapData(e, t) {
  var r = e.__data__;
  return isKeyable(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map;
}
function mapCacheDelete(e) {
  var t = getMapData(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function mapCacheGet(e) {
  return getMapData(this, e).get(e);
}
function mapCacheHas(e) {
  return getMapData(this, e).has(e);
}
function mapCacheSet(e, t) {
  var r = getMapData(this, e), a = r.size;
  return r.set(e, t), this.size += r.size == a ? 0 : 1, this;
}
function MapCache(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var a = e[t];
    this.set(a[0], a[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype.delete = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function arrayPush$1(e, t) {
  for (var r = -1, a = t.length, o = e.length; ++r < a; )
    e[o + r] = t[r];
  return e;
}
function stackClear() {
  this.__data__ = new ListCache(), this.size = 0;
}
function stackDelete(e) {
  var t = this.__data__, r = t.delete(e);
  return this.size = t.size, r;
}
function stackGet(e) {
  return this.__data__.get(e);
}
function stackHas(e) {
  return this.__data__.has(e);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(e, t) {
  var r = this.__data__;
  if (r instanceof ListCache) {
    var a = r.__data__;
    if (!Map$1 || a.length < LARGE_ARRAY_SIZE - 1)
      return a.push([e, t]), this.size = ++r.size, this;
    r = this.__data__ = new MapCache(a);
  }
  return r.set(e, t), this.size = r.size, this;
}
function Stack(e) {
  var t = this.__data__ = new ListCache(e);
  this.size = t.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype.delete = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function arrayFilter(e, t) {
  for (var r = -1, a = e == null ? 0 : e.length, o = 0, u = []; ++r < a; ) {
    var c = e[r];
    t(c, r, e) && (u[o++] = c);
  }
  return u;
}
function stubArray() {
  return [];
}
var objectProto$2 = Object.prototype, propertyIsEnumerable = objectProto$2.propertyIsEnumerable, nativeGetSymbols = Object.getOwnPropertySymbols, getSymbols = nativeGetSymbols ? function(e) {
  return e == null ? [] : (e = Object(e), arrayFilter(nativeGetSymbols(e), function(t) {
    return propertyIsEnumerable.call(e, t);
  }));
} : stubArray;
function baseGetAllKeys(e, t, r) {
  var a = t(e);
  return isArray$1(e) ? a : arrayPush$1(a, r(e));
}
function getAllKeys(e) {
  return baseGetAllKeys(e, keys$1, getSymbols);
}
var DataView$1 = getNative(root$7, "DataView"), Promise$1 = getNative(root$7, "Promise"), Set$1 = getNative(root$7, "Set"), mapTag$1 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$1 = "[object Set]", weakMapTag = "[object WeakMap]", dataViewTag$1 = "[object DataView]", dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1), getTag = baseGetTag;
(DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$1 || Map$1 && getTag(new Map$1()) != mapTag$1 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$1 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag) && (getTag = function(e) {
  var t = baseGetTag(e), r = t == objectTag$1 ? e.constructor : void 0, a = r ? toSource(r) : "";
  if (a)
    switch (a) {
      case dataViewCtorString:
        return dataViewTag$1;
      case mapCtorString:
        return mapTag$1;
      case promiseCtorString:
        return promiseTag;
      case setCtorString:
        return setTag$1;
      case weakMapCtorString:
        return weakMapTag;
    }
  return t;
});
var Uint8Array$1 = root$7.Uint8Array, HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(e) {
  return this.__data__.set(e, HASH_UNDEFINED), this;
}
function setCacheHas(e) {
  return this.__data__.has(e);
}
function SetCache(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.__data__ = new MapCache(); ++t < r; )
    this.add(e[t]);
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(e, t) {
  for (var r = -1, a = e == null ? 0 : e.length; ++r < a; )
    if (t(e[r], r, e))
      return !0;
  return !1;
}
function cacheHas(e, t) {
  return e.has(t);
}
var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function equalArrays(e, t, r, a, o, u) {
  var c = r & COMPARE_PARTIAL_FLAG$3, d = e.length, g = t.length;
  if (d != g && !(c && g > d))
    return !1;
  var b = u.get(e), _ = u.get(t);
  if (b && _)
    return b == t && _ == e;
  var y = -1, A = !0, E = r & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
  for (u.set(e, t), u.set(t, e); ++y < d; ) {
    var v = e[y], C = t[y];
    if (a)
      var R = c ? a(C, v, y, t, e, u) : a(v, C, y, e, t, u);
    if (R !== void 0) {
      if (R)
        continue;
      A = !1;
      break;
    }
    if (E) {
      if (!arraySome(t, function(I, w) {
        if (!cacheHas(E, w) && (v === I || o(v, I, r, a, u)))
          return E.push(w);
      })) {
        A = !1;
        break;
      }
    } else if (!(v === C || o(v, C, r, a, u))) {
      A = !1;
      break;
    }
  }
  return u.delete(e), u.delete(t), A;
}
function mapToArray(e) {
  var t = -1, r = Array(e.size);
  return e.forEach(function(a, o) {
    r[++t] = [o, a];
  }), r;
}
function setToArray(e) {
  var t = -1, r = Array(e.size);
  return e.forEach(function(a) {
    r[++t] = a;
  }), r;
}
var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2, boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(e, t, r, a, o, u, c) {
  switch (r) {
    case dataViewTag:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case arrayBufferTag:
      return !(e.byteLength != t.byteLength || !u(new Uint8Array$1(e), new Uint8Array$1(t)));
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+e, +t);
    case errorTag:
      return e.name == t.name && e.message == t.message;
    case regexpTag:
    case stringTag:
      return e == t + "";
    case mapTag:
      var d = mapToArray;
    case setTag:
      var g = a & COMPARE_PARTIAL_FLAG$2;
      if (d || (d = setToArray), e.size != t.size && !g)
        return !1;
      var b = c.get(e);
      if (b)
        return b == t;
      a |= COMPARE_UNORDERED_FLAG, c.set(e, t);
      var _ = equalArrays(d(e), d(t), a, o, u, c);
      return c.delete(e), _;
    case symbolTag:
      if (symbolValueOf)
        return symbolValueOf.call(e) == symbolValueOf.call(t);
  }
  return !1;
}
var COMPARE_PARTIAL_FLAG$1 = 1, objectProto$1 = Object.prototype, hasOwnProperty$3 = objectProto$1.hasOwnProperty;
function equalObjects(e, t, r, a, o, u) {
  var c = r & COMPARE_PARTIAL_FLAG$1, d = getAllKeys(e), g = d.length, b = getAllKeys(t), _ = b.length;
  if (g != _ && !c)
    return !1;
  for (var y = g; y--; ) {
    var A = d[y];
    if (!(c ? A in t : hasOwnProperty$3.call(t, A)))
      return !1;
  }
  var E = u.get(e), v = u.get(t);
  if (E && v)
    return E == t && v == e;
  var C = !0;
  u.set(e, t), u.set(t, e);
  for (var R = c; ++y < g; ) {
    A = d[y];
    var I = e[A], w = t[A];
    if (a)
      var N = c ? a(w, I, A, t, e, u) : a(I, w, A, e, t, u);
    if (!(N === void 0 ? I === w || o(I, w, r, a, u) : N)) {
      C = !1;
      break;
    }
    R || (R = A == "constructor");
  }
  if (C && !R) {
    var F = e.constructor, M = t.constructor;
    F != M && "constructor" in e && "constructor" in t && !(typeof F == "function" && F instanceof F && typeof M == "function" && M instanceof M) && (C = !1);
  }
  return u.delete(e), u.delete(t), C;
}
var COMPARE_PARTIAL_FLAG = 1, argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]", objectProto = Object.prototype, hasOwnProperty$2 = objectProto.hasOwnProperty;
function baseIsEqualDeep(e, t, r, a, o, u) {
  var c = isArray$1(e), d = isArray$1(t), g = c ? arrayTag : getTag(e), b = d ? arrayTag : getTag(t);
  g = g == argsTag ? objectTag : g, b = b == argsTag ? objectTag : b;
  var _ = g == objectTag, y = b == objectTag, A = g == b;
  if (A && isBuffer(e)) {
    if (!isBuffer(t))
      return !1;
    c = !0, _ = !1;
  }
  if (A && !_)
    return u || (u = new Stack()), c || isTypedArray(e) ? equalArrays(e, t, r, a, o, u) : equalByTag(e, t, g, r, a, o, u);
  if (!(r & COMPARE_PARTIAL_FLAG)) {
    var E = _ && hasOwnProperty$2.call(e, "__wrapped__"), v = y && hasOwnProperty$2.call(t, "__wrapped__");
    if (E || v) {
      var C = E ? e.value() : e, R = v ? t.value() : t;
      return u || (u = new Stack()), o(C, R, r, a, u);
    }
  }
  return A ? (u || (u = new Stack()), equalObjects(e, t, r, a, o, u)) : !1;
}
function baseIsEqual(e, t, r, a, o) {
  return e === t ? !0 : e == null || t == null || !isObjectLike(e) && !isObjectLike(t) ? e !== e && t !== t : baseIsEqualDeep(e, t, r, a, baseIsEqual, o);
}
function isEqual(e, t) {
  return baseIsEqual(e, t);
}
const {
  SvelteComponent: SvelteComponent$2n,
  assign: assign$7,
  children: children$2h,
  claim_element: claim_element$r,
  create_slot: create_slot$a,
  detach: detach$2h,
  element: element$z,
  get_all_dirty_from_scope: get_all_dirty_from_scope$a,
  get_slot_changes: get_slot_changes$a,
  get_spread_update: get_spread_update$6,
  init: init$2n,
  insert_hydration: insert_hydration$2h,
  safe_not_equal: safe_not_equal$2o,
  set_dynamic_element_data: set_dynamic_element_data$1,
  set_style: set_style$c,
  toggle_class: toggle_class$j,
  transition_in: transition_in$u,
  transition_out: transition_out$u,
  update_slot_base: update_slot_base$a
} = window.__gradio__svelte__internal;
function create_dynamic_element(e) {
  let t, r, a;
  const o = (
    /*#slots*/
    e[18].default
  ), u = create_slot$a(
    o,
    e,
    /*$$scope*/
    e[17],
    null
  );
  let c = [{
    "data-testid": (
      /*test_id*/
      e[7]
    )
  }, {
    id: (
      /*elem_id*/
      e[2]
    )
  }, {
    class: r = "block " + /*elem_classes*/
    e[3].join(" ") + " svelte-nl1om8"
  }], d = {};
  for (let g = 0; g < c.length; g += 1)
    d = assign$7(d, c[g]);
  return {
    c() {
      t = element$z(
        /*tag*/
        e[14]
      ), u && u.c(), this.h();
    },
    l(g) {
      t = claim_element$r(
        g,
        /*tag*/
        (e[14] || "null").toUpperCase(),
        {
          "data-testid": !0,
          id: !0,
          class: !0
        }
      );
      var b = children$2h(t);
      u && u.l(b), b.forEach(detach$2h), this.h();
    },
    h() {
      set_dynamic_element_data$1(
        /*tag*/
        e[14]
      )(t, d), toggle_class$j(
        t,
        "hidden",
        /*visible*/
        e[10] === !1
      ), toggle_class$j(
        t,
        "padded",
        /*padding*/
        e[6]
      ), toggle_class$j(
        t,
        "border_focus",
        /*border_mode*/
        e[5] === "focus"
      ), toggle_class$j(
        t,
        "border_contrast",
        /*border_mode*/
        e[5] === "contrast"
      ), toggle_class$j(t, "hide-container", !/*explicit_call*/
      e[8] && !/*container*/
      e[9]), set_style$c(
        t,
        "height",
        /*get_dimension*/
        e[15](
          /*height*/
          e[0]
        )
      ), set_style$c(t, "width", typeof /*width*/
      e[1] == "number" ? `calc(min(${/*width*/
      e[1]}px, 100%))` : (
        /*get_dimension*/
        e[15](
          /*width*/
          e[1]
        )
      )), set_style$c(
        t,
        "border-style",
        /*variant*/
        e[4]
      ), set_style$c(
        t,
        "overflow",
        /*allow_overflow*/
        e[11] ? "visible" : "hidden"
      ), set_style$c(
        t,
        "flex-grow",
        /*scale*/
        e[12]
      ), set_style$c(t, "min-width", `calc(min(${/*min_width*/
      e[13]}px, 100%))`), set_style$c(t, "border-width", "var(--block-border-width)");
    },
    m(g, b) {
      insert_hydration$2h(g, t, b), u && u.m(t, null), a = !0;
    },
    p(g, b) {
      u && u.p && (!a || b & /*$$scope*/
      131072) && update_slot_base$a(
        u,
        o,
        g,
        /*$$scope*/
        g[17],
        a ? get_slot_changes$a(
          o,
          /*$$scope*/
          g[17],
          b,
          null
        ) : get_all_dirty_from_scope$a(
          /*$$scope*/
          g[17]
        ),
        null
      ), set_dynamic_element_data$1(
        /*tag*/
        g[14]
      )(t, d = get_spread_update$6(c, [(!a || b & /*test_id*/
      128) && {
        "data-testid": (
          /*test_id*/
          g[7]
        )
      }, (!a || b & /*elem_id*/
      4) && {
        id: (
          /*elem_id*/
          g[2]
        )
      }, (!a || b & /*elem_classes*/
      8 && r !== (r = "block " + /*elem_classes*/
      g[3].join(" ") + " svelte-nl1om8")) && {
        class: r
      }])), toggle_class$j(
        t,
        "hidden",
        /*visible*/
        g[10] === !1
      ), toggle_class$j(
        t,
        "padded",
        /*padding*/
        g[6]
      ), toggle_class$j(
        t,
        "border_focus",
        /*border_mode*/
        g[5] === "focus"
      ), toggle_class$j(
        t,
        "border_contrast",
        /*border_mode*/
        g[5] === "contrast"
      ), toggle_class$j(t, "hide-container", !/*explicit_call*/
      g[8] && !/*container*/
      g[9]), b & /*height*/
      1 && set_style$c(
        t,
        "height",
        /*get_dimension*/
        g[15](
          /*height*/
          g[0]
        )
      ), b & /*width*/
      2 && set_style$c(t, "width", typeof /*width*/
      g[1] == "number" ? `calc(min(${/*width*/
      g[1]}px, 100%))` : (
        /*get_dimension*/
        g[15](
          /*width*/
          g[1]
        )
      )), b & /*variant*/
      16 && set_style$c(
        t,
        "border-style",
        /*variant*/
        g[4]
      ), b & /*allow_overflow*/
      2048 && set_style$c(
        t,
        "overflow",
        /*allow_overflow*/
        g[11] ? "visible" : "hidden"
      ), b & /*scale*/
      4096 && set_style$c(
        t,
        "flex-grow",
        /*scale*/
        g[12]
      ), b & /*min_width*/
      8192 && set_style$c(t, "min-width", `calc(min(${/*min_width*/
      g[13]}px, 100%))`);
    },
    i(g) {
      a || (transition_in$u(u, g), a = !0);
    },
    o(g) {
      transition_out$u(u, g), a = !1;
    },
    d(g) {
      g && detach$2h(t), u && u.d(g);
    }
  };
}
function create_fragment$n(e) {
  let t, r = (
    /*tag*/
    e[14] && create_dynamic_element(e)
  );
  return {
    c() {
      r && r.c();
    },
    l(a) {
      r && r.l(a);
    },
    m(a, o) {
      r && r.m(a, o), t = !0;
    },
    p(a, [o]) {
      /*tag*/
      a[14] && r.p(a, o);
    },
    i(a) {
      t || (transition_in$u(r, a), t = !0);
    },
    o(a) {
      transition_out$u(r, a), t = !1;
    },
    d(a) {
      r && r.d(a);
    }
  };
}
function instance$i(e, t, r) {
  let {
    $$slots: a = {},
    $$scope: o
  } = t, {
    height: u = void 0
  } = t, {
    width: c = void 0
  } = t, {
    elem_id: d = ""
  } = t, {
    elem_classes: g = []
  } = t, {
    variant: b = "solid"
  } = t, {
    border_mode: _ = "base"
  } = t, {
    padding: y = !0
  } = t, {
    type: A = "normal"
  } = t, {
    test_id: E = void 0
  } = t, {
    explicit_call: v = !1
  } = t, {
    container: C = !0
  } = t, {
    visible: R = !0
  } = t, {
    allow_overflow: I = !0
  } = t, {
    scale: w = null
  } = t, {
    min_width: N = 0
  } = t, F = A === "fieldset" ? "fieldset" : "div";
  const M = (x) => {
    if (x !== void 0) {
      if (typeof x == "number")
        return x + "px";
      if (typeof x == "string")
        return x;
    }
  };
  return e.$$set = (x) => {
    "height" in x && r(0, u = x.height), "width" in x && r(1, c = x.width), "elem_id" in x && r(2, d = x.elem_id), "elem_classes" in x && r(3, g = x.elem_classes), "variant" in x && r(4, b = x.variant), "border_mode" in x && r(5, _ = x.border_mode), "padding" in x && r(6, y = x.padding), "type" in x && r(16, A = x.type), "test_id" in x && r(7, E = x.test_id), "explicit_call" in x && r(8, v = x.explicit_call), "container" in x && r(9, C = x.container), "visible" in x && r(10, R = x.visible), "allow_overflow" in x && r(11, I = x.allow_overflow), "scale" in x && r(12, w = x.scale), "min_width" in x && r(13, N = x.min_width), "$$scope" in x && r(17, o = x.$$scope);
  }, [u, c, d, g, b, _, y, E, v, C, R, I, w, N, F, M, A, o, a];
}
class Block extends SvelteComponent$2n {
  constructor(t) {
    super(), init$2n(this, t, instance$i, create_fragment$n, safe_not_equal$2o, {
      height: 0,
      width: 1,
      elem_id: 2,
      elem_classes: 3,
      variant: 4,
      border_mode: 5,
      padding: 6,
      type: 16,
      test_id: 7,
      explicit_call: 8,
      container: 9,
      visible: 10,
      allow_overflow: 11,
      scale: 12,
      min_width: 13
    });
  }
}
const {
  SvelteComponent: SvelteComponent$2m,
  attr: attr$2f,
  children: children$2g,
  claim_element: claim_element$q,
  create_slot: create_slot$9,
  detach: detach$2g,
  element: element$y,
  get_all_dirty_from_scope: get_all_dirty_from_scope$9,
  get_slot_changes: get_slot_changes$9,
  init: init$2m,
  insert_hydration: insert_hydration$2g,
  safe_not_equal: safe_not_equal$2n,
  transition_in: transition_in$t,
  transition_out: transition_out$t,
  update_slot_base: update_slot_base$9
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$2l,
  attr: attr$2e,
  check_outros: check_outros$b,
  children: children$2f,
  claim_component: claim_component$m,
  claim_element: claim_element$p,
  claim_space: claim_space$f,
  claim_text: claim_text$i,
  create_component: create_component$m,
  create_slot: create_slot$8,
  destroy_component: destroy_component$m,
  detach: detach$2f,
  element: element$x,
  empty: empty$a,
  get_all_dirty_from_scope: get_all_dirty_from_scope$8,
  get_slot_changes: get_slot_changes$8,
  group_outros: group_outros$b,
  init: init$2l,
  insert_hydration: insert_hydration$2f,
  mount_component: mount_component$m,
  safe_not_equal: safe_not_equal$2m,
  set_data: set_data$a,
  space: space$j,
  text: text$u,
  toggle_class: toggle_class$i,
  transition_in: transition_in$s,
  transition_out: transition_out$s,
  update_slot_base: update_slot_base$8
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$2k,
  append_hydration: append_hydration$26,
  attr: attr$2d,
  children: children$2e,
  claim_component: claim_component$l,
  claim_element: claim_element$o,
  claim_space: claim_space$e,
  claim_text: claim_text$h,
  create_component: create_component$l,
  destroy_component: destroy_component$l,
  detach: detach$2e,
  element: element$w,
  init: init$2k,
  insert_hydration: insert_hydration$2e,
  mount_component: mount_component$l,
  safe_not_equal: safe_not_equal$2l,
  set_data: set_data$9,
  space: space$i,
  text: text$t,
  toggle_class: toggle_class$h,
  transition_in: transition_in$r,
  transition_out: transition_out$r
} = window.__gradio__svelte__internal;
function create_fragment$m(e) {
  let t, r, a, o, u, c;
  return a = new /*Icon*/
  e[1]({}), {
    c() {
      t = element$w("label"), r = element$w("span"), create_component$l(a.$$.fragment), o = space$i(), u = text$t(
        /*label*/
        e[0]
      ), this.h();
    },
    l(d) {
      t = claim_element$o(d, "LABEL", {
        for: !0,
        "data-testid": !0,
        class: !0
      });
      var g = children$2e(t);
      r = claim_element$o(g, "SPAN", {
        class: !0
      });
      var b = children$2e(r);
      claim_component$l(a.$$.fragment, b), b.forEach(detach$2e), o = claim_space$e(g), u = claim_text$h(
        g,
        /*label*/
        e[0]
      ), g.forEach(detach$2e), this.h();
    },
    h() {
      attr$2d(r, "class", "svelte-9gxdi0"), attr$2d(t, "for", ""), attr$2d(t, "data-testid", "block-label"), attr$2d(t, "class", "svelte-9gxdi0"), toggle_class$h(t, "hide", !/*show_label*/
      e[2]), toggle_class$h(t, "sr-only", !/*show_label*/
      e[2]), toggle_class$h(
        t,
        "float",
        /*float*/
        e[4]
      ), toggle_class$h(
        t,
        "hide-label",
        /*disable*/
        e[3]
      );
    },
    m(d, g) {
      insert_hydration$2e(d, t, g), append_hydration$26(t, r), mount_component$l(a, r, null), append_hydration$26(t, o), append_hydration$26(t, u), c = !0;
    },
    p(d, [g]) {
      (!c || g & /*label*/
      1) && set_data$9(
        u,
        /*label*/
        d[0]
      ), (!c || g & /*show_label*/
      4) && toggle_class$h(t, "hide", !/*show_label*/
      d[2]), (!c || g & /*show_label*/
      4) && toggle_class$h(t, "sr-only", !/*show_label*/
      d[2]), (!c || g & /*float*/
      16) && toggle_class$h(
        t,
        "float",
        /*float*/
        d[4]
      ), (!c || g & /*disable*/
      8) && toggle_class$h(
        t,
        "hide-label",
        /*disable*/
        d[3]
      );
    },
    i(d) {
      c || (transition_in$r(a.$$.fragment, d), c = !0);
    },
    o(d) {
      transition_out$r(a.$$.fragment, d), c = !1;
    },
    d(d) {
      d && detach$2e(t), destroy_component$l(a);
    }
  };
}
function instance$h(e, t, r) {
  let {
    label: a = null
  } = t, {
    Icon: o
  } = t, {
    show_label: u = !0
  } = t, {
    disable: c = !1
  } = t, {
    float: d = !0
  } = t;
  return e.$$set = (g) => {
    "label" in g && r(0, a = g.label), "Icon" in g && r(1, o = g.Icon), "show_label" in g && r(2, u = g.show_label), "disable" in g && r(3, c = g.disable), "float" in g && r(4, d = g.float);
  }, [a, o, u, c, d];
}
class BlockLabel extends SvelteComponent$2k {
  constructor(t) {
    super(), init$2k(this, t, instance$h, create_fragment$m, safe_not_equal$2l, {
      label: 0,
      Icon: 1,
      show_label: 2,
      disable: 3,
      float: 4
    });
  }
}
const {
  SvelteComponent: SvelteComponent$2j,
  append_hydration: append_hydration$25,
  attr: attr$2c,
  bubble: bubble$4,
  children: children$2d,
  claim_component: claim_component$k,
  claim_element: claim_element$n,
  claim_space: claim_space$d,
  claim_text: claim_text$g,
  create_component: create_component$k,
  destroy_component: destroy_component$k,
  detach: detach$2d,
  element: element$v,
  init: init$2j,
  insert_hydration: insert_hydration$2d,
  listen: listen$7,
  mount_component: mount_component$k,
  safe_not_equal: safe_not_equal$2k,
  set_data: set_data$8,
  set_style: set_style$b,
  space: space$h,
  text: text$s,
  toggle_class: toggle_class$g,
  transition_in: transition_in$q,
  transition_out: transition_out$q
} = window.__gradio__svelte__internal;
function create_if_block$5(e) {
  let t, r;
  return {
    c() {
      t = element$v("span"), r = text$s(
        /*label*/
        e[1]
      ), this.h();
    },
    l(a) {
      t = claim_element$n(a, "SPAN", {
        class: !0
      });
      var o = children$2d(t);
      r = claim_text$g(
        o,
        /*label*/
        e[1]
      ), o.forEach(detach$2d), this.h();
    },
    h() {
      attr$2c(t, "class", "svelte-1lrphxw");
    },
    m(a, o) {
      insert_hydration$2d(a, t, o), append_hydration$25(t, r);
    },
    p(a, o) {
      o & /*label*/
      2 && set_data$8(
        r,
        /*label*/
        a[1]
      );
    },
    d(a) {
      a && detach$2d(t);
    }
  };
}
function create_fragment$l(e) {
  let t, r, a, o, u, c, d, g = (
    /*show_label*/
    e[2] && create_if_block$5(e)
  );
  return o = new /*Icon*/
  e[0]({}), {
    c() {
      t = element$v("button"), g && g.c(), r = space$h(), a = element$v("div"), create_component$k(o.$$.fragment), this.h();
    },
    l(b) {
      t = claim_element$n(b, "BUTTON", {
        "aria-label": !0,
        "aria-haspopup": !0,
        title: !0,
        class: !0
      });
      var _ = children$2d(t);
      g && g.l(_), r = claim_space$d(_), a = claim_element$n(_, "DIV", {
        class: !0
      });
      var y = children$2d(a);
      claim_component$k(o.$$.fragment, y), y.forEach(detach$2d), _.forEach(detach$2d), this.h();
    },
    h() {
      attr$2c(a, "class", "svelte-1lrphxw"), toggle_class$g(
        a,
        "small",
        /*size*/
        e[4] === "small"
      ), toggle_class$g(
        a,
        "large",
        /*size*/
        e[4] === "large"
      ), toggle_class$g(
        a,
        "medium",
        /*size*/
        e[4] === "medium"
      ), t.disabled = /*disabled*/
      e[7], attr$2c(
        t,
        "aria-label",
        /*label*/
        e[1]
      ), attr$2c(
        t,
        "aria-haspopup",
        /*hasPopup*/
        e[8]
      ), attr$2c(
        t,
        "title",
        /*label*/
        e[1]
      ), attr$2c(t, "class", "svelte-1lrphxw"), toggle_class$g(
        t,
        "pending",
        /*pending*/
        e[3]
      ), toggle_class$g(
        t,
        "padded",
        /*padded*/
        e[5]
      ), toggle_class$g(
        t,
        "highlight",
        /*highlight*/
        e[6]
      ), toggle_class$g(
        t,
        "transparent",
        /*transparent*/
        e[9]
      ), set_style$b(t, "color", !/*disabled*/
      e[7] && /*_color*/
      e[12] ? (
        /*_color*/
        e[12]
      ) : "var(--block-label-text-color)"), set_style$b(t, "--bg-color", /*disabled*/
      e[7] ? "auto" : (
        /*background*/
        e[10]
      )), set_style$b(
        t,
        "margin-left",
        /*offset*/
        e[11] + "px"
      );
    },
    m(b, _) {
      insert_hydration$2d(b, t, _), g && g.m(t, null), append_hydration$25(t, r), append_hydration$25(t, a), mount_component$k(o, a, null), u = !0, c || (d = listen$7(
        t,
        "click",
        /*click_handler*/
        e[14]
      ), c = !0);
    },
    p(b, [_]) {
      /*show_label*/
      b[2] ? g ? g.p(b, _) : (g = create_if_block$5(b), g.c(), g.m(t, r)) : g && (g.d(1), g = null), (!u || _ & /*size*/
      16) && toggle_class$g(
        a,
        "small",
        /*size*/
        b[4] === "small"
      ), (!u || _ & /*size*/
      16) && toggle_class$g(
        a,
        "large",
        /*size*/
        b[4] === "large"
      ), (!u || _ & /*size*/
      16) && toggle_class$g(
        a,
        "medium",
        /*size*/
        b[4] === "medium"
      ), (!u || _ & /*disabled*/
      128) && (t.disabled = /*disabled*/
      b[7]), (!u || _ & /*label*/
      2) && attr$2c(
        t,
        "aria-label",
        /*label*/
        b[1]
      ), (!u || _ & /*hasPopup*/
      256) && attr$2c(
        t,
        "aria-haspopup",
        /*hasPopup*/
        b[8]
      ), (!u || _ & /*label*/
      2) && attr$2c(
        t,
        "title",
        /*label*/
        b[1]
      ), (!u || _ & /*pending*/
      8) && toggle_class$g(
        t,
        "pending",
        /*pending*/
        b[3]
      ), (!u || _ & /*padded*/
      32) && toggle_class$g(
        t,
        "padded",
        /*padded*/
        b[5]
      ), (!u || _ & /*highlight*/
      64) && toggle_class$g(
        t,
        "highlight",
        /*highlight*/
        b[6]
      ), (!u || _ & /*transparent*/
      512) && toggle_class$g(
        t,
        "transparent",
        /*transparent*/
        b[9]
      ), _ & /*disabled, _color*/
      4224 && set_style$b(t, "color", !/*disabled*/
      b[7] && /*_color*/
      b[12] ? (
        /*_color*/
        b[12]
      ) : "var(--block-label-text-color)"), _ & /*disabled, background*/
      1152 && set_style$b(t, "--bg-color", /*disabled*/
      b[7] ? "auto" : (
        /*background*/
        b[10]
      )), _ & /*offset*/
      2048 && set_style$b(
        t,
        "margin-left",
        /*offset*/
        b[11] + "px"
      );
    },
    i(b) {
      u || (transition_in$q(o.$$.fragment, b), u = !0);
    },
    o(b) {
      transition_out$q(o.$$.fragment, b), u = !1;
    },
    d(b) {
      b && detach$2d(t), g && g.d(), destroy_component$k(o), c = !1, d();
    }
  };
}
function instance$g(e, t, r) {
  let a, {
    Icon: o
  } = t, {
    label: u = ""
  } = t, {
    show_label: c = !1
  } = t, {
    pending: d = !1
  } = t, {
    size: g = "small"
  } = t, {
    padded: b = !0
  } = t, {
    highlight: _ = !1
  } = t, {
    disabled: y = !1
  } = t, {
    hasPopup: A = !1
  } = t, {
    color: E = "var(--block-label-text-color)"
  } = t, {
    transparent: v = !1
  } = t, {
    background: C = "var(--background-fill-primary)"
  } = t, {
    offset: R = 0
  } = t;
  function I(w) {
    bubble$4.call(this, e, w);
  }
  return e.$$set = (w) => {
    "Icon" in w && r(0, o = w.Icon), "label" in w && r(1, u = w.label), "show_label" in w && r(2, c = w.show_label), "pending" in w && r(3, d = w.pending), "size" in w && r(4, g = w.size), "padded" in w && r(5, b = w.padded), "highlight" in w && r(6, _ = w.highlight), "disabled" in w && r(7, y = w.disabled), "hasPopup" in w && r(8, A = w.hasPopup), "color" in w && r(13, E = w.color), "transparent" in w && r(9, v = w.transparent), "background" in w && r(10, C = w.background), "offset" in w && r(11, R = w.offset);
  }, e.$$.update = () => {
    e.$$.dirty & /*highlight, color*/
    8256 && r(12, a = _ ? "var(--color-accent)" : E);
  }, [o, u, c, d, g, b, _, y, A, v, C, R, a, E, I];
}
let IconButton$1 = class extends SvelteComponent$2j {
  constructor(t) {
    super(), init$2j(this, t, instance$g, create_fragment$l, safe_not_equal$2k, {
      Icon: 0,
      label: 1,
      show_label: 2,
      pending: 3,
      size: 4,
      padded: 5,
      highlight: 6,
      disabled: 7,
      hasPopup: 8,
      color: 13,
      transparent: 9,
      background: 10,
      offset: 11
    });
  }
};
const {
  SvelteComponent: SvelteComponent$2i,
  append_hydration: append_hydration$24,
  attr: attr$2b,
  binding_callbacks: binding_callbacks$4,
  children: children$2c,
  claim_element: claim_element$m,
  create_slot: create_slot$7,
  detach: detach$2c,
  element: element$u,
  get_all_dirty_from_scope: get_all_dirty_from_scope$7,
  get_slot_changes: get_slot_changes$7,
  init: init$2i,
  insert_hydration: insert_hydration$2c,
  safe_not_equal: safe_not_equal$2j,
  toggle_class: toggle_class$f,
  transition_in: transition_in$p,
  transition_out: transition_out$p,
  update_slot_base: update_slot_base$7
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$2h,
  append_hydration: append_hydration$23,
  attr: attr$2a,
  children: children$2b,
  claim_svg_element: claim_svg_element$1S,
  detach: detach$2b,
  init: init$2h,
  insert_hydration: insert_hydration$2b,
  noop: noop$1Y,
  safe_not_equal: safe_not_equal$2i,
  svg_element: svg_element$1S
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$2g,
  append_hydration: append_hydration$22,
  attr: attr$29,
  children: children$2a,
  claim_svg_element: claim_svg_element$1R,
  detach: detach$2a,
  init: init$2g,
  insert_hydration: insert_hydration$2a,
  noop: noop$1X,
  safe_not_equal: safe_not_equal$2h,
  svg_element: svg_element$1R
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$2f,
  append_hydration: append_hydration$21,
  attr: attr$28,
  children: children$29,
  claim_svg_element: claim_svg_element$1Q,
  detach: detach$29,
  init: init$2f,
  insert_hydration: insert_hydration$29,
  noop: noop$1W,
  safe_not_equal: safe_not_equal$2g,
  svg_element: svg_element$1Q
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$2e,
  append_hydration: append_hydration$20,
  attr: attr$27,
  children: children$28,
  claim_svg_element: claim_svg_element$1P,
  detach: detach$28,
  init: init$2e,
  insert_hydration: insert_hydration$28,
  noop: noop$1V,
  safe_not_equal: safe_not_equal$2f,
  svg_element: svg_element$1P
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$2d,
  append_hydration: append_hydration$1$,
  attr: attr$26,
  children: children$27,
  claim_svg_element: claim_svg_element$1O,
  detach: detach$27,
  init: init$2d,
  insert_hydration: insert_hydration$27,
  noop: noop$1U,
  safe_not_equal: safe_not_equal$2e,
  svg_element: svg_element$1O
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$2c,
  append_hydration: append_hydration$1_,
  attr: attr$25,
  children: children$26,
  claim_svg_element: claim_svg_element$1N,
  detach: detach$26,
  init: init$2c,
  insert_hydration: insert_hydration$26,
  noop: noop$1T,
  safe_not_equal: safe_not_equal$2d,
  svg_element: svg_element$1N
} = window.__gradio__svelte__internal;
function create_fragment$k(e) {
  let t, r, a;
  return {
    c() {
      t = svg_element$1N("svg"), r = svg_element$1N("path"), a = svg_element$1N("path"), this.h();
    },
    l(o) {
      t = claim_svg_element$1N(o, "svg", {
        xmlns: !0,
        "xmlns:xlink": !0,
        "aria-hidden": !0,
        role: !0,
        class: !0,
        width: !0,
        height: !0,
        preserveAspectRatio: !0,
        viewBox: !0
      });
      var u = children$26(t);
      r = claim_svg_element$1N(u, "path", {
        fill: !0,
        d: !0
      }), children$26(r).forEach(detach$26), a = claim_svg_element$1N(u, "path", {
        fill: !0,
        d: !0
      }), children$26(a).forEach(detach$26), u.forEach(detach$26), this.h();
    },
    h() {
      attr$25(r, "fill", "currentColor"), attr$25(r, "d", "M17.74 30L16 29l4-7h6a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h9v2H6a4 4 0 0 1-4-4V8a4 4 0 0 1 4-4h20a4 4 0 0 1 4 4v12a4 4 0 0 1-4 4h-4.84Z"), attr$25(a, "fill", "currentColor"), attr$25(a, "d", "M8 10h16v2H8zm0 6h10v2H8z"), attr$25(t, "xmlns", "http://www.w3.org/2000/svg"), attr$25(t, "xmlns:xlink", "http://www.w3.org/1999/xlink"), attr$25(t, "aria-hidden", "true"), attr$25(t, "role", "img"), attr$25(t, "class", "iconify iconify--carbon"), attr$25(t, "width", "100%"), attr$25(t, "height", "100%"), attr$25(t, "preserveAspectRatio", "xMidYMid meet"), attr$25(t, "viewBox", "0 0 32 32");
    },
    m(o, u) {
      insert_hydration$26(o, t, u), append_hydration$1_(t, r), append_hydration$1_(t, a);
    },
    p: noop$1T,
    i: noop$1T,
    o: noop$1T,
    d(o) {
      o && detach$26(t);
    }
  };
}
class Chat extends SvelteComponent$2c {
  constructor(t) {
    super(), init$2c(this, t, null, create_fragment$k, safe_not_equal$2d, {});
  }
}
const {
  SvelteComponent: SvelteComponent$2b,
  append_hydration: append_hydration$1Z,
  attr: attr$24,
  children: children$25,
  claim_svg_element: claim_svg_element$1M,
  detach: detach$25,
  init: init$2b,
  insert_hydration: insert_hydration$25,
  noop: noop$1S,
  safe_not_equal: safe_not_equal$2c,
  svg_element: svg_element$1M
} = window.__gradio__svelte__internal;
function create_fragment$j(e) {
  let t, r;
  return {
    c() {
      t = svg_element$1M("svg"), r = svg_element$1M("polyline"), this.h();
    },
    l(a) {
      t = claim_svg_element$1M(a, "svg", {
        xmlns: !0,
        viewBox: !0,
        fill: !0,
        stroke: !0,
        "stroke-width": !0,
        "stroke-linecap": !0,
        "stroke-linejoin": !0
      });
      var o = children$25(t);
      r = claim_svg_element$1M(o, "polyline", {
        points: !0
      }), children$25(r).forEach(detach$25), o.forEach(detach$25), this.h();
    },
    h() {
      attr$24(r, "points", "20 6 9 17 4 12"), attr$24(t, "xmlns", "http://www.w3.org/2000/svg"), attr$24(t, "viewBox", "2 0 20 20"), attr$24(t, "fill", "none"), attr$24(t, "stroke", "currentColor"), attr$24(t, "stroke-width", "3"), attr$24(t, "stroke-linecap", "round"), attr$24(t, "stroke-linejoin", "round");
    },
    m(a, o) {
      insert_hydration$25(a, t, o), append_hydration$1Z(t, r);
    },
    p: noop$1S,
    i: noop$1S,
    o: noop$1S,
    d(a) {
      a && detach$25(t);
    }
  };
}
class Check extends SvelteComponent$2b {
  constructor(t) {
    super(), init$2b(this, t, null, create_fragment$j, safe_not_equal$2c, {});
  }
}
const {
  SvelteComponent: SvelteComponent$2a,
  append_hydration: append_hydration$1Y,
  attr: attr$23,
  children: children$24,
  claim_svg_element: claim_svg_element$1L,
  detach: detach$24,
  init: init$2a,
  insert_hydration: insert_hydration$24,
  noop: noop$1R,
  safe_not_equal: safe_not_equal$2b,
  svg_element: svg_element$1L
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$29,
  append_hydration: append_hydration$1X,
  attr: attr$22,
  children: children$23,
  claim_svg_element: claim_svg_element$1K,
  detach: detach$23,
  init: init$29,
  insert_hydration: insert_hydration$23,
  noop: noop$1Q,
  safe_not_equal: safe_not_equal$2a,
  set_style: set_style$a,
  svg_element: svg_element$1K
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$28,
  append_hydration: append_hydration$1W,
  attr: attr$21,
  children: children$22,
  claim_svg_element: claim_svg_element$1J,
  detach: detach$22,
  init: init$28,
  insert_hydration: insert_hydration$22,
  noop: noop$1P,
  safe_not_equal: safe_not_equal$29,
  svg_element: svg_element$1J
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$27,
  append_hydration: append_hydration$1V,
  attr: attr$20,
  children: children$21,
  claim_svg_element: claim_svg_element$1I,
  detach: detach$21,
  init: init$27,
  insert_hydration: insert_hydration$21,
  noop: noop$1O,
  safe_not_equal: safe_not_equal$28,
  svg_element: svg_element$1I
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$26,
  append_hydration: append_hydration$1U,
  attr: attr$1$,
  children: children$20,
  claim_svg_element: claim_svg_element$1H,
  detach: detach$20,
  init: init$26,
  insert_hydration: insert_hydration$20,
  noop: noop$1N,
  safe_not_equal: safe_not_equal$27,
  svg_element: svg_element$1H
} = window.__gradio__svelte__internal;
function create_fragment$i(e) {
  let t, r;
  return {
    c() {
      t = svg_element$1H("svg"), r = svg_element$1H("path"), this.h();
    },
    l(a) {
      t = claim_svg_element$1H(a, "svg", {
        id: !0,
        xmlns: !0,
        viewBox: !0
      });
      var o = children$20(t);
      r = claim_svg_element$1H(o, "path", {
        d: !0,
        fill: !0
      }), children$20(r).forEach(detach$20), o.forEach(detach$20), this.h();
    },
    h() {
      attr$1$(r, "d", "M23,20a5,5,0,0,0-3.89,1.89L11.8,17.32a4.46,4.46,0,0,0,0-2.64l7.31-4.57A5,5,0,1,0,18,7a4.79,4.79,0,0,0,.2,1.32l-7.31,4.57a5,5,0,1,0,0,6.22l7.31,4.57A4.79,4.79,0,0,0,18,25a5,5,0,1,0,5-5ZM23,4a3,3,0,1,1-3,3A3,3,0,0,1,23,4ZM7,19a3,3,0,1,1,3-3A3,3,0,0,1,7,19Zm16,9a3,3,0,1,1,3-3A3,3,0,0,1,23,28Z"), attr$1$(r, "fill", "currentColor"), attr$1$(t, "id", "icon"), attr$1$(t, "xmlns", "http://www.w3.org/2000/svg"), attr$1$(t, "viewBox", "0 0 32 32");
    },
    m(a, o) {
      insert_hydration$20(a, t, o), append_hydration$1U(t, r);
    },
    p: noop$1N,
    i: noop$1N,
    o: noop$1N,
    d(a) {
      a && detach$20(t);
    }
  };
}
class Community extends SvelteComponent$26 {
  constructor(t) {
    super(), init$26(this, t, null, create_fragment$i, safe_not_equal$27, {});
  }
}
const {
  SvelteComponent: SvelteComponent$25,
  append_hydration: append_hydration$1T,
  attr: attr$1_,
  children: children$1$,
  claim_svg_element: claim_svg_element$1G,
  detach: detach$1$,
  init: init$25,
  insert_hydration: insert_hydration$1$,
  noop: noop$1M,
  safe_not_equal: safe_not_equal$26,
  svg_element: svg_element$1G
} = window.__gradio__svelte__internal;
function create_fragment$h(e) {
  let t, r, a;
  return {
    c() {
      t = svg_element$1G("svg"), r = svg_element$1G("path"), a = svg_element$1G("path"), this.h();
    },
    l(o) {
      t = claim_svg_element$1G(o, "svg", {
        xmlns: !0,
        viewBox: !0,
        color: !0
      });
      var u = children$1$(t);
      r = claim_svg_element$1G(u, "path", {
        fill: !0,
        d: !0
      }), children$1$(r).forEach(detach$1$), a = claim_svg_element$1G(u, "path", {
        fill: !0,
        d: !0
      }), children$1$(a).forEach(detach$1$), u.forEach(detach$1$), this.h();
    },
    h() {
      attr$1_(r, "fill", "currentColor"), attr$1_(r, "d", "M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z"), attr$1_(a, "fill", "currentColor"), attr$1_(a, "d", "M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z"), attr$1_(t, "xmlns", "http://www.w3.org/2000/svg"), attr$1_(t, "viewBox", "0 0 33 33"), attr$1_(t, "color", "currentColor");
    },
    m(o, u) {
      insert_hydration$1$(o, t, u), append_hydration$1T(t, r), append_hydration$1T(t, a);
    },
    p: noop$1M,
    i: noop$1M,
    o: noop$1M,
    d(o) {
      o && detach$1$(t);
    }
  };
}
class Copy extends SvelteComponent$25 {
  constructor(t) {
    super(), init$25(this, t, null, create_fragment$h, safe_not_equal$26, {});
  }
}
const {
  SvelteComponent: SvelteComponent$24,
  append_hydration: append_hydration$1S,
  attr: attr$1Z,
  children: children$1_,
  claim_svg_element: claim_svg_element$1F,
  detach: detach$1_,
  init: init$24,
  insert_hydration: insert_hydration$1_,
  noop: noop$1L,
  safe_not_equal: safe_not_equal$25,
  svg_element: svg_element$1F
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$23,
  append_hydration: append_hydration$1R,
  attr: attr$1Y,
  children: children$1Z,
  claim_svg_element: claim_svg_element$1E,
  detach: detach$1Z,
  init: init$23,
  insert_hydration: insert_hydration$1Z,
  noop: noop$1K,
  safe_not_equal: safe_not_equal$24,
  svg_element: svg_element$1E
} = window.__gradio__svelte__internal;
function create_fragment$g(e) {
  let t, r, a, o;
  return {
    c() {
      t = svg_element$1E("svg"), r = svg_element$1E("path"), a = svg_element$1E("path"), this.h();
    },
    l(u) {
      t = claim_svg_element$1E(u, "svg", {
        xmlns: !0,
        viewBox: !0,
        fill: !0,
        "stroke-width": !0,
        color: !0
      });
      var c = children$1Z(t);
      r = claim_svg_element$1E(c, "path", {
        stroke: !0,
        "stroke-width": !0,
        "stroke-linecap": !0,
        d: !0
      }), children$1Z(r).forEach(detach$1Z), a = claim_svg_element$1E(c, "path", {
        stroke: !0,
        "stroke-width": !0,
        "stroke-linecap": !0,
        "stroke-linejoin": !0,
        d: !0
      }), children$1Z(a).forEach(detach$1Z), c.forEach(detach$1Z), this.h();
    },
    h() {
      attr$1Y(r, "stroke", "currentColor"), attr$1Y(r, "stroke-width", "1.5"), attr$1Y(r, "stroke-linecap", "round"), attr$1Y(r, "d", "M16.472 3.5H4.1a.6.6 0 0 0-.6.6v9.8a.6.6 0 0 0 .6.6h2.768a2 2 0 0 1 1.715.971l2.71 4.517a1.631 1.631 0 0 0 2.961-1.308l-1.022-3.408a.6.6 0 0 1 .574-.772h4.575a2 2 0 0 0 1.93-2.526l-1.91-7A2 2 0 0 0 16.473 3.5Z"), attr$1Y(a, "stroke", "currentColor"), attr$1Y(a, "stroke-width", "1.5"), attr$1Y(a, "stroke-linecap", "round"), attr$1Y(a, "stroke-linejoin", "round"), attr$1Y(a, "d", "M7 14.5v-11"), attr$1Y(t, "xmlns", "http://www.w3.org/2000/svg"), attr$1Y(t, "viewBox", "0 0 24 24"), attr$1Y(t, "fill", o = /*selected*/
      e[0] ? "currentColor" : "none"), attr$1Y(t, "stroke-width", "1.5"), attr$1Y(t, "color", "currentColor");
    },
    m(u, c) {
      insert_hydration$1Z(u, t, c), append_hydration$1R(t, r), append_hydration$1R(t, a);
    },
    p(u, [c]) {
      c & /*selected*/
      1 && o !== (o = /*selected*/
      u[0] ? "currentColor" : "none") && attr$1Y(t, "fill", o);
    },
    i: noop$1K,
    o: noop$1K,
    d(u) {
      u && detach$1Z(t);
    }
  };
}
function instance$f(e, t, r) {
  let {
    selected: a
  } = t;
  return e.$$set = (o) => {
    "selected" in o && r(0, a = o.selected);
  }, [a];
}
class Dislike extends SvelteComponent$23 {
  constructor(t) {
    super(), init$23(this, t, instance$f, create_fragment$g, safe_not_equal$24, {
      selected: 0
    });
  }
}
const {
  SvelteComponent: SvelteComponent$22,
  append_hydration: append_hydration$1Q,
  attr: attr$1X,
  children: children$1Y,
  claim_svg_element: claim_svg_element$1D,
  detach: detach$1Y,
  init: init$22,
  insert_hydration: insert_hydration$1Y,
  noop: noop$1J,
  safe_not_equal: safe_not_equal$23,
  svg_element: svg_element$1D
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$21,
  append_hydration: append_hydration$1P,
  attr: attr$1W,
  children: children$1X,
  claim_svg_element: claim_svg_element$1C,
  detach: detach$1X,
  init: init$21,
  insert_hydration: insert_hydration$1X,
  noop: noop$1I,
  safe_not_equal: safe_not_equal$22,
  svg_element: svg_element$1C
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$20,
  append_hydration: append_hydration$1O,
  attr: attr$1V,
  children: children$1W,
  claim_svg_element: claim_svg_element$1B,
  detach: detach$1W,
  init: init$20,
  insert_hydration: insert_hydration$1W,
  noop: noop$1H,
  safe_not_equal: safe_not_equal$21,
  svg_element: svg_element$1B
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1$,
  append_hydration: append_hydration$1N,
  attr: attr$1U,
  children: children$1V,
  claim_svg_element: claim_svg_element$1A,
  detach: detach$1V,
  init: init$1$,
  insert_hydration: insert_hydration$1V,
  noop: noop$1G,
  safe_not_equal: safe_not_equal$20,
  svg_element: svg_element$1A
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1_,
  append_hydration: append_hydration$1M,
  attr: attr$1T,
  children: children$1U,
  claim_svg_element: claim_svg_element$1z,
  detach: detach$1U,
  init: init$1_,
  insert_hydration: insert_hydration$1U,
  noop: noop$1F,
  safe_not_equal: safe_not_equal$1$,
  svg_element: svg_element$1z
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1Z,
  append_hydration: append_hydration$1L,
  attr: attr$1S,
  children: children$1T,
  claim_svg_element: claim_svg_element$1y,
  detach: detach$1T,
  init: init$1Z,
  insert_hydration: insert_hydration$1T,
  noop: noop$1E,
  safe_not_equal: safe_not_equal$1_,
  svg_element: svg_element$1y
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1Y,
  append_hydration: append_hydration$1K,
  attr: attr$1R,
  children: children$1S,
  claim_svg_element: claim_svg_element$1x,
  detach: detach$1S,
  init: init$1Y,
  insert_hydration: insert_hydration$1S,
  noop: noop$1D,
  safe_not_equal: safe_not_equal$1Z,
  svg_element: svg_element$1x
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1X,
  append_hydration: append_hydration$1J,
  attr: attr$1Q,
  children: children$1R,
  claim_svg_element: claim_svg_element$1w,
  detach: detach$1R,
  init: init$1X,
  insert_hydration: insert_hydration$1R,
  noop: noop$1C,
  safe_not_equal: safe_not_equal$1Y,
  svg_element: svg_element$1w
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1W,
  append_hydration: append_hydration$1I,
  attr: attr$1P,
  children: children$1Q,
  claim_svg_element: claim_svg_element$1v,
  detach: detach$1Q,
  init: init$1W,
  insert_hydration: insert_hydration$1Q,
  noop: noop$1B,
  safe_not_equal: safe_not_equal$1X,
  svg_element: svg_element$1v
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1V,
  append_hydration: append_hydration$1H,
  attr: attr$1O,
  children: children$1P,
  claim_svg_element: claim_svg_element$1u,
  detach: detach$1P,
  init: init$1V,
  insert_hydration: insert_hydration$1P,
  noop: noop$1A,
  safe_not_equal: safe_not_equal$1W,
  svg_element: svg_element$1u
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1U,
  append_hydration: append_hydration$1G,
  attr: attr$1N,
  children: children$1O,
  claim_svg_element: claim_svg_element$1t,
  detach: detach$1O,
  init: init$1U,
  insert_hydration: insert_hydration$1O,
  noop: noop$1z,
  safe_not_equal: safe_not_equal$1V,
  svg_element: svg_element$1t
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1T,
  append_hydration: append_hydration$1F,
  attr: attr$1M,
  children: children$1N,
  claim_svg_element: claim_svg_element$1s,
  detach: detach$1N,
  init: init$1T,
  insert_hydration: insert_hydration$1N,
  noop: noop$1y,
  safe_not_equal: safe_not_equal$1U,
  svg_element: svg_element$1s
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1S,
  append_hydration: append_hydration$1E,
  attr: attr$1L,
  children: children$1M,
  claim_svg_element: claim_svg_element$1r,
  detach: detach$1M,
  init: init$1S,
  insert_hydration: insert_hydration$1M,
  noop: noop$1x,
  safe_not_equal: safe_not_equal$1T,
  svg_element: svg_element$1r
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1R,
  append_hydration: append_hydration$1D,
  attr: attr$1K,
  children: children$1L,
  claim_svg_element: claim_svg_element$1q,
  detach: detach$1L,
  init: init$1R,
  insert_hydration: insert_hydration$1L,
  noop: noop$1w,
  safe_not_equal: safe_not_equal$1S,
  svg_element: svg_element$1q
} = window.__gradio__svelte__internal;
function create_fragment$f(e) {
  let t, r, a, o;
  return {
    c() {
      t = svg_element$1q("svg"), r = svg_element$1q("path"), a = svg_element$1q("path"), this.h();
    },
    l(u) {
      t = claim_svg_element$1q(u, "svg", {
        xmlns: !0,
        viewBox: !0,
        fill: !0,
        "stroke-width": !0,
        color: !0
      });
      var c = children$1L(t);
      r = claim_svg_element$1q(c, "path", {
        stroke: !0,
        "stroke-width": !0,
        "stroke-linecap": !0,
        d: !0
      }), children$1L(r).forEach(detach$1L), a = claim_svg_element$1q(c, "path", {
        stroke: !0,
        "stroke-width": !0,
        "stroke-linecap": !0,
        "stroke-linejoin": !0,
        d: !0
      }), children$1L(a).forEach(detach$1L), c.forEach(detach$1L), this.h();
    },
    h() {
      attr$1K(r, "stroke", "currentColor"), attr$1K(r, "stroke-width", "1.5"), attr$1K(r, "stroke-linecap", "round"), attr$1K(r, "d", "M16.472 20H4.1a.6.6 0 0 1-.6-.6V9.6a.6.6 0 0 1 .6-.6h2.768a2 2 0 0 0 1.715-.971l2.71-4.517a1.631 1.631 0 0 1 2.961 1.308l-1.022 3.408a.6.6 0 0 0 .574.772h4.575a2 2 0 0 1 1.93 2.526l-1.91 7A2 2 0 0 1 16.473 20Z"), attr$1K(a, "stroke", "currentColor"), attr$1K(a, "stroke-width", "1.5"), attr$1K(a, "stroke-linecap", "round"), attr$1K(a, "stroke-linejoin", "round"), attr$1K(a, "d", "M7 20V9"), attr$1K(t, "xmlns", "http://www.w3.org/2000/svg"), attr$1K(t, "viewBox", "0 0 24 24"), attr$1K(t, "fill", o = /*selected*/
      e[0] ? "currentColor" : "none"), attr$1K(t, "stroke-width", "1.5"), attr$1K(t, "color", "currentColor");
    },
    m(u, c) {
      insert_hydration$1L(u, t, c), append_hydration$1D(t, r), append_hydration$1D(t, a);
    },
    p(u, [c]) {
      c & /*selected*/
      1 && o !== (o = /*selected*/
      u[0] ? "currentColor" : "none") && attr$1K(t, "fill", o);
    },
    i: noop$1w,
    o: noop$1w,
    d(u) {
      u && detach$1L(t);
    }
  };
}
function instance$e(e, t, r) {
  let {
    selected: a
  } = t;
  return e.$$set = (o) => {
    "selected" in o && r(0, a = o.selected);
  }, [a];
}
class Like extends SvelteComponent$1R {
  constructor(t) {
    super(), init$1R(this, t, instance$e, create_fragment$f, safe_not_equal$1S, {
      selected: 0
    });
  }
}
const {
  SvelteComponent: SvelteComponent$1Q,
  append_hydration: append_hydration$1C,
  attr: attr$1J,
  children: children$1K,
  claim_svg_element: claim_svg_element$1p,
  detach: detach$1K,
  init: init$1Q,
  insert_hydration: insert_hydration$1K,
  noop: noop$1v,
  safe_not_equal: safe_not_equal$1R,
  svg_element: svg_element$1p
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1P,
  append_hydration: append_hydration$1B,
  attr: attr$1I,
  children: children$1J,
  claim_svg_element: claim_svg_element$1o,
  detach: detach$1J,
  init: init$1P,
  insert_hydration: insert_hydration$1J,
  noop: noop$1u,
  safe_not_equal: safe_not_equal$1Q,
  svg_element: svg_element$1o
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1O,
  append_hydration: append_hydration$1A,
  attr: attr$1H,
  children: children$1I,
  claim_svg_element: claim_svg_element$1n,
  detach: detach$1I,
  init: init$1O,
  insert_hydration: insert_hydration$1I,
  noop: noop$1t,
  safe_not_equal: safe_not_equal$1P,
  svg_element: svg_element$1n
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1N,
  append_hydration: append_hydration$1z,
  attr: attr$1G,
  children: children$1H,
  claim_svg_element: claim_svg_element$1m,
  detach: detach$1H,
  init: init$1N,
  insert_hydration: insert_hydration$1H,
  noop: noop$1s,
  safe_not_equal: safe_not_equal$1O,
  svg_element: svg_element$1m
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1M,
  append_hydration: append_hydration$1y,
  attr: attr$1F,
  children: children$1G,
  claim_svg_element: claim_svg_element$1l,
  detach: detach$1G,
  init: init$1M,
  insert_hydration: insert_hydration$1G,
  noop: noop$1r,
  safe_not_equal: safe_not_equal$1N,
  svg_element: svg_element$1l
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1L,
  append_hydration: append_hydration$1x,
  attr: attr$1E,
  children: children$1F,
  claim_svg_element: claim_svg_element$1k,
  detach: detach$1F,
  init: init$1L,
  insert_hydration: insert_hydration$1F,
  noop: noop$1q,
  safe_not_equal: safe_not_equal$1M,
  svg_element: svg_element$1k
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1K,
  append_hydration: append_hydration$1w,
  attr: attr$1D,
  children: children$1E,
  claim_svg_element: claim_svg_element$1j,
  detach: detach$1E,
  init: init$1K,
  insert_hydration: insert_hydration$1E,
  noop: noop$1p,
  safe_not_equal: safe_not_equal$1L,
  svg_element: svg_element$1j
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1J,
  append_hydration: append_hydration$1v,
  attr: attr$1C,
  children: children$1D,
  claim_svg_element: claim_svg_element$1i,
  detach: detach$1D,
  init: init$1J,
  insert_hydration: insert_hydration$1D,
  noop: noop$1o,
  safe_not_equal: safe_not_equal$1K,
  svg_element: svg_element$1i
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1I,
  append_hydration: append_hydration$1u,
  attr: attr$1B,
  children: children$1C,
  claim_svg_element: claim_svg_element$1h,
  detach: detach$1C,
  init: init$1I,
  insert_hydration: insert_hydration$1C,
  noop: noop$1n,
  safe_not_equal: safe_not_equal$1J,
  svg_element: svg_element$1h
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1H,
  append_hydration: append_hydration$1t,
  attr: attr$1A,
  children: children$1B,
  claim_svg_element: claim_svg_element$1g,
  detach: detach$1B,
  init: init$1H,
  insert_hydration: insert_hydration$1B,
  noop: noop$1m,
  safe_not_equal: safe_not_equal$1I,
  set_style: set_style$9,
  svg_element: svg_element$1g
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1G,
  append_hydration: append_hydration$1s,
  attr: attr$1z,
  children: children$1A,
  claim_svg_element: claim_svg_element$1f,
  detach: detach$1A,
  init: init$1G,
  insert_hydration: insert_hydration$1A,
  noop: noop$1l,
  safe_not_equal: safe_not_equal$1H,
  svg_element: svg_element$1f
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1F,
  append_hydration: append_hydration$1r,
  attr: attr$1y,
  children: children$1z,
  claim_svg_element: claim_svg_element$1e,
  detach: detach$1z,
  init: init$1F,
  insert_hydration: insert_hydration$1z,
  noop: noop$1k,
  safe_not_equal: safe_not_equal$1G,
  svg_element: svg_element$1e
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1E,
  append_hydration: append_hydration$1q,
  attr: attr$1x,
  children: children$1y,
  claim_svg_element: claim_svg_element$1d,
  detach: detach$1y,
  init: init$1E,
  insert_hydration: insert_hydration$1y,
  noop: noop$1j,
  safe_not_equal: safe_not_equal$1F,
  svg_element: svg_element$1d
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1D,
  append_hydration: append_hydration$1p,
  attr: attr$1w,
  children: children$1x,
  claim_svg_element: claim_svg_element$1c,
  detach: detach$1x,
  init: init$1D,
  insert_hydration: insert_hydration$1x,
  noop: noop$1i,
  safe_not_equal: safe_not_equal$1E,
  svg_element: svg_element$1c
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1C,
  append_hydration: append_hydration$1o,
  attr: attr$1v,
  children: children$1w,
  claim_svg_element: claim_svg_element$1b,
  detach: detach$1w,
  init: init$1C,
  insert_hydration: insert_hydration$1w,
  noop: noop$1h,
  safe_not_equal: safe_not_equal$1D,
  svg_element: svg_element$1b
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1B,
  append_hydration: append_hydration$1n,
  attr: attr$1u,
  children: children$1v,
  claim_svg_element: claim_svg_element$1a,
  detach: detach$1v,
  init: init$1B,
  insert_hydration: insert_hydration$1v,
  noop: noop$1g,
  safe_not_equal: safe_not_equal$1C,
  svg_element: svg_element$1a
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1A,
  append_hydration: append_hydration$1m,
  attr: attr$1t,
  children: children$1u,
  claim_svg_element: claim_svg_element$19,
  detach: detach$1u,
  init: init$1A,
  insert_hydration: insert_hydration$1u,
  noop: noop$1f,
  safe_not_equal: safe_not_equal$1B,
  svg_element: svg_element$19
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1z,
  append_hydration: append_hydration$1l,
  attr: attr$1s,
  children: children$1t,
  claim_svg_element: claim_svg_element$18,
  detach: detach$1t,
  init: init$1z,
  insert_hydration: insert_hydration$1t,
  noop: noop$1e,
  safe_not_equal: safe_not_equal$1A,
  svg_element: svg_element$18
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1y,
  append_hydration: append_hydration$1k,
  attr: attr$1r,
  children: children$1s,
  claim_svg_element: claim_svg_element$17,
  claim_text: claim_text$f,
  detach: detach$1s,
  init: init$1y,
  insert_hydration: insert_hydration$1s,
  noop: noop$1d,
  safe_not_equal: safe_not_equal$1z,
  svg_element: svg_element$17,
  text: text$r
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1x,
  append_hydration: append_hydration$1j,
  attr: attr$1q,
  children: children$1r,
  claim_svg_element: claim_svg_element$16,
  detach: detach$1r,
  init: init$1x,
  insert_hydration: insert_hydration$1r,
  noop: noop$1c,
  safe_not_equal: safe_not_equal$1y,
  svg_element: svg_element$16
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1w,
  append_hydration: append_hydration$1i,
  attr: attr$1p,
  children: children$1q,
  claim_svg_element: claim_svg_element$15,
  detach: detach$1q,
  init: init$1w,
  insert_hydration: insert_hydration$1q,
  noop: noop$1b,
  safe_not_equal: safe_not_equal$1x,
  svg_element: svg_element$15
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1v,
  append_hydration: append_hydration$1h,
  attr: attr$1o,
  children: children$1p,
  claim_svg_element: claim_svg_element$14,
  detach: detach$1p,
  init: init$1v,
  insert_hydration: insert_hydration$1p,
  noop: noop$1a,
  safe_not_equal: safe_not_equal$1w,
  svg_element: svg_element$14
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1u,
  append_hydration: append_hydration$1g,
  attr: attr$1n,
  children: children$1o,
  claim_svg_element: claim_svg_element$13,
  detach: detach$1o,
  init: init$1u,
  insert_hydration: insert_hydration$1o,
  noop: noop$19,
  safe_not_equal: safe_not_equal$1v,
  svg_element: svg_element$13
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1t,
  append_hydration: append_hydration$1f,
  attr: attr$1m,
  children: children$1n,
  claim_svg_element: claim_svg_element$12,
  detach: detach$1n,
  init: init$1t,
  insert_hydration: insert_hydration$1n,
  noop: noop$18,
  safe_not_equal: safe_not_equal$1u,
  svg_element: svg_element$12
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1s,
  append_hydration: append_hydration$1e,
  attr: attr$1l,
  children: children$1m,
  claim_svg_element: claim_svg_element$11,
  claim_text: claim_text$e,
  detach: detach$1m,
  init: init$1s,
  insert_hydration: insert_hydration$1m,
  noop: noop$17,
  safe_not_equal: safe_not_equal$1t,
  svg_element: svg_element$11,
  text: text$q
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1r,
  append_hydration: append_hydration$1d,
  attr: attr$1k,
  children: children$1l,
  claim_svg_element: claim_svg_element$10,
  claim_text: claim_text$d,
  detach: detach$1l,
  init: init$1r,
  insert_hydration: insert_hydration$1l,
  noop: noop$16,
  safe_not_equal: safe_not_equal$1s,
  svg_element: svg_element$10,
  text: text$p
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1q,
  append_hydration: append_hydration$1c,
  attr: attr$1j,
  children: children$1k,
  claim_svg_element: claim_svg_element$$,
  claim_text: claim_text$c,
  detach: detach$1k,
  init: init$1q,
  insert_hydration: insert_hydration$1k,
  noop: noop$15,
  safe_not_equal: safe_not_equal$1r,
  svg_element: svg_element$$,
  text: text$o
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1p,
  append_hydration: append_hydration$1b,
  attr: attr$1i,
  children: children$1j,
  claim_svg_element: claim_svg_element$_,
  detach: detach$1j,
  init: init$1p,
  insert_hydration: insert_hydration$1j,
  noop: noop$14,
  safe_not_equal: safe_not_equal$1q,
  svg_element: svg_element$_
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1o,
  append_hydration: append_hydration$1a,
  attr: attr$1h,
  children: children$1i,
  claim_svg_element: claim_svg_element$Z,
  detach: detach$1i,
  init: init$1o,
  insert_hydration: insert_hydration$1i,
  noop: noop$13,
  safe_not_equal: safe_not_equal$1p,
  svg_element: svg_element$Z
} = window.__gradio__svelte__internal, color_values$1 = [{
  color: "red",
  primary: 600,
  secondary: 100
}, {
  color: "green",
  primary: 600,
  secondary: 100
}, {
  color: "blue",
  primary: 600,
  secondary: 100
}, {
  color: "yellow",
  primary: 500,
  secondary: 100
}, {
  color: "purple",
  primary: 600,
  secondary: 100
}, {
  color: "teal",
  primary: 600,
  secondary: 100
}, {
  color: "orange",
  primary: 600,
  secondary: 100
}, {
  color: "cyan",
  primary: 600,
  secondary: 100
}, {
  color: "lime",
  primary: 500,
  secondary: 100
}, {
  color: "pink",
  primary: 600,
  secondary: 100
}], tw_colors$1 = {
  inherit: "inherit",
  current: "currentColor",
  transparent: "transparent",
  black: "#000",
  white: "#fff",
  slate: {
    50: "#f8fafc",
    100: "#f1f5f9",
    200: "#e2e8f0",
    300: "#cbd5e1",
    400: "#94a3b8",
    500: "#64748b",
    600: "#475569",
    700: "#334155",
    800: "#1e293b",
    900: "#0f172a",
    950: "#020617"
  },
  gray: {
    50: "#f9fafb",
    100: "#f3f4f6",
    200: "#e5e7eb",
    300: "#d1d5db",
    400: "#9ca3af",
    500: "#6b7280",
    600: "#4b5563",
    700: "#374151",
    800: "#1f2937",
    900: "#111827",
    950: "#030712"
  },
  zinc: {
    50: "#fafafa",
    100: "#f4f4f5",
    200: "#e4e4e7",
    300: "#d4d4d8",
    400: "#a1a1aa",
    500: "#71717a",
    600: "#52525b",
    700: "#3f3f46",
    800: "#27272a",
    900: "#18181b",
    950: "#09090b"
  },
  neutral: {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#e5e5e5",
    300: "#d4d4d4",
    400: "#a3a3a3",
    500: "#737373",
    600: "#525252",
    700: "#404040",
    800: "#262626",
    900: "#171717",
    950: "#0a0a0a"
  },
  stone: {
    50: "#fafaf9",
    100: "#f5f5f4",
    200: "#e7e5e4",
    300: "#d6d3d1",
    400: "#a8a29e",
    500: "#78716c",
    600: "#57534e",
    700: "#44403c",
    800: "#292524",
    900: "#1c1917",
    950: "#0c0a09"
  },
  red: {
    50: "#fef2f2",
    100: "#fee2e2",
    200: "#fecaca",
    300: "#fca5a5",
    400: "#f87171",
    500: "#ef4444",
    600: "#dc2626",
    700: "#b91c1c",
    800: "#991b1b",
    900: "#7f1d1d",
    950: "#450a0a"
  },
  orange: {
    50: "#fff7ed",
    100: "#ffedd5",
    200: "#fed7aa",
    300: "#fdba74",
    400: "#fb923c",
    500: "#f97316",
    600: "#ea580c",
    700: "#c2410c",
    800: "#9a3412",
    900: "#7c2d12",
    950: "#431407"
  },
  amber: {
    50: "#fffbeb",
    100: "#fef3c7",
    200: "#fde68a",
    300: "#fcd34d",
    400: "#fbbf24",
    500: "#f59e0b",
    600: "#d97706",
    700: "#b45309",
    800: "#92400e",
    900: "#78350f",
    950: "#451a03"
  },
  yellow: {
    50: "#fefce8",
    100: "#fef9c3",
    200: "#fef08a",
    300: "#fde047",
    400: "#facc15",
    500: "#eab308",
    600: "#ca8a04",
    700: "#a16207",
    800: "#854d0e",
    900: "#713f12",
    950: "#422006"
  },
  lime: {
    50: "#f7fee7",
    100: "#ecfccb",
    200: "#d9f99d",
    300: "#bef264",
    400: "#a3e635",
    500: "#84cc16",
    600: "#65a30d",
    700: "#4d7c0f",
    800: "#3f6212",
    900: "#365314",
    950: "#1a2e05"
  },
  green: {
    50: "#f0fdf4",
    100: "#dcfce7",
    200: "#bbf7d0",
    300: "#86efac",
    400: "#4ade80",
    500: "#22c55e",
    600: "#16a34a",
    700: "#15803d",
    800: "#166534",
    900: "#14532d",
    950: "#052e16"
  },
  emerald: {
    50: "#ecfdf5",
    100: "#d1fae5",
    200: "#a7f3d0",
    300: "#6ee7b7",
    400: "#34d399",
    500: "#10b981",
    600: "#059669",
    700: "#047857",
    800: "#065f46",
    900: "#064e3b",
    950: "#022c22"
  },
  teal: {
    50: "#f0fdfa",
    100: "#ccfbf1",
    200: "#99f6e4",
    300: "#5eead4",
    400: "#2dd4bf",
    500: "#14b8a6",
    600: "#0d9488",
    700: "#0f766e",
    800: "#115e59",
    900: "#134e4a",
    950: "#042f2e"
  },
  cyan: {
    50: "#ecfeff",
    100: "#cffafe",
    200: "#a5f3fc",
    300: "#67e8f9",
    400: "#22d3ee",
    500: "#06b6d4",
    600: "#0891b2",
    700: "#0e7490",
    800: "#155e75",
    900: "#164e63",
    950: "#083344"
  },
  sky: {
    50: "#f0f9ff",
    100: "#e0f2fe",
    200: "#bae6fd",
    300: "#7dd3fc",
    400: "#38bdf8",
    500: "#0ea5e9",
    600: "#0284c7",
    700: "#0369a1",
    800: "#075985",
    900: "#0c4a6e",
    950: "#082f49"
  },
  blue: {
    50: "#eff6ff",
    100: "#dbeafe",
    200: "#bfdbfe",
    300: "#93c5fd",
    400: "#60a5fa",
    500: "#3b82f6",
    600: "#2563eb",
    700: "#1d4ed8",
    800: "#1e40af",
    900: "#1e3a8a",
    950: "#172554"
  },
  indigo: {
    50: "#eef2ff",
    100: "#e0e7ff",
    200: "#c7d2fe",
    300: "#a5b4fc",
    400: "#818cf8",
    500: "#6366f1",
    600: "#4f46e5",
    700: "#4338ca",
    800: "#3730a3",
    900: "#312e81",
    950: "#1e1b4b"
  },
  violet: {
    50: "#f5f3ff",
    100: "#ede9fe",
    200: "#ddd6fe",
    300: "#c4b5fd",
    400: "#a78bfa",
    500: "#8b5cf6",
    600: "#7c3aed",
    700: "#6d28d9",
    800: "#5b21b6",
    900: "#4c1d95",
    950: "#2e1065"
  },
  purple: {
    50: "#faf5ff",
    100: "#f3e8ff",
    200: "#e9d5ff",
    300: "#d8b4fe",
    400: "#c084fc",
    500: "#a855f7",
    600: "#9333ea",
    700: "#7e22ce",
    800: "#6b21a8",
    900: "#581c87",
    950: "#3b0764"
  },
  fuchsia: {
    50: "#fdf4ff",
    100: "#fae8ff",
    200: "#f5d0fe",
    300: "#f0abfc",
    400: "#e879f9",
    500: "#d946ef",
    600: "#c026d3",
    700: "#a21caf",
    800: "#86198f",
    900: "#701a75",
    950: "#4a044e"
  },
  pink: {
    50: "#fdf2f8",
    100: "#fce7f3",
    200: "#fbcfe8",
    300: "#f9a8d4",
    400: "#f472b6",
    500: "#ec4899",
    600: "#db2777",
    700: "#be185d",
    800: "#9d174d",
    900: "#831843",
    950: "#500724"
  },
  rose: {
    50: "#fff1f2",
    100: "#ffe4e6",
    200: "#fecdd3",
    300: "#fda4af",
    400: "#fb7185",
    500: "#f43f5e",
    600: "#e11d48",
    700: "#be123c",
    800: "#9f1239",
    900: "#881337",
    950: "#4c0519"
  }
};
color_values$1.reduce((e, {
  color: t,
  primary: r,
  secondary: a
}) => ({
  ...e,
  [t]: {
    primary: tw_colors$1[t][r],
    secondary: tw_colors$1[t][a]
  }
}), {});
class ShareError extends Error {
  constructor(t) {
    super(t), this.name = "ShareError";
  }
}
const {
  SvelteComponent: SvelteComponent$1n,
  claim_component: claim_component$j,
  create_component: create_component$j,
  destroy_component: destroy_component$j,
  init: init$1n,
  mount_component: mount_component$j,
  safe_not_equal: safe_not_equal$1o,
  transition_in: transition_in$o,
  transition_out: transition_out$o
} = window.__gradio__svelte__internal, {
  createEventDispatcher: createEventDispatcher$5
} = window.__gradio__svelte__internal;
function create_fragment$e(e) {
  let t, r;
  return t = new IconButton$1({
    props: {
      Icon: Community,
      label: (
        /*i18n*/
        e[2]("common.share")
      ),
      pending: (
        /*pending*/
        e[3]
      )
    }
  }), t.$on(
    "click",
    /*click_handler*/
    e[5]
  ), {
    c() {
      create_component$j(t.$$.fragment);
    },
    l(a) {
      claim_component$j(t.$$.fragment, a);
    },
    m(a, o) {
      mount_component$j(t, a, o), r = !0;
    },
    p(a, [o]) {
      const u = {};
      o & /*i18n*/
      4 && (u.label = /*i18n*/
      a[2]("common.share")), o & /*pending*/
      8 && (u.pending = /*pending*/
      a[3]), t.$set(u);
    },
    i(a) {
      r || (transition_in$o(t.$$.fragment, a), r = !0);
    },
    o(a) {
      transition_out$o(t.$$.fragment, a), r = !1;
    },
    d(a) {
      destroy_component$j(t, a);
    }
  };
}
function instance$d(e, t, r) {
  const a = createEventDispatcher$5();
  let {
    formatter: o
  } = t, {
    value: u
  } = t, {
    i18n: c
  } = t, d = !1;
  const g = async () => {
    try {
      r(3, d = !0);
      const b = await o(u);
      a("share", {
        description: b
      });
    } catch (b) {
      console.error(b);
      let _ = b instanceof ShareError ? b.message : "Share failed.";
      a("error", _);
    } finally {
      r(3, d = !1);
    }
  };
  return e.$$set = (b) => {
    "formatter" in b && r(0, o = b.formatter), "value" in b && r(1, u = b.value), "i18n" in b && r(2, c = b.i18n);
  }, [o, u, c, d, a, g];
}
class ShareButton extends SvelteComponent$1n {
  constructor(t) {
    super(), init$1n(this, t, instance$d, create_fragment$e, safe_not_equal$1o, {
      formatter: 0,
      value: 1,
      i18n: 2
    });
  }
}
const {
  SvelteComponent: SvelteComponent$1m,
  append_hydration: append_hydration$19,
  attr: attr$1g,
  check_outros: check_outros$a,
  children: children$1h,
  claim_component: claim_component$i,
  claim_element: claim_element$l,
  claim_space: claim_space$c,
  claim_text: claim_text$b,
  create_component: create_component$i,
  destroy_component: destroy_component$i,
  detach: detach$1h,
  element: element$t,
  group_outros: group_outros$a,
  init: init$1m,
  insert_hydration: insert_hydration$1h,
  mount_component: mount_component$i,
  safe_not_equal: safe_not_equal$1n,
  set_data: set_data$7,
  space: space$g,
  text: text$n,
  toggle_class: toggle_class$e,
  transition_in: transition_in$n,
  transition_out: transition_out$n
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1l,
  attr: attr$1f,
  children: children$1g,
  claim_element: claim_element$k,
  create_slot: create_slot$6,
  detach: detach$1g,
  element: element$s,
  get_all_dirty_from_scope: get_all_dirty_from_scope$6,
  get_slot_changes: get_slot_changes$6,
  init: init$1l,
  insert_hydration: insert_hydration$1g,
  safe_not_equal: safe_not_equal$1m,
  toggle_class: toggle_class$d,
  transition_in: transition_in$m,
  transition_out: transition_out$m,
  update_slot_base: update_slot_base$6
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1k,
  append_hydration: append_hydration$18,
  attr: attr$1e,
  check_outros: check_outros$9,
  children: children$1f,
  claim_component: claim_component$h,
  claim_element: claim_element$j,
  claim_space: claim_space$b,
  create_component: create_component$h,
  destroy_component: destroy_component$h,
  detach: detach$1f,
  element: element$r,
  empty: empty$9,
  group_outros: group_outros$9,
  init: init$1k,
  insert_hydration: insert_hydration$1f,
  listen: listen$6,
  mount_component: mount_component$h,
  safe_not_equal: safe_not_equal$1l,
  space: space$f,
  toggle_class: toggle_class$c,
  transition_in: transition_in$l,
  transition_out: transition_out$l
} = window.__gradio__svelte__internal;
new Intl.Collator(0, {
  numeric: 1
}).compare;
class FileData {
  constructor({
    path: t,
    url: r,
    orig_name: a,
    size: o,
    blob: u,
    is_stream: c,
    mime_type: d,
    alt_text: g,
    b64: b
  }) {
    ft(this, "path");
    ft(this, "url");
    ft(this, "orig_name");
    ft(this, "size");
    ft(this, "blob");
    ft(this, "is_stream");
    ft(this, "mime_type");
    ft(this, "alt_text");
    ft(this, "b64");
    ft(this, "meta", {
      _type: "gradio.FileData"
    });
    this.path = t, this.url = r, this.orig_name = a, this.size = o, this.blob = r ? void 0 : u, this.is_stream = c, this.mime_type = d, this.alt_text = g, this.b64 = b;
  }
}
typeof process < "u" && process.versions && process.versions.node;
var Ct;
class TextLineStream extends TransformStream {
  /** Constructs a new instance. */
  constructor(r = {
    allowCR: !1
  }) {
    super({
      transform: (a, o) => {
        for (a = G(this, Ct) + a; ; ) {
          const u = a.indexOf(`
`), c = r.allowCR ? a.indexOf("\r") : -1;
          if (c !== -1 && c !== a.length - 1 && (u === -1 || u - 1 > c)) {
            o.enqueue(a.slice(0, c)), a = a.slice(c + 1);
            continue;
          }
          if (u === -1) break;
          const d = a[u - 1] === "\r" ? u - 1 : u;
          o.enqueue(a.slice(0, d)), a = a.slice(u + 1);
        }
        Ie(this, Ct, a);
      },
      flush: (a) => {
        if (G(this, Ct) === "") return;
        const o = r.allowCR && G(this, Ct).endsWith("\r") ? G(this, Ct).slice(0, -1) : G(this, Ct);
        a.enqueue(o);
      }
    });
    we(this, Ct, "");
  }
}
Ct = new WeakMap();
function pretty_si(e) {
  let t = ["", "k", "M", "G", "T", "P", "E", "Z"], r = 0;
  for (; e > 1e3 && r < t.length - 1; )
    e /= 1e3, r++;
  let a = t[r];
  return (Number.isInteger(e) ? e : e.toFixed(1)) + a;
}
function noop$12() {
}
function run(e) {
  return e();
}
function run_all$3(e) {
  e.forEach(run);
}
function is_function(e) {
  return typeof e == "function";
}
function safe_not_equal$1k(e, t) {
  return e != e ? t == t : e !== t || e && typeof e == "object" || typeof e == "function";
}
function subscribe(e, ...t) {
  if (e == null) {
    for (const a of t)
      a(void 0);
    return noop$12;
  }
  const r = e.subscribe(...t);
  return r.unsubscribe ? () => r.unsubscribe() : r;
}
const is_client = typeof window < "u";
let now = is_client ? () => window.performance.now() : () => Date.now(), raf = is_client ? (e) => requestAnimationFrame(e) : noop$12;
const tasks = /* @__PURE__ */ new Set();
function run_tasks(e) {
  tasks.forEach((t) => {
    t.c(e) || (tasks.delete(t), t.f());
  }), tasks.size !== 0 && raf(run_tasks);
}
function loop(e) {
  let t;
  return tasks.size === 0 && raf(run_tasks), {
    promise: new Promise((r) => {
      tasks.add(t = {
        c: e,
        f: r
      });
    }),
    abort() {
      tasks.delete(t);
    }
  };
}
const subscriber_queue = [];
function readable(e, t) {
  return {
    subscribe: writable(e, t).subscribe
  };
}
function writable(e, t = noop$12) {
  let r;
  const a = /* @__PURE__ */ new Set();
  function o(d) {
    if (safe_not_equal$1k(e, d) && (e = d, r)) {
      const g = !subscriber_queue.length;
      for (const b of a)
        b[1](), subscriber_queue.push(b, e);
      if (g) {
        for (let b = 0; b < subscriber_queue.length; b += 2)
          subscriber_queue[b][0](subscriber_queue[b + 1]);
        subscriber_queue.length = 0;
      }
    }
  }
  function u(d) {
    o(d(e));
  }
  function c(d, g = noop$12) {
    const b = [d, g];
    return a.add(b), a.size === 1 && (r = t(o, u) || noop$12), d(e), () => {
      a.delete(b), a.size === 0 && r && (r(), r = null);
    };
  }
  return {
    set: o,
    update: u,
    subscribe: c
  };
}
function derived(e, t, r) {
  const a = !Array.isArray(e), o = a ? [e] : e;
  if (!o.every(Boolean))
    throw new Error("derived() expects stores as input, got a falsy value");
  const u = t.length < 2;
  return readable(r, (c, d) => {
    let g = !1;
    const b = [];
    let _ = 0, y = noop$12;
    const A = () => {
      if (_)
        return;
      y();
      const v = t(a ? b[0] : b, c, d);
      u ? c(v) : y = is_function(v) ? v : noop$12;
    }, E = o.map((v, C) => subscribe(v, (R) => {
      b[C] = R, _ &= ~(1 << C), g && A();
    }, () => {
      _ |= 1 << C;
    }));
    return g = !0, A(), function() {
      run_all$3(E), y(), g = !1;
    };
  });
}
function is_date(e) {
  return Object.prototype.toString.call(e) === "[object Date]";
}
function tick_spring(e, t, r, a) {
  if (typeof r == "number" || is_date(r)) {
    const o = a - r, u = (r - t) / (e.dt || 1 / 60), c = e.opts.stiffness * o, d = e.opts.damping * u, g = (c - d) * e.inv_mass, b = (u + g) * e.dt;
    return Math.abs(b) < e.opts.precision && Math.abs(o) < e.opts.precision ? a : (e.settled = !1, is_date(r) ? new Date(r.getTime() + b) : r + b);
  } else {
    if (Array.isArray(r))
      return r.map((o, u) => tick_spring(e, t[u], r[u], a[u]));
    if (typeof r == "object") {
      const o = {};
      for (const u in r)
        o[u] = tick_spring(e, t[u], r[u], a[u]);
      return o;
    } else
      throw new Error(`Cannot spring ${typeof r} values`);
  }
}
function spring(e, t = {}) {
  const r = writable(e), {
    stiffness: a = 0.15,
    damping: o = 0.8,
    precision: u = 0.01
  } = t;
  let c, d, g, b = e, _ = e, y = 1, A = 0, E = !1;
  function v(R, I = {}) {
    _ = R;
    const w = g = {};
    return e == null || I.hard || C.stiffness >= 1 && C.damping >= 1 ? (E = !0, c = now(), b = R, r.set(e = _), Promise.resolve()) : (I.soft && (A = 1 / ((I.soft === !0 ? 0.5 : +I.soft) * 60), y = 0), d || (c = now(), E = !1, d = loop((N) => {
      if (E)
        return E = !1, d = null, !1;
      y = Math.min(y + A, 1);
      const F = {
        inv_mass: y,
        opts: C,
        settled: !0,
        dt: (N - c) * 60 / 1e3
      }, M = tick_spring(F, b, e, _);
      return c = N, b = e, r.set(e = M), F.settled && (d = null), !F.settled;
    })), new Promise((N) => {
      d.promise.then(() => {
        w === g && N();
      });
    }));
  }
  const C = {
    set: v,
    update: (R, I) => v(R(_, e), I),
    subscribe: r.subscribe,
    stiffness: a,
    damping: o,
    precision: u
  };
  return C;
}
const {
  SvelteComponent: SvelteComponent$1j,
  append_hydration: append_hydration$17,
  attr: attr$1d,
  children: children$1e,
  claim_element: claim_element$i,
  claim_svg_element: claim_svg_element$Y,
  component_subscribe,
  detach: detach$1e,
  element: element$q,
  init: init$1j,
  insert_hydration: insert_hydration$1e,
  noop: noop$11,
  safe_not_equal: safe_not_equal$1j,
  set_style: set_style$8,
  svg_element: svg_element$Y,
  toggle_class: toggle_class$b
} = window.__gradio__svelte__internal, {
  onMount: onMount$1
} = window.__gradio__svelte__internal;
function create_fragment$d(e) {
  let t, r, a, o, u, c, d, g, b, _, y, A;
  return {
    c() {
      t = element$q("div"), r = svg_element$Y("svg"), a = svg_element$Y("g"), o = svg_element$Y("path"), u = svg_element$Y("path"), c = svg_element$Y("path"), d = svg_element$Y("path"), g = svg_element$Y("g"), b = svg_element$Y("path"), _ = svg_element$Y("path"), y = svg_element$Y("path"), A = svg_element$Y("path"), this.h();
    },
    l(E) {
      t = claim_element$i(E, "DIV", {
        class: !0
      });
      var v = children$1e(t);
      r = claim_svg_element$Y(v, "svg", {
        viewBox: !0,
        fill: !0,
        xmlns: !0,
        class: !0
      });
      var C = children$1e(r);
      a = claim_svg_element$Y(C, "g", {
        style: !0
      });
      var R = children$1e(a);
      o = claim_svg_element$Y(R, "path", {
        d: !0,
        fill: !0,
        "fill-opacity": !0,
        class: !0
      }), children$1e(o).forEach(detach$1e), u = claim_svg_element$Y(R, "path", {
        d: !0,
        fill: !0,
        class: !0
      }), children$1e(u).forEach(detach$1e), c = claim_svg_element$Y(R, "path", {
        d: !0,
        fill: !0,
        "fill-opacity": !0,
        class: !0
      }), children$1e(c).forEach(detach$1e), d = claim_svg_element$Y(R, "path", {
        d: !0,
        fill: !0,
        class: !0
      }), children$1e(d).forEach(detach$1e), R.forEach(detach$1e), g = claim_svg_element$Y(C, "g", {
        style: !0
      });
      var I = children$1e(g);
      b = claim_svg_element$Y(I, "path", {
        d: !0,
        fill: !0,
        "fill-opacity": !0,
        class: !0
      }), children$1e(b).forEach(detach$1e), _ = claim_svg_element$Y(I, "path", {
        d: !0,
        fill: !0,
        class: !0
      }), children$1e(_).forEach(detach$1e), y = claim_svg_element$Y(I, "path", {
        d: !0,
        fill: !0,
        "fill-opacity": !0,
        class: !0
      }), children$1e(y).forEach(detach$1e), A = claim_svg_element$Y(I, "path", {
        d: !0,
        fill: !0,
        class: !0
      }), children$1e(A).forEach(detach$1e), I.forEach(detach$1e), C.forEach(detach$1e), v.forEach(detach$1e), this.h();
    },
    h() {
      attr$1d(o, "d", "M255.926 0.754768L509.702 139.936V221.027L255.926 81.8465V0.754768Z"), attr$1d(o, "fill", "#FF7C00"), attr$1d(o, "fill-opacity", "0.4"), attr$1d(o, "class", "svelte-43sxxs"), attr$1d(u, "d", "M509.69 139.936L254.981 279.641V361.255L509.69 221.55V139.936Z"), attr$1d(u, "fill", "#FF7C00"), attr$1d(u, "class", "svelte-43sxxs"), attr$1d(c, "d", "M0.250138 139.937L254.981 279.641V361.255L0.250138 221.55V139.937Z"), attr$1d(c, "fill", "#FF7C00"), attr$1d(c, "fill-opacity", "0.4"), attr$1d(c, "class", "svelte-43sxxs"), attr$1d(d, "d", "M255.923 0.232622L0.236328 139.936V221.55L255.923 81.8469V0.232622Z"), attr$1d(d, "fill", "#FF7C00"), attr$1d(d, "class", "svelte-43sxxs"), set_style$8(a, "transform", "translate(" + /*$top*/
      e[1][0] + "px, " + /*$top*/
      e[1][1] + "px)"), attr$1d(b, "d", "M255.926 141.5L509.702 280.681V361.773L255.926 222.592V141.5Z"), attr$1d(b, "fill", "#FF7C00"), attr$1d(b, "fill-opacity", "0.4"), attr$1d(b, "class", "svelte-43sxxs"), attr$1d(_, "d", "M509.69 280.679L254.981 420.384V501.998L509.69 362.293V280.679Z"), attr$1d(_, "fill", "#FF7C00"), attr$1d(_, "class", "svelte-43sxxs"), attr$1d(y, "d", "M0.250138 280.681L254.981 420.386V502L0.250138 362.295V280.681Z"), attr$1d(y, "fill", "#FF7C00"), attr$1d(y, "fill-opacity", "0.4"), attr$1d(y, "class", "svelte-43sxxs"), attr$1d(A, "d", "M255.923 140.977L0.236328 280.68V362.294L255.923 222.591V140.977Z"), attr$1d(A, "fill", "#FF7C00"), attr$1d(A, "class", "svelte-43sxxs"), set_style$8(g, "transform", "translate(" + /*$bottom*/
      e[2][0] + "px, " + /*$bottom*/
      e[2][1] + "px)"), attr$1d(r, "viewBox", "-1200 -1200 3000 3000"), attr$1d(r, "fill", "none"), attr$1d(r, "xmlns", "http://www.w3.org/2000/svg"), attr$1d(r, "class", "svelte-43sxxs"), attr$1d(t, "class", "svelte-43sxxs"), toggle_class$b(
        t,
        "margin",
        /*margin*/
        e[0]
      );
    },
    m(E, v) {
      insert_hydration$1e(E, t, v), append_hydration$17(t, r), append_hydration$17(r, a), append_hydration$17(a, o), append_hydration$17(a, u), append_hydration$17(a, c), append_hydration$17(a, d), append_hydration$17(r, g), append_hydration$17(g, b), append_hydration$17(g, _), append_hydration$17(g, y), append_hydration$17(g, A);
    },
    p(E, [v]) {
      v & /*$top*/
      2 && set_style$8(a, "transform", "translate(" + /*$top*/
      E[1][0] + "px, " + /*$top*/
      E[1][1] + "px)"), v & /*$bottom*/
      4 && set_style$8(g, "transform", "translate(" + /*$bottom*/
      E[2][0] + "px, " + /*$bottom*/
      E[2][1] + "px)"), v & /*margin*/
      1 && toggle_class$b(
        t,
        "margin",
        /*margin*/
        E[0]
      );
    },
    i: noop$11,
    o: noop$11,
    d(E) {
      E && detach$1e(t);
    }
  };
}
function instance$c(e, t, r) {
  let a, o, {
    margin: u = !0
  } = t;
  const c = spring([0, 0]);
  component_subscribe(e, c, (A) => r(1, a = A));
  const d = spring([0, 0]);
  component_subscribe(e, d, (A) => r(2, o = A));
  let g;
  async function b() {
    await Promise.all([c.set([125, 140]), d.set([-125, -140])]), await Promise.all([c.set([-125, 140]), d.set([125, -140])]), await Promise.all([c.set([-125, 0]), d.set([125, -0])]), await Promise.all([c.set([125, 0]), d.set([-125, 0])]);
  }
  async function _() {
    await b(), g || _();
  }
  async function y() {
    await Promise.all([c.set([125, 0]), d.set([-125, 0])]), _();
  }
  return onMount$1(() => (y(), () => g = !0)), e.$$set = (A) => {
    "margin" in A && r(0, u = A.margin);
  }, [u, a, o, c, d];
}
class Loader extends SvelteComponent$1j {
  constructor(t) {
    super(), init$1j(this, t, instance$c, create_fragment$d, safe_not_equal$1j, {
      margin: 0
    });
  }
}
const {
  SvelteComponent: SvelteComponent$1i,
  assign: assign$6,
  children: children$1d,
  claim_element: claim_element$h,
  create_slot: create_slot$5,
  detach: detach$1d,
  element: element$p,
  get_all_dirty_from_scope: get_all_dirty_from_scope$5,
  get_slot_changes: get_slot_changes$5,
  get_spread_update: get_spread_update$5,
  init: init$1i,
  insert_hydration: insert_hydration$1d,
  safe_not_equal: safe_not_equal$1i,
  set_dynamic_element_data,
  set_style: set_style$7,
  toggle_class: toggle_class$a,
  transition_in: transition_in$k,
  transition_out: transition_out$k,
  update_slot_base: update_slot_base$5
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1h,
  attr: attr$1c,
  children: children$1c,
  claim_element: claim_element$g,
  create_slot: create_slot$4,
  detach: detach$1c,
  element: element$o,
  get_all_dirty_from_scope: get_all_dirty_from_scope$4,
  get_slot_changes: get_slot_changes$4,
  init: init$1h,
  insert_hydration: insert_hydration$1c,
  safe_not_equal: safe_not_equal$1h,
  transition_in: transition_in$j,
  transition_out: transition_out$j,
  update_slot_base: update_slot_base$4
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1g,
  attr: attr$1b,
  check_outros: check_outros$8,
  children: children$1b,
  claim_component: claim_component$g,
  claim_element: claim_element$f,
  claim_space: claim_space$a,
  claim_text: claim_text$a,
  create_component: create_component$g,
  create_slot: create_slot$3,
  destroy_component: destroy_component$g,
  detach: detach$1b,
  element: element$n,
  empty: empty$8,
  get_all_dirty_from_scope: get_all_dirty_from_scope$3,
  get_slot_changes: get_slot_changes$3,
  group_outros: group_outros$8,
  init: init$1g,
  insert_hydration: insert_hydration$1b,
  mount_component: mount_component$g,
  safe_not_equal: safe_not_equal$1g,
  set_data: set_data$6,
  space: space$e,
  text: text$m,
  toggle_class: toggle_class$9,
  transition_in: transition_in$i,
  transition_out: transition_out$i,
  update_slot_base: update_slot_base$3
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1f,
  append_hydration: append_hydration$16,
  attr: attr$1a,
  children: children$1a,
  claim_component: claim_component$f,
  claim_element: claim_element$e,
  claim_space: claim_space$9,
  claim_text: claim_text$9,
  create_component: create_component$f,
  destroy_component: destroy_component$f,
  detach: detach$1a,
  element: element$m,
  init: init$1f,
  insert_hydration: insert_hydration$1a,
  mount_component: mount_component$f,
  safe_not_equal: safe_not_equal$1f,
  set_data: set_data$5,
  space: space$d,
  text: text$l,
  toggle_class: toggle_class$8,
  transition_in: transition_in$h,
  transition_out: transition_out$h
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1e,
  append_hydration: append_hydration$15,
  attr: attr$19,
  bubble: bubble$3,
  children: children$19,
  claim_component: claim_component$e,
  claim_element: claim_element$d,
  claim_space: claim_space$8,
  claim_text: claim_text$8,
  create_component: create_component$e,
  destroy_component: destroy_component$e,
  detach: detach$19,
  element: element$l,
  init: init$1e,
  insert_hydration: insert_hydration$19,
  listen: listen$5,
  mount_component: mount_component$e,
  safe_not_equal: safe_not_equal$1e,
  set_data: set_data$4,
  set_style: set_style$6,
  space: space$c,
  text: text$k,
  toggle_class: toggle_class$7,
  transition_in: transition_in$g,
  transition_out: transition_out$g
} = window.__gradio__svelte__internal;
function create_if_block$4(e) {
  let t, r;
  return {
    c() {
      t = element$l("span"), r = text$k(
        /*label*/
        e[1]
      ), this.h();
    },
    l(a) {
      t = claim_element$d(a, "SPAN", {
        class: !0
      });
      var o = children$19(t);
      r = claim_text$8(
        o,
        /*label*/
        e[1]
      ), o.forEach(detach$19), this.h();
    },
    h() {
      attr$19(t, "class", "svelte-1lrphxw");
    },
    m(a, o) {
      insert_hydration$19(a, t, o), append_hydration$15(t, r);
    },
    p(a, o) {
      o & /*label*/
      2 && set_data$4(
        r,
        /*label*/
        a[1]
      );
    },
    d(a) {
      a && detach$19(t);
    }
  };
}
function create_fragment$c(e) {
  let t, r, a, o, u, c, d, g = (
    /*show_label*/
    e[2] && create_if_block$4(e)
  );
  return o = new /*Icon*/
  e[0]({}), {
    c() {
      t = element$l("button"), g && g.c(), r = space$c(), a = element$l("div"), create_component$e(o.$$.fragment), this.h();
    },
    l(b) {
      t = claim_element$d(b, "BUTTON", {
        "aria-label": !0,
        "aria-haspopup": !0,
        title: !0,
        class: !0
      });
      var _ = children$19(t);
      g && g.l(_), r = claim_space$8(_), a = claim_element$d(_, "DIV", {
        class: !0
      });
      var y = children$19(a);
      claim_component$e(o.$$.fragment, y), y.forEach(detach$19), _.forEach(detach$19), this.h();
    },
    h() {
      attr$19(a, "class", "svelte-1lrphxw"), toggle_class$7(
        a,
        "small",
        /*size*/
        e[4] === "small"
      ), toggle_class$7(
        a,
        "large",
        /*size*/
        e[4] === "large"
      ), toggle_class$7(
        a,
        "medium",
        /*size*/
        e[4] === "medium"
      ), t.disabled = /*disabled*/
      e[7], attr$19(
        t,
        "aria-label",
        /*label*/
        e[1]
      ), attr$19(
        t,
        "aria-haspopup",
        /*hasPopup*/
        e[8]
      ), attr$19(
        t,
        "title",
        /*label*/
        e[1]
      ), attr$19(t, "class", "svelte-1lrphxw"), toggle_class$7(
        t,
        "pending",
        /*pending*/
        e[3]
      ), toggle_class$7(
        t,
        "padded",
        /*padded*/
        e[5]
      ), toggle_class$7(
        t,
        "highlight",
        /*highlight*/
        e[6]
      ), toggle_class$7(
        t,
        "transparent",
        /*transparent*/
        e[9]
      ), set_style$6(t, "color", !/*disabled*/
      e[7] && /*_color*/
      e[12] ? (
        /*_color*/
        e[12]
      ) : "var(--block-label-text-color)"), set_style$6(t, "--bg-color", /*disabled*/
      e[7] ? "auto" : (
        /*background*/
        e[10]
      )), set_style$6(
        t,
        "margin-left",
        /*offset*/
        e[11] + "px"
      );
    },
    m(b, _) {
      insert_hydration$19(b, t, _), g && g.m(t, null), append_hydration$15(t, r), append_hydration$15(t, a), mount_component$e(o, a, null), u = !0, c || (d = listen$5(
        t,
        "click",
        /*click_handler*/
        e[14]
      ), c = !0);
    },
    p(b, [_]) {
      /*show_label*/
      b[2] ? g ? g.p(b, _) : (g = create_if_block$4(b), g.c(), g.m(t, r)) : g && (g.d(1), g = null), (!u || _ & /*size*/
      16) && toggle_class$7(
        a,
        "small",
        /*size*/
        b[4] === "small"
      ), (!u || _ & /*size*/
      16) && toggle_class$7(
        a,
        "large",
        /*size*/
        b[4] === "large"
      ), (!u || _ & /*size*/
      16) && toggle_class$7(
        a,
        "medium",
        /*size*/
        b[4] === "medium"
      ), (!u || _ & /*disabled*/
      128) && (t.disabled = /*disabled*/
      b[7]), (!u || _ & /*label*/
      2) && attr$19(
        t,
        "aria-label",
        /*label*/
        b[1]
      ), (!u || _ & /*hasPopup*/
      256) && attr$19(
        t,
        "aria-haspopup",
        /*hasPopup*/
        b[8]
      ), (!u || _ & /*label*/
      2) && attr$19(
        t,
        "title",
        /*label*/
        b[1]
      ), (!u || _ & /*pending*/
      8) && toggle_class$7(
        t,
        "pending",
        /*pending*/
        b[3]
      ), (!u || _ & /*padded*/
      32) && toggle_class$7(
        t,
        "padded",
        /*padded*/
        b[5]
      ), (!u || _ & /*highlight*/
      64) && toggle_class$7(
        t,
        "highlight",
        /*highlight*/
        b[6]
      ), (!u || _ & /*transparent*/
      512) && toggle_class$7(
        t,
        "transparent",
        /*transparent*/
        b[9]
      ), _ & /*disabled, _color*/
      4224 && set_style$6(t, "color", !/*disabled*/
      b[7] && /*_color*/
      b[12] ? (
        /*_color*/
        b[12]
      ) : "var(--block-label-text-color)"), _ & /*disabled, background*/
      1152 && set_style$6(t, "--bg-color", /*disabled*/
      b[7] ? "auto" : (
        /*background*/
        b[10]
      )), _ & /*offset*/
      2048 && set_style$6(
        t,
        "margin-left",
        /*offset*/
        b[11] + "px"
      );
    },
    i(b) {
      u || (transition_in$g(o.$$.fragment, b), u = !0);
    },
    o(b) {
      transition_out$g(o.$$.fragment, b), u = !1;
    },
    d(b) {
      b && detach$19(t), g && g.d(), destroy_component$e(o), c = !1, d();
    }
  };
}
function instance$b(e, t, r) {
  let a, {
    Icon: o
  } = t, {
    label: u = ""
  } = t, {
    show_label: c = !1
  } = t, {
    pending: d = !1
  } = t, {
    size: g = "small"
  } = t, {
    padded: b = !0
  } = t, {
    highlight: _ = !1
  } = t, {
    disabled: y = !1
  } = t, {
    hasPopup: A = !1
  } = t, {
    color: E = "var(--block-label-text-color)"
  } = t, {
    transparent: v = !1
  } = t, {
    background: C = "var(--background-fill-primary)"
  } = t, {
    offset: R = 0
  } = t;
  function I(w) {
    bubble$3.call(this, e, w);
  }
  return e.$$set = (w) => {
    "Icon" in w && r(0, o = w.Icon), "label" in w && r(1, u = w.label), "show_label" in w && r(2, c = w.show_label), "pending" in w && r(3, d = w.pending), "size" in w && r(4, g = w.size), "padded" in w && r(5, b = w.padded), "highlight" in w && r(6, _ = w.highlight), "disabled" in w && r(7, y = w.disabled), "hasPopup" in w && r(8, A = w.hasPopup), "color" in w && r(13, E = w.color), "transparent" in w && r(9, v = w.transparent), "background" in w && r(10, C = w.background), "offset" in w && r(11, R = w.offset);
  }, e.$$.update = () => {
    e.$$.dirty & /*highlight, color*/
    8256 && r(12, a = _ ? "var(--color-accent)" : E);
  }, [o, u, c, d, g, b, _, y, A, v, C, R, a, E, I];
}
class IconButton extends SvelteComponent$1e {
  constructor(t) {
    super(), init$1e(this, t, instance$b, create_fragment$c, safe_not_equal$1e, {
      Icon: 0,
      label: 1,
      show_label: 2,
      pending: 3,
      size: 4,
      padded: 5,
      highlight: 6,
      disabled: 7,
      hasPopup: 8,
      color: 13,
      transparent: 9,
      background: 10,
      offset: 11
    });
  }
}
const {
  SvelteComponent: SvelteComponent$1d,
  append_hydration: append_hydration$14,
  attr: attr$18,
  binding_callbacks: binding_callbacks$3,
  children: children$18,
  claim_element: claim_element$c,
  create_slot: create_slot$2,
  detach: detach$18,
  element: element$k,
  get_all_dirty_from_scope: get_all_dirty_from_scope$2,
  get_slot_changes: get_slot_changes$2,
  init: init$1d,
  insert_hydration: insert_hydration$18,
  safe_not_equal: safe_not_equal$1d,
  toggle_class: toggle_class$6,
  transition_in: transition_in$f,
  transition_out: transition_out$f,
  update_slot_base: update_slot_base$2
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1c,
  append_hydration: append_hydration$13,
  attr: attr$17,
  children: children$17,
  claim_svg_element: claim_svg_element$X,
  detach: detach$17,
  init: init$1c,
  insert_hydration: insert_hydration$17,
  noop: noop$10,
  safe_not_equal: safe_not_equal$1c,
  svg_element: svg_element$X
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1b,
  append_hydration: append_hydration$12,
  attr: attr$16,
  children: children$16,
  claim_svg_element: claim_svg_element$W,
  detach: detach$16,
  init: init$1b,
  insert_hydration: insert_hydration$16,
  noop: noop$$,
  safe_not_equal: safe_not_equal$1b,
  svg_element: svg_element$W
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1a,
  append_hydration: append_hydration$11,
  attr: attr$15,
  children: children$15,
  claim_svg_element: claim_svg_element$V,
  detach: detach$15,
  init: init$1a,
  insert_hydration: insert_hydration$15,
  noop: noop$_,
  safe_not_equal: safe_not_equal$1a,
  svg_element: svg_element$V
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$19,
  append_hydration: append_hydration$10,
  attr: attr$14,
  children: children$14,
  claim_svg_element: claim_svg_element$U,
  detach: detach$14,
  init: init$19,
  insert_hydration: insert_hydration$14,
  noop: noop$Z,
  safe_not_equal: safe_not_equal$19,
  svg_element: svg_element$U
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$18,
  append_hydration: append_hydration$$,
  attr: attr$13,
  children: children$13,
  claim_svg_element: claim_svg_element$T,
  detach: detach$13,
  init: init$18,
  insert_hydration: insert_hydration$13,
  noop: noop$Y,
  safe_not_equal: safe_not_equal$18,
  svg_element: svg_element$T
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$17,
  append_hydration: append_hydration$_,
  attr: attr$12,
  children: children$12,
  claim_svg_element: claim_svg_element$S,
  detach: detach$12,
  init: init$17,
  insert_hydration: insert_hydration$12,
  noop: noop$X,
  safe_not_equal: safe_not_equal$17,
  svg_element: svg_element$S
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$16,
  append_hydration: append_hydration$Z,
  attr: attr$11,
  children: children$11,
  claim_svg_element: claim_svg_element$R,
  detach: detach$11,
  init: init$16,
  insert_hydration: insert_hydration$11,
  noop: noop$W,
  safe_not_equal: safe_not_equal$16,
  svg_element: svg_element$R
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$15,
  append_hydration: append_hydration$Y,
  attr: attr$10,
  children: children$10,
  claim_svg_element: claim_svg_element$Q,
  detach: detach$10,
  init: init$15,
  insert_hydration: insert_hydration$10,
  noop: noop$V,
  safe_not_equal: safe_not_equal$15,
  svg_element: svg_element$Q
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$14,
  append_hydration: append_hydration$X,
  attr: attr$$,
  children: children$$,
  claim_svg_element: claim_svg_element$P,
  detach: detach$$,
  init: init$14,
  insert_hydration: insert_hydration$$,
  noop: noop$U,
  safe_not_equal: safe_not_equal$14,
  svg_element: svg_element$P
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$13,
  append_hydration: append_hydration$W,
  attr: attr$_,
  children: children$_,
  claim_svg_element: claim_svg_element$O,
  detach: detach$_,
  init: init$13,
  insert_hydration: insert_hydration$_,
  noop: noop$T,
  safe_not_equal: safe_not_equal$13,
  svg_element: svg_element$O
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$12,
  append_hydration: append_hydration$V,
  attr: attr$Z,
  children: children$Z,
  claim_svg_element: claim_svg_element$N,
  detach: detach$Z,
  init: init$12,
  insert_hydration: insert_hydration$Z,
  noop: noop$S,
  safe_not_equal: safe_not_equal$12,
  set_style: set_style$5,
  svg_element: svg_element$N
} = window.__gradio__svelte__internal;
function create_fragment$b(e) {
  let t, r, a, o;
  return {
    c() {
      t = svg_element$N("svg"), r = svg_element$N("g"), a = svg_element$N("path"), o = svg_element$N("path"), this.h();
    },
    l(u) {
      t = claim_svg_element$N(u, "svg", {
        width: !0,
        height: !0,
        viewBox: !0,
        version: !0,
        xmlns: !0,
        "xmlns:xlink": !0,
        "xml:space": !0,
        stroke: !0,
        style: !0
      });
      var c = children$Z(t);
      r = claim_svg_element$N(c, "g", {
        transform: !0
      });
      var d = children$Z(r);
      a = claim_svg_element$N(d, "path", {
        d: !0,
        style: !0
      }), children$Z(a).forEach(detach$Z), d.forEach(detach$Z), o = claim_svg_element$N(c, "path", {
        d: !0,
        style: !0
      }), children$Z(o).forEach(detach$Z), c.forEach(detach$Z), this.h();
    },
    h() {
      attr$Z(a, "d", "M18,6L6.087,17.913"), set_style$5(a, "fill", "none"), set_style$5(a, "fill-rule", "nonzero"), set_style$5(a, "stroke-width", "2px"), attr$Z(r, "transform", "matrix(1.14096,-0.140958,-0.140958,1.14096,-0.0559523,0.0559523)"), attr$Z(o, "d", "M4.364,4.364L19.636,19.636"), set_style$5(o, "fill", "none"), set_style$5(o, "fill-rule", "nonzero"), set_style$5(o, "stroke-width", "2px"), attr$Z(t, "width", "100%"), attr$Z(t, "height", "100%"), attr$Z(t, "viewBox", "0 0 24 24"), attr$Z(t, "version", "1.1"), attr$Z(t, "xmlns", "http://www.w3.org/2000/svg"), attr$Z(t, "xmlns:xlink", "http://www.w3.org/1999/xlink"), attr$Z(t, "xml:space", "preserve"), attr$Z(t, "stroke", "currentColor"), set_style$5(t, "fill-rule", "evenodd"), set_style$5(t, "clip-rule", "evenodd"), set_style$5(t, "stroke-linecap", "round"), set_style$5(t, "stroke-linejoin", "round");
    },
    m(u, c) {
      insert_hydration$Z(u, t, c), append_hydration$V(t, r), append_hydration$V(r, a), append_hydration$V(t, o);
    },
    p: noop$S,
    i: noop$S,
    o: noop$S,
    d(u) {
      u && detach$Z(t);
    }
  };
}
class Clear extends SvelteComponent$12 {
  constructor(t) {
    super(), init$12(this, t, null, create_fragment$b, safe_not_equal$12, {});
  }
}
const {
  SvelteComponent: SvelteComponent$11,
  append_hydration: append_hydration$U,
  attr: attr$Y,
  children: children$Y,
  claim_svg_element: claim_svg_element$M,
  detach: detach$Y,
  init: init$11,
  insert_hydration: insert_hydration$Y,
  noop: noop$R,
  safe_not_equal: safe_not_equal$11,
  svg_element: svg_element$M
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$10,
  append_hydration: append_hydration$T,
  attr: attr$X,
  children: children$X,
  claim_svg_element: claim_svg_element$L,
  detach: detach$X,
  init: init$10,
  insert_hydration: insert_hydration$X,
  noop: noop$Q,
  safe_not_equal: safe_not_equal$10,
  svg_element: svg_element$L
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$$,
  append_hydration: append_hydration$S,
  attr: attr$W,
  children: children$W,
  claim_svg_element: claim_svg_element$K,
  detach: detach$W,
  init: init$$,
  insert_hydration: insert_hydration$W,
  noop: noop$P,
  safe_not_equal: safe_not_equal$$,
  svg_element: svg_element$K
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$_,
  append_hydration: append_hydration$R,
  attr: attr$V,
  children: children$V,
  claim_svg_element: claim_svg_element$J,
  detach: detach$V,
  init: init$_,
  insert_hydration: insert_hydration$V,
  noop: noop$O,
  safe_not_equal: safe_not_equal$_,
  svg_element: svg_element$J
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$Z,
  append_hydration: append_hydration$Q,
  attr: attr$U,
  children: children$U,
  claim_svg_element: claim_svg_element$I,
  detach: detach$U,
  init: init$Z,
  insert_hydration: insert_hydration$U,
  noop: noop$N,
  safe_not_equal: safe_not_equal$Z,
  svg_element: svg_element$I
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$Y,
  append_hydration: append_hydration$P,
  attr: attr$T,
  children: children$T,
  claim_svg_element: claim_svg_element$H,
  detach: detach$T,
  init: init$Y,
  insert_hydration: insert_hydration$T,
  noop: noop$M,
  safe_not_equal: safe_not_equal$Y,
  svg_element: svg_element$H
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$X,
  append_hydration: append_hydration$O,
  attr: attr$S,
  children: children$S,
  claim_svg_element: claim_svg_element$G,
  detach: detach$S,
  init: init$X,
  insert_hydration: insert_hydration$S,
  noop: noop$L,
  safe_not_equal: safe_not_equal$X,
  svg_element: svg_element$G
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$W,
  append_hydration: append_hydration$N,
  attr: attr$R,
  children: children$R,
  claim_svg_element: claim_svg_element$F,
  detach: detach$R,
  init: init$W,
  insert_hydration: insert_hydration$R,
  noop: noop$K,
  safe_not_equal: safe_not_equal$W,
  svg_element: svg_element$F
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$V,
  append_hydration: append_hydration$M,
  attr: attr$Q,
  children: children$Q,
  claim_svg_element: claim_svg_element$E,
  detach: detach$Q,
  init: init$V,
  insert_hydration: insert_hydration$Q,
  noop: noop$J,
  safe_not_equal: safe_not_equal$V,
  svg_element: svg_element$E
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$U,
  append_hydration: append_hydration$L,
  attr: attr$P,
  children: children$P,
  claim_svg_element: claim_svg_element$D,
  detach: detach$P,
  init: init$U,
  insert_hydration: insert_hydration$P,
  noop: noop$I,
  safe_not_equal: safe_not_equal$U,
  svg_element: svg_element$D
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$T,
  append_hydration: append_hydration$K,
  attr: attr$O,
  children: children$O,
  claim_svg_element: claim_svg_element$C,
  detach: detach$O,
  init: init$T,
  insert_hydration: insert_hydration$O,
  noop: noop$H,
  safe_not_equal: safe_not_equal$T,
  svg_element: svg_element$C
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$S,
  append_hydration: append_hydration$J,
  attr: attr$N,
  children: children$N,
  claim_svg_element: claim_svg_element$B,
  detach: detach$N,
  init: init$S,
  insert_hydration: insert_hydration$N,
  noop: noop$G,
  safe_not_equal: safe_not_equal$S,
  svg_element: svg_element$B
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$R,
  append_hydration: append_hydration$I,
  attr: attr$M,
  children: children$M,
  claim_svg_element: claim_svg_element$A,
  detach: detach$M,
  init: init$R,
  insert_hydration: insert_hydration$M,
  noop: noop$F,
  safe_not_equal: safe_not_equal$R,
  svg_element: svg_element$A
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$Q,
  append_hydration: append_hydration$H,
  attr: attr$L,
  children: children$L,
  claim_svg_element: claim_svg_element$z,
  detach: detach$L,
  init: init$Q,
  insert_hydration: insert_hydration$L,
  noop: noop$E,
  safe_not_equal: safe_not_equal$Q,
  svg_element: svg_element$z
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$P,
  append_hydration: append_hydration$G,
  attr: attr$K,
  children: children$K,
  claim_svg_element: claim_svg_element$y,
  detach: detach$K,
  init: init$P,
  insert_hydration: insert_hydration$K,
  noop: noop$D,
  safe_not_equal: safe_not_equal$P,
  svg_element: svg_element$y
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$O,
  append_hydration: append_hydration$F,
  attr: attr$J,
  children: children$J,
  claim_svg_element: claim_svg_element$x,
  detach: detach$J,
  init: init$O,
  insert_hydration: insert_hydration$J,
  noop: noop$C,
  safe_not_equal: safe_not_equal$O,
  svg_element: svg_element$x
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$N,
  append_hydration: append_hydration$E,
  attr: attr$I,
  children: children$I,
  claim_svg_element: claim_svg_element$w,
  detach: detach$I,
  init: init$N,
  insert_hydration: insert_hydration$I,
  noop: noop$B,
  safe_not_equal: safe_not_equal$N,
  svg_element: svg_element$w
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$M,
  append_hydration: append_hydration$D,
  attr: attr$H,
  children: children$H,
  claim_svg_element: claim_svg_element$v,
  detach: detach$H,
  init: init$M,
  insert_hydration: insert_hydration$H,
  noop: noop$A,
  safe_not_equal: safe_not_equal$M,
  svg_element: svg_element$v
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$L,
  append_hydration: append_hydration$C,
  attr: attr$G,
  children: children$G,
  claim_svg_element: claim_svg_element$u,
  detach: detach$G,
  init: init$L,
  insert_hydration: insert_hydration$G,
  noop: noop$z,
  safe_not_equal: safe_not_equal$L,
  svg_element: svg_element$u
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$K,
  append_hydration: append_hydration$B,
  attr: attr$F,
  children: children$F,
  claim_svg_element: claim_svg_element$t,
  detach: detach$F,
  init: init$K,
  insert_hydration: insert_hydration$F,
  noop: noop$y,
  safe_not_equal: safe_not_equal$K,
  svg_element: svg_element$t
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$J,
  append_hydration: append_hydration$A,
  attr: attr$E,
  children: children$E,
  claim_svg_element: claim_svg_element$s,
  detach: detach$E,
  init: init$J,
  insert_hydration: insert_hydration$E,
  noop: noop$x,
  safe_not_equal: safe_not_equal$J,
  svg_element: svg_element$s
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$I,
  append_hydration: append_hydration$z,
  attr: attr$D,
  children: children$D,
  claim_svg_element: claim_svg_element$r,
  detach: detach$D,
  init: init$I,
  insert_hydration: insert_hydration$D,
  noop: noop$w,
  safe_not_equal: safe_not_equal$I,
  svg_element: svg_element$r
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$H,
  append_hydration: append_hydration$y,
  attr: attr$C,
  children: children$C,
  claim_svg_element: claim_svg_element$q,
  detach: detach$C,
  init: init$H,
  insert_hydration: insert_hydration$C,
  noop: noop$v,
  safe_not_equal: safe_not_equal$H,
  svg_element: svg_element$q
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$G,
  append_hydration: append_hydration$x,
  attr: attr$B,
  children: children$B,
  claim_svg_element: claim_svg_element$p,
  detach: detach$B,
  init: init$G,
  insert_hydration: insert_hydration$B,
  noop: noop$u,
  safe_not_equal: safe_not_equal$G,
  svg_element: svg_element$p
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$F,
  append_hydration: append_hydration$w,
  attr: attr$A,
  children: children$A,
  claim_svg_element: claim_svg_element$o,
  detach: detach$A,
  init: init$F,
  insert_hydration: insert_hydration$A,
  noop: noop$t,
  safe_not_equal: safe_not_equal$F,
  svg_element: svg_element$o
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$E,
  append_hydration: append_hydration$v,
  attr: attr$z,
  children: children$z,
  claim_svg_element: claim_svg_element$n,
  detach: detach$z,
  init: init$E,
  insert_hydration: insert_hydration$z,
  noop: noop$s,
  safe_not_equal: safe_not_equal$E,
  svg_element: svg_element$n
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$D,
  append_hydration: append_hydration$u,
  attr: attr$y,
  children: children$y,
  claim_svg_element: claim_svg_element$m,
  detach: detach$y,
  init: init$D,
  insert_hydration: insert_hydration$y,
  noop: noop$r,
  safe_not_equal: safe_not_equal$D,
  svg_element: svg_element$m
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$C,
  append_hydration: append_hydration$t,
  attr: attr$x,
  children: children$x,
  claim_svg_element: claim_svg_element$l,
  detach: detach$x,
  init: init$C,
  insert_hydration: insert_hydration$x,
  noop: noop$q,
  safe_not_equal: safe_not_equal$C,
  svg_element: svg_element$l
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$B,
  append_hydration: append_hydration$s,
  attr: attr$w,
  children: children$w,
  claim_svg_element: claim_svg_element$k,
  detach: detach$w,
  init: init$B,
  insert_hydration: insert_hydration$w,
  noop: noop$p,
  safe_not_equal: safe_not_equal$B,
  svg_element: svg_element$k
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$A,
  append_hydration: append_hydration$r,
  attr: attr$v,
  children: children$v,
  claim_svg_element: claim_svg_element$j,
  detach: detach$v,
  init: init$A,
  insert_hydration: insert_hydration$v,
  noop: noop$o,
  safe_not_equal: safe_not_equal$A,
  set_style: set_style$4,
  svg_element: svg_element$j
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$z,
  append_hydration: append_hydration$q,
  attr: attr$u,
  children: children$u,
  claim_svg_element: claim_svg_element$i,
  detach: detach$u,
  init: init$z,
  insert_hydration: insert_hydration$u,
  noop: noop$n,
  safe_not_equal: safe_not_equal$z,
  svg_element: svg_element$i
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$y,
  append_hydration: append_hydration$p,
  attr: attr$t,
  children: children$t,
  claim_svg_element: claim_svg_element$h,
  detach: detach$t,
  init: init$y,
  insert_hydration: insert_hydration$t,
  noop: noop$m,
  safe_not_equal: safe_not_equal$y,
  svg_element: svg_element$h
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$x,
  append_hydration: append_hydration$o,
  attr: attr$s,
  children: children$s,
  claim_svg_element: claim_svg_element$g,
  detach: detach$s,
  init: init$x,
  insert_hydration: insert_hydration$s,
  noop: noop$l,
  safe_not_equal: safe_not_equal$x,
  svg_element: svg_element$g
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$w,
  append_hydration: append_hydration$n,
  attr: attr$r,
  children: children$r,
  claim_svg_element: claim_svg_element$f,
  detach: detach$r,
  init: init$w,
  insert_hydration: insert_hydration$r,
  noop: noop$k,
  safe_not_equal: safe_not_equal$w,
  svg_element: svg_element$f
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$v,
  append_hydration: append_hydration$m,
  attr: attr$q,
  children: children$q,
  claim_svg_element: claim_svg_element$e,
  detach: detach$q,
  init: init$v,
  insert_hydration: insert_hydration$q,
  noop: noop$j,
  safe_not_equal: safe_not_equal$v,
  svg_element: svg_element$e
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$u,
  append_hydration: append_hydration$l,
  attr: attr$p,
  children: children$p,
  claim_svg_element: claim_svg_element$d,
  detach: detach$p,
  init: init$u,
  insert_hydration: insert_hydration$p,
  noop: noop$i,
  safe_not_equal: safe_not_equal$u,
  svg_element: svg_element$d
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$t,
  append_hydration: append_hydration$k,
  attr: attr$o,
  children: children$o,
  claim_svg_element: claim_svg_element$c,
  detach: detach$o,
  init: init$t,
  insert_hydration: insert_hydration$o,
  noop: noop$h,
  safe_not_equal: safe_not_equal$t,
  svg_element: svg_element$c
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$s,
  append_hydration: append_hydration$j,
  attr: attr$n,
  children: children$n,
  claim_svg_element: claim_svg_element$b,
  detach: detach$n,
  init: init$s,
  insert_hydration: insert_hydration$n,
  noop: noop$g,
  safe_not_equal: safe_not_equal$s,
  svg_element: svg_element$b
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$r,
  append_hydration: append_hydration$i,
  attr: attr$m,
  children: children$m,
  claim_svg_element: claim_svg_element$a,
  claim_text: claim_text$7,
  detach: detach$m,
  init: init$r,
  insert_hydration: insert_hydration$m,
  noop: noop$f,
  safe_not_equal: safe_not_equal$r,
  svg_element: svg_element$a,
  text: text$j
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$q,
  append_hydration: append_hydration$h,
  attr: attr$l,
  children: children$l,
  claim_svg_element: claim_svg_element$9,
  detach: detach$l,
  init: init$q,
  insert_hydration: insert_hydration$l,
  noop: noop$e,
  safe_not_equal: safe_not_equal$q,
  svg_element: svg_element$9
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$p,
  append_hydration: append_hydration$g,
  attr: attr$k,
  children: children$k,
  claim_svg_element: claim_svg_element$8,
  detach: detach$k,
  init: init$p,
  insert_hydration: insert_hydration$k,
  noop: noop$d,
  safe_not_equal: safe_not_equal$p,
  svg_element: svg_element$8
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$o,
  append_hydration: append_hydration$f,
  attr: attr$j,
  children: children$j,
  claim_svg_element: claim_svg_element$7,
  detach: detach$j,
  init: init$o,
  insert_hydration: insert_hydration$j,
  noop: noop$c,
  safe_not_equal: safe_not_equal$o,
  svg_element: svg_element$7
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$n,
  append_hydration: append_hydration$e,
  attr: attr$i,
  children: children$i,
  claim_svg_element: claim_svg_element$6,
  detach: detach$i,
  init: init$n,
  insert_hydration: insert_hydration$i,
  noop: noop$b,
  safe_not_equal: safe_not_equal$n,
  svg_element: svg_element$6
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$m,
  append_hydration: append_hydration$d,
  attr: attr$h,
  children: children$h,
  claim_svg_element: claim_svg_element$5,
  detach: detach$h,
  init: init$m,
  insert_hydration: insert_hydration$h,
  noop: noop$a,
  safe_not_equal: safe_not_equal$m,
  svg_element: svg_element$5
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$l,
  append_hydration: append_hydration$c,
  attr: attr$g,
  children: children$g,
  claim_svg_element: claim_svg_element$4,
  claim_text: claim_text$6,
  detach: detach$g,
  init: init$l,
  insert_hydration: insert_hydration$g,
  noop: noop$9,
  safe_not_equal: safe_not_equal$l,
  svg_element: svg_element$4,
  text: text$i
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$k,
  append_hydration: append_hydration$b,
  attr: attr$f,
  children: children$f,
  claim_svg_element: claim_svg_element$3,
  claim_text: claim_text$5,
  detach: detach$f,
  init: init$k,
  insert_hydration: insert_hydration$f,
  noop: noop$8,
  safe_not_equal: safe_not_equal$k,
  svg_element: svg_element$3,
  text: text$h
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$j,
  append_hydration: append_hydration$a,
  attr: attr$e,
  children: children$e,
  claim_svg_element: claim_svg_element$2,
  claim_text: claim_text$4,
  detach: detach$e,
  init: init$j,
  insert_hydration: insert_hydration$e,
  noop: noop$7,
  safe_not_equal: safe_not_equal$j,
  svg_element: svg_element$2,
  text: text$g
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$i,
  append_hydration: append_hydration$9,
  attr: attr$d,
  children: children$d,
  claim_svg_element: claim_svg_element$1,
  detach: detach$d,
  init: init$i,
  insert_hydration: insert_hydration$d,
  noop: noop$6,
  safe_not_equal: safe_not_equal$i,
  svg_element: svg_element$1
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$h,
  append_hydration: append_hydration$8,
  attr: attr$c,
  children: children$c,
  claim_svg_element,
  detach: detach$c,
  init: init$h,
  insert_hydration: insert_hydration$c,
  noop: noop$5,
  safe_not_equal: safe_not_equal$h,
  svg_element
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$g,
  claim_component: claim_component$d,
  create_component: create_component$d,
  destroy_component: destroy_component$d,
  init: init$g,
  mount_component: mount_component$d,
  safe_not_equal: safe_not_equal$g,
  transition_in: transition_in$e,
  transition_out: transition_out$e
} = window.__gradio__svelte__internal, {
  createEventDispatcher: createEventDispatcher$4
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$f,
  append_hydration: append_hydration$7,
  attr: attr$b,
  check_outros: check_outros$7,
  children: children$b,
  claim_component: claim_component$c,
  claim_element: claim_element$b,
  claim_space: claim_space$7,
  claim_text: claim_text$3,
  create_component: create_component$c,
  destroy_component: destroy_component$c,
  detach: detach$b,
  element: element$j,
  empty: empty$7,
  group_outros: group_outros$7,
  init: init$f,
  insert_hydration: insert_hydration$b,
  mount_component: mount_component$c,
  safe_not_equal: safe_not_equal$f,
  set_data: set_data$3,
  space: space$b,
  text: text$f,
  toggle_class: toggle_class$5,
  transition_in: transition_in$d,
  transition_out: transition_out$d
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$e,
  attr: attr$a,
  children: children$a,
  claim_element: claim_element$a,
  create_slot: create_slot$1,
  detach: detach$a,
  element: element$i,
  get_all_dirty_from_scope: get_all_dirty_from_scope$1,
  get_slot_changes: get_slot_changes$1,
  init: init$e,
  insert_hydration: insert_hydration$a,
  safe_not_equal: safe_not_equal$e,
  toggle_class: toggle_class$4,
  transition_in: transition_in$c,
  transition_out: transition_out$c,
  update_slot_base: update_slot_base$1
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$d,
  append_hydration: append_hydration$6,
  attr: attr$9,
  check_outros: check_outros$6,
  children: children$9,
  claim_component: claim_component$b,
  claim_element: claim_element$9,
  claim_space: claim_space$6,
  create_component: create_component$b,
  destroy_component: destroy_component$b,
  detach: detach$9,
  element: element$h,
  empty: empty$6,
  group_outros: group_outros$6,
  init: init$d,
  insert_hydration: insert_hydration$9,
  listen: listen$4,
  mount_component: mount_component$b,
  safe_not_equal: safe_not_equal$d,
  space: space$a,
  toggle_class: toggle_class$3,
  transition_in: transition_in$b,
  transition_out: transition_out$b
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$c,
  append_hydration: append_hydration$5,
  attr: attr$8,
  binding_callbacks: binding_callbacks$2,
  check_outros: check_outros$5,
  children: children$8,
  claim_component: claim_component$a,
  claim_element: claim_element$8,
  claim_space: claim_space$5,
  claim_text: claim_text$2,
  create_component: create_component$a,
  create_slot,
  destroy_component: destroy_component$a,
  destroy_each: destroy_each$1,
  detach: detach$8,
  element: element$g,
  empty: empty$5,
  ensure_array_like: ensure_array_like$2,
  get_all_dirty_from_scope,
  get_slot_changes,
  group_outros: group_outros$5,
  init: init$c,
  insert_hydration: insert_hydration$8,
  mount_component: mount_component$a,
  noop: noop$4,
  safe_not_equal: safe_not_equal$c,
  set_data: set_data$2,
  set_style: set_style$3,
  space: space$9,
  text: text$e,
  toggle_class: toggle_class$2,
  transition_in: transition_in$a,
  transition_out: transition_out$a,
  update_slot_base
} = window.__gradio__svelte__internal, {
  tick
} = window.__gradio__svelte__internal, {
  onDestroy: onDestroy$3
} = window.__gradio__svelte__internal, {
  createEventDispatcher: createEventDispatcher$3
} = window.__gradio__svelte__internal, get_error_slot_changes = (e) => ({}), get_error_slot_context = (e) => ({}), get_additional_loading_text_slot_changes = (e) => ({}), get_additional_loading_text_slot_context = (e) => ({});
function get_each_context$1(e, t, r) {
  const a = e.slice();
  return a[40] = t[r], a[42] = r, a;
}
function get_each_context_1$1(e, t, r) {
  const a = e.slice();
  return a[40] = t[r], a;
}
function create_if_block_17(e) {
  let t, r, a, o, u = (
    /*i18n*/
    e[1]("common.error") + ""
  ), c, d, g;
  r = new IconButton({
    props: {
      Icon: Clear,
      label: (
        /*i18n*/
        e[1]("common.clear")
      ),
      disabled: !1
    }
  }), r.$on(
    "click",
    /*click_handler*/
    e[32]
  );
  const b = (
    /*#slots*/
    e[30].error
  ), _ = create_slot(
    b,
    e,
    /*$$scope*/
    e[29],
    get_error_slot_context
  );
  return {
    c() {
      t = element$g("div"), create_component$a(r.$$.fragment), a = space$9(), o = element$g("span"), c = text$e(u), d = space$9(), _ && _.c(), this.h();
    },
    l(y) {
      t = claim_element$8(y, "DIV", {
        class: !0
      });
      var A = children$8(t);
      claim_component$a(r.$$.fragment, A), A.forEach(detach$8), a = claim_space$5(y), o = claim_element$8(y, "SPAN", {
        class: !0
      });
      var E = children$8(o);
      c = claim_text$2(E, u), E.forEach(detach$8), d = claim_space$5(y), _ && _.l(y), this.h();
    },
    h() {
      attr$8(t, "class", "clear-status svelte-v0wucf"), attr$8(o, "class", "error svelte-v0wucf");
    },
    m(y, A) {
      insert_hydration$8(y, t, A), mount_component$a(r, t, null), insert_hydration$8(y, a, A), insert_hydration$8(y, o, A), append_hydration$5(o, c), insert_hydration$8(y, d, A), _ && _.m(y, A), g = !0;
    },
    p(y, A) {
      const E = {};
      A[0] & /*i18n*/
      2 && (E.label = /*i18n*/
      y[1]("common.clear")), r.$set(E), (!g || A[0] & /*i18n*/
      2) && u !== (u = /*i18n*/
      y[1]("common.error") + "") && set_data$2(c, u), _ && _.p && (!g || A[0] & /*$$scope*/
      536870912) && update_slot_base(
        _,
        b,
        y,
        /*$$scope*/
        y[29],
        g ? get_slot_changes(
          b,
          /*$$scope*/
          y[29],
          A,
          get_error_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          y[29]
        ),
        get_error_slot_context
      );
    },
    i(y) {
      g || (transition_in$a(r.$$.fragment, y), transition_in$a(_, y), g = !0);
    },
    o(y) {
      transition_out$a(r.$$.fragment, y), transition_out$a(_, y), g = !1;
    },
    d(y) {
      y && (detach$8(t), detach$8(a), detach$8(o), detach$8(d)), destroy_component$a(r), _ && _.d(y);
    }
  };
}
function create_if_block$3(e) {
  let t, r, a, o, u, c, d, g, b, _ = (
    /*variant*/
    e[8] === "default" && /*show_eta_bar*/
    e[18] && /*show_progress*/
    e[6] === "full" && create_if_block_16(e)
  );
  function y(N, F) {
    if (
      /*progress*/
      N[7]
    ) return create_if_block_11;
    if (
      /*queue_position*/
      N[2] !== null && /*queue_size*/
      N[3] !== void 0 && /*queue_position*/
      N[2] >= 0
    ) return create_if_block_14;
    if (
      /*queue_position*/
      N[2] === 0
    ) return create_if_block_15;
  }
  let A = y(e), E = A && A(e), v = (
    /*timer*/
    e[5] && create_if_block_10$1(e)
  );
  const C = [create_if_block_2$1, create_if_block_9$1], R = [];
  function I(N, F) {
    return (
      /*last_progress_level*/
      N[15] != null ? 0 : (
        /*show_progress*/
        N[6] === "full" ? 1 : -1
      )
    );
  }
  ~(u = I(e)) && (c = R[u] = C[u](e));
  let w = !/*timer*/
  e[5] && create_if_block_1$3(e);
  return {
    c() {
      _ && _.c(), t = space$9(), r = element$g("div"), E && E.c(), a = space$9(), v && v.c(), o = space$9(), c && c.c(), d = space$9(), w && w.c(), g = empty$5(), this.h();
    },
    l(N) {
      _ && _.l(N), t = claim_space$5(N), r = claim_element$8(N, "DIV", {
        class: !0
      });
      var F = children$8(r);
      E && E.l(F), a = claim_space$5(F), v && v.l(F), F.forEach(detach$8), o = claim_space$5(N), c && c.l(N), d = claim_space$5(N), w && w.l(N), g = empty$5(), this.h();
    },
    h() {
      attr$8(r, "class", "progress-text svelte-v0wucf"), toggle_class$2(
        r,
        "meta-text-center",
        /*variant*/
        e[8] === "center"
      ), toggle_class$2(
        r,
        "meta-text",
        /*variant*/
        e[8] === "default"
      );
    },
    m(N, F) {
      _ && _.m(N, F), insert_hydration$8(N, t, F), insert_hydration$8(N, r, F), E && E.m(r, null), append_hydration$5(r, a), v && v.m(r, null), insert_hydration$8(N, o, F), ~u && R[u].m(N, F), insert_hydration$8(N, d, F), w && w.m(N, F), insert_hydration$8(N, g, F), b = !0;
    },
    p(N, F) {
      /*variant*/
      N[8] === "default" && /*show_eta_bar*/
      N[18] && /*show_progress*/
      N[6] === "full" ? _ ? _.p(N, F) : (_ = create_if_block_16(N), _.c(), _.m(t.parentNode, t)) : _ && (_.d(1), _ = null), A === (A = y(N)) && E ? E.p(N, F) : (E && E.d(1), E = A && A(N), E && (E.c(), E.m(r, a))), /*timer*/
      N[5] ? v ? v.p(N, F) : (v = create_if_block_10$1(N), v.c(), v.m(r, null)) : v && (v.d(1), v = null), (!b || F[0] & /*variant*/
      256) && toggle_class$2(
        r,
        "meta-text-center",
        /*variant*/
        N[8] === "center"
      ), (!b || F[0] & /*variant*/
      256) && toggle_class$2(
        r,
        "meta-text",
        /*variant*/
        N[8] === "default"
      );
      let M = u;
      u = I(N), u === M ? ~u && R[u].p(N, F) : (c && (group_outros$5(), transition_out$a(R[M], 1, 1, () => {
        R[M] = null;
      }), check_outros$5()), ~u ? (c = R[u], c ? c.p(N, F) : (c = R[u] = C[u](N), c.c()), transition_in$a(c, 1), c.m(d.parentNode, d)) : c = null), /*timer*/
      N[5] ? w && (group_outros$5(), transition_out$a(w, 1, 1, () => {
        w = null;
      }), check_outros$5()) : w ? (w.p(N, F), F[0] & /*timer*/
      32 && transition_in$a(w, 1)) : (w = create_if_block_1$3(N), w.c(), transition_in$a(w, 1), w.m(g.parentNode, g));
    },
    i(N) {
      b || (transition_in$a(c), transition_in$a(w), b = !0);
    },
    o(N) {
      transition_out$a(c), transition_out$a(w), b = !1;
    },
    d(N) {
      N && (detach$8(t), detach$8(r), detach$8(o), detach$8(d), detach$8(g)), _ && _.d(N), E && E.d(), v && v.d(), ~u && R[u].d(N), w && w.d(N);
    }
  };
}
function create_if_block_16(e) {
  let t, r = `translateX(${/*eta_level*/
  (e[17] || 0) * 100 - 100}%)`;
  return {
    c() {
      t = element$g("div"), this.h();
    },
    l(a) {
      t = claim_element$8(a, "DIV", {
        class: !0
      }), children$8(t).forEach(detach$8), this.h();
    },
    h() {
      attr$8(t, "class", "eta-bar svelte-v0wucf"), set_style$3(t, "transform", r);
    },
    m(a, o) {
      insert_hydration$8(a, t, o);
    },
    p(a, o) {
      o[0] & /*eta_level*/
      131072 && r !== (r = `translateX(${/*eta_level*/
      (a[17] || 0) * 100 - 100}%)`) && set_style$3(t, "transform", r);
    },
    d(a) {
      a && detach$8(t);
    }
  };
}
function create_if_block_15(e) {
  let t;
  return {
    c() {
      t = text$e("processing |");
    },
    l(r) {
      t = claim_text$2(r, "processing |");
    },
    m(r, a) {
      insert_hydration$8(r, t, a);
    },
    p: noop$4,
    d(r) {
      r && detach$8(t);
    }
  };
}
function create_if_block_14(e) {
  let t, r = (
    /*queue_position*/
    e[2] + 1 + ""
  ), a, o, u, c;
  return {
    c() {
      t = text$e("queue: "), a = text$e(r), o = text$e("/"), u = text$e(
        /*queue_size*/
        e[3]
      ), c = text$e(" |");
    },
    l(d) {
      t = claim_text$2(d, "queue: "), a = claim_text$2(d, r), o = claim_text$2(d, "/"), u = claim_text$2(
        d,
        /*queue_size*/
        e[3]
      ), c = claim_text$2(d, " |");
    },
    m(d, g) {
      insert_hydration$8(d, t, g), insert_hydration$8(d, a, g), insert_hydration$8(d, o, g), insert_hydration$8(d, u, g), insert_hydration$8(d, c, g);
    },
    p(d, g) {
      g[0] & /*queue_position*/
      4 && r !== (r = /*queue_position*/
      d[2] + 1 + "") && set_data$2(a, r), g[0] & /*queue_size*/
      8 && set_data$2(
        u,
        /*queue_size*/
        d[3]
      );
    },
    d(d) {
      d && (detach$8(t), detach$8(a), detach$8(o), detach$8(u), detach$8(c));
    }
  };
}
function create_if_block_11(e) {
  let t, r = ensure_array_like$2(
    /*progress*/
    e[7]
  ), a = [];
  for (let o = 0; o < r.length; o += 1)
    a[o] = create_each_block_1$1(get_each_context_1$1(e, r, o));
  return {
    c() {
      for (let o = 0; o < a.length; o += 1)
        a[o].c();
      t = empty$5();
    },
    l(o) {
      for (let u = 0; u < a.length; u += 1)
        a[u].l(o);
      t = empty$5();
    },
    m(o, u) {
      for (let c = 0; c < a.length; c += 1)
        a[c] && a[c].m(o, u);
      insert_hydration$8(o, t, u);
    },
    p(o, u) {
      if (u[0] & /*progress*/
      128) {
        r = ensure_array_like$2(
          /*progress*/
          o[7]
        );
        let c;
        for (c = 0; c < r.length; c += 1) {
          const d = get_each_context_1$1(o, r, c);
          a[c] ? a[c].p(d, u) : (a[c] = create_each_block_1$1(d), a[c].c(), a[c].m(t.parentNode, t));
        }
        for (; c < a.length; c += 1)
          a[c].d(1);
        a.length = r.length;
      }
    },
    d(o) {
      o && detach$8(t), destroy_each$1(a, o);
    }
  };
}
function create_if_block_12(e) {
  let t, r = (
    /*p*/
    e[40].unit + ""
  ), a, o, u = " ", c;
  function d(_, y) {
    return (
      /*p*/
      _[40].length != null ? create_if_block_13 : create_else_block
    );
  }
  let g = d(e), b = g(e);
  return {
    c() {
      b.c(), t = space$9(), a = text$e(r), o = text$e(" | "), c = text$e(u);
    },
    l(_) {
      b.l(_), t = claim_space$5(_), a = claim_text$2(_, r), o = claim_text$2(_, " | "), c = claim_text$2(_, u);
    },
    m(_, y) {
      b.m(_, y), insert_hydration$8(_, t, y), insert_hydration$8(_, a, y), insert_hydration$8(_, o, y), insert_hydration$8(_, c, y);
    },
    p(_, y) {
      g === (g = d(_)) && b ? b.p(_, y) : (b.d(1), b = g(_), b && (b.c(), b.m(t.parentNode, t))), y[0] & /*progress*/
      128 && r !== (r = /*p*/
      _[40].unit + "") && set_data$2(a, r);
    },
    d(_) {
      _ && (detach$8(t), detach$8(a), detach$8(o), detach$8(c)), b.d(_);
    }
  };
}
function create_else_block(e) {
  let t = pretty_si(
    /*p*/
    e[40].index || 0
  ) + "", r;
  return {
    c() {
      r = text$e(t);
    },
    l(a) {
      r = claim_text$2(a, t);
    },
    m(a, o) {
      insert_hydration$8(a, r, o);
    },
    p(a, o) {
      o[0] & /*progress*/
      128 && t !== (t = pretty_si(
        /*p*/
        a[40].index || 0
      ) + "") && set_data$2(r, t);
    },
    d(a) {
      a && detach$8(r);
    }
  };
}
function create_if_block_13(e) {
  let t = pretty_si(
    /*p*/
    e[40].index || 0
  ) + "", r, a, o = pretty_si(
    /*p*/
    e[40].length
  ) + "", u;
  return {
    c() {
      r = text$e(t), a = text$e("/"), u = text$e(o);
    },
    l(c) {
      r = claim_text$2(c, t), a = claim_text$2(c, "/"), u = claim_text$2(c, o);
    },
    m(c, d) {
      insert_hydration$8(c, r, d), insert_hydration$8(c, a, d), insert_hydration$8(c, u, d);
    },
    p(c, d) {
      d[0] & /*progress*/
      128 && t !== (t = pretty_si(
        /*p*/
        c[40].index || 0
      ) + "") && set_data$2(r, t), d[0] & /*progress*/
      128 && o !== (o = pretty_si(
        /*p*/
        c[40].length
      ) + "") && set_data$2(u, o);
    },
    d(c) {
      c && (detach$8(r), detach$8(a), detach$8(u));
    }
  };
}
function create_each_block_1$1(e) {
  let t, r = (
    /*p*/
    e[40].index != null && create_if_block_12(e)
  );
  return {
    c() {
      r && r.c(), t = empty$5();
    },
    l(a) {
      r && r.l(a), t = empty$5();
    },
    m(a, o) {
      r && r.m(a, o), insert_hydration$8(a, t, o);
    },
    p(a, o) {
      /*p*/
      a[40].index != null ? r ? r.p(a, o) : (r = create_if_block_12(a), r.c(), r.m(t.parentNode, t)) : r && (r.d(1), r = null);
    },
    d(a) {
      a && detach$8(t), r && r.d(a);
    }
  };
}
function create_if_block_10$1(e) {
  let t, r = (
    /*eta*/
    e[0] ? `/${/*formatted_eta*/
    e[19]}` : ""
  ), a, o;
  return {
    c() {
      t = text$e(
        /*formatted_timer*/
        e[20]
      ), a = text$e(r), o = text$e("s");
    },
    l(u) {
      t = claim_text$2(
        u,
        /*formatted_timer*/
        e[20]
      ), a = claim_text$2(u, r), o = claim_text$2(u, "s");
    },
    m(u, c) {
      insert_hydration$8(u, t, c), insert_hydration$8(u, a, c), insert_hydration$8(u, o, c);
    },
    p(u, c) {
      c[0] & /*formatted_timer*/
      1048576 && set_data$2(
        t,
        /*formatted_timer*/
        u[20]
      ), c[0] & /*eta, formatted_eta*/
      524289 && r !== (r = /*eta*/
      u[0] ? `/${/*formatted_eta*/
      u[19]}` : "") && set_data$2(a, r);
    },
    d(u) {
      u && (detach$8(t), detach$8(a), detach$8(o));
    }
  };
}
function create_if_block_9$1(e) {
  let t, r;
  return t = new Loader({
    props: {
      margin: (
        /*variant*/
        e[8] === "default"
      )
    }
  }), {
    c() {
      create_component$a(t.$$.fragment);
    },
    l(a) {
      claim_component$a(t.$$.fragment, a);
    },
    m(a, o) {
      mount_component$a(t, a, o), r = !0;
    },
    p(a, o) {
      const u = {};
      o[0] & /*variant*/
      256 && (u.margin = /*variant*/
      a[8] === "default"), t.$set(u);
    },
    i(a) {
      r || (transition_in$a(t.$$.fragment, a), r = !0);
    },
    o(a) {
      transition_out$a(t.$$.fragment, a), r = !1;
    },
    d(a) {
      destroy_component$a(t, a);
    }
  };
}
function create_if_block_2$1(e) {
  let t, r, a, o, u, c = `${/*last_progress_level*/
  e[15] * 100}%`, d = (
    /*progress*/
    e[7] != null && create_if_block_3$1(e)
  );
  return {
    c() {
      t = element$g("div"), r = element$g("div"), d && d.c(), a = space$9(), o = element$g("div"), u = element$g("div"), this.h();
    },
    l(g) {
      t = claim_element$8(g, "DIV", {
        class: !0
      });
      var b = children$8(t);
      r = claim_element$8(b, "DIV", {
        class: !0
      });
      var _ = children$8(r);
      d && d.l(_), _.forEach(detach$8), a = claim_space$5(b), o = claim_element$8(b, "DIV", {
        class: !0
      });
      var y = children$8(o);
      u = claim_element$8(y, "DIV", {
        class: !0
      }), children$8(u).forEach(detach$8), y.forEach(detach$8), b.forEach(detach$8), this.h();
    },
    h() {
      attr$8(r, "class", "progress-level-inner svelte-v0wucf"), attr$8(u, "class", "progress-bar svelte-v0wucf"), set_style$3(u, "width", c), attr$8(o, "class", "progress-bar-wrap svelte-v0wucf"), attr$8(t, "class", "progress-level svelte-v0wucf");
    },
    m(g, b) {
      insert_hydration$8(g, t, b), append_hydration$5(t, r), d && d.m(r, null), append_hydration$5(t, a), append_hydration$5(t, o), append_hydration$5(o, u), e[31](u);
    },
    p(g, b) {
      /*progress*/
      g[7] != null ? d ? d.p(g, b) : (d = create_if_block_3$1(g), d.c(), d.m(r, null)) : d && (d.d(1), d = null), b[0] & /*last_progress_level*/
      32768 && c !== (c = `${/*last_progress_level*/
      g[15] * 100}%`) && set_style$3(u, "width", c);
    },
    i: noop$4,
    o: noop$4,
    d(g) {
      g && detach$8(t), d && d.d(), e[31](null);
    }
  };
}
function create_if_block_3$1(e) {
  let t, r = ensure_array_like$2(
    /*progress*/
    e[7]
  ), a = [];
  for (let o = 0; o < r.length; o += 1)
    a[o] = create_each_block$1(get_each_context$1(e, r, o));
  return {
    c() {
      for (let o = 0; o < a.length; o += 1)
        a[o].c();
      t = empty$5();
    },
    l(o) {
      for (let u = 0; u < a.length; u += 1)
        a[u].l(o);
      t = empty$5();
    },
    m(o, u) {
      for (let c = 0; c < a.length; c += 1)
        a[c] && a[c].m(o, u);
      insert_hydration$8(o, t, u);
    },
    p(o, u) {
      if (u[0] & /*progress_level, progress*/
      16512) {
        r = ensure_array_like$2(
          /*progress*/
          o[7]
        );
        let c;
        for (c = 0; c < r.length; c += 1) {
          const d = get_each_context$1(o, r, c);
          a[c] ? a[c].p(d, u) : (a[c] = create_each_block$1(d), a[c].c(), a[c].m(t.parentNode, t));
        }
        for (; c < a.length; c += 1)
          a[c].d(1);
        a.length = r.length;
      }
    },
    d(o) {
      o && detach$8(t), destroy_each$1(a, o);
    }
  };
}
function create_if_block_4$1(e) {
  let t, r, a, o, u = (
    /*i*/
    e[42] !== 0 && create_if_block_8$1()
  ), c = (
    /*p*/
    e[40].desc != null && create_if_block_7$1(e)
  ), d = (
    /*p*/
    e[40].desc != null && /*progress_level*/
    e[14] && /*progress_level*/
    e[14][
      /*i*/
      e[42]
    ] != null && create_if_block_6$1()
  ), g = (
    /*progress_level*/
    e[14] != null && create_if_block_5$1(e)
  );
  return {
    c() {
      u && u.c(), t = space$9(), c && c.c(), r = space$9(), d && d.c(), a = space$9(), g && g.c(), o = empty$5();
    },
    l(b) {
      u && u.l(b), t = claim_space$5(b), c && c.l(b), r = claim_space$5(b), d && d.l(b), a = claim_space$5(b), g && g.l(b), o = empty$5();
    },
    m(b, _) {
      u && u.m(b, _), insert_hydration$8(b, t, _), c && c.m(b, _), insert_hydration$8(b, r, _), d && d.m(b, _), insert_hydration$8(b, a, _), g && g.m(b, _), insert_hydration$8(b, o, _);
    },
    p(b, _) {
      /*p*/
      b[40].desc != null ? c ? c.p(b, _) : (c = create_if_block_7$1(b), c.c(), c.m(r.parentNode, r)) : c && (c.d(1), c = null), /*p*/
      b[40].desc != null && /*progress_level*/
      b[14] && /*progress_level*/
      b[14][
        /*i*/
        b[42]
      ] != null ? d || (d = create_if_block_6$1(), d.c(), d.m(a.parentNode, a)) : d && (d.d(1), d = null), /*progress_level*/
      b[14] != null ? g ? g.p(b, _) : (g = create_if_block_5$1(b), g.c(), g.m(o.parentNode, o)) : g && (g.d(1), g = null);
    },
    d(b) {
      b && (detach$8(t), detach$8(r), detach$8(a), detach$8(o)), u && u.d(b), c && c.d(b), d && d.d(b), g && g.d(b);
    }
  };
}
function create_if_block_8$1(e) {
  let t;
  return {
    c() {
      t = text$e("/");
    },
    l(r) {
      t = claim_text$2(r, "/");
    },
    m(r, a) {
      insert_hydration$8(r, t, a);
    },
    d(r) {
      r && detach$8(t);
    }
  };
}
function create_if_block_7$1(e) {
  let t = (
    /*p*/
    e[40].desc + ""
  ), r;
  return {
    c() {
      r = text$e(t);
    },
    l(a) {
      r = claim_text$2(a, t);
    },
    m(a, o) {
      insert_hydration$8(a, r, o);
    },
    p(a, o) {
      o[0] & /*progress*/
      128 && t !== (t = /*p*/
      a[40].desc + "") && set_data$2(r, t);
    },
    d(a) {
      a && detach$8(r);
    }
  };
}
function create_if_block_6$1(e) {
  let t;
  return {
    c() {
      t = text$e("-");
    },
    l(r) {
      t = claim_text$2(r, "-");
    },
    m(r, a) {
      insert_hydration$8(r, t, a);
    },
    d(r) {
      r && detach$8(t);
    }
  };
}
function create_if_block_5$1(e) {
  let t = (100 * /*progress_level*/
  (e[14][
    /*i*/
    e[42]
  ] || 0)).toFixed(1) + "", r, a;
  return {
    c() {
      r = text$e(t), a = text$e("%");
    },
    l(o) {
      r = claim_text$2(o, t), a = claim_text$2(o, "%");
    },
    m(o, u) {
      insert_hydration$8(o, r, u), insert_hydration$8(o, a, u);
    },
    p(o, u) {
      u[0] & /*progress_level*/
      16384 && t !== (t = (100 * /*progress_level*/
      (o[14][
        /*i*/
        o[42]
      ] || 0)).toFixed(1) + "") && set_data$2(r, t);
    },
    d(o) {
      o && (detach$8(r), detach$8(a));
    }
  };
}
function create_each_block$1(e) {
  let t, r = (
    /*p*/
    (e[40].desc != null || /*progress_level*/
    e[14] && /*progress_level*/
    e[14][
      /*i*/
      e[42]
    ] != null) && create_if_block_4$1(e)
  );
  return {
    c() {
      r && r.c(), t = empty$5();
    },
    l(a) {
      r && r.l(a), t = empty$5();
    },
    m(a, o) {
      r && r.m(a, o), insert_hydration$8(a, t, o);
    },
    p(a, o) {
      /*p*/
      a[40].desc != null || /*progress_level*/
      a[14] && /*progress_level*/
      a[14][
        /*i*/
        a[42]
      ] != null ? r ? r.p(a, o) : (r = create_if_block_4$1(a), r.c(), r.m(t.parentNode, t)) : r && (r.d(1), r = null);
    },
    d(a) {
      a && detach$8(t), r && r.d(a);
    }
  };
}
function create_if_block_1$3(e) {
  let t, r, a, o;
  const u = (
    /*#slots*/
    e[30]["additional-loading-text"]
  ), c = create_slot(
    u,
    e,
    /*$$scope*/
    e[29],
    get_additional_loading_text_slot_context
  );
  return {
    c() {
      t = element$g("p"), r = text$e(
        /*loading_text*/
        e[9]
      ), a = space$9(), c && c.c(), this.h();
    },
    l(d) {
      t = claim_element$8(d, "P", {
        class: !0
      });
      var g = children$8(t);
      r = claim_text$2(
        g,
        /*loading_text*/
        e[9]
      ), g.forEach(detach$8), a = claim_space$5(d), c && c.l(d), this.h();
    },
    h() {
      attr$8(t, "class", "loading svelte-v0wucf");
    },
    m(d, g) {
      insert_hydration$8(d, t, g), append_hydration$5(t, r), insert_hydration$8(d, a, g), c && c.m(d, g), o = !0;
    },
    p(d, g) {
      (!o || g[0] & /*loading_text*/
      512) && set_data$2(
        r,
        /*loading_text*/
        d[9]
      ), c && c.p && (!o || g[0] & /*$$scope*/
      536870912) && update_slot_base(
        c,
        u,
        d,
        /*$$scope*/
        d[29],
        o ? get_slot_changes(
          u,
          /*$$scope*/
          d[29],
          g,
          get_additional_loading_text_slot_changes
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          d[29]
        ),
        get_additional_loading_text_slot_context
      );
    },
    i(d) {
      o || (transition_in$a(c, d), o = !0);
    },
    o(d) {
      transition_out$a(c, d), o = !1;
    },
    d(d) {
      d && (detach$8(t), detach$8(a)), c && c.d(d);
    }
  };
}
function create_fragment$a(e) {
  let t, r, a, o, u;
  const c = [create_if_block$3, create_if_block_17], d = [];
  function g(b, _) {
    return (
      /*status*/
      b[4] === "pending" ? 0 : (
        /*status*/
        b[4] === "error" ? 1 : -1
      )
    );
  }
  return ~(r = g(e)) && (a = d[r] = c[r](e)), {
    c() {
      t = element$g("div"), a && a.c(), this.h();
    },
    l(b) {
      t = claim_element$8(b, "DIV", {
        class: !0
      });
      var _ = children$8(t);
      a && a.l(_), _.forEach(detach$8), this.h();
    },
    h() {
      attr$8(t, "class", o = "wrap " + /*variant*/
      e[8] + " " + /*show_progress*/
      e[6] + " svelte-v0wucf"), toggle_class$2(t, "hide", !/*status*/
      e[4] || /*status*/
      e[4] === "complete" || /*show_progress*/
      e[6] === "hidden"), toggle_class$2(
        t,
        "translucent",
        /*variant*/
        e[8] === "center" && /*status*/
        (e[4] === "pending" || /*status*/
        e[4] === "error") || /*translucent*/
        e[11] || /*show_progress*/
        e[6] === "minimal"
      ), toggle_class$2(
        t,
        "generating",
        /*status*/
        e[4] === "generating" && /*show_progress*/
        e[6] === "full"
      ), toggle_class$2(
        t,
        "border",
        /*border*/
        e[12]
      ), set_style$3(
        t,
        "position",
        /*absolute*/
        e[10] ? "absolute" : "static"
      ), set_style$3(
        t,
        "padding",
        /*absolute*/
        e[10] ? "0" : "var(--size-8) 0"
      );
    },
    m(b, _) {
      insert_hydration$8(b, t, _), ~r && d[r].m(t, null), e[33](t), u = !0;
    },
    p(b, _) {
      let y = r;
      r = g(b), r === y ? ~r && d[r].p(b, _) : (a && (group_outros$5(), transition_out$a(d[y], 1, 1, () => {
        d[y] = null;
      }), check_outros$5()), ~r ? (a = d[r], a ? a.p(b, _) : (a = d[r] = c[r](b), a.c()), transition_in$a(a, 1), a.m(t, null)) : a = null), (!u || _[0] & /*variant, show_progress*/
      320 && o !== (o = "wrap " + /*variant*/
      b[8] + " " + /*show_progress*/
      b[6] + " svelte-v0wucf")) && attr$8(t, "class", o), (!u || _[0] & /*variant, show_progress, status, show_progress*/
      336) && toggle_class$2(t, "hide", !/*status*/
      b[4] || /*status*/
      b[4] === "complete" || /*show_progress*/
      b[6] === "hidden"), (!u || _[0] & /*variant, show_progress, variant, status, translucent, show_progress*/
      2384) && toggle_class$2(
        t,
        "translucent",
        /*variant*/
        b[8] === "center" && /*status*/
        (b[4] === "pending" || /*status*/
        b[4] === "error") || /*translucent*/
        b[11] || /*show_progress*/
        b[6] === "minimal"
      ), (!u || _[0] & /*variant, show_progress, status, show_progress*/
      336) && toggle_class$2(
        t,
        "generating",
        /*status*/
        b[4] === "generating" && /*show_progress*/
        b[6] === "full"
      ), (!u || _[0] & /*variant, show_progress, border*/
      4416) && toggle_class$2(
        t,
        "border",
        /*border*/
        b[12]
      ), _[0] & /*absolute*/
      1024 && set_style$3(
        t,
        "position",
        /*absolute*/
        b[10] ? "absolute" : "static"
      ), _[0] & /*absolute*/
      1024 && set_style$3(
        t,
        "padding",
        /*absolute*/
        b[10] ? "0" : "var(--size-8) 0"
      );
    },
    i(b) {
      u || (transition_in$a(a), u = !0);
    },
    o(b) {
      transition_out$a(a), u = !1;
    },
    d(b) {
      b && detach$8(t), ~r && d[r].d(), e[33](null);
    }
  };
}
let items = [], called = !1;
async function scroll_into_view(e, t = !0) {
  if (!(window.__gradio_mode__ === "website" || window.__gradio_mode__ !== "app" && t !== !0)) {
    if (items.push(e), !called) called = !0;
    else return;
    await tick(), requestAnimationFrame(() => {
      let r = [0, 0];
      for (let a = 0; a < items.length; a++) {
        const u = items[a].getBoundingClientRect();
        (a === 0 || u.top + window.scrollY <= r[0]) && (r[0] = u.top + window.scrollY, r[1] = a);
      }
      window.scrollTo({
        top: r[0] - 20,
        behavior: "smooth"
      }), called = !1, items = [];
    });
  }
}
function instance$a(e, t, r) {
  let a, {
    $$slots: o = {},
    $$scope: u
  } = t;
  const c = createEventDispatcher$3();
  let {
    i18n: d
  } = t, {
    eta: g = null
  } = t, {
    queue_position: b
  } = t, {
    queue_size: _
  } = t, {
    status: y
  } = t, {
    scroll_to_output: A = !1
  } = t, {
    timer: E = !0
  } = t, {
    show_progress: v = "full"
  } = t, {
    message: C = null
  } = t, {
    progress: R = null
  } = t, {
    variant: I = "default"
  } = t, {
    loading_text: w = "Loading..."
  } = t, {
    absolute: N = !0
  } = t, {
    translucent: F = !1
  } = t, {
    border: M = !1
  } = t, {
    autoscroll: x
  } = t, P, U = !1, L = 0, H = 0, B = null, V = null, X = 0, de = null, Y, se = null, ue = !0;
  const pe = () => {
    r(0, g = r(27, B = r(19, le = null))), r(25, L = performance.now()), r(26, H = 0), U = !0, J();
  };
  function J() {
    requestAnimationFrame(() => {
      r(26, H = (performance.now() - L) / 1e3), U && J();
    });
  }
  function j() {
    r(26, H = 0), r(0, g = r(27, B = r(19, le = null))), U && (U = !1);
  }
  onDestroy$3(() => {
    U && j();
  });
  let le = null;
  function Z(W) {
    binding_callbacks$2[W ? "unshift" : "push"](() => {
      se = W, r(16, se), r(7, R), r(14, de), r(15, Y);
    });
  }
  const O = () => {
    c("clear_status");
  };
  function z(W) {
    binding_callbacks$2[W ? "unshift" : "push"](() => {
      P = W, r(13, P);
    });
  }
  return e.$$set = (W) => {
    "i18n" in W && r(1, d = W.i18n), "eta" in W && r(0, g = W.eta), "queue_position" in W && r(2, b = W.queue_position), "queue_size" in W && r(3, _ = W.queue_size), "status" in W && r(4, y = W.status), "scroll_to_output" in W && r(22, A = W.scroll_to_output), "timer" in W && r(5, E = W.timer), "show_progress" in W && r(6, v = W.show_progress), "message" in W && r(23, C = W.message), "progress" in W && r(7, R = W.progress), "variant" in W && r(8, I = W.variant), "loading_text" in W && r(9, w = W.loading_text), "absolute" in W && r(10, N = W.absolute), "translucent" in W && r(11, F = W.translucent), "border" in W && r(12, M = W.border), "autoscroll" in W && r(24, x = W.autoscroll), "$$scope" in W && r(29, u = W.$$scope);
  }, e.$$.update = () => {
    e.$$.dirty[0] & /*eta, old_eta, timer_start, eta_from_start*/
    436207617 && (g === null && r(0, g = B), g != null && B !== g && (r(28, V = (performance.now() - L) / 1e3 + g), r(19, le = V.toFixed(1)), r(27, B = g))), e.$$.dirty[0] & /*eta_from_start, timer_diff*/
    335544320 && r(17, X = V === null || V <= 0 || !H ? null : Math.min(H / V, 1)), e.$$.dirty[0] & /*progress*/
    128 && R != null && r(18, ue = !1), e.$$.dirty[0] & /*progress, progress_level, progress_bar, last_progress_level*/
    114816 && (R != null ? r(14, de = R.map((W) => {
      if (W.index != null && W.length != null)
        return W.index / W.length;
      if (W.progress != null)
        return W.progress;
    })) : r(14, de = null), de ? (r(15, Y = de[de.length - 1]), se && (Y === 0 ? r(16, se.style.transition = "0", se) : r(16, se.style.transition = "150ms", se))) : r(15, Y = void 0)), e.$$.dirty[0] & /*status*/
    16 && (y === "pending" ? pe() : j()), e.$$.dirty[0] & /*el, scroll_to_output, status, autoscroll*/
    20979728 && P && A && (y === "pending" || y === "complete") && scroll_into_view(P, x), e.$$.dirty[0] & /*status, message*/
    8388624, e.$$.dirty[0] & /*timer_diff*/
    67108864 && r(20, a = H.toFixed(1));
  }, [g, d, b, _, y, E, v, R, I, w, N, F, M, P, de, Y, se, X, ue, le, a, c, A, C, x, L, H, B, V, u, o, Z, O, z];
}
class Static extends SvelteComponent$c {
  constructor(t) {
    super(), init$c(this, t, instance$a, create_fragment$a, safe_not_equal$c, {
      i18n: 1,
      eta: 0,
      queue_position: 2,
      queue_size: 3,
      status: 4,
      scroll_to_output: 22,
      timer: 5,
      show_progress: 6,
      message: 23,
      progress: 7,
      variant: 8,
      loading_text: 9,
      absolute: 10,
      translucent: 11,
      border: 12,
      autoscroll: 24
    }, null, [-1, -1]);
  }
}
/*! @license DOMPurify 3.1.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.6/LICENSE */
const {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf,
  getOwnPropertyDescriptor
} = Object;
let {
  freeze,
  seal,
  create: create$8
} = Object, {
  apply,
  construct
} = typeof Reflect < "u" && Reflect;
freeze || (freeze = function(t) {
  return t;
});
seal || (seal = function(t) {
  return t;
});
apply || (apply = function(t, r, a) {
  return t.apply(r, a);
});
construct || (construct = function(t, r) {
  return new t(...r);
});
const arrayForEach = unapply(Array.prototype.forEach), arrayPop = unapply(Array.prototype.pop), arrayPush = unapply(Array.prototype.push), stringToLowerCase = unapply(String.prototype.toLowerCase), stringToString = unapply(String.prototype.toString), stringMatch = unapply(String.prototype.match), stringReplace = unapply(String.prototype.replace), stringIndexOf = unapply(String.prototype.indexOf), stringTrim = unapply(String.prototype.trim), objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty), regExpTest = unapply(RegExp.prototype.test), typeErrorCreate = unconstruct(TypeError);
function unapply(e) {
  return function(t) {
    for (var r = arguments.length, a = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)
      a[o - 1] = arguments[o];
    return apply(e, t, a);
  };
}
function unconstruct(e) {
  return function() {
    for (var t = arguments.length, r = new Array(t), a = 0; a < t; a++)
      r[a] = arguments[a];
    return construct(e, r);
  };
}
function addToSet(e, t) {
  let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
  setPrototypeOf && setPrototypeOf(e, null);
  let a = t.length;
  for (; a--; ) {
    let o = t[a];
    if (typeof o == "string") {
      const u = r(o);
      u !== o && (isFrozen(t) || (t[a] = u), o = u);
    }
    e[o] = !0;
  }
  return e;
}
function cleanArray(e) {
  for (let t = 0; t < e.length; t++)
    objectHasOwnProperty(e, t) || (e[t] = null);
  return e;
}
function clone(e) {
  const t = create$8(null);
  for (const [r, a] of entries(e))
    objectHasOwnProperty(e, r) && (Array.isArray(a) ? t[r] = cleanArray(a) : a && typeof a == "object" && a.constructor === Object ? t[r] = clone(a) : t[r] = a);
  return t;
}
function lookupGetter(e, t) {
  for (; e !== null; ) {
    const a = getOwnPropertyDescriptor(e, t);
    if (a) {
      if (a.get)
        return unapply(a.get);
      if (typeof a.value == "function")
        return unapply(a.value);
    }
    e = getPrototypeOf(e);
  }
  function r() {
    return null;
  }
  return r;
}
const html$1$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), svg$1$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), text$d = freeze(["#text"]), html$9 = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), svg$4 = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), xml$4 = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm), ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm), TMPLIT_EXPR = seal(/\${[\w\W]*}/gm), DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/), ARIA_ATTR = seal(/^aria-[\-\w]+$/), IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i), ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), DOCTYPE_NAME = seal(/^html$/i), CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR,
  ERB_EXPR,
  TMPLIT_EXPR,
  DATA_ATTR,
  ARIA_ATTR,
  IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA,
  ATTR_WHITESPACE,
  DOCTYPE_NAME,
  CUSTOM_ELEMENT
});
const NODE_TYPE = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, getGlobal = function() {
  return typeof window > "u" ? null : window;
}, _createTrustedTypesPolicy = function(t, r) {
  if (typeof t != "object" || typeof t.createPolicy != "function")
    return null;
  let a = null;
  const o = "data-tt-policy-suffix";
  r && r.hasAttribute(o) && (a = r.getAttribute(o));
  const u = "dompurify" + (a ? "#" + a : "");
  try {
    return t.createPolicy(u, {
      createHTML(c) {
        return c;
      },
      createScriptURL(c) {
        return c;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + u + " could not be created."), null;
  }
};
function createDOMPurify() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  const t = (tt) => createDOMPurify(tt);
  if (t.version = "3.1.6", t.removed = [], !e || !e.document || e.document.nodeType !== NODE_TYPE.document)
    return t.isSupported = !1, t;
  let {
    document: r
  } = e;
  const a = r, o = a.currentScript, {
    DocumentFragment: u,
    HTMLTemplateElement: c,
    Node: d,
    Element: g,
    NodeFilter: b,
    NamedNodeMap: _ = e.NamedNodeMap || e.MozNamedAttrMap,
    HTMLFormElement: y,
    DOMParser: A,
    trustedTypes: E
  } = e, v = g.prototype, C = lookupGetter(v, "cloneNode"), R = lookupGetter(v, "remove"), I = lookupGetter(v, "nextSibling"), w = lookupGetter(v, "childNodes"), N = lookupGetter(v, "parentNode");
  if (typeof c == "function") {
    const tt = r.createElement("template");
    tt.content && tt.content.ownerDocument && (r = tt.content.ownerDocument);
  }
  let F, M = "";
  const {
    implementation: x,
    createNodeIterator: P,
    createDocumentFragment: U,
    getElementsByTagName: L
  } = r, {
    importNode: H
  } = a;
  let B = {};
  t.isSupported = typeof entries == "function" && typeof N == "function" && x && x.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: V,
    ERB_EXPR: X,
    TMPLIT_EXPR: de,
    DATA_ATTR: Y,
    ARIA_ATTR: se,
    IS_SCRIPT_OR_DATA: ue,
    ATTR_WHITESPACE: pe,
    CUSTOM_ELEMENT: J
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: j
  } = EXPRESSIONS, le = null;
  const Z = addToSet({}, [...html$1$1, ...svg$1$1, ...svgFilters, ...mathMl$1, ...text$d]);
  let O = null;
  const z = addToSet({}, [...html$9, ...svg$4, ...mathMl, ...xml$4]);
  let W = Object.seal(create$8(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), ee = null, ae = null, ie = !0, me = !0, ye = !1, Re = !0, De = !1, Pe = !0, he = !1, Le = !1, Ee = !1, Se = !1, Q = !1, K = !1, fe = !0, be = !1;
  const ke = "user-content-";
  let Fe = !0, Be = !1, te = {}, Ce = null;
  const Me = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let Ve = null;
  const je = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  let ot = null;
  const We = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Xe = "http://www.w3.org/1998/Math/MathML", ut = "http://www.w3.org/2000/svg", ct = "http://www.w3.org/1999/xhtml";
  let $e = ct, Ae = !1, ve = null;
  const Ke = addToSet({}, [Xe, ut, ct], stringToString);
  let dt = null;
  const pt = ["application/xhtml+xml", "text/html"], ce = "text/html";
  let Ne = null, Ge = null;
  const nt = r.createElement("form"), rt = function(Te) {
    return Te instanceof RegExp || Te instanceof Function;
  }, Ye = function() {
    let Te = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(Ge && Ge === Te)) {
      if ((!Te || typeof Te != "object") && (Te = {}), Te = clone(Te), dt = // eslint-disable-next-line unicorn/prefer-includes
      pt.indexOf(Te.PARSER_MEDIA_TYPE) === -1 ? ce : Te.PARSER_MEDIA_TYPE, Ne = dt === "application/xhtml+xml" ? stringToString : stringToLowerCase, le = objectHasOwnProperty(Te, "ALLOWED_TAGS") ? addToSet({}, Te.ALLOWED_TAGS, Ne) : Z, O = objectHasOwnProperty(Te, "ALLOWED_ATTR") ? addToSet({}, Te.ALLOWED_ATTR, Ne) : z, ve = objectHasOwnProperty(Te, "ALLOWED_NAMESPACES") ? addToSet({}, Te.ALLOWED_NAMESPACES, stringToString) : Ke, ot = objectHasOwnProperty(Te, "ADD_URI_SAFE_ATTR") ? addToSet(
        clone(We),
        // eslint-disable-line indent
        Te.ADD_URI_SAFE_ATTR,
        // eslint-disable-line indent
        Ne
        // eslint-disable-line indent
      ) : We, Ve = objectHasOwnProperty(Te, "ADD_DATA_URI_TAGS") ? addToSet(
        clone(je),
        // eslint-disable-line indent
        Te.ADD_DATA_URI_TAGS,
        // eslint-disable-line indent
        Ne
        // eslint-disable-line indent
      ) : je, Ce = objectHasOwnProperty(Te, "FORBID_CONTENTS") ? addToSet({}, Te.FORBID_CONTENTS, Ne) : Me, ee = objectHasOwnProperty(Te, "FORBID_TAGS") ? addToSet({}, Te.FORBID_TAGS, Ne) : {}, ae = objectHasOwnProperty(Te, "FORBID_ATTR") ? addToSet({}, Te.FORBID_ATTR, Ne) : {}, te = objectHasOwnProperty(Te, "USE_PROFILES") ? Te.USE_PROFILES : !1, ie = Te.ALLOW_ARIA_ATTR !== !1, me = Te.ALLOW_DATA_ATTR !== !1, ye = Te.ALLOW_UNKNOWN_PROTOCOLS || !1, Re = Te.ALLOW_SELF_CLOSE_IN_ATTR !== !1, De = Te.SAFE_FOR_TEMPLATES || !1, Pe = Te.SAFE_FOR_XML !== !1, he = Te.WHOLE_DOCUMENT || !1, Se = Te.RETURN_DOM || !1, Q = Te.RETURN_DOM_FRAGMENT || !1, K = Te.RETURN_TRUSTED_TYPE || !1, Ee = Te.FORCE_BODY || !1, fe = Te.SANITIZE_DOM !== !1, be = Te.SANITIZE_NAMED_PROPS || !1, Fe = Te.KEEP_CONTENT !== !1, Be = Te.IN_PLACE || !1, j = Te.ALLOWED_URI_REGEXP || IS_ALLOWED_URI, $e = Te.NAMESPACE || ct, W = Te.CUSTOM_ELEMENT_HANDLING || {}, Te.CUSTOM_ELEMENT_HANDLING && rt(Te.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (W.tagNameCheck = Te.CUSTOM_ELEMENT_HANDLING.tagNameCheck), Te.CUSTOM_ELEMENT_HANDLING && rt(Te.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (W.attributeNameCheck = Te.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), Te.CUSTOM_ELEMENT_HANDLING && typeof Te.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (W.allowCustomizedBuiltInElements = Te.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), De && (me = !1), Q && (Se = !0), te && (le = addToSet({}, text$d), O = [], te.html === !0 && (addToSet(le, html$1$1), addToSet(O, html$9)), te.svg === !0 && (addToSet(le, svg$1$1), addToSet(O, svg$4), addToSet(O, xml$4)), te.svgFilters === !0 && (addToSet(le, svgFilters), addToSet(O, svg$4), addToSet(O, xml$4)), te.mathMl === !0 && (addToSet(le, mathMl$1), addToSet(O, mathMl), addToSet(O, xml$4))), Te.ADD_TAGS && (le === Z && (le = clone(le)), addToSet(le, Te.ADD_TAGS, Ne)), Te.ADD_ATTR && (O === z && (O = clone(O)), addToSet(O, Te.ADD_ATTR, Ne)), Te.ADD_URI_SAFE_ATTR && addToSet(ot, Te.ADD_URI_SAFE_ATTR, Ne), Te.FORBID_CONTENTS && (Ce === Me && (Ce = clone(Ce)), addToSet(Ce, Te.FORBID_CONTENTS, Ne)), Fe && (le["#text"] = !0), he && addToSet(le, ["html", "head", "body"]), le.table && (addToSet(le, ["tbody"]), delete ee.tbody), Te.TRUSTED_TYPES_POLICY) {
        if (typeof Te.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof Te.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        F = Te.TRUSTED_TYPES_POLICY, M = F.createHTML("");
      } else
        F === void 0 && (F = _createTrustedTypesPolicy(E, o)), F !== null && typeof M == "string" && (M = F.createHTML(""));
      freeze && freeze(Te), Ge = Te;
    }
  }, oe = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]), ne = addToSet({}, ["foreignobject", "annotation-xml"]), ge = addToSet({}, ["title", "style", "font", "a", "script"]), xe = addToSet({}, [...svg$1$1, ...svgFilters, ...svgDisallowed]), Oe = addToSet({}, [...mathMl$1, ...mathMlDisallowed]), Ue = function(Te) {
    let ze = N(Te);
    (!ze || !ze.tagName) && (ze = {
      namespaceURI: $e,
      tagName: "template"
    });
    const at = stringToLowerCase(Te.tagName), _t = stringToLowerCase(ze.tagName);
    return ve[Te.namespaceURI] ? Te.namespaceURI === ut ? ze.namespaceURI === ct ? at === "svg" : ze.namespaceURI === Xe ? at === "svg" && (_t === "annotation-xml" || oe[_t]) : !!xe[at] : Te.namespaceURI === Xe ? ze.namespaceURI === ct ? at === "math" : ze.namespaceURI === ut ? at === "math" && ne[_t] : !!Oe[at] : Te.namespaceURI === ct ? ze.namespaceURI === ut && !ne[_t] || ze.namespaceURI === Xe && !oe[_t] ? !1 : !Oe[at] && (ge[at] || !xe[at]) : !!(dt === "application/xhtml+xml" && ve[Te.namespaceURI]) : !1;
  }, qe = function(Te) {
    arrayPush(t.removed, {
      element: Te
    });
    try {
      N(Te).removeChild(Te);
    } catch {
      R(Te);
    }
  }, Qe = function(Te, ze) {
    try {
      arrayPush(t.removed, {
        attribute: ze.getAttributeNode(Te),
        from: ze
      });
    } catch {
      arrayPush(t.removed, {
        attribute: null,
        from: ze
      });
    }
    if (ze.removeAttribute(Te), Te === "is" && !O[Te])
      if (Se || Q)
        try {
          qe(ze);
        } catch {
        }
      else
        try {
          ze.setAttribute(Te, "");
        } catch {
        }
  }, Je = function(Te) {
    let ze = null, at = null;
    if (Ee)
      Te = "<remove></remove>" + Te;
    else {
      const Et = stringMatch(Te, /^[\r\n\t ]+/);
      at = Et && Et[0];
    }
    dt === "application/xhtml+xml" && $e === ct && (Te = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + Te + "</body></html>");
    const _t = F ? F.createHTML(Te) : Te;
    if ($e === ct)
      try {
        ze = new A().parseFromString(_t, dt);
      } catch {
      }
    if (!ze || !ze.documentElement) {
      ze = x.createDocument($e, "template", null);
      try {
        ze.documentElement.innerHTML = Ae ? M : _t;
      } catch {
      }
    }
    const St = ze.body || ze.documentElement;
    return Te && at && St.insertBefore(r.createTextNode(at), St.childNodes[0] || null), $e === ct ? L.call(ze, he ? "html" : "body")[0] : he ? ze.documentElement : St;
  }, He = function(Te) {
    return P.call(
      Te.ownerDocument || Te,
      Te,
      // eslint-disable-next-line no-bitwise
      b.SHOW_ELEMENT | b.SHOW_COMMENT | b.SHOW_TEXT | b.SHOW_PROCESSING_INSTRUCTION | b.SHOW_CDATA_SECTION,
      null
    );
  }, st = function(Te) {
    return Te instanceof y && (typeof Te.nodeName != "string" || typeof Te.textContent != "string" || typeof Te.removeChild != "function" || !(Te.attributes instanceof _) || typeof Te.removeAttribute != "function" || typeof Te.setAttribute != "function" || typeof Te.namespaceURI != "string" || typeof Te.insertBefore != "function" || typeof Te.hasChildNodes != "function");
  }, et = function(Te) {
    return typeof d == "function" && Te instanceof d;
  }, Ze = function(Te, ze, at) {
    B[Te] && arrayForEach(B[Te], (_t) => {
      _t.call(t, ze, at, Ge);
    });
  }, it = function(Te) {
    let ze = null;
    if (Ze("beforeSanitizeElements", Te, null), st(Te))
      return qe(Te), !0;
    const at = Ne(Te.nodeName);
    if (Ze("uponSanitizeElement", Te, {
      tagName: at,
      allowedTags: le
    }), Te.hasChildNodes() && !et(Te.firstElementChild) && regExpTest(/<[/\w]/g, Te.innerHTML) && regExpTest(/<[/\w]/g, Te.textContent) || Te.nodeType === NODE_TYPE.progressingInstruction || Pe && Te.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, Te.data))
      return qe(Te), !0;
    if (!le[at] || ee[at]) {
      if (!ee[at] && mt(at) && (W.tagNameCheck instanceof RegExp && regExpTest(W.tagNameCheck, at) || W.tagNameCheck instanceof Function && W.tagNameCheck(at)))
        return !1;
      if (Fe && !Ce[at]) {
        const _t = N(Te) || Te.parentNode, St = w(Te) || Te.childNodes;
        if (St && _t) {
          const Et = St.length;
          for (let At = Et - 1; At >= 0; --At) {
            const kt = C(St[At], !0);
            kt.__removalCount = (Te.__removalCount || 0) + 1, _t.insertBefore(kt, I(Te));
          }
        }
      }
      return qe(Te), !0;
    }
    return Te instanceof g && !Ue(Te) || (at === "noscript" || at === "noembed" || at === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, Te.innerHTML) ? (qe(Te), !0) : (De && Te.nodeType === NODE_TYPE.text && (ze = Te.textContent, arrayForEach([V, X, de], (_t) => {
      ze = stringReplace(ze, _t, " ");
    }), Te.textContent !== ze && (arrayPush(t.removed, {
      element: Te.cloneNode()
    }), Te.textContent = ze)), Ze("afterSanitizeElements", Te, null), !1);
  }, ht = function(Te, ze, at) {
    if (fe && (ze === "id" || ze === "name") && (at in r || at in nt))
      return !1;
    if (!(me && !ae[ze] && regExpTest(Y, ze))) {
      if (!(ie && regExpTest(se, ze))) {
        if (!O[ze] || ae[ze]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(mt(Te) && (W.tagNameCheck instanceof RegExp && regExpTest(W.tagNameCheck, Te) || W.tagNameCheck instanceof Function && W.tagNameCheck(Te)) && (W.attributeNameCheck instanceof RegExp && regExpTest(W.attributeNameCheck, ze) || W.attributeNameCheck instanceof Function && W.attributeNameCheck(ze)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            ze === "is" && W.allowCustomizedBuiltInElements && (W.tagNameCheck instanceof RegExp && regExpTest(W.tagNameCheck, at) || W.tagNameCheck instanceof Function && W.tagNameCheck(at)))
          ) return !1;
        } else if (!ot[ze]) {
          if (!regExpTest(j, stringReplace(at, pe, ""))) {
            if (!((ze === "src" || ze === "xlink:href" || ze === "href") && Te !== "script" && stringIndexOf(at, "data:") === 0 && Ve[Te])) {
              if (!(ye && !regExpTest(ue, stringReplace(at, pe, "")))) {
                if (at)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, mt = function(Te) {
    return Te !== "annotation-xml" && stringMatch(Te, J);
  }, bt = function(Te) {
    Ze("beforeSanitizeAttributes", Te, null);
    const {
      attributes: ze
    } = Te;
    if (!ze)
      return;
    const at = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: O
    };
    let _t = ze.length;
    for (; _t--; ) {
      const St = ze[_t], {
        name: Et,
        namespaceURI: At,
        value: kt
      } = St, Lt = Ne(Et);
      let Tt = Et === "value" ? kt : stringTrim(kt);
      if (at.attrName = Lt, at.attrValue = Tt, at.keepAttr = !0, at.forceKeepAttr = void 0, Ze("uponSanitizeAttribute", Te, at), Tt = at.attrValue, Pe && regExpTest(/((--!?|])>)|<\/(style|title)/i, Tt)) {
        Qe(Et, Te);
        continue;
      }
      if (at.forceKeepAttr || (Qe(Et, Te), !at.keepAttr))
        continue;
      if (!Re && regExpTest(/\/>/i, Tt)) {
        Qe(Et, Te);
        continue;
      }
      De && arrayForEach([V, X, de], (Un) => {
        Tt = stringReplace(Tt, Un, " ");
      });
      const Bn = Ne(Te.nodeName);
      if (ht(Bn, Lt, Tt)) {
        if (be && (Lt === "id" || Lt === "name") && (Qe(Et, Te), Tt = ke + Tt), F && typeof E == "object" && typeof E.getAttributeType == "function" && !At)
          switch (E.getAttributeType(Bn, Lt)) {
            case "TrustedHTML": {
              Tt = F.createHTML(Tt);
              break;
            }
            case "TrustedScriptURL": {
              Tt = F.createScriptURL(Tt);
              break;
            }
          }
        try {
          At ? Te.setAttributeNS(At, Et, Tt) : Te.setAttribute(Et, Tt), st(Te) ? qe(Te) : arrayPop(t.removed);
        } catch {
        }
      }
    }
    Ze("afterSanitizeAttributes", Te, null);
  }, yt = function tt(Te) {
    let ze = null;
    const at = He(Te);
    for (Ze("beforeSanitizeShadowDOM", Te, null); ze = at.nextNode(); )
      Ze("uponSanitizeShadowNode", ze, null), !it(ze) && (ze.content instanceof u && tt(ze.content), bt(ze));
    Ze("afterSanitizeShadowDOM", Te, null);
  };
  return t.sanitize = function(tt) {
    let Te = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, ze = null, at = null, _t = null, St = null;
    if (Ae = !tt, Ae && (tt = "<!-->"), typeof tt != "string" && !et(tt))
      if (typeof tt.toString == "function") {
        if (tt = tt.toString(), typeof tt != "string")
          throw typeErrorCreate("dirty is not a string, aborting");
      } else
        throw typeErrorCreate("toString is not a function");
    if (!t.isSupported)
      return tt;
    if (Le || Ye(Te), t.removed = [], typeof tt == "string" && (Be = !1), Be) {
      if (tt.nodeName) {
        const kt = Ne(tt.nodeName);
        if (!le[kt] || ee[kt])
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (tt instanceof d)
      ze = Je("<!---->"), at = ze.ownerDocument.importNode(tt, !0), at.nodeType === NODE_TYPE.element && at.nodeName === "BODY" || at.nodeName === "HTML" ? ze = at : ze.appendChild(at);
    else {
      if (!Se && !De && !he && // eslint-disable-next-line unicorn/prefer-includes
      tt.indexOf("<") === -1)
        return F && K ? F.createHTML(tt) : tt;
      if (ze = Je(tt), !ze)
        return Se ? null : K ? M : "";
    }
    ze && Ee && qe(ze.firstChild);
    const Et = He(Be ? tt : ze);
    for (; _t = Et.nextNode(); )
      it(_t) || (_t.content instanceof u && yt(_t.content), bt(_t));
    if (Be)
      return tt;
    if (Se) {
      if (Q)
        for (St = U.call(ze.ownerDocument); ze.firstChild; )
          St.appendChild(ze.firstChild);
      else
        St = ze;
      return (O.shadowroot || O.shadowrootmode) && (St = H.call(a, St, !0)), St;
    }
    let At = he ? ze.outerHTML : ze.innerHTML;
    return he && le["!doctype"] && ze.ownerDocument && ze.ownerDocument.doctype && ze.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, ze.ownerDocument.doctype.name) && (At = "<!DOCTYPE " + ze.ownerDocument.doctype.name + `>
` + At), De && arrayForEach([V, X, de], (kt) => {
      At = stringReplace(At, kt, " ");
    }), F && K ? F.createHTML(At) : At;
  }, t.setConfig = function() {
    let tt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Ye(tt), Le = !0;
  }, t.clearConfig = function() {
    Ge = null, Le = !1;
  }, t.isValidAttribute = function(tt, Te, ze) {
    Ge || Ye({});
    const at = Ne(tt), _t = Ne(Te);
    return ht(at, _t, ze);
  }, t.addHook = function(tt, Te) {
    typeof Te == "function" && (B[tt] = B[tt] || [], arrayPush(B[tt], Te));
  }, t.removeHook = function(tt) {
    if (B[tt])
      return arrayPop(B[tt]);
  }, t.removeHooks = function(tt) {
    B[tt] && (B[tt] = []);
  }, t.removeAllHooks = function() {
    B = {};
  }, t;
}
createDOMPurify();
const {
  HtmlTagHydration,
  SvelteComponent: SvelteComponent$b,
  add_render_callback,
  append_hydration: append_hydration$4,
  attr: attr$7,
  bubble: bubble$2,
  check_outros: check_outros$4,
  children: children$7,
  claim_component: claim_component$9,
  claim_element: claim_element$7,
  claim_html_tag,
  claim_space: claim_space$4,
  claim_text: claim_text$1,
  create_component: create_component$9,
  create_in_transition,
  create_out_transition,
  destroy_component: destroy_component$9,
  detach: detach$7,
  element: element$f,
  get_svelte_dataset: get_svelte_dataset$1,
  group_outros: group_outros$4,
  init: init$b,
  insert_hydration: insert_hydration$7,
  listen: listen$3,
  mount_component: mount_component$9,
  run_all: run_all$2,
  safe_not_equal: safe_not_equal$b,
  set_data: set_data$1,
  space: space$8,
  stop_propagation,
  text: text$c,
  toggle_class: toggle_class$1,
  transition_in: transition_in$9,
  transition_out: transition_out$9
} = window.__gradio__svelte__internal, {
  createEventDispatcher: createEventDispatcher$2,
  onMount
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$a,
  append_hydration: append_hydration$3,
  attr: attr$6,
  bubble: bubble$1,
  check_outros: check_outros$3,
  children: children$6,
  claim_component: claim_component$8,
  claim_element: claim_element$6,
  claim_space: claim_space$3,
  create_animation,
  create_component: create_component$8,
  destroy_component: destroy_component$8,
  detach: detach$6,
  element: element$e,
  ensure_array_like: ensure_array_like$1,
  fix_and_outro_and_destroy_block,
  fix_position,
  group_outros: group_outros$3,
  init: init$a,
  insert_hydration: insert_hydration$6,
  mount_component: mount_component$8,
  noop: noop$3,
  safe_not_equal: safe_not_equal$a,
  set_style: set_style$2,
  space: space$7,
  transition_in: transition_in$8,
  transition_out: transition_out$8,
  update_keyed_each: update_keyed_each$1
} = window.__gradio__svelte__internal;
function normalise_file(e, t, r) {
  if (e == null)
    return null;
  if (Array.isArray(e)) {
    const a = [];
    for (const o of e)
      o == null ? a.push(null) : a.push(normalise_file(o, t, r));
    return a;
  }
  return e.is_stream ? r == null ? new FileData({
    ...e,
    url: t + "/stream/" + e.path
  }) : new FileData({
    ...e,
    url: "/proxy=" + r + "stream/" + e.path
  }) : new FileData({
    ...e,
    url: get_fetchable_url_or_file(e.path, t, r)
  });
}
function is_url(e) {
  try {
    const t = new URL(e);
    return t.protocol === "http:" || t.protocol === "https:";
  } catch {
    return !1;
  }
}
function get_gradio_version() {
  const e = document.querySelector(".gradio-container");
  if (!e)
    return "";
  const t = e.className.match(/gradio-container-(.+)/);
  return t ? t[1] : "";
}
const gradio_version = +get_gradio_version()[0];
function get_fetchable_url_or_file(e, t, r) {
  const a = gradio_version >= 5 ? "gradio_api/" : "";
  return e == null ? r ? `/proxy=${r}${a}file=` : `${t}${a}file=` : is_url(e) ? e : r ? `/proxy=${r}${a}file=${e}` : `${t}/${a}file=${e}`;
}
const color_values = [{
  color: "red",
  primary: 600,
  secondary: 100
}, {
  color: "green",
  primary: 600,
  secondary: 100
}, {
  color: "blue",
  primary: 600,
  secondary: 100
}, {
  color: "yellow",
  primary: 500,
  secondary: 100
}, {
  color: "purple",
  primary: 600,
  secondary: 100
}, {
  color: "teal",
  primary: 600,
  secondary: 100
}, {
  color: "orange",
  primary: 600,
  secondary: 100
}, {
  color: "cyan",
  primary: 600,
  secondary: 100
}, {
  color: "lime",
  primary: 500,
  secondary: 100
}, {
  color: "pink",
  primary: 600,
  secondary: 100
}], tw_colors = {
  inherit: "inherit",
  current: "currentColor",
  transparent: "transparent",
  black: "#000",
  white: "#fff",
  slate: {
    50: "#f8fafc",
    100: "#f1f5f9",
    200: "#e2e8f0",
    300: "#cbd5e1",
    400: "#94a3b8",
    500: "#64748b",
    600: "#475569",
    700: "#334155",
    800: "#1e293b",
    900: "#0f172a",
    950: "#020617"
  },
  gray: {
    50: "#f9fafb",
    100: "#f3f4f6",
    200: "#e5e7eb",
    300: "#d1d5db",
    400: "#9ca3af",
    500: "#6b7280",
    600: "#4b5563",
    700: "#374151",
    800: "#1f2937",
    900: "#111827",
    950: "#030712"
  },
  zinc: {
    50: "#fafafa",
    100: "#f4f4f5",
    200: "#e4e4e7",
    300: "#d4d4d8",
    400: "#a1a1aa",
    500: "#71717a",
    600: "#52525b",
    700: "#3f3f46",
    800: "#27272a",
    900: "#18181b",
    950: "#09090b"
  },
  neutral: {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#e5e5e5",
    300: "#d4d4d4",
    400: "#a3a3a3",
    500: "#737373",
    600: "#525252",
    700: "#404040",
    800: "#262626",
    900: "#171717",
    950: "#0a0a0a"
  },
  stone: {
    50: "#fafaf9",
    100: "#f5f5f4",
    200: "#e7e5e4",
    300: "#d6d3d1",
    400: "#a8a29e",
    500: "#78716c",
    600: "#57534e",
    700: "#44403c",
    800: "#292524",
    900: "#1c1917",
    950: "#0c0a09"
  },
  red: {
    50: "#fef2f2",
    100: "#fee2e2",
    200: "#fecaca",
    300: "#fca5a5",
    400: "#f87171",
    500: "#ef4444",
    600: "#dc2626",
    700: "#b91c1c",
    800: "#991b1b",
    900: "#7f1d1d",
    950: "#450a0a"
  },
  orange: {
    50: "#fff7ed",
    100: "#ffedd5",
    200: "#fed7aa",
    300: "#fdba74",
    400: "#fb923c",
    500: "#f97316",
    600: "#ea580c",
    700: "#c2410c",
    800: "#9a3412",
    900: "#7c2d12",
    950: "#431407"
  },
  amber: {
    50: "#fffbeb",
    100: "#fef3c7",
    200: "#fde68a",
    300: "#fcd34d",
    400: "#fbbf24",
    500: "#f59e0b",
    600: "#d97706",
    700: "#b45309",
    800: "#92400e",
    900: "#78350f",
    950: "#451a03"
  },
  yellow: {
    50: "#fefce8",
    100: "#fef9c3",
    200: "#fef08a",
    300: "#fde047",
    400: "#facc15",
    500: "#eab308",
    600: "#ca8a04",
    700: "#a16207",
    800: "#854d0e",
    900: "#713f12",
    950: "#422006"
  },
  lime: {
    50: "#f7fee7",
    100: "#ecfccb",
    200: "#d9f99d",
    300: "#bef264",
    400: "#a3e635",
    500: "#84cc16",
    600: "#65a30d",
    700: "#4d7c0f",
    800: "#3f6212",
    900: "#365314",
    950: "#1a2e05"
  },
  green: {
    50: "#f0fdf4",
    100: "#dcfce7",
    200: "#bbf7d0",
    300: "#86efac",
    400: "#4ade80",
    500: "#22c55e",
    600: "#16a34a",
    700: "#15803d",
    800: "#166534",
    900: "#14532d",
    950: "#052e16"
  },
  emerald: {
    50: "#ecfdf5",
    100: "#d1fae5",
    200: "#a7f3d0",
    300: "#6ee7b7",
    400: "#34d399",
    500: "#10b981",
    600: "#059669",
    700: "#047857",
    800: "#065f46",
    900: "#064e3b",
    950: "#022c22"
  },
  teal: {
    50: "#f0fdfa",
    100: "#ccfbf1",
    200: "#99f6e4",
    300: "#5eead4",
    400: "#2dd4bf",
    500: "#14b8a6",
    600: "#0d9488",
    700: "#0f766e",
    800: "#115e59",
    900: "#134e4a",
    950: "#042f2e"
  },
  cyan: {
    50: "#ecfeff",
    100: "#cffafe",
    200: "#a5f3fc",
    300: "#67e8f9",
    400: "#22d3ee",
    500: "#06b6d4",
    600: "#0891b2",
    700: "#0e7490",
    800: "#155e75",
    900: "#164e63",
    950: "#083344"
  },
  sky: {
    50: "#f0f9ff",
    100: "#e0f2fe",
    200: "#bae6fd",
    300: "#7dd3fc",
    400: "#38bdf8",
    500: "#0ea5e9",
    600: "#0284c7",
    700: "#0369a1",
    800: "#075985",
    900: "#0c4a6e",
    950: "#082f49"
  },
  blue: {
    50: "#eff6ff",
    100: "#dbeafe",
    200: "#bfdbfe",
    300: "#93c5fd",
    400: "#60a5fa",
    500: "#3b82f6",
    600: "#2563eb",
    700: "#1d4ed8",
    800: "#1e40af",
    900: "#1e3a8a",
    950: "#172554"
  },
  indigo: {
    50: "#eef2ff",
    100: "#e0e7ff",
    200: "#c7d2fe",
    300: "#a5b4fc",
    400: "#818cf8",
    500: "#6366f1",
    600: "#4f46e5",
    700: "#4338ca",
    800: "#3730a3",
    900: "#312e81",
    950: "#1e1b4b"
  },
  violet: {
    50: "#f5f3ff",
    100: "#ede9fe",
    200: "#ddd6fe",
    300: "#c4b5fd",
    400: "#a78bfa",
    500: "#8b5cf6",
    600: "#7c3aed",
    700: "#6d28d9",
    800: "#5b21b6",
    900: "#4c1d95",
    950: "#2e1065"
  },
  purple: {
    50: "#faf5ff",
    100: "#f3e8ff",
    200: "#e9d5ff",
    300: "#d8b4fe",
    400: "#c084fc",
    500: "#a855f7",
    600: "#9333ea",
    700: "#7e22ce",
    800: "#6b21a8",
    900: "#581c87",
    950: "#3b0764"
  },
  fuchsia: {
    50: "#fdf4ff",
    100: "#fae8ff",
    200: "#f5d0fe",
    300: "#f0abfc",
    400: "#e879f9",
    500: "#d946ef",
    600: "#c026d3",
    700: "#a21caf",
    800: "#86198f",
    900: "#701a75",
    950: "#4a044e"
  },
  pink: {
    50: "#fdf2f8",
    100: "#fce7f3",
    200: "#fbcfe8",
    300: "#f9a8d4",
    400: "#f472b6",
    500: "#ec4899",
    600: "#db2777",
    700: "#be185d",
    800: "#9d174d",
    900: "#831843",
    950: "#500724"
  },
  rose: {
    50: "#fff1f2",
    100: "#ffe4e6",
    200: "#fecdd3",
    300: "#fda4af",
    400: "#fb7185",
    500: "#f43f5e",
    600: "#e11d48",
    700: "#be123c",
    800: "#9f1239",
    900: "#881337",
    950: "#4c0519"
  }
};
color_values.reduce((e, {
  color: t,
  primary: r,
  secondary: a
}) => ({
  ...e,
  [t]: {
    primary: tw_colors[t][r],
    secondary: tw_colors[t][a]
  }
}), {});
function copy$1(e) {
  e.addEventListener("click", t);
  async function t(r) {
    const a = r.composedPath(), [o] = a.filter((u) => (u == null ? void 0 : u.tagName) === "BUTTON" && u.classList.contains("copy_code_button"));
    if (o) {
      let u = function(b) {
        b.style.opacity = "1", setTimeout(() => {
          b.style.opacity = "0";
        }, 2e3);
      };
      r.stopImmediatePropagation();
      const c = o.parentElement.innerText.trim(), d = Array.from(o.children)[1];
      await copy_to_clipboard$1(c) && u(d);
    }
  }
  return {
    destroy() {
      e.removeEventListener("click", t);
    }
  };
}
async function copy_to_clipboard$1(e) {
  let t = !1;
  if ("clipboard" in navigator)
    await navigator.clipboard.writeText(e), t = !0;
  else {
    const r = document.createElement("textarea");
    r.value = e, r.style.position = "absolute", r.style.left = "-999999px", document.body.prepend(r), r.select();
    try {
      document.execCommand("copy"), t = !0;
    } catch (a) {
      console.error(a), t = !1;
    } finally {
      r.remove();
    }
  }
  return t;
}
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function getAugmentedNamespace(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function a() {
      return this instanceof a ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", {
    value: !0
  }), Object.keys(e).forEach(function(a) {
    var o = Object.getOwnPropertyDescriptor(e, a);
    Object.defineProperty(r, a, o.get ? o : {
      enumerable: !0,
      get: function() {
        return e[a];
      }
    });
  }), r;
}
var jsxRuntime = {
  exports: {}
}, reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f = React, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$1 = {
  key: !0,
  ref: !0,
  __self: !0,
  __source: !0
};
function q(e, t, r) {
  var a, o = {}, u = null, c = null;
  r !== void 0 && (u = "" + r), t.key !== void 0 && (u = "" + t.key), t.ref !== void 0 && (c = t.ref);
  for (a in t) m.call(t, a) && !p$1.hasOwnProperty(a) && (o[a] = t[a]);
  if (e && e.defaultProps) for (a in t = e.defaultProps, t) o[a] === void 0 && (o[a] = t[a]);
  return {
    $$typeof: k,
    type: e,
    key: u,
    ref: c,
    props: o,
    _owner: n.current
  };
}
reactJsxRuntime_production_min.Fragment = l;
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
jsxRuntime.exports = reactJsxRuntime_production_min;
var jsxRuntimeExports = jsxRuntime.exports;
function defineComponent(e) {
  return e;
}
function usePreview() {
  const [e, t] = useState(!1);
  return useEffect(() => {
    e ? document.body.classList.add("ms-preview-container") : document.body.classList.remove("ms-preview-container");
  }, [e]), {
    visible: e,
    onVisibleChange: (r) => {
      t(r);
    }
  };
}
function commonjsRequire(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var pdf = {
  exports: {}
};
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, {
  value: "Module"
})), require$$5 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(module, exports) {
  (function(t, r) {
    module.exports = t.pdfjsLib = r();
  })(globalThis, () => (
    /******/
    (() => {
      var __webpack_modules__ = [
        ,
        /* 1 */
        /***/
        (e, t) => {
          var ct;
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.VerbosityLevel = t.Util = t.UnknownErrorException = t.UnexpectedResponseException = t.TextRenderingMode = t.RenderingIntentFlag = t.PromiseCapability = t.PermissionFlag = t.PasswordResponses = t.PasswordException = t.PageActionEventType = t.OPS = t.MissingPDFException = t.MAX_IMAGE_SIZE_TO_CACHE = t.LINE_FACTOR = t.LINE_DESCENT_FACTOR = t.InvalidPDFException = t.ImageKind = t.IDENTITY_MATRIX = t.FormatError = t.FeatureTest = t.FONT_IDENTITY_MATRIX = t.DocumentActionEventType = t.CMapCompressionType = t.BaseException = t.BASELINE_FACTOR = t.AnnotationType = t.AnnotationReplyType = t.AnnotationPrefix = t.AnnotationMode = t.AnnotationFlag = t.AnnotationFieldFlag = t.AnnotationEditorType = t.AnnotationEditorPrefix = t.AnnotationEditorParamsType = t.AnnotationBorderStyleType = t.AnnotationActionEventType = t.AbortException = void 0, t.assert = J, t.bytesToString = Re, t.createValidAbsoluteUrl = le, t.getModificationDate = Me, t.getUuid = Xe, t.getVerbosityLevel = Y, t.info = se, t.isArrayBuffer = te, t.isArrayEqual = Ce, t.isNodeJS = void 0, t.normalizeUnicode = We, t.objectFromMap = Le, t.objectSize = he, t.setVerbosityLevel = de, t.shadow = Z, t.string32 = Pe, t.stringToBytes = De, t.stringToPDFString = ke, t.stringToUTF8String = Fe, t.unreachable = pe, t.utf8StringToString = Be, t.warn = ue;
          const r = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
          t.isNodeJS = r;
          const a = [1, 0, 0, 1, 0, 0];
          t.IDENTITY_MATRIX = a;
          const o = [1e-3, 0, 0, 1e-3, 0, 0];
          t.FONT_IDENTITY_MATRIX = o;
          const u = 1e7;
          t.MAX_IMAGE_SIZE_TO_CACHE = u;
          const c = 1.35;
          t.LINE_FACTOR = c;
          const d = 0.35;
          t.LINE_DESCENT_FACTOR = d;
          const g = d / c;
          t.BASELINE_FACTOR = g;
          const b = {
            ANY: 1,
            DISPLAY: 2,
            PRINT: 4,
            SAVE: 8,
            ANNOTATIONS_FORMS: 16,
            ANNOTATIONS_STORAGE: 32,
            ANNOTATIONS_DISABLE: 64,
            OPLIST: 256
          };
          t.RenderingIntentFlag = b;
          const _ = {
            DISABLE: 0,
            ENABLE: 1,
            ENABLE_FORMS: 2,
            ENABLE_STORAGE: 3
          };
          t.AnnotationMode = _;
          const y = "pdfjs_internal_editor_";
          t.AnnotationEditorPrefix = y;
          const A = {
            DISABLE: -1,
            NONE: 0,
            FREETEXT: 3,
            STAMP: 13,
            INK: 15
          };
          t.AnnotationEditorType = A;
          const E = {
            RESIZE: 1,
            CREATE: 2,
            FREETEXT_SIZE: 11,
            FREETEXT_COLOR: 12,
            FREETEXT_OPACITY: 13,
            INK_COLOR: 21,
            INK_THICKNESS: 22,
            INK_OPACITY: 23
          };
          t.AnnotationEditorParamsType = E;
          const v = {
            PRINT: 4,
            MODIFY_CONTENTS: 8,
            COPY: 16,
            MODIFY_ANNOTATIONS: 32,
            FILL_INTERACTIVE_FORMS: 256,
            COPY_FOR_ACCESSIBILITY: 512,
            ASSEMBLE: 1024,
            PRINT_HIGH_QUALITY: 2048
          };
          t.PermissionFlag = v;
          const C = {
            FILL: 0,
            STROKE: 1,
            FILL_STROKE: 2,
            INVISIBLE: 3,
            FILL_ADD_TO_PATH: 4,
            STROKE_ADD_TO_PATH: 5,
            FILL_STROKE_ADD_TO_PATH: 6,
            ADD_TO_PATH: 7,
            FILL_STROKE_MASK: 3,
            ADD_TO_PATH_FLAG: 4
          };
          t.TextRenderingMode = C;
          const R = {
            GRAYSCALE_1BPP: 1,
            RGB_24BPP: 2,
            RGBA_32BPP: 3
          };
          t.ImageKind = R;
          const I = {
            TEXT: 1,
            LINK: 2,
            FREETEXT: 3,
            LINE: 4,
            SQUARE: 5,
            CIRCLE: 6,
            POLYGON: 7,
            POLYLINE: 8,
            HIGHLIGHT: 9,
            UNDERLINE: 10,
            SQUIGGLY: 11,
            STRIKEOUT: 12,
            STAMP: 13,
            CARET: 14,
            INK: 15,
            POPUP: 16,
            FILEATTACHMENT: 17,
            SOUND: 18,
            MOVIE: 19,
            WIDGET: 20,
            SCREEN: 21,
            PRINTERMARK: 22,
            TRAPNET: 23,
            WATERMARK: 24,
            THREED: 25,
            REDACT: 26
          };
          t.AnnotationType = I;
          const w = {
            GROUP: "Group",
            REPLY: "R"
          };
          t.AnnotationReplyType = w;
          const N = {
            INVISIBLE: 1,
            HIDDEN: 2,
            PRINT: 4,
            NOZOOM: 8,
            NOROTATE: 16,
            NOVIEW: 32,
            READONLY: 64,
            LOCKED: 128,
            TOGGLENOVIEW: 256,
            LOCKEDCONTENTS: 512
          };
          t.AnnotationFlag = N;
          const F = {
            READONLY: 1,
            REQUIRED: 2,
            NOEXPORT: 4,
            MULTILINE: 4096,
            PASSWORD: 8192,
            NOTOGGLETOOFF: 16384,
            RADIO: 32768,
            PUSHBUTTON: 65536,
            COMBO: 131072,
            EDIT: 262144,
            SORT: 524288,
            FILESELECT: 1048576,
            MULTISELECT: 2097152,
            DONOTSPELLCHECK: 4194304,
            DONOTSCROLL: 8388608,
            COMB: 16777216,
            RICHTEXT: 33554432,
            RADIOSINUNISON: 33554432,
            COMMITONSELCHANGE: 67108864
          };
          t.AnnotationFieldFlag = F;
          const M = {
            SOLID: 1,
            DASHED: 2,
            BEVELED: 3,
            INSET: 4,
            UNDERLINE: 5
          };
          t.AnnotationBorderStyleType = M;
          const x = {
            E: "Mouse Enter",
            X: "Mouse Exit",
            D: "Mouse Down",
            U: "Mouse Up",
            Fo: "Focus",
            Bl: "Blur",
            PO: "PageOpen",
            PC: "PageClose",
            PV: "PageVisible",
            PI: "PageInvisible",
            K: "Keystroke",
            F: "Format",
            V: "Validate",
            C: "Calculate"
          };
          t.AnnotationActionEventType = x;
          const P = {
            WC: "WillClose",
            WS: "WillSave",
            DS: "DidSave",
            WP: "WillPrint",
            DP: "DidPrint"
          };
          t.DocumentActionEventType = P;
          const U = {
            O: "PageOpen",
            C: "PageClose"
          };
          t.PageActionEventType = U;
          const L = {
            ERRORS: 0,
            WARNINGS: 1,
            INFOS: 5
          };
          t.VerbosityLevel = L;
          const H = {
            NONE: 0,
            BINARY: 1
          };
          t.CMapCompressionType = H;
          const B = {
            dependency: 1,
            setLineWidth: 2,
            setLineCap: 3,
            setLineJoin: 4,
            setMiterLimit: 5,
            setDash: 6,
            setRenderingIntent: 7,
            setFlatness: 8,
            setGState: 9,
            save: 10,
            restore: 11,
            transform: 12,
            moveTo: 13,
            lineTo: 14,
            curveTo: 15,
            curveTo2: 16,
            curveTo3: 17,
            closePath: 18,
            rectangle: 19,
            stroke: 20,
            closeStroke: 21,
            fill: 22,
            eoFill: 23,
            fillStroke: 24,
            eoFillStroke: 25,
            closeFillStroke: 26,
            closeEOFillStroke: 27,
            endPath: 28,
            clip: 29,
            eoClip: 30,
            beginText: 31,
            endText: 32,
            setCharSpacing: 33,
            setWordSpacing: 34,
            setHScale: 35,
            setLeading: 36,
            setFont: 37,
            setTextRenderingMode: 38,
            setTextRise: 39,
            moveText: 40,
            setLeadingMoveText: 41,
            setTextMatrix: 42,
            nextLine: 43,
            showText: 44,
            showSpacedText: 45,
            nextLineShowText: 46,
            nextLineSetSpacingShowText: 47,
            setCharWidth: 48,
            setCharWidthAndBounds: 49,
            setStrokeColorSpace: 50,
            setFillColorSpace: 51,
            setStrokeColor: 52,
            setStrokeColorN: 53,
            setFillColor: 54,
            setFillColorN: 55,
            setStrokeGray: 56,
            setFillGray: 57,
            setStrokeRGBColor: 58,
            setFillRGBColor: 59,
            setStrokeCMYKColor: 60,
            setFillCMYKColor: 61,
            shadingFill: 62,
            beginInlineImage: 63,
            beginImageData: 64,
            endInlineImage: 65,
            paintXObject: 66,
            markPoint: 67,
            markPointProps: 68,
            beginMarkedContent: 69,
            beginMarkedContentProps: 70,
            endMarkedContent: 71,
            beginCompat: 72,
            endCompat: 73,
            paintFormXObjectBegin: 74,
            paintFormXObjectEnd: 75,
            beginGroup: 76,
            endGroup: 77,
            beginAnnotation: 80,
            endAnnotation: 81,
            paintImageMaskXObject: 83,
            paintImageMaskXObjectGroup: 84,
            paintImageXObject: 85,
            paintInlineImageXObject: 86,
            paintInlineImageXObjectGroup: 87,
            paintImageXObjectRepeat: 88,
            paintImageMaskXObjectRepeat: 89,
            paintSolidColorImageMask: 90,
            constructPath: 91
          };
          t.OPS = B;
          const V = {
            NEED_PASSWORD: 1,
            INCORRECT_PASSWORD: 2
          };
          t.PasswordResponses = V;
          let X = L.WARNINGS;
          function de($e) {
            Number.isInteger($e) && (X = $e);
          }
          function Y() {
            return X;
          }
          function se($e) {
            X >= L.INFOS && console.log(`Info: ${$e}`);
          }
          function ue($e) {
            X >= L.WARNINGS && console.log(`Warning: ${$e}`);
          }
          function pe($e) {
            throw new Error($e);
          }
          function J($e, Ae) {
            $e || pe(Ae);
          }
          function j($e) {
            switch ($e == null ? void 0 : $e.protocol) {
              case "http:":
              case "https:":
              case "ftp:":
              case "mailto:":
              case "tel:":
                return !0;
              default:
                return !1;
            }
          }
          function le($e, Ae = null, ve = null) {
            if (!$e)
              return null;
            try {
              if (ve && typeof $e == "string") {
                if (ve.addDefaultProtocol && $e.startsWith("www.")) {
                  const dt = $e.match(/\./g);
                  (dt == null ? void 0 : dt.length) >= 2 && ($e = `http://${$e}`);
                }
                if (ve.tryConvertEncoding)
                  try {
                    $e = Fe($e);
                  } catch {
                  }
              }
              const Ke = Ae ? new URL($e, Ae) : new URL($e);
              if (j(Ke))
                return Ke;
            } catch {
            }
            return null;
          }
          function Z($e, Ae, ve, Ke = !1) {
            return Object.defineProperty($e, Ae, {
              value: ve,
              enumerable: !Ke,
              configurable: !0,
              writable: !1
            }), ve;
          }
          const O = function() {
            function Ae(ve, Ke) {
              this.constructor === Ae && pe("Cannot initialize BaseException."), this.message = ve, this.name = Ke;
            }
            return Ae.prototype = new Error(), Ae.constructor = Ae, Ae;
          }();
          t.BaseException = O;
          class z extends O {
            constructor(Ae, ve) {
              super(Ae, "PasswordException"), this.code = ve;
            }
          }
          t.PasswordException = z;
          class W extends O {
            constructor(Ae, ve) {
              super(Ae, "UnknownErrorException"), this.details = ve;
            }
          }
          t.UnknownErrorException = W;
          class ee extends O {
            constructor(Ae) {
              super(Ae, "InvalidPDFException");
            }
          }
          t.InvalidPDFException = ee;
          class ae extends O {
            constructor(Ae) {
              super(Ae, "MissingPDFException");
            }
          }
          t.MissingPDFException = ae;
          class ie extends O {
            constructor(Ae, ve) {
              super(Ae, "UnexpectedResponseException"), this.status = ve;
            }
          }
          t.UnexpectedResponseException = ie;
          class me extends O {
            constructor(Ae) {
              super(Ae, "FormatError");
            }
          }
          t.FormatError = me;
          class ye extends O {
            constructor(Ae) {
              super(Ae, "AbortException");
            }
          }
          t.AbortException = ye;
          function Re($e) {
            (typeof $e != "object" || ($e == null ? void 0 : $e.length) === void 0) && pe("Invalid argument for bytesToString");
            const Ae = $e.length, ve = 8192;
            if (Ae < ve)
              return String.fromCharCode.apply(null, $e);
            const Ke = [];
            for (let dt = 0; dt < Ae; dt += ve) {
              const pt = Math.min(dt + ve, Ae), ce = $e.subarray(dt, pt);
              Ke.push(String.fromCharCode.apply(null, ce));
            }
            return Ke.join("");
          }
          function De($e) {
            typeof $e != "string" && pe("Invalid argument for stringToBytes");
            const Ae = $e.length, ve = new Uint8Array(Ae);
            for (let Ke = 0; Ke < Ae; ++Ke)
              ve[Ke] = $e.charCodeAt(Ke) & 255;
            return ve;
          }
          function Pe($e) {
            return String.fromCharCode($e >> 24 & 255, $e >> 16 & 255, $e >> 8 & 255, $e & 255);
          }
          function he($e) {
            return Object.keys($e).length;
          }
          function Le($e) {
            const Ae = /* @__PURE__ */ Object.create(null);
            for (const [ve, Ke] of $e)
              Ae[ve] = Ke;
            return Ae;
          }
          function Ee() {
            const $e = new Uint8Array(4);
            return $e[0] = 1, new Uint32Array($e.buffer, 0, 1)[0] === 1;
          }
          function Se() {
            try {
              return new Function(""), !0;
            } catch {
              return !1;
            }
          }
          class Q {
            static get isLittleEndian() {
              return Z(this, "isLittleEndian", Ee());
            }
            static get isEvalSupported() {
              return Z(this, "isEvalSupported", Se());
            }
            static get isOffscreenCanvasSupported() {
              return Z(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
            }
            static get platform() {
              return typeof navigator > "u" ? Z(this, "platform", {
                isWin: !1,
                isMac: !1
              }) : Z(this, "platform", {
                isWin: navigator.platform.includes("Win"),
                isMac: navigator.platform.includes("Mac")
              });
            }
            static get isCSSRoundSupported() {
              var Ae, ve;
              return Z(this, "isCSSRoundSupported", (ve = (Ae = globalThis.CSS) == null ? void 0 : Ae.supports) == null ? void 0 : ve.call(Ae, "width: round(1.5px, 1px)"));
            }
          }
          t.FeatureTest = Q;
          const K = [...Array(256).keys()].map(($e) => $e.toString(16).padStart(2, "0"));
          class fe {
            static makeHexColor(Ae, ve, Ke) {
              return `#${K[Ae]}${K[ve]}${K[Ke]}`;
            }
            static scaleMinMax(Ae, ve) {
              let Ke;
              Ae[0] ? (Ae[0] < 0 && (Ke = ve[0], ve[0] = ve[1], ve[1] = Ke), ve[0] *= Ae[0], ve[1] *= Ae[0], Ae[3] < 0 && (Ke = ve[2], ve[2] = ve[3], ve[3] = Ke), ve[2] *= Ae[3], ve[3] *= Ae[3]) : (Ke = ve[0], ve[0] = ve[2], ve[2] = Ke, Ke = ve[1], ve[1] = ve[3], ve[3] = Ke, Ae[1] < 0 && (Ke = ve[2], ve[2] = ve[3], ve[3] = Ke), ve[2] *= Ae[1], ve[3] *= Ae[1], Ae[2] < 0 && (Ke = ve[0], ve[0] = ve[1], ve[1] = Ke), ve[0] *= Ae[2], ve[1] *= Ae[2]), ve[0] += Ae[4], ve[1] += Ae[4], ve[2] += Ae[5], ve[3] += Ae[5];
            }
            static transform(Ae, ve) {
              return [Ae[0] * ve[0] + Ae[2] * ve[1], Ae[1] * ve[0] + Ae[3] * ve[1], Ae[0] * ve[2] + Ae[2] * ve[3], Ae[1] * ve[2] + Ae[3] * ve[3], Ae[0] * ve[4] + Ae[2] * ve[5] + Ae[4], Ae[1] * ve[4] + Ae[3] * ve[5] + Ae[5]];
            }
            static applyTransform(Ae, ve) {
              const Ke = Ae[0] * ve[0] + Ae[1] * ve[2] + ve[4], dt = Ae[0] * ve[1] + Ae[1] * ve[3] + ve[5];
              return [Ke, dt];
            }
            static applyInverseTransform(Ae, ve) {
              const Ke = ve[0] * ve[3] - ve[1] * ve[2], dt = (Ae[0] * ve[3] - Ae[1] * ve[2] + ve[2] * ve[5] - ve[4] * ve[3]) / Ke, pt = (-Ae[0] * ve[1] + Ae[1] * ve[0] + ve[4] * ve[1] - ve[5] * ve[0]) / Ke;
              return [dt, pt];
            }
            static getAxialAlignedBoundingBox(Ae, ve) {
              const Ke = this.applyTransform(Ae, ve), dt = this.applyTransform(Ae.slice(2, 4), ve), pt = this.applyTransform([Ae[0], Ae[3]], ve), ce = this.applyTransform([Ae[2], Ae[1]], ve);
              return [Math.min(Ke[0], dt[0], pt[0], ce[0]), Math.min(Ke[1], dt[1], pt[1], ce[1]), Math.max(Ke[0], dt[0], pt[0], ce[0]), Math.max(Ke[1], dt[1], pt[1], ce[1])];
            }
            static inverseTransform(Ae) {
              const ve = Ae[0] * Ae[3] - Ae[1] * Ae[2];
              return [Ae[3] / ve, -Ae[1] / ve, -Ae[2] / ve, Ae[0] / ve, (Ae[2] * Ae[5] - Ae[4] * Ae[3]) / ve, (Ae[4] * Ae[1] - Ae[5] * Ae[0]) / ve];
            }
            static singularValueDecompose2dScale(Ae) {
              const ve = [Ae[0], Ae[2], Ae[1], Ae[3]], Ke = Ae[0] * ve[0] + Ae[1] * ve[2], dt = Ae[0] * ve[1] + Ae[1] * ve[3], pt = Ae[2] * ve[0] + Ae[3] * ve[2], ce = Ae[2] * ve[1] + Ae[3] * ve[3], Ne = (Ke + ce) / 2, Ge = Math.sqrt((Ke + ce) ** 2 - 4 * (Ke * ce - pt * dt)) / 2, nt = Ne + Ge || 1, rt = Ne - Ge || 1;
              return [Math.sqrt(nt), Math.sqrt(rt)];
            }
            static normalizeRect(Ae) {
              const ve = Ae.slice(0);
              return Ae[0] > Ae[2] && (ve[0] = Ae[2], ve[2] = Ae[0]), Ae[1] > Ae[3] && (ve[1] = Ae[3], ve[3] = Ae[1]), ve;
            }
            static intersect(Ae, ve) {
              const Ke = Math.max(Math.min(Ae[0], Ae[2]), Math.min(ve[0], ve[2])), dt = Math.min(Math.max(Ae[0], Ae[2]), Math.max(ve[0], ve[2]));
              if (Ke > dt)
                return null;
              const pt = Math.max(Math.min(Ae[1], Ae[3]), Math.min(ve[1], ve[3])), ce = Math.min(Math.max(Ae[1], Ae[3]), Math.max(ve[1], ve[3]));
              return pt > ce ? null : [Ke, pt, dt, ce];
            }
            static bezierBoundingBox(Ae, ve, Ke, dt, pt, ce, Ne, Ge) {
              const nt = [], rt = [[], []];
              let Ye, oe, ne, ge, xe, Oe, Ue, qe;
              for (let st = 0; st < 2; ++st) {
                if (st === 0 ? (oe = 6 * Ae - 12 * Ke + 6 * pt, Ye = -3 * Ae + 9 * Ke - 9 * pt + 3 * Ne, ne = 3 * Ke - 3 * Ae) : (oe = 6 * ve - 12 * dt + 6 * ce, Ye = -3 * ve + 9 * dt - 9 * ce + 3 * Ge, ne = 3 * dt - 3 * ve), Math.abs(Ye) < 1e-12) {
                  if (Math.abs(oe) < 1e-12)
                    continue;
                  ge = -ne / oe, 0 < ge && ge < 1 && nt.push(ge);
                  continue;
                }
                Ue = oe * oe - 4 * ne * Ye, qe = Math.sqrt(Ue), !(Ue < 0) && (xe = (-oe + qe) / (2 * Ye), 0 < xe && xe < 1 && nt.push(xe), Oe = (-oe - qe) / (2 * Ye), 0 < Oe && Oe < 1 && nt.push(Oe));
              }
              let Qe = nt.length, Je;
              const He = Qe;
              for (; Qe--; )
                ge = nt[Qe], Je = 1 - ge, rt[0][Qe] = Je * Je * Je * Ae + 3 * Je * Je * ge * Ke + 3 * Je * ge * ge * pt + ge * ge * ge * Ne, rt[1][Qe] = Je * Je * Je * ve + 3 * Je * Je * ge * dt + 3 * Je * ge * ge * ce + ge * ge * ge * Ge;
              return rt[0][He] = Ae, rt[1][He] = ve, rt[0][He + 1] = Ne, rt[1][He + 1] = Ge, rt[0].length = rt[1].length = He + 2, [Math.min(...rt[0]), Math.min(...rt[1]), Math.max(...rt[0]), Math.max(...rt[1])];
            }
          }
          t.Util = fe;
          const be = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
          function ke($e) {
            if ($e[0] >= "") {
              let ve;
              if ($e[0] === "" && $e[1] === "" ? ve = "utf-16be" : $e[0] === "" && $e[1] === "" ? ve = "utf-16le" : $e[0] === "" && $e[1] === "" && $e[2] === "" && (ve = "utf-8"), ve)
                try {
                  const Ke = new TextDecoder(ve, {
                    fatal: !0
                  }), dt = De($e);
                  return Ke.decode(dt);
                } catch (Ke) {
                  ue(`stringToPDFString: "${Ke}".`);
                }
            }
            const Ae = [];
            for (let ve = 0, Ke = $e.length; ve < Ke; ve++) {
              const dt = be[$e.charCodeAt(ve)];
              Ae.push(dt ? String.fromCharCode(dt) : $e.charAt(ve));
            }
            return Ae.join("");
          }
          function Fe($e) {
            return decodeURIComponent(escape($e));
          }
          function Be($e) {
            return unescape(encodeURIComponent($e));
          }
          function te($e) {
            return typeof $e == "object" && ($e == null ? void 0 : $e.byteLength) !== void 0;
          }
          function Ce($e, Ae) {
            if ($e.length !== Ae.length)
              return !1;
            for (let ve = 0, Ke = $e.length; ve < Ke; ve++)
              if ($e[ve] !== Ae[ve])
                return !1;
            return !0;
          }
          function Me($e = /* @__PURE__ */ new Date()) {
            return [$e.getUTCFullYear().toString(), ($e.getUTCMonth() + 1).toString().padStart(2, "0"), $e.getUTCDate().toString().padStart(2, "0"), $e.getUTCHours().toString().padStart(2, "0"), $e.getUTCMinutes().toString().padStart(2, "0"), $e.getUTCSeconds().toString().padStart(2, "0")].join("");
          }
          class Ve {
            constructor() {
              we(this, ct, !1);
              this.promise = new Promise((Ae, ve) => {
                this.resolve = (Ke) => {
                  Ie(this, ct, !0), Ae(Ke);
                }, this.reject = (Ke) => {
                  Ie(this, ct, !0), ve(Ke);
                };
              });
            }
            get settled() {
              return G(this, ct);
            }
          }
          ct = new WeakMap(), t.PromiseCapability = Ve;
          let je = null, ot = null;
          function We($e) {
            return je || (je = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, ot = /* @__PURE__ */ new Map([["", "t"]])), $e.replaceAll(je, (Ae, ve, Ke) => ve ? ve.normalize("NFKC") : ot.get(Ke));
          }
          function Xe() {
            if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.randomUUID) == "function")
              return crypto.randomUUID();
            const $e = new Uint8Array(32);
            if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.getRandomValues) == "function")
              crypto.getRandomValues($e);
            else
              for (let Ae = 0; Ae < 32; Ae++)
                $e[Ae] = Math.floor(Math.random() * 255);
            return Re($e);
          }
          const ut = "pdfjs_internal_id_";
          t.AnnotationPrefix = ut;
        },
        /* 2 */
        /***/
        (__unused_webpack_module, exports, __w_pdfjs_require__) => {
          var e, r, a, o, xt, Ht, d, g, b, _, y, A, E, v, C, zt, I, w, an, F, M;
          Object.defineProperty(exports, "__esModule", {
            value: !0
          }), exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultFilterFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0, Object.defineProperty(exports, "SVGGraphics", {
            enumerable: !0,
            get: function() {
              return _displaySvg.SVGGraphics;
            }
          }), exports.build = void 0, exports.getDocument = getDocument, exports.version = void 0;
          var _util = __w_pdfjs_require__(1), _annotation_storage = __w_pdfjs_require__(3), _display_utils = __w_pdfjs_require__(6), _font_loader = __w_pdfjs_require__(9), _displayNode_utils = __w_pdfjs_require__(10), _canvas = __w_pdfjs_require__(11), _worker_options = __w_pdfjs_require__(14), _message_handler = __w_pdfjs_require__(15), _metadata = __w_pdfjs_require__(16), _optional_content_config = __w_pdfjs_require__(17), _transport_stream = __w_pdfjs_require__(18), _displayFetch_stream = __w_pdfjs_require__(19), _displayNetwork = __w_pdfjs_require__(22), _displayNode_stream = __w_pdfjs_require__(23), _displaySvg = __w_pdfjs_require__(24), _xfa_text = __w_pdfjs_require__(25);
          const DEFAULT_RANGE_CHUNK_SIZE = 65536, RENDERING_CANCELLED_TIMEOUT = 100, DELAYED_CLEANUP_TIMEOUT = 5e3, DefaultCanvasFactory = _util.isNodeJS ? _displayNode_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;
          exports.DefaultCanvasFactory = DefaultCanvasFactory;
          const DefaultCMapReaderFactory = _util.isNodeJS ? _displayNode_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;
          exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
          const DefaultFilterFactory = _util.isNodeJS ? _displayNode_utils.NodeFilterFactory : _display_utils.DOMFilterFactory;
          exports.DefaultFilterFactory = DefaultFilterFactory;
          const DefaultStandardFontDataFactory = _util.isNodeJS ? _displayNode_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory;
          exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;
          function getDocument(P) {
            if (typeof P == "string" || P instanceof URL ? P = {
              url: P
            } : (0, _util.isArrayBuffer)(P) && (P = {
              data: P
            }), typeof P != "object")
              throw new Error("Invalid parameter in getDocument, need parameter object.");
            if (!P.url && !P.data && !P.range)
              throw new Error("Invalid parameter object: need either .data, .range or .url");
            const U = new PDFDocumentLoadingTask(), {
              docId: L
            } = U, H = P.url ? getUrlProp(P.url) : null, B = P.data ? getDataProp(P.data) : null, V = P.httpHeaders || null, X = P.withCredentials === !0, de = P.password ?? null, Y = P.range instanceof PDFDataRangeTransport ? P.range : null, se = Number.isInteger(P.rangeChunkSize) && P.rangeChunkSize > 0 ? P.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;
            let ue = P.worker instanceof PDFWorker ? P.worker : null;
            const pe = P.verbosity, J = typeof P.docBaseUrl == "string" && !(0, _display_utils.isDataScheme)(P.docBaseUrl) ? P.docBaseUrl : null, j = typeof P.cMapUrl == "string" ? P.cMapUrl : null, le = P.cMapPacked !== !1, Z = P.CMapReaderFactory || DefaultCMapReaderFactory, O = typeof P.standardFontDataUrl == "string" ? P.standardFontDataUrl : null, z = P.StandardFontDataFactory || DefaultStandardFontDataFactory, W = P.stopAtErrors !== !0, ee = Number.isInteger(P.maxImageSize) && P.maxImageSize > -1 ? P.maxImageSize : -1, ae = P.isEvalSupported !== !1, ie = typeof P.isOffscreenCanvasSupported == "boolean" ? P.isOffscreenCanvasSupported : !_util.isNodeJS, me = Number.isInteger(P.canvasMaxAreaInBytes) ? P.canvasMaxAreaInBytes : -1, ye = typeof P.disableFontFace == "boolean" ? P.disableFontFace : _util.isNodeJS, Re = P.fontExtraProperties === !0, De = P.enableXfa === !0, Pe = P.ownerDocument || globalThis.document, he = P.disableRange === !0, Le = P.disableStream === !0, Ee = P.disableAutoFetch === !0, Se = P.pdfBug === !0, Q = Y ? Y.length : P.length ?? NaN, K = typeof P.useSystemFonts == "boolean" ? P.useSystemFonts : !_util.isNodeJS && !ye, fe = typeof P.useWorkerFetch == "boolean" ? P.useWorkerFetch : Z === _display_utils.DOMCMapReaderFactory && z === _display_utils.DOMStandardFontDataFactory && j && O && (0, _display_utils.isValidFetchUrl)(j, document.baseURI) && (0, _display_utils.isValidFetchUrl)(O, document.baseURI), be = P.canvasFactory || new DefaultCanvasFactory({
              ownerDocument: Pe
            }), ke = P.filterFactory || new DefaultFilterFactory({
              docId: L,
              ownerDocument: Pe
            }), Fe = null;
            (0, _util.setVerbosityLevel)(pe);
            const Be = {
              canvasFactory: be,
              filterFactory: ke
            };
            if (fe || (Be.cMapReaderFactory = new Z({
              baseUrl: j,
              isCompressed: le
            }), Be.standardFontDataFactory = new z({
              baseUrl: O
            })), !ue) {
              const Me = {
                verbosity: pe,
                port: _worker_options.GlobalWorkerOptions.workerPort
              };
              ue = Me.port ? PDFWorker.fromPort(Me) : new PDFWorker(Me), U._worker = ue;
            }
            const te = {
              docId: L,
              apiVersion: "3.11.174",
              data: B,
              password: de,
              disableAutoFetch: Ee,
              rangeChunkSize: se,
              length: Q,
              docBaseUrl: J,
              enableXfa: De,
              evaluatorOptions: {
                maxImageSize: ee,
                disableFontFace: ye,
                ignoreErrors: W,
                isEvalSupported: ae,
                isOffscreenCanvasSupported: ie,
                canvasMaxAreaInBytes: me,
                fontExtraProperties: Re,
                useSystemFonts: K,
                cMapUrl: fe ? j : null,
                standardFontDataUrl: fe ? O : null
              }
            }, Ce = {
              ignoreErrors: W,
              isEvalSupported: ae,
              disableFontFace: ye,
              fontExtraProperties: Re,
              enableXfa: De,
              ownerDocument: Pe,
              disableAutoFetch: Ee,
              pdfBug: Se,
              styleElement: Fe
            };
            return ue.promise.then(function() {
              if (U.destroyed)
                throw new Error("Loading aborted");
              const Me = _fetchDocument(ue, te), Ve = new Promise(function(je) {
                let ot;
                Y ? ot = new _transport_stream.PDFDataTransportStream({
                  length: Q,
                  initialData: Y.initialData,
                  progressiveDone: Y.progressiveDone,
                  contentDispositionFilename: Y.contentDispositionFilename,
                  disableRange: he,
                  disableStream: Le
                }, Y) : B || (ot = ((Xe) => _util.isNodeJS ? new _displayNode_stream.PDFNodeStream(Xe) : (0, _display_utils.isValidFetchUrl)(Xe.url) ? new _displayFetch_stream.PDFFetchStream(Xe) : new _displayNetwork.PDFNetworkStream(Xe))({
                  url: H,
                  length: Q,
                  httpHeaders: V,
                  withCredentials: X,
                  rangeChunkSize: se,
                  disableRange: he,
                  disableStream: Le
                })), je(ot);
              });
              return Promise.all([Me, Ve]).then(function([je, ot]) {
                if (U.destroyed)
                  throw new Error("Loading aborted");
                const We = new _message_handler.MessageHandler(L, je, ue.port), Xe = new WorkerTransport(We, U, ot, Ce, Be);
                U._transport = Xe, We.send("Ready", null);
              });
            }).catch(U._capability.reject), U;
          }
          async function _fetchDocument(P, U) {
            if (P.destroyed)
              throw new Error("Worker was destroyed");
            const L = await P.messageHandler.sendWithPromise("GetDocRequest", U, U.data ? [U.data.buffer] : null);
            if (P.destroyed)
              throw new Error("Worker was destroyed");
            return L;
          }
          function getUrlProp(P) {
            if (P instanceof URL)
              return P.href;
            try {
              return new URL(P, window.location).href;
            } catch {
              if (_util.isNodeJS && typeof P == "string")
                return P;
            }
            throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
          }
          function getDataProp(P) {
            if (_util.isNodeJS && typeof Buffer < "u" && P instanceof Buffer)
              throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
            if (P instanceof Uint8Array && P.byteLength === P.buffer.byteLength)
              return P;
            if (typeof P == "string")
              return (0, _util.stringToBytes)(P);
            if (typeof P == "object" && !isNaN(P == null ? void 0 : P.length) || (0, _util.isArrayBuffer)(P))
              return new Uint8Array(P);
            throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
          }
          const t = class t {
            constructor() {
              this._capability = new _util.PromiseCapability(), this._transport = null, this._worker = null, this.docId = `d${Mt(t, e)._++}`, this.destroyed = !1, this.onPassword = null, this.onProgress = null;
            }
            get promise() {
              return this._capability.promise;
            }
            async destroy() {
              var U, L, H;
              this.destroyed = !0;
              try {
                (U = this._worker) != null && U.port && (this._worker._pendingDestroy = !0), await ((L = this._transport) == null ? void 0 : L.destroy());
              } catch (B) {
                throw (H = this._worker) != null && H.port && delete this._worker._pendingDestroy, B;
              }
              this._transport = null, this._worker && (this._worker.destroy(), this._worker = null);
            }
          };
          e = new WeakMap(), we(t, e, 0);
          let PDFDocumentLoadingTask = t;
          exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
          class PDFDataRangeTransport {
            constructor(U, L, H = !1, B = null) {
              this.length = U, this.initialData = L, this.progressiveDone = H, this.contentDispositionFilename = B, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = new _util.PromiseCapability();
            }
            addRangeListener(U) {
              this._rangeListeners.push(U);
            }
            addProgressListener(U) {
              this._progressListeners.push(U);
            }
            addProgressiveReadListener(U) {
              this._progressiveReadListeners.push(U);
            }
            addProgressiveDoneListener(U) {
              this._progressiveDoneListeners.push(U);
            }
            onDataRange(U, L) {
              for (const H of this._rangeListeners)
                H(U, L);
            }
            onDataProgress(U, L) {
              this._readyCapability.promise.then(() => {
                for (const H of this._progressListeners)
                  H(U, L);
              });
            }
            onDataProgressiveRead(U) {
              this._readyCapability.promise.then(() => {
                for (const L of this._progressiveReadListeners)
                  L(U);
              });
            }
            onDataProgressiveDone() {
              this._readyCapability.promise.then(() => {
                for (const U of this._progressiveDoneListeners)
                  U();
              });
            }
            transportReady() {
              this._readyCapability.resolve();
            }
            requestDataRange(U, L) {
              (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
            }
            abort() {
            }
          }
          exports.PDFDataRangeTransport = PDFDataRangeTransport;
          class PDFDocumentProxy {
            constructor(U, L) {
              this._pdfInfo = U, this._transport = L, Object.defineProperty(this, "getJavaScript", {
                value: () => ((0, _display_utils.deprecated)("`PDFDocumentProxy.getJavaScript`, please use `PDFDocumentProxy.getJSActions` instead."), this.getJSActions().then((H) => {
                  if (!H)
                    return H;
                  const B = [];
                  for (const V in H)
                    B.push(...H[V]);
                  return B;
                }))
              });
            }
            get annotationStorage() {
              return this._transport.annotationStorage;
            }
            get filterFactory() {
              return this._transport.filterFactory;
            }
            get numPages() {
              return this._pdfInfo.numPages;
            }
            get fingerprints() {
              return this._pdfInfo.fingerprints;
            }
            get isPureXfa() {
              return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
            }
            get allXfaHtml() {
              return this._transport._htmlForXfa;
            }
            getPage(U) {
              return this._transport.getPage(U);
            }
            getPageIndex(U) {
              return this._transport.getPageIndex(U);
            }
            getDestinations() {
              return this._transport.getDestinations();
            }
            getDestination(U) {
              return this._transport.getDestination(U);
            }
            getPageLabels() {
              return this._transport.getPageLabels();
            }
            getPageLayout() {
              return this._transport.getPageLayout();
            }
            getPageMode() {
              return this._transport.getPageMode();
            }
            getViewerPreferences() {
              return this._transport.getViewerPreferences();
            }
            getOpenAction() {
              return this._transport.getOpenAction();
            }
            getAttachments() {
              return this._transport.getAttachments();
            }
            getJSActions() {
              return this._transport.getDocJSActions();
            }
            getOutline() {
              return this._transport.getOutline();
            }
            getOptionalContentConfig() {
              return this._transport.getOptionalContentConfig();
            }
            getPermissions() {
              return this._transport.getPermissions();
            }
            getMetadata() {
              return this._transport.getMetadata();
            }
            getMarkInfo() {
              return this._transport.getMarkInfo();
            }
            getData() {
              return this._transport.getData();
            }
            saveDocument() {
              return this._transport.saveDocument();
            }
            getDownloadInfo() {
              return this._transport.downloadInfoCapability.promise;
            }
            cleanup(U = !1) {
              return this._transport.startCleanup(U || this.isPureXfa);
            }
            destroy() {
              return this.loadingTask.destroy();
            }
            get loadingParams() {
              return this._transport.loadingParams;
            }
            get loadingTask() {
              return this._transport.loadingTask;
            }
            getFieldObjects() {
              return this._transport.getFieldObjects();
            }
            hasJSActions() {
              return this._transport.hasJSActions();
            }
            getCalculationOrderIds() {
              return this._transport.getCalculationOrderIds();
            }
          }
          exports.PDFDocumentProxy = PDFDocumentProxy;
          class PDFPageProxy {
            constructor(U, L, H, B = !1) {
              we(this, o);
              we(this, r, null);
              we(this, a, !1);
              this._pageIndex = U, this._pageInfo = L, this._transport = H, this._stats = B ? new _display_utils.StatTimer() : null, this._pdfBug = B, this.commonObjs = H.commonObjs, this.objs = new PDFObjects(), this._maybeCleanupAfterRender = !1, this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = !1;
            }
            get pageNumber() {
              return this._pageIndex + 1;
            }
            get rotate() {
              return this._pageInfo.rotate;
            }
            get ref() {
              return this._pageInfo.ref;
            }
            get userUnit() {
              return this._pageInfo.userUnit;
            }
            get view() {
              return this._pageInfo.view;
            }
            getViewport({
              scale: U,
              rotation: L = this.rotate,
              offsetX: H = 0,
              offsetY: B = 0,
              dontFlip: V = !1
            } = {}) {
              return new _display_utils.PageViewport({
                viewBox: this.view,
                scale: U,
                rotation: L,
                offsetX: H,
                offsetY: B,
                dontFlip: V
              });
            }
            getAnnotations({
              intent: U = "display"
            } = {}) {
              const L = this._transport.getRenderingIntent(U);
              return this._transport.getAnnotations(this._pageIndex, L.renderingIntent);
            }
            getJSActions() {
              return this._transport.getPageJSActions(this._pageIndex);
            }
            get filterFactory() {
              return this._transport.filterFactory;
            }
            get isPureXfa() {
              return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
            }
            async getXfa() {
              var U;
              return ((U = this._transport._htmlForXfa) == null ? void 0 : U.children[this._pageIndex]) || null;
            }
            render({
              canvasContext: U,
              viewport: L,
              intent: H = "display",
              annotationMode: B = _util.AnnotationMode.ENABLE,
              transform: V = null,
              background: X = null,
              optionalContentConfigPromise: de = null,
              annotationCanvasMap: Y = null,
              pageColors: se = null,
              printAnnotationStorage: ue = null
            }) {
              var z, W;
              (z = this._stats) == null || z.time("Overall");
              const pe = this._transport.getRenderingIntent(H, B, ue);
              Ie(this, a, !1), _e(this, o, Ht).call(this), de || (de = this._transport.getOptionalContentConfig());
              let J = this._intentStates.get(pe.cacheKey);
              J || (J = /* @__PURE__ */ Object.create(null), this._intentStates.set(pe.cacheKey, J)), J.streamReaderCancelTimeout && (clearTimeout(J.streamReaderCancelTimeout), J.streamReaderCancelTimeout = null);
              const j = !!(pe.renderingIntent & _util.RenderingIntentFlag.PRINT);
              J.displayReadyCapability || (J.displayReadyCapability = new _util.PromiseCapability(), J.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: !1,
                separateAnnots: null
              }, (W = this._stats) == null || W.time("Page Request"), this._pumpOperatorList(pe));
              const le = (ee) => {
                var ae, ie;
                J.renderTasks.delete(Z), (this._maybeCleanupAfterRender || j) && Ie(this, a, !0), _e(this, o, xt).call(this, !j), ee ? (Z.capability.reject(ee), this._abortOperatorList({
                  intentState: J,
                  reason: ee instanceof Error ? ee : new Error(ee)
                })) : Z.capability.resolve(), (ae = this._stats) == null || ae.timeEnd("Rendering"), (ie = this._stats) == null || ie.timeEnd("Overall");
              }, Z = new InternalRenderTask({
                callback: le,
                params: {
                  canvasContext: U,
                  viewport: L,
                  transform: V,
                  background: X
                },
                objs: this.objs,
                commonObjs: this.commonObjs,
                annotationCanvasMap: Y,
                operatorList: J.operatorList,
                pageIndex: this._pageIndex,
                canvasFactory: this._transport.canvasFactory,
                filterFactory: this._transport.filterFactory,
                useRequestAnimationFrame: !j,
                pdfBug: this._pdfBug,
                pageColors: se
              });
              (J.renderTasks || (J.renderTasks = /* @__PURE__ */ new Set())).add(Z);
              const O = Z.task;
              return Promise.all([J.displayReadyCapability.promise, de]).then(([ee, ae]) => {
                var ie;
                if (this.destroyed) {
                  le();
                  return;
                }
                (ie = this._stats) == null || ie.time("Rendering"), Z.initializeGraphics({
                  transparency: ee,
                  optionalContentConfig: ae
                }), Z.operatorListChanged();
              }).catch(le), O;
            }
            getOperatorList({
              intent: U = "display",
              annotationMode: L = _util.AnnotationMode.ENABLE,
              printAnnotationStorage: H = null
            } = {}) {
              var Y;
              function B() {
                X.operatorList.lastChunk && (X.opListReadCapability.resolve(X.operatorList), X.renderTasks.delete(de));
              }
              const V = this._transport.getRenderingIntent(U, L, H, !0);
              let X = this._intentStates.get(V.cacheKey);
              X || (X = /* @__PURE__ */ Object.create(null), this._intentStates.set(V.cacheKey, X));
              let de;
              return X.opListReadCapability || (de = /* @__PURE__ */ Object.create(null), de.operatorListChanged = B, X.opListReadCapability = new _util.PromiseCapability(), (X.renderTasks || (X.renderTasks = /* @__PURE__ */ new Set())).add(de), X.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: !1,
                separateAnnots: null
              }, (Y = this._stats) == null || Y.time("Page Request"), this._pumpOperatorList(V)), X.opListReadCapability.promise;
            }
            streamTextContent({
              includeMarkedContent: U = !1,
              disableNormalization: L = !1
            } = {}) {
              return this._transport.messageHandler.sendWithStream("GetTextContent", {
                pageIndex: this._pageIndex,
                includeMarkedContent: U === !0,
                disableNormalization: L === !0
              }, {
                highWaterMark: 100,
                size(B) {
                  return B.items.length;
                }
              });
            }
            getTextContent(U = {}) {
              if (this._transport._htmlForXfa)
                return this.getXfa().then((H) => _xfa_text.XfaText.textContent(H));
              const L = this.streamTextContent(U);
              return new Promise(function(H, B) {
                function V() {
                  X.read().then(function({
                    value: Y,
                    done: se
                  }) {
                    if (se) {
                      H(de);
                      return;
                    }
                    Object.assign(de.styles, Y.styles), de.items.push(...Y.items), V();
                  }, B);
                }
                const X = L.getReader(), de = {
                  items: [],
                  styles: /* @__PURE__ */ Object.create(null)
                };
                V();
              });
            }
            getStructTree() {
              return this._transport.getStructTree(this._pageIndex);
            }
            _destroy() {
              this.destroyed = !0;
              const U = [];
              for (const L of this._intentStates.values())
                if (this._abortOperatorList({
                  intentState: L,
                  reason: new Error("Page was destroyed."),
                  force: !0
                }), !L.opListReadCapability)
                  for (const H of L.renderTasks)
                    U.push(H.completed), H.cancel();
              return this.objs.clear(), Ie(this, a, !1), _e(this, o, Ht).call(this), Promise.all(U);
            }
            cleanup(U = !1) {
              Ie(this, a, !0);
              const L = _e(this, o, xt).call(this, !1);
              return U && L && this._stats && (this._stats = new _display_utils.StatTimer()), L;
            }
            _startRenderPage(U, L) {
              var B, V;
              const H = this._intentStates.get(L);
              H && ((B = this._stats) == null || B.timeEnd("Page Request"), (V = H.displayReadyCapability) == null || V.resolve(U));
            }
            _renderPageChunk(U, L) {
              for (let H = 0, B = U.length; H < B; H++)
                L.operatorList.fnArray.push(U.fnArray[H]), L.operatorList.argsArray.push(U.argsArray[H]);
              L.operatorList.lastChunk = U.lastChunk, L.operatorList.separateAnnots = U.separateAnnots;
              for (const H of L.renderTasks)
                H.operatorListChanged();
              U.lastChunk && _e(this, o, xt).call(this, !0);
            }
            _pumpOperatorList({
              renderingIntent: U,
              cacheKey: L,
              annotationStorageSerializable: H
            }) {
              const {
                map: B,
                transfers: V
              } = H, de = this._transport.messageHandler.sendWithStream("GetOperatorList", {
                pageIndex: this._pageIndex,
                intent: U,
                cacheKey: L,
                annotationStorage: B
              }, V).getReader(), Y = this._intentStates.get(L);
              Y.streamReader = de;
              const se = () => {
                de.read().then(({
                  value: ue,
                  done: pe
                }) => {
                  if (pe) {
                    Y.streamReader = null;
                    return;
                  }
                  this._transport.destroyed || (this._renderPageChunk(ue, Y), se());
                }, (ue) => {
                  if (Y.streamReader = null, !this._transport.destroyed) {
                    if (Y.operatorList) {
                      Y.operatorList.lastChunk = !0;
                      for (const pe of Y.renderTasks)
                        pe.operatorListChanged();
                      _e(this, o, xt).call(this, !0);
                    }
                    if (Y.displayReadyCapability)
                      Y.displayReadyCapability.reject(ue);
                    else if (Y.opListReadCapability)
                      Y.opListReadCapability.reject(ue);
                    else
                      throw ue;
                  }
                });
              };
              se();
            }
            _abortOperatorList({
              intentState: U,
              reason: L,
              force: H = !1
            }) {
              if (U.streamReader) {
                if (U.streamReaderCancelTimeout && (clearTimeout(U.streamReaderCancelTimeout), U.streamReaderCancelTimeout = null), !H) {
                  if (U.renderTasks.size > 0)
                    return;
                  if (L instanceof _display_utils.RenderingCancelledException) {
                    let B = RENDERING_CANCELLED_TIMEOUT;
                    L.extraDelay > 0 && L.extraDelay < 1e3 && (B += L.extraDelay), U.streamReaderCancelTimeout = setTimeout(() => {
                      U.streamReaderCancelTimeout = null, this._abortOperatorList({
                        intentState: U,
                        reason: L,
                        force: !0
                      });
                    }, B);
                    return;
                  }
                }
                if (U.streamReader.cancel(new _util.AbortException(L.message)).catch(() => {
                }), U.streamReader = null, !this._transport.destroyed) {
                  for (const [B, V] of this._intentStates)
                    if (V === U) {
                      this._intentStates.delete(B);
                      break;
                    }
                  this.cleanup();
                }
              }
            }
            get stats() {
              return this._stats;
            }
          }
          r = new WeakMap(), a = new WeakMap(), o = new WeakSet(), xt = function(U = !1) {
            if (_e(this, o, Ht).call(this), !G(this, a) || this.destroyed)
              return !1;
            if (U)
              return Ie(this, r, setTimeout(() => {
                Ie(this, r, null), _e(this, o, xt).call(this, !1);
              }, DELAYED_CLEANUP_TIMEOUT)), !1;
            for (const {
              renderTasks: L,
              operatorList: H
            } of this._intentStates.values())
              if (L.size > 0 || !H.lastChunk)
                return !1;
            return this._intentStates.clear(), this.objs.clear(), Ie(this, a, !1), !0;
          }, Ht = function() {
            G(this, r) && (clearTimeout(G(this, r)), Ie(this, r, null));
          }, exports.PDFPageProxy = PDFPageProxy;
          class LoopbackPort {
            constructor() {
              we(this, d, /* @__PURE__ */ new Set());
              we(this, g, Promise.resolve());
            }
            postMessage(U, L) {
              const H = {
                data: structuredClone(U, L ? {
                  transfer: L
                } : null)
              };
              G(this, g).then(() => {
                for (const B of G(this, d))
                  B.call(this, H);
              });
            }
            addEventListener(U, L) {
              G(this, d).add(L);
            }
            removeEventListener(U, L) {
              G(this, d).delete(L);
            }
            terminate() {
              G(this, d).clear();
            }
          }
          d = new WeakMap(), g = new WeakMap(), exports.LoopbackPort = LoopbackPort;
          const PDFWorkerUtil = {
            isWorkerDisabled: !1,
            fallbackWorkerSrc: null,
            fakeWorkerId: 0
          };
          exports.PDFWorkerUtil = PDFWorkerUtil;
          {
            if (_util.isNodeJS && typeof commonjsRequire == "function")
              PDFWorkerUtil.isWorkerDisabled = !0, PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
            else if (typeof document == "object") {
              const P = (b = document == null ? void 0 : document.currentScript) == null ? void 0 : b.src;
              P && (PDFWorkerUtil.fallbackWorkerSrc = P.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2"));
            }
            PDFWorkerUtil.isSameOrigin = function(P, U) {
              let L;
              try {
                if (L = new URL(P), !L.origin || L.origin === "null")
                  return !1;
              } catch {
                return !1;
              }
              const H = new URL(U, L);
              return L.origin === H.origin;
            }, PDFWorkerUtil.createCDNWrapper = function(P) {
              const U = `importScripts("${P}");`;
              return URL.createObjectURL(new Blob([U]));
            };
          }
          const _PDFWorker = class _PDFWorker {
            constructor({
              name: P = null,
              port: U = null,
              verbosity: L = (0, _util.getVerbosityLevel)()
            } = {}) {
              var H;
              if (this.name = P, this.destroyed = !1, this.verbosity = L, this._readyCapability = new _util.PromiseCapability(), this._port = null, this._webWorker = null, this._messageHandler = null, U) {
                if ((H = G(_PDFWorker, _)) != null && H.has(U))
                  throw new Error("Cannot use more than one PDFWorker per port.");
                (G(_PDFWorker, _) || Ie(_PDFWorker, _, /* @__PURE__ */ new WeakMap())).set(U, this), this._initializeFromPort(U);
                return;
              }
              this._initialize();
            }
            get promise() {
              return this._readyCapability.promise;
            }
            get port() {
              return this._port;
            }
            get messageHandler() {
              return this._messageHandler;
            }
            _initializeFromPort(P) {
              this._port = P, this._messageHandler = new _message_handler.MessageHandler("main", "worker", P), this._messageHandler.on("ready", function() {
              }), this._readyCapability.resolve(), this._messageHandler.send("configure", {
                verbosity: this.verbosity
              });
            }
            _initialize() {
              if (!PDFWorkerUtil.isWorkerDisabled && !_PDFWorker._mainThreadWorkerMessageHandler) {
                let {
                  workerSrc: P
                } = _PDFWorker;
                try {
                  PDFWorkerUtil.isSameOrigin(window.location.href, P) || (P = PDFWorkerUtil.createCDNWrapper(new URL(P, window.location).href));
                  const U = new Worker(P), L = new _message_handler.MessageHandler("main", "worker", U), H = () => {
                    U.removeEventListener("error", B), L.destroy(), U.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
                  }, B = () => {
                    this._webWorker || H();
                  };
                  U.addEventListener("error", B), L.on("test", (X) => {
                    if (U.removeEventListener("error", B), this.destroyed) {
                      H();
                      return;
                    }
                    X ? (this._messageHandler = L, this._port = U, this._webWorker = U, this._readyCapability.resolve(), L.send("configure", {
                      verbosity: this.verbosity
                    })) : (this._setupFakeWorker(), L.destroy(), U.terminate());
                  }), L.on("ready", (X) => {
                    if (U.removeEventListener("error", B), this.destroyed) {
                      H();
                      return;
                    }
                    try {
                      V();
                    } catch {
                      this._setupFakeWorker();
                    }
                  });
                  const V = () => {
                    const X = new Uint8Array();
                    L.send("test", X, [X.buffer]);
                  };
                  V();
                  return;
                } catch {
                  (0, _util.info)("The worker has been disabled.");
                }
              }
              this._setupFakeWorker();
            }
            _setupFakeWorker() {
              PDFWorkerUtil.isWorkerDisabled || ((0, _util.warn)("Setting up fake worker."), PDFWorkerUtil.isWorkerDisabled = !0), _PDFWorker._setupFakeWorkerGlobal.then((P) => {
                if (this.destroyed) {
                  this._readyCapability.reject(new Error("Worker was destroyed"));
                  return;
                }
                const U = new LoopbackPort();
                this._port = U;
                const L = `fake${PDFWorkerUtil.fakeWorkerId++}`, H = new _message_handler.MessageHandler(L + "_worker", L, U);
                P.setup(H, U);
                const B = new _message_handler.MessageHandler(L, L + "_worker", U);
                this._messageHandler = B, this._readyCapability.resolve(), B.send("configure", {
                  verbosity: this.verbosity
                });
              }).catch((P) => {
                this._readyCapability.reject(new Error(`Setting up fake worker failed: "${P.message}".`));
              });
            }
            destroy() {
              var P;
              this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), (P = G(_PDFWorker, _)) == null || P.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
            }
            static fromPort(P) {
              var L;
              if (!(P != null && P.port))
                throw new Error("PDFWorker.fromPort - invalid method signature.");
              const U = (L = G(this, _)) == null ? void 0 : L.get(P.port);
              if (U) {
                if (U._pendingDestroy)
                  throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
                return U;
              }
              return new _PDFWorker(P);
            }
            static get workerSrc() {
              if (_worker_options.GlobalWorkerOptions.workerSrc)
                return _worker_options.GlobalWorkerOptions.workerSrc;
              if (PDFWorkerUtil.fallbackWorkerSrc !== null)
                return _util.isNodeJS || (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.'), PDFWorkerUtil.fallbackWorkerSrc;
              throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
            }
            static get _mainThreadWorkerMessageHandler() {
              var P;
              try {
                return ((P = globalThis.pdfjsWorker) == null ? void 0 : P.WorkerMessageHandler) || null;
              } catch {
                return null;
              }
            }
            static get _setupFakeWorkerGlobal() {
              const loader = async () => {
                const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;
                if (mainWorkerMessageHandler)
                  return mainWorkerMessageHandler;
                if (_util.isNodeJS && typeof commonjsRequire == "function") {
                  const worker = eval("require")(this.workerSrc);
                  return worker.WorkerMessageHandler;
                }
                return await (0, _display_utils.loadScript)(this.workerSrc), window.pdfjsWorker.WorkerMessageHandler;
              };
              return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
            }
          };
          _ = new WeakMap(), we(_PDFWorker, _);
          let PDFWorker = _PDFWorker;
          exports.PDFWorker = PDFWorker;
          class WorkerTransport {
            constructor(U, L, H, B, V) {
              we(this, C);
              we(this, y, /* @__PURE__ */ new Map());
              we(this, A, /* @__PURE__ */ new Map());
              we(this, E, /* @__PURE__ */ new Map());
              we(this, v, null);
              this.messageHandler = U, this.loadingTask = L, this.commonObjs = new PDFObjects(), this.fontLoader = new _font_loader.FontLoader({
                ownerDocument: B.ownerDocument,
                styleElement: B.styleElement
              }), this._params = B, this.canvasFactory = V.canvasFactory, this.filterFactory = V.filterFactory, this.cMapReaderFactory = V.cMapReaderFactory, this.standardFontDataFactory = V.standardFontDataFactory, this.destroyed = !1, this.destroyCapability = null, this._networkStream = H, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = new _util.PromiseCapability(), this.setupMessageHandler();
            }
            get annotationStorage() {
              return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
            }
            getRenderingIntent(U, L = _util.AnnotationMode.ENABLE, H = null, B = !1) {
              let V = _util.RenderingIntentFlag.DISPLAY, X = _annotation_storage.SerializableEmpty;
              switch (U) {
                case "any":
                  V = _util.RenderingIntentFlag.ANY;
                  break;
                case "display":
                  break;
                case "print":
                  V = _util.RenderingIntentFlag.PRINT;
                  break;
                default:
                  (0, _util.warn)(`getRenderingIntent - invalid intent: ${U}`);
              }
              switch (L) {
                case _util.AnnotationMode.DISABLE:
                  V += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                  break;
                case _util.AnnotationMode.ENABLE:
                  break;
                case _util.AnnotationMode.ENABLE_FORMS:
                  V += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                  break;
                case _util.AnnotationMode.ENABLE_STORAGE:
                  V += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE, X = (V & _util.RenderingIntentFlag.PRINT && H instanceof _annotation_storage.PrintAnnotationStorage ? H : this.annotationStorage).serializable;
                  break;
                default:
                  (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${L}`);
              }
              return B && (V += _util.RenderingIntentFlag.OPLIST), {
                renderingIntent: V,
                cacheKey: `${V}_${X.hash}`,
                annotationStorageSerializable: X
              };
            }
            destroy() {
              var H;
              if (this.destroyCapability)
                return this.destroyCapability.promise;
              this.destroyed = !0, this.destroyCapability = new _util.PromiseCapability(), (H = G(this, v)) == null || H.reject(new Error("Worker was destroyed during onPassword callback"));
              const U = [];
              for (const B of G(this, A).values())
                U.push(B._destroy());
              G(this, A).clear(), G(this, E).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
              const L = this.messageHandler.sendWithPromise("Terminate", null);
              return U.push(L), Promise.all(U).then(() => {
                var B;
                this.commonObjs.clear(), this.fontLoader.clear(), G(this, y).clear(), this.filterFactory.destroy(), (B = this._networkStream) == null || B.cancelAllRequests(new _util.AbortException("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
              }, this.destroyCapability.reject), this.destroyCapability.promise;
            }
            setupMessageHandler() {
              const {
                messageHandler: U,
                loadingTask: L
              } = this;
              U.on("GetReader", (H, B) => {
                (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (V) => {
                  this._lastProgress = {
                    loaded: V.loaded,
                    total: V.total
                  };
                }, B.onPull = () => {
                  this._fullReader.read().then(function({
                    value: V,
                    done: X
                  }) {
                    if (X) {
                      B.close();
                      return;
                    }
                    (0, _util.assert)(V instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), B.enqueue(new Uint8Array(V), 1, [V]);
                  }).catch((V) => {
                    B.error(V);
                  });
                }, B.onCancel = (V) => {
                  this._fullReader.cancel(V), B.ready.catch((X) => {
                    if (!this.destroyed)
                      throw X;
                  });
                };
              }), U.on("ReaderHeadersReady", (H) => {
                const B = new _util.PromiseCapability(), V = this._fullReader;
                return V.headersReady.then(() => {
                  var X;
                  (!V.isStreamingSupported || !V.isRangeSupported) && (this._lastProgress && ((X = L.onProgress) == null || X.call(L, this._lastProgress)), V.onProgress = (de) => {
                    var Y;
                    (Y = L.onProgress) == null || Y.call(L, {
                      loaded: de.loaded,
                      total: de.total
                    });
                  }), B.resolve({
                    isStreamingSupported: V.isStreamingSupported,
                    isRangeSupported: V.isRangeSupported,
                    contentLength: V.contentLength
                  });
                }, B.reject), B.promise;
              }), U.on("GetRangeReader", (H, B) => {
                (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                const V = this._networkStream.getRangeReader(H.begin, H.end);
                if (!V) {
                  B.close();
                  return;
                }
                B.onPull = () => {
                  V.read().then(function({
                    value: X,
                    done: de
                  }) {
                    if (de) {
                      B.close();
                      return;
                    }
                    (0, _util.assert)(X instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), B.enqueue(new Uint8Array(X), 1, [X]);
                  }).catch((X) => {
                    B.error(X);
                  });
                }, B.onCancel = (X) => {
                  V.cancel(X), B.ready.catch((de) => {
                    if (!this.destroyed)
                      throw de;
                  });
                };
              }), U.on("GetDoc", ({
                pdfInfo: H
              }) => {
                this._numPages = H.numPages, this._htmlForXfa = H.htmlForXfa, delete H.htmlForXfa, L._capability.resolve(new PDFDocumentProxy(H, this));
              }), U.on("DocException", function(H) {
                let B;
                switch (H.name) {
                  case "PasswordException":
                    B = new _util.PasswordException(H.message, H.code);
                    break;
                  case "InvalidPDFException":
                    B = new _util.InvalidPDFException(H.message);
                    break;
                  case "MissingPDFException":
                    B = new _util.MissingPDFException(H.message);
                    break;
                  case "UnexpectedResponseException":
                    B = new _util.UnexpectedResponseException(H.message, H.status);
                    break;
                  case "UnknownErrorException":
                    B = new _util.UnknownErrorException(H.message, H.details);
                    break;
                  default:
                    (0, _util.unreachable)("DocException - expected a valid Error.");
                }
                L._capability.reject(B);
              }), U.on("PasswordRequest", (H) => {
                if (Ie(this, v, new _util.PromiseCapability()), L.onPassword) {
                  const B = (V) => {
                    V instanceof Error ? G(this, v).reject(V) : G(this, v).resolve({
                      password: V
                    });
                  };
                  try {
                    L.onPassword(B, H.code);
                  } catch (V) {
                    G(this, v).reject(V);
                  }
                } else
                  G(this, v).reject(new _util.PasswordException(H.message, H.code));
                return G(this, v).promise;
              }), U.on("DataLoaded", (H) => {
                var B;
                (B = L.onProgress) == null || B.call(L, {
                  loaded: H.length,
                  total: H.length
                }), this.downloadInfoCapability.resolve(H);
              }), U.on("StartRenderPage", (H) => {
                if (this.destroyed)
                  return;
                G(this, A).get(H.pageIndex)._startRenderPage(H.transparency, H.cacheKey);
              }), U.on("commonobj", ([H, B, V]) => {
                var X;
                if (!this.destroyed && !this.commonObjs.has(H))
                  switch (B) {
                    case "Font":
                      const de = this._params;
                      if ("error" in V) {
                        const ue = V.error;
                        (0, _util.warn)(`Error during font loading: ${ue}`), this.commonObjs.resolve(H, ue);
                        break;
                      }
                      const Y = de.pdfBug && ((X = globalThis.FontInspector) != null && X.enabled) ? (ue, pe) => globalThis.FontInspector.fontAdded(ue, pe) : null, se = new _font_loader.FontFaceObject(V, {
                        isEvalSupported: de.isEvalSupported,
                        disableFontFace: de.disableFontFace,
                        ignoreErrors: de.ignoreErrors,
                        inspectFont: Y
                      });
                      this.fontLoader.bind(se).catch((ue) => U.sendWithPromise("FontFallback", {
                        id: H
                      })).finally(() => {
                        !de.fontExtraProperties && se.data && (se.data = null), this.commonObjs.resolve(H, se);
                      });
                      break;
                    case "FontPath":
                    case "Image":
                    case "Pattern":
                      this.commonObjs.resolve(H, V);
                      break;
                    default:
                      throw new Error(`Got unknown common object type ${B}`);
                  }
              }), U.on("obj", ([H, B, V, X]) => {
                var Y;
                if (this.destroyed)
                  return;
                const de = G(this, A).get(B);
                if (!de.objs.has(H))
                  switch (V) {
                    case "Image":
                      if (de.objs.resolve(H, X), X) {
                        let se;
                        if (X.bitmap) {
                          const {
                            width: ue,
                            height: pe
                          } = X;
                          se = ue * pe * 4;
                        } else
                          se = ((Y = X.data) == null ? void 0 : Y.length) || 0;
                        se > _util.MAX_IMAGE_SIZE_TO_CACHE && (de._maybeCleanupAfterRender = !0);
                      }
                      break;
                    case "Pattern":
                      de.objs.resolve(H, X);
                      break;
                    default:
                      throw new Error(`Got unknown object type ${V}`);
                  }
              }), U.on("DocProgress", (H) => {
                var B;
                this.destroyed || (B = L.onProgress) == null || B.call(L, {
                  loaded: H.loaded,
                  total: H.total
                });
              }), U.on("FetchBuiltInCMap", (H) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.cMapReaderFactory ? this.cMapReaderFactory.fetch(H) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."))), U.on("FetchStandardFontData", (H) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.standardFontDataFactory ? this.standardFontDataFactory.fetch(H) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")));
            }
            getData() {
              return this.messageHandler.sendWithPromise("GetData", null);
            }
            saveDocument() {
              var H;
              this.annotationStorage.size <= 0 && (0, _util.warn)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
              const {
                map: U,
                transfers: L
              } = this.annotationStorage.serializable;
              return this.messageHandler.sendWithPromise("SaveDocument", {
                isPureXfa: !!this._htmlForXfa,
                numPages: this._numPages,
                annotationStorage: U,
                filename: ((H = this._fullReader) == null ? void 0 : H.filename) ?? null
              }, L).finally(() => {
                this.annotationStorage.resetModified();
              });
            }
            getPage(U) {
              if (!Number.isInteger(U) || U <= 0 || U > this._numPages)
                return Promise.reject(new Error("Invalid page request."));
              const L = U - 1, H = G(this, E).get(L);
              if (H)
                return H;
              const B = this.messageHandler.sendWithPromise("GetPage", {
                pageIndex: L
              }).then((V) => {
                if (this.destroyed)
                  throw new Error("Transport destroyed");
                const X = new PDFPageProxy(L, V, this, this._params.pdfBug);
                return G(this, A).set(L, X), X;
              });
              return G(this, E).set(L, B), B;
            }
            getPageIndex(U) {
              return typeof U != "object" || U === null || !Number.isInteger(U.num) || U.num < 0 || !Number.isInteger(U.gen) || U.gen < 0 ? Promise.reject(new Error("Invalid pageIndex request.")) : this.messageHandler.sendWithPromise("GetPageIndex", {
                num: U.num,
                gen: U.gen
              });
            }
            getAnnotations(U, L) {
              return this.messageHandler.sendWithPromise("GetAnnotations", {
                pageIndex: U,
                intent: L
              });
            }
            getFieldObjects() {
              return _e(this, C, zt).call(this, "GetFieldObjects");
            }
            hasJSActions() {
              return _e(this, C, zt).call(this, "HasJSActions");
            }
            getCalculationOrderIds() {
              return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
            }
            getDestinations() {
              return this.messageHandler.sendWithPromise("GetDestinations", null);
            }
            getDestination(U) {
              return typeof U != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
                id: U
              });
            }
            getPageLabels() {
              return this.messageHandler.sendWithPromise("GetPageLabels", null);
            }
            getPageLayout() {
              return this.messageHandler.sendWithPromise("GetPageLayout", null);
            }
            getPageMode() {
              return this.messageHandler.sendWithPromise("GetPageMode", null);
            }
            getViewerPreferences() {
              return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
            }
            getOpenAction() {
              return this.messageHandler.sendWithPromise("GetOpenAction", null);
            }
            getAttachments() {
              return this.messageHandler.sendWithPromise("GetAttachments", null);
            }
            getDocJSActions() {
              return _e(this, C, zt).call(this, "GetDocJSActions");
            }
            getPageJSActions(U) {
              return this.messageHandler.sendWithPromise("GetPageJSActions", {
                pageIndex: U
              });
            }
            getStructTree(U) {
              return this.messageHandler.sendWithPromise("GetStructTree", {
                pageIndex: U
              });
            }
            getOutline() {
              return this.messageHandler.sendWithPromise("GetOutline", null);
            }
            getOptionalContentConfig() {
              return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((U) => new _optional_content_config.OptionalContentConfig(U));
            }
            getPermissions() {
              return this.messageHandler.sendWithPromise("GetPermissions", null);
            }
            getMetadata() {
              const U = "GetMetadata", L = G(this, y).get(U);
              if (L)
                return L;
              const H = this.messageHandler.sendWithPromise(U, null).then((B) => {
                var V, X;
                return {
                  info: B[0],
                  metadata: B[1] ? new _metadata.Metadata(B[1]) : null,
                  contentDispositionFilename: ((V = this._fullReader) == null ? void 0 : V.filename) ?? null,
                  contentLength: ((X = this._fullReader) == null ? void 0 : X.contentLength) ?? null
                };
              });
              return G(this, y).set(U, H), H;
            }
            getMarkInfo() {
              return this.messageHandler.sendWithPromise("GetMarkInfo", null);
            }
            async startCleanup(U = !1) {
              if (!this.destroyed) {
                await this.messageHandler.sendWithPromise("Cleanup", null);
                for (const L of G(this, A).values())
                  if (!L.cleanup())
                    throw new Error(`startCleanup: Page ${L.pageNumber} is currently rendering.`);
                this.commonObjs.clear(), U || this.fontLoader.clear(), G(this, y).clear(), this.filterFactory.destroy(!0);
              }
            }
            get loadingParams() {
              const {
                disableAutoFetch: U,
                enableXfa: L
              } = this._params;
              return (0, _util.shadow)(this, "loadingParams", {
                disableAutoFetch: U,
                enableXfa: L
              });
            }
          }
          y = new WeakMap(), A = new WeakMap(), E = new WeakMap(), v = new WeakMap(), C = new WeakSet(), zt = function(U, L = null) {
            const H = G(this, y).get(U);
            if (H)
              return H;
            const B = this.messageHandler.sendWithPromise(U, L);
            return G(this, y).set(U, B), B;
          };
          class PDFObjects {
            constructor() {
              we(this, w);
              we(this, I, /* @__PURE__ */ Object.create(null));
            }
            get(U, L = null) {
              if (L) {
                const B = _e(this, w, an).call(this, U);
                return B.capability.promise.then(() => L(B.data)), null;
              }
              const H = G(this, I)[U];
              if (!(H != null && H.capability.settled))
                throw new Error(`Requesting object that isn't resolved yet ${U}.`);
              return H.data;
            }
            has(U) {
              const L = G(this, I)[U];
              return (L == null ? void 0 : L.capability.settled) || !1;
            }
            resolve(U, L = null) {
              const H = _e(this, w, an).call(this, U);
              H.data = L, H.capability.resolve();
            }
            clear() {
              var U;
              for (const L in G(this, I)) {
                const {
                  data: H
                } = G(this, I)[L];
                (U = H == null ? void 0 : H.bitmap) == null || U.close();
              }
              Ie(this, I, /* @__PURE__ */ Object.create(null));
            }
          }
          I = new WeakMap(), w = new WeakSet(), an = function(U) {
            var L;
            return (L = G(this, I))[U] || (L[U] = {
              capability: new _util.PromiseCapability(),
              data: null
            });
          };
          class RenderTask {
            constructor(U) {
              we(this, F, null);
              Ie(this, F, U), this.onContinue = null;
            }
            get promise() {
              return G(this, F).capability.promise;
            }
            cancel(U = 0) {
              G(this, F).cancel(null, U);
            }
            get separateAnnots() {
              const {
                separateAnnots: U
              } = G(this, F).operatorList;
              if (!U)
                return !1;
              const {
                annotationCanvasMap: L
              } = G(this, F);
              return U.form || U.canvas && (L == null ? void 0 : L.size) > 0;
            }
          }
          F = new WeakMap(), exports.RenderTask = RenderTask;
          const x = class x {
            constructor({
              callback: U,
              params: L,
              objs: H,
              commonObjs: B,
              annotationCanvasMap: V,
              operatorList: X,
              pageIndex: de,
              canvasFactory: Y,
              filterFactory: se,
              useRequestAnimationFrame: ue = !1,
              pdfBug: pe = !1,
              pageColors: J = null
            }) {
              this.callback = U, this.params = L, this.objs = H, this.commonObjs = B, this.annotationCanvasMap = V, this.operatorListIdx = null, this.operatorList = X, this._pageIndex = de, this.canvasFactory = Y, this.filterFactory = se, this._pdfBug = pe, this.pageColors = J, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = ue === !0 && typeof window < "u", this.cancelled = !1, this.capability = new _util.PromiseCapability(), this.task = new RenderTask(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = L.canvasContext.canvas;
            }
            get completed() {
              return this.capability.promise.catch(function() {
              });
            }
            initializeGraphics({
              transparency: U = !1,
              optionalContentConfig: L
            }) {
              var de, Y;
              if (this.cancelled)
                return;
              if (this._canvas) {
                if (G(x, M).has(this._canvas))
                  throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                G(x, M).add(this._canvas);
              }
              this._pdfBug && ((de = globalThis.StepperManager) != null && de.enabled) && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
              const {
                canvasContext: H,
                viewport: B,
                transform: V,
                background: X
              } = this.params;
              this.gfx = new _canvas.CanvasGraphics(H, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                optionalContentConfig: L
              }, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({
                transform: V,
                viewport: B,
                transparency: U,
                background: X
              }), this.operatorListIdx = 0, this.graphicsReady = !0, (Y = this.graphicsReadyCallback) == null || Y.call(this);
            }
            cancel(U = null, L = 0) {
              var H;
              this.running = !1, this.cancelled = !0, (H = this.gfx) == null || H.endDrawing(), G(x, M).delete(this._canvas), this.callback(U || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, L));
            }
            operatorListChanged() {
              var U;
              if (!this.graphicsReady) {
                this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
                return;
              }
              (U = this.stepper) == null || U.updateOperatorList(this.operatorList), !this.running && this._continue();
            }
            _continue() {
              this.running = !0, !this.cancelled && (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
            }
            _scheduleNext() {
              this._useRequestAnimationFrame ? window.requestAnimationFrame(() => {
                this._nextBound().catch(this._cancelBound);
              }) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
            }
            async _next() {
              this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), G(x, M).delete(this._canvas), this.callback())));
            }
          };
          M = new WeakMap(), we(x, M, /* @__PURE__ */ new WeakSet());
          let InternalRenderTask = x;
          const version = "3.11.174";
          exports.version = version;
          const build = "ce8716743";
          exports.build = build;
        },
        /* 3 */
        /***/
        (e, t, r) => {
          var b, _, y, Gn, E;
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.SerializableEmpty = t.PrintAnnotationStorage = t.AnnotationStorage = void 0;
          var a = r(1), o = r(4), u = r(8);
          const c = Object.freeze({
            map: null,
            hash: "",
            transfers: void 0
          });
          t.SerializableEmpty = c;
          class d {
            constructor() {
              we(this, y);
              we(this, b, !1);
              we(this, _, /* @__PURE__ */ new Map());
              this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
            }
            getValue(C, R) {
              const I = G(this, _).get(C);
              return I === void 0 ? R : Object.assign(R, I);
            }
            getRawValue(C) {
              return G(this, _).get(C);
            }
            remove(C) {
              if (G(this, _).delete(C), G(this, _).size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
                for (const R of G(this, _).values())
                  if (R instanceof o.AnnotationEditor)
                    return;
                this.onAnnotationEditor(null);
              }
            }
            setValue(C, R) {
              const I = G(this, _).get(C);
              let w = !1;
              if (I !== void 0)
                for (const [N, F] of Object.entries(R))
                  I[N] !== F && (w = !0, I[N] = F);
              else
                w = !0, G(this, _).set(C, R);
              w && _e(this, y, Gn).call(this), R instanceof o.AnnotationEditor && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(R.constructor._type);
            }
            has(C) {
              return G(this, _).has(C);
            }
            getAll() {
              return G(this, _).size > 0 ? (0, a.objectFromMap)(G(this, _)) : null;
            }
            setAll(C) {
              for (const [R, I] of Object.entries(C))
                this.setValue(R, I);
            }
            get size() {
              return G(this, _).size;
            }
            resetModified() {
              G(this, b) && (Ie(this, b, !1), typeof this.onResetModified == "function" && this.onResetModified());
            }
            get print() {
              return new g(this);
            }
            get serializable() {
              if (G(this, _).size === 0)
                return c;
              const C = /* @__PURE__ */ new Map(), R = new u.MurmurHash3_64(), I = [], w = /* @__PURE__ */ Object.create(null);
              let N = !1;
              for (const [F, M] of G(this, _)) {
                const x = M instanceof o.AnnotationEditor ? M.serialize(!1, w) : M;
                x && (C.set(F, x), R.update(`${F}:${JSON.stringify(x)}`), N || (N = !!x.bitmap));
              }
              if (N)
                for (const F of C.values())
                  F.bitmap && I.push(F.bitmap);
              return C.size > 0 ? {
                map: C,
                hash: R.hexdigest(),
                transfers: I
              } : c;
            }
          }
          b = new WeakMap(), _ = new WeakMap(), y = new WeakSet(), Gn = function() {
            G(this, b) || (Ie(this, b, !0), typeof this.onSetModified == "function" && this.onSetModified());
          }, t.AnnotationStorage = d;
          class g extends d {
            constructor(R) {
              super();
              we(this, E);
              const {
                map: I,
                hash: w,
                transfers: N
              } = R.serializable, F = structuredClone(I, N ? {
                transfer: N
              } : null);
              Ie(this, E, {
                map: F,
                hash: w,
                transfers: N
              });
            }
            get print() {
              (0, a.unreachable)("Should not call PrintAnnotationStorage.print");
            }
            get serializable() {
              return G(this, E);
            }
          }
          E = new WeakMap(), t.PrintAnnotationStorage = g;
        },
        /* 4 */
        /***/
        (e, t, r) => {
          var g, b, _, y, A, E, v, C, R, I, w, N, F, M, x, on, sn, L, ln, un, Hn, zn, jn, cn, Vn;
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.AnnotationEditor = void 0;
          var a = r(5), o = r(1), u = r(6);
          const ue = class ue {
            constructor(J) {
              we(this, x);
              we(this, g, "");
              we(this, b, !1);
              we(this, _, null);
              we(this, y, null);
              we(this, A, null);
              we(this, E, !1);
              we(this, v, null);
              we(this, C, this.focusin.bind(this));
              we(this, R, this.focusout.bind(this));
              we(this, I, !1);
              we(this, w, !1);
              we(this, N, !1);
              ft(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
              ft(this, "_uiManager", null);
              ft(this, "_focusEventsAllowed", !0);
              ft(this, "_l10nPromise", null);
              we(this, F, !1);
              we(this, M, ue._zIndex++);
              this.constructor === ue && (0, o.unreachable)("Cannot initialize AnnotationEditor."), this.parent = J.parent, this.id = J.id, this.width = this.height = null, this.pageIndex = J.parent.pageIndex, this.name = J.name, this.div = null, this._uiManager = J.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = !1, this._initialOptions.isCentered = J.isCentered, this._structTreeParentId = null;
              const {
                rotation: j,
                rawDims: {
                  pageWidth: le,
                  pageHeight: Z,
                  pageX: O,
                  pageY: z
                }
              } = this.parent.viewport;
              this.rotation = j, this.pageRotation = (360 + j - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [le, Z], this.pageTranslation = [O, z];
              const [W, ee] = this.parentDimensions;
              this.x = J.x / W, this.y = J.y / ee, this.isAttachedToDOM = !1, this.deleted = !1;
            }
            get editorType() {
              return Object.getPrototypeOf(this).constructor._type;
            }
            static get _defaultLineColor() {
              return (0, o.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
            }
            static deleteAnnotationElement(J) {
              const j = new d({
                id: J.parent.getNextId(),
                parent: J.parent,
                uiManager: J._uiManager
              });
              j.annotationElementId = J.annotationElementId, j.deleted = !0, j._uiManager.addToAnnotationStorage(j);
            }
            static initialize(J, j = null) {
              if (ue._l10nPromise || (ue._l10nPromise = new Map(["editor_alt_text_button_label", "editor_alt_text_edit_button_label", "editor_alt_text_decorative_tooltip"].map((Z) => [Z, J.get(Z)]))), j != null && j.strings)
                for (const Z of j.strings)
                  ue._l10nPromise.set(Z, J.get(Z));
              if (ue._borderLineWidth !== -1)
                return;
              const le = getComputedStyle(document.documentElement);
              ue._borderLineWidth = parseFloat(le.getPropertyValue("--outline-width")) || 0;
            }
            static updateDefaultParams(J, j) {
            }
            static get defaultPropertiesToUpdate() {
              return [];
            }
            static isHandlingMimeForPasting(J) {
              return !1;
            }
            static paste(J, j) {
              (0, o.unreachable)("Not implemented");
            }
            get propertiesToUpdate() {
              return [];
            }
            get _isDraggable() {
              return G(this, F);
            }
            set _isDraggable(J) {
              var j;
              Ie(this, F, J), (j = this.div) == null || j.classList.toggle("draggable", J);
            }
            center() {
              const [J, j] = this.pageDimensions;
              switch (this.parentRotation) {
                case 90:
                  this.x -= this.height * j / (J * 2), this.y += this.width * J / (j * 2);
                  break;
                case 180:
                  this.x += this.width / 2, this.y += this.height / 2;
                  break;
                case 270:
                  this.x += this.height * j / (J * 2), this.y -= this.width * J / (j * 2);
                  break;
                default:
                  this.x -= this.width / 2, this.y -= this.height / 2;
                  break;
              }
              this.fixAndSetPosition();
            }
            addCommands(J) {
              this._uiManager.addCommands(J);
            }
            get currentLayer() {
              return this._uiManager.currentLayer;
            }
            setInBackground() {
              this.div.style.zIndex = 0;
            }
            setInForeground() {
              this.div.style.zIndex = G(this, M);
            }
            setParent(J) {
              J !== null && (this.pageIndex = J.pageIndex, this.pageDimensions = J.pageDimensions), this.parent = J;
            }
            focusin(J) {
              this._focusEventsAllowed && (G(this, I) ? Ie(this, I, !1) : this.parent.setSelected(this));
            }
            focusout(J) {
              var le;
              if (!this._focusEventsAllowed || !this.isAttachedToDOM)
                return;
              const j = J.relatedTarget;
              j != null && j.closest(`#${this.id}`) || (J.preventDefault(), (le = this.parent) != null && le.isMultipleSelection || this.commitOrRemove());
            }
            commitOrRemove() {
              this.isEmpty() ? this.remove() : this.commit();
            }
            commit() {
              this.addToAnnotationStorage();
            }
            addToAnnotationStorage() {
              this._uiManager.addToAnnotationStorage(this);
            }
            setAt(J, j, le, Z) {
              const [O, z] = this.parentDimensions;
              [le, Z] = this.screenToPageTranslation(le, Z), this.x = (J + le) / O, this.y = (j + Z) / z, this.fixAndSetPosition();
            }
            translate(J, j) {
              _e(this, x, on).call(this, this.parentDimensions, J, j);
            }
            translateInPage(J, j) {
              _e(this, x, on).call(this, this.pageDimensions, J, j), this.div.scrollIntoView({
                block: "nearest"
              });
            }
            drag(J, j) {
              const [le, Z] = this.parentDimensions;
              if (this.x += J / le, this.y += j / Z, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
                const {
                  x: ae,
                  y: ie
                } = this.div.getBoundingClientRect();
                this.parent.findNewParent(this, ae, ie) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
              }
              let {
                x: O,
                y: z
              } = this;
              const [W, ee] = _e(this, x, sn).call(this);
              O += W, z += ee, this.div.style.left = `${(100 * O).toFixed(2)}%`, this.div.style.top = `${(100 * z).toFixed(2)}%`, this.div.scrollIntoView({
                block: "nearest"
              });
            }
            fixAndSetPosition() {
              const [J, j] = this.pageDimensions;
              let {
                x: le,
                y: Z,
                width: O,
                height: z
              } = this;
              switch (O *= J, z *= j, le *= J, Z *= j, this.rotation) {
                case 0:
                  le = Math.max(0, Math.min(J - O, le)), Z = Math.max(0, Math.min(j - z, Z));
                  break;
                case 90:
                  le = Math.max(0, Math.min(J - z, le)), Z = Math.min(j, Math.max(O, Z));
                  break;
                case 180:
                  le = Math.min(J, Math.max(O, le)), Z = Math.min(j, Math.max(z, Z));
                  break;
                case 270:
                  le = Math.min(J, Math.max(z, le)), Z = Math.max(0, Math.min(j - O, Z));
                  break;
              }
              this.x = le /= J, this.y = Z /= j;
              const [W, ee] = _e(this, x, sn).call(this);
              le += W, Z += ee;
              const {
                style: ae
              } = this.div;
              ae.left = `${(100 * le).toFixed(2)}%`, ae.top = `${(100 * Z).toFixed(2)}%`, this.moveInDOM();
            }
            screenToPageTranslation(J, j) {
              var le;
              return _e(le = ue, L, ln).call(le, J, j, this.parentRotation);
            }
            pageTranslationToScreen(J, j) {
              var le;
              return _e(le = ue, L, ln).call(le, J, j, 360 - this.parentRotation);
            }
            get parentScale() {
              return this._uiManager.viewParameters.realScale;
            }
            get parentRotation() {
              return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
            }
            get parentDimensions() {
              const {
                parentScale: J,
                pageDimensions: [j, le]
              } = this, Z = j * J, O = le * J;
              return o.FeatureTest.isCSSRoundSupported ? [Math.round(Z), Math.round(O)] : [Z, O];
            }
            setDims(J, j) {
              var O;
              const [le, Z] = this.parentDimensions;
              this.div.style.width = `${(100 * J / le).toFixed(2)}%`, G(this, E) || (this.div.style.height = `${(100 * j / Z).toFixed(2)}%`), (O = G(this, _)) == null || O.classList.toggle("small", J < ue.SMALL_EDITOR_SIZE || j < ue.SMALL_EDITOR_SIZE);
            }
            fixDims() {
              const {
                style: J
              } = this.div, {
                height: j,
                width: le
              } = J, Z = le.endsWith("%"), O = !G(this, E) && j.endsWith("%");
              if (Z && O)
                return;
              const [z, W] = this.parentDimensions;
              Z || (J.width = `${(100 * parseFloat(le) / z).toFixed(2)}%`), !G(this, E) && !O && (J.height = `${(100 * parseFloat(j) / W).toFixed(2)}%`);
            }
            getInitialTranslation() {
              return [0, 0];
            }
            async addAltTextButton() {
              if (G(this, _))
                return;
              const J = Ie(this, _, document.createElement("button"));
              J.className = "altText";
              const j = await ue._l10nPromise.get("editor_alt_text_button_label");
              J.textContent = j, J.setAttribute("aria-label", j), J.tabIndex = "0", J.addEventListener("contextmenu", u.noContextMenu), J.addEventListener("pointerdown", (le) => le.stopPropagation()), J.addEventListener("click", (le) => {
                le.preventDefault(), this._uiManager.editAltText(this);
              }, {
                capture: !0
              }), J.addEventListener("keydown", (le) => {
                le.target === J && le.key === "Enter" && (le.preventDefault(), this._uiManager.editAltText(this));
              }), _e(this, x, cn).call(this), this.div.append(J), ue.SMALL_EDITOR_SIZE || (ue.SMALL_EDITOR_SIZE = Math.min(128, Math.round(J.getBoundingClientRect().width * 1.4)));
            }
            getClientDimensions() {
              return this.div.getBoundingClientRect();
            }
            get altTextData() {
              return {
                altText: G(this, g),
                decorative: G(this, b)
              };
            }
            set altTextData({
              altText: J,
              decorative: j
            }) {
              G(this, g) === J && G(this, b) === j || (Ie(this, g, J), Ie(this, b, j), _e(this, x, cn).call(this));
            }
            render() {
              this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.setAttribute("tabIndex", 0), this.setInForeground(), this.div.addEventListener("focusin", G(this, C)), this.div.addEventListener("focusout", G(this, R));
              const [J, j] = this.parentDimensions;
              this.parentRotation % 180 !== 0 && (this.div.style.maxWidth = `${(100 * j / J).toFixed(2)}%`, this.div.style.maxHeight = `${(100 * J / j).toFixed(2)}%`);
              const [le, Z] = this.getInitialTranslation();
              return this.translate(le, Z), (0, a.bindEvents)(this, this.div, ["pointerdown"]), this.div;
            }
            pointerdown(J) {
              const {
                isMac: j
              } = o.FeatureTest.platform;
              if (J.button !== 0 || J.ctrlKey && j) {
                J.preventDefault();
                return;
              }
              Ie(this, I, !0), _e(this, x, Vn).call(this, J);
            }
            moveInDOM() {
              var J;
              (J = this.parent) == null || J.moveEditorInDOM(this);
            }
            _setParentAndPosition(J, j, le) {
              J.changeParent(this), this.x = j, this.y = le, this.fixAndSetPosition();
            }
            getRect(J, j) {
              const le = this.parentScale, [Z, O] = this.pageDimensions, [z, W] = this.pageTranslation, ee = J / le, ae = j / le, ie = this.x * Z, me = this.y * O, ye = this.width * Z, Re = this.height * O;
              switch (this.rotation) {
                case 0:
                  return [ie + ee + z, O - me - ae - Re + W, ie + ee + ye + z, O - me - ae + W];
                case 90:
                  return [ie + ae + z, O - me + ee + W, ie + ae + Re + z, O - me + ee + ye + W];
                case 180:
                  return [ie - ee - ye + z, O - me + ae + W, ie - ee + z, O - me + ae + Re + W];
                case 270:
                  return [ie - ae - Re + z, O - me - ee - ye + W, ie - ae + z, O - me - ee + W];
                default:
                  throw new Error("Invalid rotation");
              }
            }
            getRectInCurrentCoords(J, j) {
              const [le, Z, O, z] = J, W = O - le, ee = z - Z;
              switch (this.rotation) {
                case 0:
                  return [le, j - z, W, ee];
                case 90:
                  return [le, j - Z, ee, W];
                case 180:
                  return [O, j - Z, W, ee];
                case 270:
                  return [O, j - z, ee, W];
                default:
                  throw new Error("Invalid rotation");
              }
            }
            onceAdded() {
            }
            isEmpty() {
              return !1;
            }
            enableEditMode() {
              Ie(this, N, !0);
            }
            disableEditMode() {
              Ie(this, N, !1);
            }
            isInEditMode() {
              return G(this, N);
            }
            shouldGetKeyboardEvents() {
              return !1;
            }
            needsToBeRebuilt() {
              return this.div && !this.isAttachedToDOM;
            }
            rebuild() {
              var J, j;
              (J = this.div) == null || J.addEventListener("focusin", G(this, C)), (j = this.div) == null || j.addEventListener("focusout", G(this, R));
            }
            serialize(J = !1, j = null) {
              (0, o.unreachable)("An editor must be serializable");
            }
            static deserialize(J, j, le) {
              const Z = new this.prototype.constructor({
                parent: j,
                id: j.getNextId(),
                uiManager: le
              });
              Z.rotation = J.rotation;
              const [O, z] = Z.pageDimensions, [W, ee, ae, ie] = Z.getRectInCurrentCoords(J.rect, z);
              return Z.x = W / O, Z.y = ee / z, Z.width = ae / O, Z.height = ie / z, Z;
            }
            remove() {
              var J;
              this.div.removeEventListener("focusin", G(this, C)), this.div.removeEventListener("focusout", G(this, R)), this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), (J = G(this, _)) == null || J.remove(), Ie(this, _, null), Ie(this, y, null);
            }
            get isResizable() {
              return !1;
            }
            makeResizable() {
              this.isResizable && (_e(this, x, Hn).call(this), G(this, v).classList.remove("hidden"));
            }
            select() {
              var J;
              this.makeResizable(), (J = this.div) == null || J.classList.add("selectedEditor");
            }
            unselect() {
              var J, j, le;
              (J = G(this, v)) == null || J.classList.add("hidden"), (j = this.div) == null || j.classList.remove("selectedEditor"), (le = this.div) != null && le.contains(document.activeElement) && this._uiManager.currentLayer.div.focus();
            }
            updateParams(J, j) {
            }
            disableEditing() {
              G(this, _) && (G(this, _).hidden = !0);
            }
            enableEditing() {
              G(this, _) && (G(this, _).hidden = !1);
            }
            enterInEditMode() {
            }
            get contentDiv() {
              return this.div;
            }
            get isEditing() {
              return G(this, w);
            }
            set isEditing(J) {
              Ie(this, w, J), this.parent && (J ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
            }
            setAspectRatio(J, j) {
              Ie(this, E, !0);
              const le = J / j, {
                style: Z
              } = this.div;
              Z.aspectRatio = le, Z.height = "auto";
            }
            static get MIN_SIZE() {
              return 16;
            }
          };
          g = new WeakMap(), b = new WeakMap(), _ = new WeakMap(), y = new WeakMap(), A = new WeakMap(), E = new WeakMap(), v = new WeakMap(), C = new WeakMap(), R = new WeakMap(), I = new WeakMap(), w = new WeakMap(), N = new WeakMap(), F = new WeakMap(), M = new WeakMap(), x = new WeakSet(), on = function([J, j], le, Z) {
            [le, Z] = this.screenToPageTranslation(le, Z), this.x += le / J, this.y += Z / j, this.fixAndSetPosition();
          }, sn = function() {
            const [J, j] = this.parentDimensions, {
              _borderLineWidth: le
            } = ue, Z = le / J, O = le / j;
            switch (this.rotation) {
              case 90:
                return [-Z, O];
              case 180:
                return [Z, O];
              case 270:
                return [Z, -O];
              default:
                return [-Z, -O];
            }
          }, L = new WeakSet(), ln = function(J, j, le) {
            switch (le) {
              case 90:
                return [j, -J];
              case 180:
                return [-J, -j];
              case 270:
                return [-j, J];
              default:
                return [J, j];
            }
          }, un = function(J) {
            switch (J) {
              case 90: {
                const [j, le] = this.pageDimensions;
                return [0, -j / le, le / j, 0];
              }
              case 180:
                return [-1, 0, 0, -1];
              case 270: {
                const [j, le] = this.pageDimensions;
                return [0, j / le, -le / j, 0];
              }
              default:
                return [1, 0, 0, 1];
            }
          }, Hn = function() {
            if (G(this, v))
              return;
            Ie(this, v, document.createElement("div")), G(this, v).classList.add("resizers");
            const J = ["topLeft", "topRight", "bottomRight", "bottomLeft"];
            this._willKeepAspectRatio || J.push("topMiddle", "middleRight", "bottomMiddle", "middleLeft");
            for (const j of J) {
              const le = document.createElement("div");
              G(this, v).append(le), le.classList.add("resizer", j), le.addEventListener("pointerdown", _e(this, x, zn).bind(this, j)), le.addEventListener("contextmenu", u.noContextMenu);
            }
            this.div.prepend(G(this, v));
          }, zn = function(J, j) {
            j.preventDefault();
            const {
              isMac: le
            } = o.FeatureTest.platform;
            if (j.button !== 0 || j.ctrlKey && le)
              return;
            const Z = _e(this, x, jn).bind(this, J), O = this._isDraggable;
            this._isDraggable = !1;
            const z = {
              passive: !0,
              capture: !0
            };
            window.addEventListener("pointermove", Z, z);
            const W = this.x, ee = this.y, ae = this.width, ie = this.height, me = this.parent.div.style.cursor, ye = this.div.style.cursor;
            this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(j.target).cursor;
            const Re = () => {
              this._isDraggable = O, window.removeEventListener("pointerup", Re), window.removeEventListener("blur", Re), window.removeEventListener("pointermove", Z, z), this.parent.div.style.cursor = me, this.div.style.cursor = ye;
              const De = this.x, Pe = this.y, he = this.width, Le = this.height;
              De === W && Pe === ee && he === ae && Le === ie || this.addCommands({
                cmd: () => {
                  this.width = he, this.height = Le, this.x = De, this.y = Pe;
                  const [Ee, Se] = this.parentDimensions;
                  this.setDims(Ee * he, Se * Le), this.fixAndSetPosition();
                },
                undo: () => {
                  this.width = ae, this.height = ie, this.x = W, this.y = ee;
                  const [Ee, Se] = this.parentDimensions;
                  this.setDims(Ee * ae, Se * ie), this.fixAndSetPosition();
                },
                mustExec: !0
              });
            };
            window.addEventListener("pointerup", Re), window.addEventListener("blur", Re);
          }, jn = function(J, j) {
            const [le, Z] = this.parentDimensions, O = this.x, z = this.y, W = this.width, ee = this.height, ae = ue.MIN_SIZE / le, ie = ue.MIN_SIZE / Z, me = (We) => Math.round(We * 1e4) / 1e4, ye = _e(this, x, un).call(this, this.rotation), Re = (We, Xe) => [ye[0] * We + ye[2] * Xe, ye[1] * We + ye[3] * Xe], De = _e(this, x, un).call(this, 360 - this.rotation), Pe = (We, Xe) => [De[0] * We + De[2] * Xe, De[1] * We + De[3] * Xe];
            let he, Le, Ee = !1, Se = !1;
            switch (J) {
              case "topLeft":
                Ee = !0, he = (We, Xe) => [0, 0], Le = (We, Xe) => [We, Xe];
                break;
              case "topMiddle":
                he = (We, Xe) => [We / 2, 0], Le = (We, Xe) => [We / 2, Xe];
                break;
              case "topRight":
                Ee = !0, he = (We, Xe) => [We, 0], Le = (We, Xe) => [0, Xe];
                break;
              case "middleRight":
                Se = !0, he = (We, Xe) => [We, Xe / 2], Le = (We, Xe) => [0, Xe / 2];
                break;
              case "bottomRight":
                Ee = !0, he = (We, Xe) => [We, Xe], Le = (We, Xe) => [0, 0];
                break;
              case "bottomMiddle":
                he = (We, Xe) => [We / 2, Xe], Le = (We, Xe) => [We / 2, 0];
                break;
              case "bottomLeft":
                Ee = !0, he = (We, Xe) => [0, Xe], Le = (We, Xe) => [We, 0];
                break;
              case "middleLeft":
                Se = !0, he = (We, Xe) => [0, Xe / 2], Le = (We, Xe) => [We, Xe / 2];
                break;
            }
            const Q = he(W, ee), K = Le(W, ee);
            let fe = Re(...K);
            const be = me(O + fe[0]), ke = me(z + fe[1]);
            let Fe = 1, Be = 1, [te, Ce] = this.screenToPageTranslation(j.movementX, j.movementY);
            if ([te, Ce] = Pe(te / le, Ce / Z), Ee) {
              const We = Math.hypot(W, ee);
              Fe = Be = Math.max(Math.min(Math.hypot(K[0] - Q[0] - te, K[1] - Q[1] - Ce) / We, 1 / W, 1 / ee), ae / W, ie / ee);
            } else Se ? Fe = Math.max(ae, Math.min(1, Math.abs(K[0] - Q[0] - te))) / W : Be = Math.max(ie, Math.min(1, Math.abs(K[1] - Q[1] - Ce))) / ee;
            const Me = me(W * Fe), Ve = me(ee * Be);
            fe = Re(...Le(Me, Ve));
            const je = be - fe[0], ot = ke - fe[1];
            this.width = Me, this.height = Ve, this.x = je, this.y = ot, this.setDims(le * Me, Z * Ve), this.fixAndSetPosition();
          }, cn = async function() {
            var le;
            const J = G(this, _);
            if (!J)
              return;
            if (!G(this, g) && !G(this, b)) {
              J.classList.remove("done"), (le = G(this, y)) == null || le.remove();
              return;
            }
            ue._l10nPromise.get("editor_alt_text_edit_button_label").then((Z) => {
              J.setAttribute("aria-label", Z);
            });
            let j = G(this, y);
            if (!j) {
              Ie(this, y, j = document.createElement("span")), j.className = "tooltip", j.setAttribute("role", "tooltip");
              const Z = j.id = `alt-text-tooltip-${this.id}`;
              J.setAttribute("aria-describedby", Z);
              const O = 100;
              J.addEventListener("mouseenter", () => {
                Ie(this, A, setTimeout(() => {
                  Ie(this, A, null), G(this, y).classList.add("show"), this._uiManager._eventBus.dispatch("reporttelemetry", {
                    source: this,
                    details: {
                      type: "editing",
                      subtype: this.editorType,
                      data: {
                        action: "alt_text_tooltip"
                      }
                    }
                  });
                }, O));
              }), J.addEventListener("mouseleave", () => {
                var z;
                clearTimeout(G(this, A)), Ie(this, A, null), (z = G(this, y)) == null || z.classList.remove("show");
              });
            }
            J.classList.add("done"), j.innerText = G(this, b) ? await ue._l10nPromise.get("editor_alt_text_decorative_tooltip") : G(this, g), j.parentNode || J.append(j);
          }, Vn = function(J) {
            if (!this._isDraggable)
              return;
            const j = this._uiManager.isSelected(this);
            this._uiManager.setUpDragSession();
            let le, Z;
            j && (le = {
              passive: !0,
              capture: !0
            }, Z = (z) => {
              const [W, ee] = this.screenToPageTranslation(z.movementX, z.movementY);
              this._uiManager.dragSelectedEditors(W, ee);
            }, window.addEventListener("pointermove", Z, le));
            const O = () => {
              if (window.removeEventListener("pointerup", O), window.removeEventListener("blur", O), j && window.removeEventListener("pointermove", Z, le), Ie(this, I, !1), !this._uiManager.endDragSession()) {
                const {
                  isMac: z
                } = o.FeatureTest.platform;
                J.ctrlKey && !z || J.shiftKey || J.metaKey && z ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
              }
            };
            window.addEventListener("pointerup", O), window.addEventListener("blur", O);
          }, we(ue, L), ft(ue, "_borderLineWidth", -1), ft(ue, "_colorManager", new a.ColorManager()), ft(ue, "_zIndex", 1), ft(ue, "SMALL_EDITOR_SIZE", 0);
          let c = ue;
          t.AnnotationEditor = c;
          class d extends c {
            constructor(J) {
              super(J), this.annotationElementId = J.annotationElementId, this.deleted = !0;
            }
            serialize() {
              return {
                id: this.annotationElementId,
                deleted: !0,
                pageIndex: this.pageIndex
              };
            }
          }
        },
        /* 5 */
        /***/
        (e, t, r) => {
          var E, v, C, R, I, dn, F, M, x, P, U, Wn, B, V, X, de, Y, se, ue, pe, J, j, le, Z, O, z, W, ee, ae, ie, me, ye, Re, De, Pe, he, Le, Ee, Se, Q, K, fe, be, ke, Fe, Be, te, Yn, hn, pn, jt, mn, fn, vt, $t, Xn, Kn, gn, Pt, bn;
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.KeyboardManager = t.CommandManager = t.ColorManager = t.AnnotationEditorUIManager = void 0, t.bindEvents = u, t.opacityToHex = c;
          var a = r(1), o = r(6);
          function u(pt, ce, Ne) {
            for (const Ge of Ne)
              ce.addEventListener(Ge, pt[Ge].bind(pt));
          }
          function c(pt) {
            return Math.round(Math.min(255, Math.max(1, 255 * pt))).toString(16).padStart(2, "0");
          }
          class d {
            constructor() {
              we(this, E, 0);
            }
            getId() {
              return `${a.AnnotationEditorPrefix}${Mt(this, E)._++}`;
            }
          }
          E = new WeakMap();
          const N = class N {
            constructor() {
              we(this, I);
              we(this, v, (0, a.getUuid)());
              we(this, C, 0);
              we(this, R, null);
            }
            static get _isSVGFittingCanvas() {
              const ce = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>', Ge = new OffscreenCanvas(1, 3).getContext("2d"), nt = new Image();
              nt.src = ce;
              const rt = nt.decode().then(() => (Ge.drawImage(nt, 0, 0, 1, 1, 0, 0, 1, 3), new Uint32Array(Ge.getImageData(0, 0, 1, 1).data.buffer)[0] === 0));
              return (0, a.shadow)(this, "_isSVGFittingCanvas", rt);
            }
            async getFromFile(ce) {
              const {
                lastModified: Ne,
                name: Ge,
                size: nt,
                type: rt
              } = ce;
              return _e(this, I, dn).call(this, `${Ne}_${Ge}_${nt}_${rt}`, ce);
            }
            async getFromUrl(ce) {
              return _e(this, I, dn).call(this, ce, ce);
            }
            async getFromId(ce) {
              G(this, R) || Ie(this, R, /* @__PURE__ */ new Map());
              const Ne = G(this, R).get(ce);
              return Ne ? Ne.bitmap ? (Ne.refCounter += 1, Ne) : Ne.file ? this.getFromFile(Ne.file) : this.getFromUrl(Ne.url) : null;
            }
            getSvgUrl(ce) {
              const Ne = G(this, R).get(ce);
              return Ne != null && Ne.isSvg ? Ne.svgUrl : null;
            }
            deleteId(ce) {
              G(this, R) || Ie(this, R, /* @__PURE__ */ new Map());
              const Ne = G(this, R).get(ce);
              Ne && (Ne.refCounter -= 1, Ne.refCounter === 0 && (Ne.bitmap = null));
            }
            isValidId(ce) {
              return ce.startsWith(`image_${G(this, v)}_`);
            }
          };
          v = new WeakMap(), C = new WeakMap(), R = new WeakMap(), I = new WeakSet(), dn = async function(ce, Ne) {
            G(this, R) || Ie(this, R, /* @__PURE__ */ new Map());
            let Ge = G(this, R).get(ce);
            if (Ge === null)
              return null;
            if (Ge != null && Ge.bitmap)
              return Ge.refCounter += 1, Ge;
            try {
              Ge || (Ge = {
                bitmap: null,
                id: `image_${G(this, v)}_${Mt(this, C)._++}`,
                refCounter: 0,
                isSvg: !1
              });
              let nt;
              if (typeof Ne == "string") {
                Ge.url = Ne;
                const rt = await fetch(Ne);
                if (!rt.ok)
                  throw new Error(rt.statusText);
                nt = await rt.blob();
              } else
                nt = Ge.file = Ne;
              if (nt.type === "image/svg+xml") {
                const rt = N._isSVGFittingCanvas, Ye = new FileReader(), oe = new Image(), ne = new Promise((ge, xe) => {
                  oe.onload = () => {
                    Ge.bitmap = oe, Ge.isSvg = !0, ge();
                  }, Ye.onload = async () => {
                    const Oe = Ge.svgUrl = Ye.result;
                    oe.src = await rt ? `${Oe}#svgView(preserveAspectRatio(none))` : Oe;
                  }, oe.onerror = Ye.onerror = xe;
                });
                Ye.readAsDataURL(nt), await ne;
              } else
                Ge.bitmap = await createImageBitmap(nt);
              Ge.refCounter = 1;
            } catch (nt) {
              console.error(nt), Ge = null;
            }
            return G(this, R).set(ce, Ge), Ge && G(this, R).set(Ge.id, Ge), Ge;
          };
          let g = N;
          class b {
            constructor(ce = 128) {
              we(this, F, []);
              we(this, M, !1);
              we(this, x);
              we(this, P, -1);
              Ie(this, x, ce);
            }
            add({
              cmd: ce,
              undo: Ne,
              mustExec: Ge,
              type: nt = NaN,
              overwriteIfSameType: rt = !1,
              keepUndo: Ye = !1
            }) {
              if (Ge && ce(), G(this, M))
                return;
              const oe = {
                cmd: ce,
                undo: Ne,
                type: nt
              };
              if (G(this, P) === -1) {
                G(this, F).length > 0 && (G(this, F).length = 0), Ie(this, P, 0), G(this, F).push(oe);
                return;
              }
              if (rt && G(this, F)[G(this, P)].type === nt) {
                Ye && (oe.undo = G(this, F)[G(this, P)].undo), G(this, F)[G(this, P)] = oe;
                return;
              }
              const ne = G(this, P) + 1;
              ne === G(this, x) ? G(this, F).splice(0, 1) : (Ie(this, P, ne), ne < G(this, F).length && G(this, F).splice(ne)), G(this, F).push(oe);
            }
            undo() {
              G(this, P) !== -1 && (Ie(this, M, !0), G(this, F)[G(this, P)].undo(), Ie(this, M, !1), Ie(this, P, G(this, P) - 1));
            }
            redo() {
              G(this, P) < G(this, F).length - 1 && (Ie(this, P, G(this, P) + 1), Ie(this, M, !0), G(this, F)[G(this, P)].cmd(), Ie(this, M, !1));
            }
            hasSomethingToUndo() {
              return G(this, P) !== -1;
            }
            hasSomethingToRedo() {
              return G(this, P) < G(this, F).length - 1;
            }
            destroy() {
              Ie(this, F, null);
            }
          }
          F = new WeakMap(), M = new WeakMap(), x = new WeakMap(), P = new WeakMap(), t.CommandManager = b;
          class _ {
            constructor(ce) {
              we(this, U);
              this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
              const {
                isMac: Ne
              } = a.FeatureTest.platform;
              for (const [Ge, nt, rt = {}] of ce)
                for (const Ye of Ge) {
                  const oe = Ye.startsWith("mac+");
                  Ne && oe ? (this.callbacks.set(Ye.slice(4), {
                    callback: nt,
                    options: rt
                  }), this.allKeys.add(Ye.split("+").at(-1))) : !Ne && !oe && (this.callbacks.set(Ye, {
                    callback: nt,
                    options: rt
                  }), this.allKeys.add(Ye.split("+").at(-1)));
                }
            }
            exec(ce, Ne) {
              if (!this.allKeys.has(Ne.key))
                return;
              const Ge = this.callbacks.get(_e(this, U, Wn).call(this, Ne));
              if (!Ge)
                return;
              const {
                callback: nt,
                options: {
                  bubbles: rt = !1,
                  args: Ye = [],
                  checker: oe = null
                }
              } = Ge;
              oe && !oe(ce, Ne) || (nt.bind(ce, ...Ye)(), rt || (Ne.stopPropagation(), Ne.preventDefault()));
            }
          }
          U = new WeakSet(), Wn = function(ce) {
            ce.altKey && this.buffer.push("alt"), ce.ctrlKey && this.buffer.push("ctrl"), ce.metaKey && this.buffer.push("meta"), ce.shiftKey && this.buffer.push("shift"), this.buffer.push(ce.key);
            const Ne = this.buffer.join("+");
            return this.buffer.length = 0, Ne;
          }, t.KeyboardManager = _;
          const H = class H {
            get _colors() {
              const ce = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
              return (0, o.getColorValues)(ce), (0, a.shadow)(this, "_colors", ce);
            }
            convert(ce) {
              const Ne = (0, o.getRGB)(ce);
              if (!window.matchMedia("(forced-colors: active)").matches)
                return Ne;
              for (const [Ge, nt] of this._colors)
                if (nt.every((rt, Ye) => rt === Ne[Ye]))
                  return H._colorsMapping.get(Ge);
              return Ne;
            }
            getHexCode(ce) {
              const Ne = this._colors.get(ce);
              return Ne ? a.Util.makeHexColor(...Ne) : ce;
            }
          };
          ft(H, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
          let y = H;
          t.ColorManager = y;
          const dt = class dt {
            constructor(ce, Ne, Ge, nt, rt, Ye) {
              we(this, te);
              we(this, B, null);
              we(this, V, /* @__PURE__ */ new Map());
              we(this, X, /* @__PURE__ */ new Map());
              we(this, de, null);
              we(this, Y, null);
              we(this, se, new b());
              we(this, ue, 0);
              we(this, pe, /* @__PURE__ */ new Set());
              we(this, J, null);
              we(this, j, null);
              we(this, le, /* @__PURE__ */ new Set());
              we(this, Z, null);
              we(this, O, new d());
              we(this, z, !1);
              we(this, W, !1);
              we(this, ee, null);
              we(this, ae, a.AnnotationEditorType.NONE);
              we(this, ie, /* @__PURE__ */ new Set());
              we(this, me, null);
              we(this, ye, this.blur.bind(this));
              we(this, Re, this.focus.bind(this));
              we(this, De, this.copy.bind(this));
              we(this, Pe, this.cut.bind(this));
              we(this, he, this.paste.bind(this));
              we(this, Le, this.keydown.bind(this));
              we(this, Ee, this.onEditingAction.bind(this));
              we(this, Se, this.onPageChanging.bind(this));
              we(this, Q, this.onScaleChanging.bind(this));
              we(this, K, this.onRotationChanging.bind(this));
              we(this, fe, {
                isEditing: !1,
                isEmpty: !0,
                hasSomethingToUndo: !1,
                hasSomethingToRedo: !1,
                hasSelectedEditor: !1
              });
              we(this, be, [0, 0]);
              we(this, ke, null);
              we(this, Fe, null);
              we(this, Be, null);
              Ie(this, Fe, ce), Ie(this, Be, Ne), Ie(this, de, Ge), this._eventBus = nt, this._eventBus._on("editingaction", G(this, Ee)), this._eventBus._on("pagechanging", G(this, Se)), this._eventBus._on("scalechanging", G(this, Q)), this._eventBus._on("rotationchanging", G(this, K)), Ie(this, Y, rt.annotationStorage), Ie(this, Z, rt.filterFactory), Ie(this, me, Ye), this.viewParameters = {
                realScale: o.PixelsPerInch.PDF_TO_CSS_UNITS,
                rotation: 0
              };
            }
            static get _keyboardManager() {
              const ce = dt.prototype, Ne = (rt) => {
                const {
                  activeElement: Ye
                } = document;
                return Ye && G(rt, Fe).contains(Ye) && rt.hasSomethingToControl();
              }, Ge = this.TRANSLATE_SMALL, nt = this.TRANSLATE_BIG;
              return (0, a.shadow)(this, "_keyboardManager", new _([[["ctrl+a", "mac+meta+a"], ce.selectAll], [["ctrl+z", "mac+meta+z"], ce.undo], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], ce.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], ce.delete], [["Escape", "mac+Escape"], ce.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], ce.translateSelectedEditors, {
                args: [-Ge, 0],
                checker: Ne
              }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], ce.translateSelectedEditors, {
                args: [-nt, 0],
                checker: Ne
              }], [["ArrowRight", "mac+ArrowRight"], ce.translateSelectedEditors, {
                args: [Ge, 0],
                checker: Ne
              }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], ce.translateSelectedEditors, {
                args: [nt, 0],
                checker: Ne
              }], [["ArrowUp", "mac+ArrowUp"], ce.translateSelectedEditors, {
                args: [0, -Ge],
                checker: Ne
              }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], ce.translateSelectedEditors, {
                args: [0, -nt],
                checker: Ne
              }], [["ArrowDown", "mac+ArrowDown"], ce.translateSelectedEditors, {
                args: [0, Ge],
                checker: Ne
              }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], ce.translateSelectedEditors, {
                args: [0, nt],
                checker: Ne
              }]]));
            }
            destroy() {
              _e(this, te, jt).call(this), _e(this, te, hn).call(this), this._eventBus._off("editingaction", G(this, Ee)), this._eventBus._off("pagechanging", G(this, Se)), this._eventBus._off("scalechanging", G(this, Q)), this._eventBus._off("rotationchanging", G(this, K));
              for (const ce of G(this, X).values())
                ce.destroy();
              G(this, X).clear(), G(this, V).clear(), G(this, le).clear(), Ie(this, B, null), G(this, ie).clear(), G(this, se).destroy(), G(this, de).destroy();
            }
            get hcmFilter() {
              return (0, a.shadow)(this, "hcmFilter", G(this, me) ? G(this, Z).addHCMFilter(G(this, me).foreground, G(this, me).background) : "none");
            }
            get direction() {
              return (0, a.shadow)(this, "direction", getComputedStyle(G(this, Fe)).direction);
            }
            editAltText(ce) {
              var Ne;
              (Ne = G(this, de)) == null || Ne.editAltText(this, ce);
            }
            onPageChanging({
              pageNumber: ce
            }) {
              Ie(this, ue, ce - 1);
            }
            focusMainContainer() {
              G(this, Fe).focus();
            }
            findParent(ce, Ne) {
              for (const Ge of G(this, X).values()) {
                const {
                  x: nt,
                  y: rt,
                  width: Ye,
                  height: oe
                } = Ge.div.getBoundingClientRect();
                if (ce >= nt && ce <= nt + Ye && Ne >= rt && Ne <= rt + oe)
                  return Ge;
              }
              return null;
            }
            disableUserSelect(ce = !1) {
              G(this, Be).classList.toggle("noUserSelect", ce);
            }
            addShouldRescale(ce) {
              G(this, le).add(ce);
            }
            removeShouldRescale(ce) {
              G(this, le).delete(ce);
            }
            onScaleChanging({
              scale: ce
            }) {
              this.commitOrRemove(), this.viewParameters.realScale = ce * o.PixelsPerInch.PDF_TO_CSS_UNITS;
              for (const Ne of G(this, le))
                Ne.onScaleChanging();
            }
            onRotationChanging({
              pagesRotation: ce
            }) {
              this.commitOrRemove(), this.viewParameters.rotation = ce;
            }
            addToAnnotationStorage(ce) {
              !ce.isEmpty() && G(this, Y) && !G(this, Y).has(ce.id) && G(this, Y).setValue(ce.id, ce);
            }
            blur() {
              if (!this.hasSelection)
                return;
              const {
                activeElement: ce
              } = document;
              for (const Ne of G(this, ie))
                if (Ne.div.contains(ce)) {
                  Ie(this, ee, [Ne, ce]), Ne._focusEventsAllowed = !1;
                  break;
                }
            }
            focus() {
              if (!G(this, ee))
                return;
              const [ce, Ne] = G(this, ee);
              Ie(this, ee, null), Ne.addEventListener("focusin", () => {
                ce._focusEventsAllowed = !0;
              }, {
                once: !0
              }), Ne.focus();
            }
            addEditListeners() {
              _e(this, te, pn).call(this), _e(this, te, mn).call(this);
            }
            removeEditListeners() {
              _e(this, te, jt).call(this), _e(this, te, fn).call(this);
            }
            copy(ce) {
              var Ge;
              if (ce.preventDefault(), (Ge = G(this, B)) == null || Ge.commitOrRemove(), !this.hasSelection)
                return;
              const Ne = [];
              for (const nt of G(this, ie)) {
                const rt = nt.serialize(!0);
                rt && Ne.push(rt);
              }
              Ne.length !== 0 && ce.clipboardData.setData("application/pdfjs", JSON.stringify(Ne));
            }
            cut(ce) {
              this.copy(ce), this.delete();
            }
            paste(ce) {
              ce.preventDefault();
              const {
                clipboardData: Ne
              } = ce;
              for (const rt of Ne.items)
                for (const Ye of G(this, j))
                  if (Ye.isHandlingMimeForPasting(rt.type)) {
                    Ye.paste(rt, this.currentLayer);
                    return;
                  }
              let Ge = Ne.getData("application/pdfjs");
              if (!Ge)
                return;
              try {
                Ge = JSON.parse(Ge);
              } catch (rt) {
                (0, a.warn)(`paste: "${rt.message}".`);
                return;
              }
              if (!Array.isArray(Ge))
                return;
              this.unselectAll();
              const nt = this.currentLayer;
              try {
                const rt = [];
                for (const ne of Ge) {
                  const ge = nt.deserialize(ne);
                  if (!ge)
                    return;
                  rt.push(ge);
                }
                const Ye = () => {
                  for (const ne of rt)
                    _e(this, te, gn).call(this, ne);
                  _e(this, te, bn).call(this, rt);
                }, oe = () => {
                  for (const ne of rt)
                    ne.remove();
                };
                this.addCommands({
                  cmd: Ye,
                  undo: oe,
                  mustExec: !0
                });
              } catch (rt) {
                (0, a.warn)(`paste: "${rt.message}".`);
              }
            }
            keydown(ce) {
              var Ne;
              (Ne = this.getActive()) != null && Ne.shouldGetKeyboardEvents() || dt._keyboardManager.exec(this, ce);
            }
            onEditingAction(ce) {
              ["undo", "redo", "delete", "selectAll"].includes(ce.name) && this[ce.name]();
            }
            setEditingState(ce) {
              ce ? (_e(this, te, Yn).call(this), _e(this, te, pn).call(this), _e(this, te, mn).call(this), _e(this, te, vt).call(this, {
                isEditing: G(this, ae) !== a.AnnotationEditorType.NONE,
                isEmpty: _e(this, te, Pt).call(this),
                hasSomethingToUndo: G(this, se).hasSomethingToUndo(),
                hasSomethingToRedo: G(this, se).hasSomethingToRedo(),
                hasSelectedEditor: !1
              })) : (_e(this, te, hn).call(this), _e(this, te, jt).call(this), _e(this, te, fn).call(this), _e(this, te, vt).call(this, {
                isEditing: !1
              }), this.disableUserSelect(!1));
            }
            registerEditorTypes(ce) {
              if (!G(this, j)) {
                Ie(this, j, ce);
                for (const Ne of G(this, j))
                  _e(this, te, $t).call(this, Ne.defaultPropertiesToUpdate);
              }
            }
            getId() {
              return G(this, O).getId();
            }
            get currentLayer() {
              return G(this, X).get(G(this, ue));
            }
            getLayer(ce) {
              return G(this, X).get(ce);
            }
            get currentPageIndex() {
              return G(this, ue);
            }
            addLayer(ce) {
              G(this, X).set(ce.pageIndex, ce), G(this, z) ? ce.enable() : ce.disable();
            }
            removeLayer(ce) {
              G(this, X).delete(ce.pageIndex);
            }
            updateMode(ce, Ne = null) {
              if (G(this, ae) !== ce) {
                if (Ie(this, ae, ce), ce === a.AnnotationEditorType.NONE) {
                  this.setEditingState(!1), _e(this, te, Kn).call(this);
                  return;
                }
                this.setEditingState(!0), _e(this, te, Xn).call(this), this.unselectAll();
                for (const Ge of G(this, X).values())
                  Ge.updateMode(ce);
                if (Ne) {
                  for (const Ge of G(this, V).values())
                    if (Ge.annotationElementId === Ne) {
                      this.setSelected(Ge), Ge.enterInEditMode();
                      break;
                    }
                }
              }
            }
            updateToolbar(ce) {
              ce !== G(this, ae) && this._eventBus.dispatch("switchannotationeditormode", {
                source: this,
                mode: ce
              });
            }
            updateParams(ce, Ne) {
              if (G(this, j)) {
                if (ce === a.AnnotationEditorParamsType.CREATE) {
                  this.currentLayer.addNewEditor(ce);
                  return;
                }
                for (const Ge of G(this, ie))
                  Ge.updateParams(ce, Ne);
                for (const Ge of G(this, j))
                  Ge.updateDefaultParams(ce, Ne);
              }
            }
            enableWaiting(ce = !1) {
              if (G(this, W) !== ce) {
                Ie(this, W, ce);
                for (const Ne of G(this, X).values())
                  ce ? Ne.disableClick() : Ne.enableClick(), Ne.div.classList.toggle("waiting", ce);
              }
            }
            getEditors(ce) {
              const Ne = [];
              for (const Ge of G(this, V).values())
                Ge.pageIndex === ce && Ne.push(Ge);
              return Ne;
            }
            getEditor(ce) {
              return G(this, V).get(ce);
            }
            addEditor(ce) {
              G(this, V).set(ce.id, ce);
            }
            removeEditor(ce) {
              var Ne;
              G(this, V).delete(ce.id), this.unselect(ce), (!ce.annotationElementId || !G(this, pe).has(ce.annotationElementId)) && ((Ne = G(this, Y)) == null || Ne.remove(ce.id));
            }
            addDeletedAnnotationElement(ce) {
              G(this, pe).add(ce.annotationElementId), ce.deleted = !0;
            }
            isDeletedAnnotationElement(ce) {
              return G(this, pe).has(ce);
            }
            removeDeletedAnnotationElement(ce) {
              G(this, pe).delete(ce.annotationElementId), ce.deleted = !1;
            }
            setActiveEditor(ce) {
              G(this, B) !== ce && (Ie(this, B, ce), ce && _e(this, te, $t).call(this, ce.propertiesToUpdate));
            }
            toggleSelected(ce) {
              if (G(this, ie).has(ce)) {
                G(this, ie).delete(ce), ce.unselect(), _e(this, te, vt).call(this, {
                  hasSelectedEditor: this.hasSelection
                });
                return;
              }
              G(this, ie).add(ce), ce.select(), _e(this, te, $t).call(this, ce.propertiesToUpdate), _e(this, te, vt).call(this, {
                hasSelectedEditor: !0
              });
            }
            setSelected(ce) {
              for (const Ne of G(this, ie))
                Ne !== ce && Ne.unselect();
              G(this, ie).clear(), G(this, ie).add(ce), ce.select(), _e(this, te, $t).call(this, ce.propertiesToUpdate), _e(this, te, vt).call(this, {
                hasSelectedEditor: !0
              });
            }
            isSelected(ce) {
              return G(this, ie).has(ce);
            }
            unselect(ce) {
              ce.unselect(), G(this, ie).delete(ce), _e(this, te, vt).call(this, {
                hasSelectedEditor: this.hasSelection
              });
            }
            get hasSelection() {
              return G(this, ie).size !== 0;
            }
            undo() {
              G(this, se).undo(), _e(this, te, vt).call(this, {
                hasSomethingToUndo: G(this, se).hasSomethingToUndo(),
                hasSomethingToRedo: !0,
                isEmpty: _e(this, te, Pt).call(this)
              });
            }
            redo() {
              G(this, se).redo(), _e(this, te, vt).call(this, {
                hasSomethingToUndo: !0,
                hasSomethingToRedo: G(this, se).hasSomethingToRedo(),
                isEmpty: _e(this, te, Pt).call(this)
              });
            }
            addCommands(ce) {
              G(this, se).add(ce), _e(this, te, vt).call(this, {
                hasSomethingToUndo: !0,
                hasSomethingToRedo: !1,
                isEmpty: _e(this, te, Pt).call(this)
              });
            }
            delete() {
              if (this.commitOrRemove(), !this.hasSelection)
                return;
              const ce = [...G(this, ie)], Ne = () => {
                for (const nt of ce)
                  nt.remove();
              }, Ge = () => {
                for (const nt of ce)
                  _e(this, te, gn).call(this, nt);
              };
              this.addCommands({
                cmd: Ne,
                undo: Ge,
                mustExec: !0
              });
            }
            commitOrRemove() {
              var ce;
              (ce = G(this, B)) == null || ce.commitOrRemove();
            }
            hasSomethingToControl() {
              return G(this, B) || this.hasSelection;
            }
            selectAll() {
              for (const ce of G(this, ie))
                ce.commit();
              _e(this, te, bn).call(this, G(this, V).values());
            }
            unselectAll() {
              if (G(this, B)) {
                G(this, B).commitOrRemove();
                return;
              }
              if (this.hasSelection) {
                for (const ce of G(this, ie))
                  ce.unselect();
                G(this, ie).clear(), _e(this, te, vt).call(this, {
                  hasSelectedEditor: !1
                });
              }
            }
            translateSelectedEditors(ce, Ne, Ge = !1) {
              if (Ge || this.commitOrRemove(), !this.hasSelection)
                return;
              G(this, be)[0] += ce, G(this, be)[1] += Ne;
              const [nt, rt] = G(this, be), Ye = [...G(this, ie)], oe = 1e3;
              G(this, ke) && clearTimeout(G(this, ke)), Ie(this, ke, setTimeout(() => {
                Ie(this, ke, null), G(this, be)[0] = G(this, be)[1] = 0, this.addCommands({
                  cmd: () => {
                    for (const ne of Ye)
                      G(this, V).has(ne.id) && ne.translateInPage(nt, rt);
                  },
                  undo: () => {
                    for (const ne of Ye)
                      G(this, V).has(ne.id) && ne.translateInPage(-nt, -rt);
                  },
                  mustExec: !1
                });
              }, oe));
              for (const ne of Ye)
                ne.translateInPage(ce, Ne);
            }
            setUpDragSession() {
              if (this.hasSelection) {
                this.disableUserSelect(!0), Ie(this, J, /* @__PURE__ */ new Map());
                for (const ce of G(this, ie))
                  G(this, J).set(ce, {
                    savedX: ce.x,
                    savedY: ce.y,
                    savedPageIndex: ce.pageIndex,
                    newX: 0,
                    newY: 0,
                    newPageIndex: -1
                  });
              }
            }
            endDragSession() {
              if (!G(this, J))
                return !1;
              this.disableUserSelect(!1);
              const ce = G(this, J);
              Ie(this, J, null);
              let Ne = !1;
              for (const [{
                x: nt,
                y: rt,
                pageIndex: Ye
              }, oe] of ce)
                oe.newX = nt, oe.newY = rt, oe.newPageIndex = Ye, Ne || (Ne = nt !== oe.savedX || rt !== oe.savedY || Ye !== oe.savedPageIndex);
              if (!Ne)
                return !1;
              const Ge = (nt, rt, Ye, oe) => {
                if (G(this, V).has(nt.id)) {
                  const ne = G(this, X).get(oe);
                  ne ? nt._setParentAndPosition(ne, rt, Ye) : (nt.pageIndex = oe, nt.x = rt, nt.y = Ye);
                }
              };
              return this.addCommands({
                cmd: () => {
                  for (const [nt, {
                    newX: rt,
                    newY: Ye,
                    newPageIndex: oe
                  }] of ce)
                    Ge(nt, rt, Ye, oe);
                },
                undo: () => {
                  for (const [nt, {
                    savedX: rt,
                    savedY: Ye,
                    savedPageIndex: oe
                  }] of ce)
                    Ge(nt, rt, Ye, oe);
                },
                mustExec: !0
              }), !0;
            }
            dragSelectedEditors(ce, Ne) {
              if (G(this, J))
                for (const Ge of G(this, J).keys())
                  Ge.drag(ce, Ne);
            }
            rebuild(ce) {
              if (ce.parent === null) {
                const Ne = this.getLayer(ce.pageIndex);
                Ne ? (Ne.changeParent(ce), Ne.addOrRebuild(ce)) : (this.addEditor(ce), this.addToAnnotationStorage(ce), ce.rebuild());
              } else
                ce.parent.addOrRebuild(ce);
            }
            isActive(ce) {
              return G(this, B) === ce;
            }
            getActive() {
              return G(this, B);
            }
            getMode() {
              return G(this, ae);
            }
            get imageManager() {
              return (0, a.shadow)(this, "imageManager", new g());
            }
          };
          B = new WeakMap(), V = new WeakMap(), X = new WeakMap(), de = new WeakMap(), Y = new WeakMap(), se = new WeakMap(), ue = new WeakMap(), pe = new WeakMap(), J = new WeakMap(), j = new WeakMap(), le = new WeakMap(), Z = new WeakMap(), O = new WeakMap(), z = new WeakMap(), W = new WeakMap(), ee = new WeakMap(), ae = new WeakMap(), ie = new WeakMap(), me = new WeakMap(), ye = new WeakMap(), Re = new WeakMap(), De = new WeakMap(), Pe = new WeakMap(), he = new WeakMap(), Le = new WeakMap(), Ee = new WeakMap(), Se = new WeakMap(), Q = new WeakMap(), K = new WeakMap(), fe = new WeakMap(), be = new WeakMap(), ke = new WeakMap(), Fe = new WeakMap(), Be = new WeakMap(), te = new WeakSet(), Yn = function() {
            window.addEventListener("focus", G(this, Re)), window.addEventListener("blur", G(this, ye));
          }, hn = function() {
            window.removeEventListener("focus", G(this, Re)), window.removeEventListener("blur", G(this, ye));
          }, pn = function() {
            window.addEventListener("keydown", G(this, Le), {
              capture: !0
            });
          }, jt = function() {
            window.removeEventListener("keydown", G(this, Le), {
              capture: !0
            });
          }, mn = function() {
            document.addEventListener("copy", G(this, De)), document.addEventListener("cut", G(this, Pe)), document.addEventListener("paste", G(this, he));
          }, fn = function() {
            document.removeEventListener("copy", G(this, De)), document.removeEventListener("cut", G(this, Pe)), document.removeEventListener("paste", G(this, he));
          }, vt = function(ce) {
            Object.entries(ce).some(([Ge, nt]) => G(this, fe)[Ge] !== nt) && this._eventBus.dispatch("annotationeditorstateschanged", {
              source: this,
              details: Object.assign(G(this, fe), ce)
            });
          }, $t = function(ce) {
            this._eventBus.dispatch("annotationeditorparamschanged", {
              source: this,
              details: ce
            });
          }, Xn = function() {
            if (!G(this, z)) {
              Ie(this, z, !0);
              for (const ce of G(this, X).values())
                ce.enable();
            }
          }, Kn = function() {
            if (this.unselectAll(), G(this, z)) {
              Ie(this, z, !1);
              for (const ce of G(this, X).values())
                ce.disable();
            }
          }, gn = function(ce) {
            const Ne = G(this, X).get(ce.pageIndex);
            Ne ? Ne.addOrRebuild(ce) : this.addEditor(ce);
          }, Pt = function() {
            if (G(this, V).size === 0)
              return !0;
            if (G(this, V).size === 1)
              for (const ce of G(this, V).values())
                return ce.isEmpty();
            return !1;
          }, bn = function(ce) {
            G(this, ie).clear();
            for (const Ne of ce)
              Ne.isEmpty() || (G(this, ie).add(Ne), Ne.select());
            _e(this, te, vt).call(this, {
              hasSelectedEditor: !0
            });
          }, ft(dt, "TRANSLATE_SMALL", 1), ft(dt, "TRANSLATE_BIG", 10);
          let A = dt;
          t.AnnotationEditorUIManager = A;
        },
        /* 6 */
        /***/
        (e, t, r) => {
          var ue, pe, J, j, le, Z, O, z, W, ee, ae, ie, Rt, Dt, _n, Vt, Wt, Ft, Bt;
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.StatTimer = t.RenderingCancelledException = t.PixelsPerInch = t.PageViewport = t.PDFDateString = t.DOMStandardFontDataFactory = t.DOMSVGFactory = t.DOMFilterFactory = t.DOMCanvasFactory = t.DOMCMapReaderFactory = void 0, t.deprecated = P, t.getColorValues = V, t.getCurrentTransform = X, t.getCurrentTransformInverse = de, t.getFilenameFromUrl = I, t.getPdfFilenameFromUrl = w, t.getRGB = B, t.getXfaPageViewport = H, t.isDataScheme = C, t.isPdfFile = R, t.isValidFetchUrl = F, t.loadScript = x, t.noContextMenu = M, t.setLayerDimensions = Y;
          var a = r(7), o = r(1);
          const u = "http://www.w3.org/2000/svg", se = class se {
          };
          ft(se, "CSS", 96), ft(se, "PDF", 72), ft(se, "PDF_TO_CSS_UNITS", se.CSS / se.PDF);
          let c = se;
          t.PixelsPerInch = c;
          class d extends a.BaseFilterFactory {
            constructor({
              docId: Q,
              ownerDocument: K = globalThis.document
            } = {}) {
              super();
              we(this, ie);
              we(this, ue);
              we(this, pe);
              we(this, J);
              we(this, j);
              we(this, le);
              we(this, Z);
              we(this, O);
              we(this, z);
              we(this, W);
              we(this, ee);
              we(this, ae, 0);
              Ie(this, J, Q), Ie(this, j, K);
            }
            addFilter(Q) {
              if (!Q)
                return "none";
              let K = G(this, ie, Rt).get(Q);
              if (K)
                return K;
              let fe, be, ke, Fe;
              if (Q.length === 1) {
                const Me = Q[0], Ve = new Array(256);
                for (let je = 0; je < 256; je++)
                  Ve[je] = Me[je] / 255;
                Fe = fe = be = ke = Ve.join(",");
              } else {
                const [Me, Ve, je] = Q, ot = new Array(256), We = new Array(256), Xe = new Array(256);
                for (let ut = 0; ut < 256; ut++)
                  ot[ut] = Me[ut] / 255, We[ut] = Ve[ut] / 255, Xe[ut] = je[ut] / 255;
                fe = ot.join(","), be = We.join(","), ke = Xe.join(","), Fe = `${fe}${be}${ke}`;
              }
              if (K = G(this, ie, Rt).get(Fe), K)
                return G(this, ie, Rt).set(Q, K), K;
              const Be = `g_${G(this, J)}_transfer_map_${Mt(this, ae)._++}`, te = `url(#${Be})`;
              G(this, ie, Rt).set(Q, te), G(this, ie, Rt).set(Fe, te);
              const Ce = _e(this, ie, Vt).call(this, Be);
              return _e(this, ie, Ft).call(this, fe, be, ke, Ce), te;
            }
            addHCMFilter(Q, K) {
              var Ve;
              const fe = `${Q}-${K}`;
              if (G(this, Z) === fe)
                return G(this, O);
              if (Ie(this, Z, fe), Ie(this, O, "none"), (Ve = G(this, le)) == null || Ve.remove(), !Q || !K)
                return G(this, O);
              const be = _e(this, ie, Bt).call(this, Q);
              Q = o.Util.makeHexColor(...be);
              const ke = _e(this, ie, Bt).call(this, K);
              if (K = o.Util.makeHexColor(...ke), G(this, ie, Dt).style.color = "", Q === "#000000" && K === "#ffffff" || Q === K)
                return G(this, O);
              const Fe = new Array(256);
              for (let je = 0; je <= 255; je++) {
                const ot = je / 255;
                Fe[je] = ot <= 0.03928 ? ot / 12.92 : ((ot + 0.055) / 1.055) ** 2.4;
              }
              const Be = Fe.join(","), te = `g_${G(this, J)}_hcm_filter`, Ce = Ie(this, z, _e(this, ie, Vt).call(this, te));
              _e(this, ie, Ft).call(this, Be, Be, Be, Ce), _e(this, ie, _n).call(this, Ce);
              const Me = (je, ot) => {
                const We = be[je] / 255, Xe = ke[je] / 255, ut = new Array(ot + 1);
                for (let ct = 0; ct <= ot; ct++)
                  ut[ct] = We + ct / ot * (Xe - We);
                return ut.join(",");
              };
              return _e(this, ie, Ft).call(this, Me(0, 5), Me(1, 5), Me(2, 5), Ce), Ie(this, O, `url(#${te})`), G(this, O);
            }
            addHighlightHCMFilter(Q, K, fe, be) {
              var Xe;
              const ke = `${Q}-${K}-${fe}-${be}`;
              if (G(this, W) === ke)
                return G(this, ee);
              if (Ie(this, W, ke), Ie(this, ee, "none"), (Xe = G(this, z)) == null || Xe.remove(), !Q || !K)
                return G(this, ee);
              const [Fe, Be] = [Q, K].map(_e(this, ie, Bt).bind(this));
              let te = Math.round(0.2126 * Fe[0] + 0.7152 * Fe[1] + 0.0722 * Fe[2]), Ce = Math.round(0.2126 * Be[0] + 0.7152 * Be[1] + 0.0722 * Be[2]), [Me, Ve] = [fe, be].map(_e(this, ie, Bt).bind(this));
              Ce < te && ([te, Ce, Me, Ve] = [Ce, te, Ve, Me]), G(this, ie, Dt).style.color = "";
              const je = (ut, ct, $e) => {
                const Ae = new Array(256), ve = (Ce - te) / $e, Ke = ut / 255, dt = (ct - ut) / (255 * $e);
                let pt = 0;
                for (let ce = 0; ce <= $e; ce++) {
                  const Ne = Math.round(te + ce * ve), Ge = Ke + ce * dt;
                  for (let nt = pt; nt <= Ne; nt++)
                    Ae[nt] = Ge;
                  pt = Ne + 1;
                }
                for (let ce = pt; ce < 256; ce++)
                  Ae[ce] = Ae[pt - 1];
                return Ae.join(",");
              }, ot = `g_${G(this, J)}_hcm_highlight_filter`, We = Ie(this, z, _e(this, ie, Vt).call(this, ot));
              return _e(this, ie, _n).call(this, We), _e(this, ie, Ft).call(this, je(Me[0], Ve[0], 5), je(Me[1], Ve[1], 5), je(Me[2], Ve[2], 5), We), Ie(this, ee, `url(#${ot})`), G(this, ee);
            }
            destroy(Q = !1) {
              Q && (G(this, O) || G(this, ee)) || (G(this, pe) && (G(this, pe).parentNode.parentNode.remove(), Ie(this, pe, null)), G(this, ue) && (G(this, ue).clear(), Ie(this, ue, null)), Ie(this, ae, 0));
            }
          }
          ue = new WeakMap(), pe = new WeakMap(), J = new WeakMap(), j = new WeakMap(), le = new WeakMap(), Z = new WeakMap(), O = new WeakMap(), z = new WeakMap(), W = new WeakMap(), ee = new WeakMap(), ae = new WeakMap(), ie = new WeakSet(), Rt = function() {
            return G(this, ue) || Ie(this, ue, /* @__PURE__ */ new Map());
          }, Dt = function() {
            if (!G(this, pe)) {
              const Q = G(this, j).createElement("div"), {
                style: K
              } = Q;
              K.visibility = "hidden", K.contain = "strict", K.width = K.height = 0, K.position = "absolute", K.top = K.left = 0, K.zIndex = -1;
              const fe = G(this, j).createElementNS(u, "svg");
              fe.setAttribute("width", 0), fe.setAttribute("height", 0), Ie(this, pe, G(this, j).createElementNS(u, "defs")), Q.append(fe), fe.append(G(this, pe)), G(this, j).body.append(Q);
            }
            return G(this, pe);
          }, _n = function(Q) {
            const K = G(this, j).createElementNS(u, "feColorMatrix");
            K.setAttribute("type", "matrix"), K.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), Q.append(K);
          }, Vt = function(Q) {
            const K = G(this, j).createElementNS(u, "filter");
            return K.setAttribute("color-interpolation-filters", "sRGB"), K.setAttribute("id", Q), G(this, ie, Dt).append(K), K;
          }, Wt = function(Q, K, fe) {
            const be = G(this, j).createElementNS(u, K);
            be.setAttribute("type", "discrete"), be.setAttribute("tableValues", fe), Q.append(be);
          }, Ft = function(Q, K, fe, be) {
            const ke = G(this, j).createElementNS(u, "feComponentTransfer");
            be.append(ke), _e(this, ie, Wt).call(this, ke, "feFuncR", Q), _e(this, ie, Wt).call(this, ke, "feFuncG", K), _e(this, ie, Wt).call(this, ke, "feFuncB", fe);
          }, Bt = function(Q) {
            return G(this, ie, Dt).style.color = Q, B(getComputedStyle(G(this, ie, Dt)).getPropertyValue("color"));
          }, t.DOMFilterFactory = d;
          class g extends a.BaseCanvasFactory {
            constructor({
              ownerDocument: Se = globalThis.document
            } = {}) {
              super(), this._document = Se;
            }
            _createCanvas(Se, Q) {
              const K = this._document.createElement("canvas");
              return K.width = Se, K.height = Q, K;
            }
          }
          t.DOMCanvasFactory = g;
          async function b(Ee, Se = !1) {
            if (F(Ee, document.baseURI)) {
              const Q = await fetch(Ee);
              if (!Q.ok)
                throw new Error(Q.statusText);
              return Se ? new Uint8Array(await Q.arrayBuffer()) : (0, o.stringToBytes)(await Q.text());
            }
            return new Promise((Q, K) => {
              const fe = new XMLHttpRequest();
              fe.open("GET", Ee, !0), Se && (fe.responseType = "arraybuffer"), fe.onreadystatechange = () => {
                if (fe.readyState === XMLHttpRequest.DONE) {
                  if (fe.status === 200 || fe.status === 0) {
                    let be;
                    if (Se && fe.response ? be = new Uint8Array(fe.response) : !Se && fe.responseText && (be = (0, o.stringToBytes)(fe.responseText)), be) {
                      Q(be);
                      return;
                    }
                  }
                  K(new Error(fe.statusText));
                }
              }, fe.send(null);
            });
          }
          class _ extends a.BaseCMapReaderFactory {
            _fetchData(Se, Q) {
              return b(Se, this.isCompressed).then((K) => ({
                cMapData: K,
                compressionType: Q
              }));
            }
          }
          t.DOMCMapReaderFactory = _;
          class y extends a.BaseStandardFontDataFactory {
            _fetchData(Se) {
              return b(Se, !0);
            }
          }
          t.DOMStandardFontDataFactory = y;
          class A extends a.BaseSVGFactory {
            _createSVG(Se) {
              return document.createElementNS(u, Se);
            }
          }
          t.DOMSVGFactory = A;
          class E {
            constructor({
              viewBox: Se,
              scale: Q,
              rotation: K,
              offsetX: fe = 0,
              offsetY: be = 0,
              dontFlip: ke = !1
            }) {
              this.viewBox = Se, this.scale = Q, this.rotation = K, this.offsetX = fe, this.offsetY = be;
              const Fe = (Se[2] + Se[0]) / 2, Be = (Se[3] + Se[1]) / 2;
              let te, Ce, Me, Ve;
              switch (K %= 360, K < 0 && (K += 360), K) {
                case 180:
                  te = -1, Ce = 0, Me = 0, Ve = 1;
                  break;
                case 90:
                  te = 0, Ce = 1, Me = 1, Ve = 0;
                  break;
                case 270:
                  te = 0, Ce = -1, Me = -1, Ve = 0;
                  break;
                case 0:
                  te = 1, Ce = 0, Me = 0, Ve = -1;
                  break;
                default:
                  throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
              }
              ke && (Me = -Me, Ve = -Ve);
              let je, ot, We, Xe;
              te === 0 ? (je = Math.abs(Be - Se[1]) * Q + fe, ot = Math.abs(Fe - Se[0]) * Q + be, We = (Se[3] - Se[1]) * Q, Xe = (Se[2] - Se[0]) * Q) : (je = Math.abs(Fe - Se[0]) * Q + fe, ot = Math.abs(Be - Se[1]) * Q + be, We = (Se[2] - Se[0]) * Q, Xe = (Se[3] - Se[1]) * Q), this.transform = [te * Q, Ce * Q, Me * Q, Ve * Q, je - te * Q * Fe - Me * Q * Be, ot - Ce * Q * Fe - Ve * Q * Be], this.width = We, this.height = Xe;
            }
            get rawDims() {
              const {
                viewBox: Se
              } = this;
              return (0, o.shadow)(this, "rawDims", {
                pageWidth: Se[2] - Se[0],
                pageHeight: Se[3] - Se[1],
                pageX: Se[0],
                pageY: Se[1]
              });
            }
            clone({
              scale: Se = this.scale,
              rotation: Q = this.rotation,
              offsetX: K = this.offsetX,
              offsetY: fe = this.offsetY,
              dontFlip: be = !1
            } = {}) {
              return new E({
                viewBox: this.viewBox.slice(),
                scale: Se,
                rotation: Q,
                offsetX: K,
                offsetY: fe,
                dontFlip: be
              });
            }
            convertToViewportPoint(Se, Q) {
              return o.Util.applyTransform([Se, Q], this.transform);
            }
            convertToViewportRectangle(Se) {
              const Q = o.Util.applyTransform([Se[0], Se[1]], this.transform), K = o.Util.applyTransform([Se[2], Se[3]], this.transform);
              return [Q[0], Q[1], K[0], K[1]];
            }
            convertToPdfPoint(Se, Q) {
              return o.Util.applyInverseTransform([Se, Q], this.transform);
            }
          }
          t.PageViewport = E;
          class v extends o.BaseException {
            constructor(Se, Q = 0) {
              super(Se, "RenderingCancelledException"), this.extraDelay = Q;
            }
          }
          t.RenderingCancelledException = v;
          function C(Ee) {
            const Se = Ee.length;
            let Q = 0;
            for (; Q < Se && Ee[Q].trim() === ""; )
              Q++;
            return Ee.substring(Q, Q + 5).toLowerCase() === "data:";
          }
          function R(Ee) {
            return typeof Ee == "string" && /\.pdf$/i.test(Ee);
          }
          function I(Ee, Se = !1) {
            return Se || ([Ee] = Ee.split(/[#?]/, 1)), Ee.substring(Ee.lastIndexOf("/") + 1);
          }
          function w(Ee, Se = "document.pdf") {
            if (typeof Ee != "string")
              return Se;
            if (C(Ee))
              return (0, o.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), Se;
            const Q = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/, K = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, fe = Q.exec(Ee);
            let be = K.exec(fe[1]) || K.exec(fe[2]) || K.exec(fe[3]);
            if (be && (be = be[0], be.includes("%")))
              try {
                be = K.exec(decodeURIComponent(be))[0];
              } catch {
              }
            return be || Se;
          }
          class N {
            constructor() {
              ft(this, "started", /* @__PURE__ */ Object.create(null));
              ft(this, "times", []);
            }
            time(Se) {
              Se in this.started && (0, o.warn)(`Timer is already running for ${Se}`), this.started[Se] = Date.now();
            }
            timeEnd(Se) {
              Se in this.started || (0, o.warn)(`Timer has not been started for ${Se}`), this.times.push({
                name: Se,
                start: this.started[Se],
                end: Date.now()
              }), delete this.started[Se];
            }
            toString() {
              const Se = [];
              let Q = 0;
              for (const {
                name: K
              } of this.times)
                Q = Math.max(K.length, Q);
              for (const {
                name: K,
                start: fe,
                end: be
              } of this.times)
                Se.push(`${K.padEnd(Q)} ${be - fe}ms
`);
              return Se.join("");
            }
          }
          t.StatTimer = N;
          function F(Ee, Se) {
            try {
              const {
                protocol: Q
              } = Se ? new URL(Ee, Se) : new URL(Ee);
              return Q === "http:" || Q === "https:";
            } catch {
              return !1;
            }
          }
          function M(Ee) {
            Ee.preventDefault();
          }
          function x(Ee, Se = !1) {
            return new Promise((Q, K) => {
              const fe = document.createElement("script");
              fe.src = Ee, fe.onload = function(be) {
                Se && fe.remove(), Q(be);
              }, fe.onerror = function() {
                K(new Error(`Cannot load script at: ${fe.src}`));
              }, (document.head || document.documentElement).append(fe);
            });
          }
          function P(Ee) {
            console.log("Deprecated API usage: " + Ee);
          }
          let U;
          class L {
            static toDateObject(Se) {
              if (!Se || typeof Se != "string")
                return null;
              U || (U = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
              const Q = U.exec(Se);
              if (!Q)
                return null;
              const K = parseInt(Q[1], 10);
              let fe = parseInt(Q[2], 10);
              fe = fe >= 1 && fe <= 12 ? fe - 1 : 0;
              let be = parseInt(Q[3], 10);
              be = be >= 1 && be <= 31 ? be : 1;
              let ke = parseInt(Q[4], 10);
              ke = ke >= 0 && ke <= 23 ? ke : 0;
              let Fe = parseInt(Q[5], 10);
              Fe = Fe >= 0 && Fe <= 59 ? Fe : 0;
              let Be = parseInt(Q[6], 10);
              Be = Be >= 0 && Be <= 59 ? Be : 0;
              const te = Q[7] || "Z";
              let Ce = parseInt(Q[8], 10);
              Ce = Ce >= 0 && Ce <= 23 ? Ce : 0;
              let Me = parseInt(Q[9], 10) || 0;
              return Me = Me >= 0 && Me <= 59 ? Me : 0, te === "-" ? (ke += Ce, Fe += Me) : te === "+" && (ke -= Ce, Fe -= Me), new Date(Date.UTC(K, fe, be, ke, Fe, Be));
            }
          }
          t.PDFDateString = L;
          function H(Ee, {
            scale: Se = 1,
            rotation: Q = 0
          }) {
            const {
              width: K,
              height: fe
            } = Ee.attributes.style, be = [0, 0, parseInt(K), parseInt(fe)];
            return new E({
              viewBox: be,
              scale: Se,
              rotation: Q
            });
          }
          function B(Ee) {
            if (Ee.startsWith("#")) {
              const Se = parseInt(Ee.slice(1), 16);
              return [(Se & 16711680) >> 16, (Se & 65280) >> 8, Se & 255];
            }
            return Ee.startsWith("rgb(") ? Ee.slice(4, -1).split(",").map((Se) => parseInt(Se)) : Ee.startsWith("rgba(") ? Ee.slice(5, -1).split(",").map((Se) => parseInt(Se)).slice(0, 3) : ((0, o.warn)(`Not a valid color format: "${Ee}"`), [0, 0, 0]);
          }
          function V(Ee) {
            const Se = document.createElement("span");
            Se.style.visibility = "hidden", document.body.append(Se);
            for (const Q of Ee.keys()) {
              Se.style.color = Q;
              const K = window.getComputedStyle(Se).color;
              Ee.set(Q, B(K));
            }
            Se.remove();
          }
          function X(Ee) {
            const {
              a: Se,
              b: Q,
              c: K,
              d: fe,
              e: be,
              f: ke
            } = Ee.getTransform();
            return [Se, Q, K, fe, be, ke];
          }
          function de(Ee) {
            const {
              a: Se,
              b: Q,
              c: K,
              d: fe,
              e: be,
              f: ke
            } = Ee.getTransform().invertSelf();
            return [Se, Q, K, fe, be, ke];
          }
          function Y(Ee, Se, Q = !1, K = !0) {
            if (Se instanceof E) {
              const {
                pageWidth: fe,
                pageHeight: be
              } = Se.rawDims, {
                style: ke
              } = Ee, Fe = o.FeatureTest.isCSSRoundSupported, Be = `var(--scale-factor) * ${fe}px`, te = `var(--scale-factor) * ${be}px`, Ce = Fe ? `round(${Be}, 1px)` : `calc(${Be})`, Me = Fe ? `round(${te}, 1px)` : `calc(${te})`;
              !Q || Se.rotation % 180 === 0 ? (ke.width = Ce, ke.height = Me) : (ke.width = Me, ke.height = Ce);
            }
            K && Ee.setAttribute("data-main-rotation", Se.rotation);
          }
        },
        /* 7 */
        /***/
        (e, t, r) => {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.BaseStandardFontDataFactory = t.BaseSVGFactory = t.BaseFilterFactory = t.BaseCanvasFactory = t.BaseCMapReaderFactory = void 0;
          var a = r(1);
          class o {
            constructor() {
              this.constructor === o && (0, a.unreachable)("Cannot initialize BaseFilterFactory.");
            }
            addFilter(_) {
              return "none";
            }
            addHCMFilter(_, y) {
              return "none";
            }
            addHighlightHCMFilter(_, y, A, E) {
              return "none";
            }
            destroy(_ = !1) {
            }
          }
          t.BaseFilterFactory = o;
          class u {
            constructor() {
              this.constructor === u && (0, a.unreachable)("Cannot initialize BaseCanvasFactory.");
            }
            create(_, y) {
              if (_ <= 0 || y <= 0)
                throw new Error("Invalid canvas size");
              const A = this._createCanvas(_, y);
              return {
                canvas: A,
                context: A.getContext("2d")
              };
            }
            reset(_, y, A) {
              if (!_.canvas)
                throw new Error("Canvas is not specified");
              if (y <= 0 || A <= 0)
                throw new Error("Invalid canvas size");
              _.canvas.width = y, _.canvas.height = A;
            }
            destroy(_) {
              if (!_.canvas)
                throw new Error("Canvas is not specified");
              _.canvas.width = 0, _.canvas.height = 0, _.canvas = null, _.context = null;
            }
            _createCanvas(_, y) {
              (0, a.unreachable)("Abstract method `_createCanvas` called.");
            }
          }
          t.BaseCanvasFactory = u;
          class c {
            constructor({
              baseUrl: _ = null,
              isCompressed: y = !0
            }) {
              this.constructor === c && (0, a.unreachable)("Cannot initialize BaseCMapReaderFactory."), this.baseUrl = _, this.isCompressed = y;
            }
            async fetch({
              name: _
            }) {
              if (!this.baseUrl)
                throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
              if (!_)
                throw new Error("CMap name must be specified.");
              const y = this.baseUrl + _ + (this.isCompressed ? ".bcmap" : ""), A = this.isCompressed ? a.CMapCompressionType.BINARY : a.CMapCompressionType.NONE;
              return this._fetchData(y, A).catch((E) => {
                throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${y}`);
              });
            }
            _fetchData(_, y) {
              (0, a.unreachable)("Abstract method `_fetchData` called.");
            }
          }
          t.BaseCMapReaderFactory = c;
          class d {
            constructor({
              baseUrl: _ = null
            }) {
              this.constructor === d && (0, a.unreachable)("Cannot initialize BaseStandardFontDataFactory."), this.baseUrl = _;
            }
            async fetch({
              filename: _
            }) {
              if (!this.baseUrl)
                throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
              if (!_)
                throw new Error("Font filename must be specified.");
              const y = `${this.baseUrl}${_}`;
              return this._fetchData(y).catch((A) => {
                throw new Error(`Unable to load font data at: ${y}`);
              });
            }
            _fetchData(_) {
              (0, a.unreachable)("Abstract method `_fetchData` called.");
            }
          }
          t.BaseStandardFontDataFactory = d;
          class g {
            constructor() {
              this.constructor === g && (0, a.unreachable)("Cannot initialize BaseSVGFactory.");
            }
            create(_, y, A = !1) {
              if (_ <= 0 || y <= 0)
                throw new Error("Invalid SVG dimensions");
              const E = this._createSVG("svg:svg");
              return E.setAttribute("version", "1.1"), A || (E.setAttribute("width", `${_}px`), E.setAttribute("height", `${y}px`)), E.setAttribute("preserveAspectRatio", "none"), E.setAttribute("viewBox", `0 0 ${_} ${y}`), E;
            }
            createElement(_) {
              if (typeof _ != "string")
                throw new Error("Invalid SVG element type");
              return this._createSVG(_);
            }
            _createSVG(_) {
              (0, a.unreachable)("Abstract method `_createSVG` called.");
            }
          }
          t.BaseSVGFactory = g;
        },
        /* 8 */
        /***/
        (e, t, r) => {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.MurmurHash3_64 = void 0;
          var a = r(1);
          const o = 3285377520, u = 4294901760, c = 65535;
          class d {
            constructor(b) {
              this.h1 = b ? b & 4294967295 : o, this.h2 = b ? b & 4294967295 : o;
            }
            update(b) {
              let _, y;
              if (typeof b == "string") {
                _ = new Uint8Array(b.length * 2), y = 0;
                for (let P = 0, U = b.length; P < U; P++) {
                  const L = b.charCodeAt(P);
                  L <= 255 ? _[y++] = L : (_[y++] = L >>> 8, _[y++] = L & 255);
                }
              } else if ((0, a.isArrayBuffer)(b))
                _ = b.slice(), y = _.byteLength;
              else
                throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
              const A = y >> 2, E = y - A * 4, v = new Uint32Array(_.buffer, 0, A);
              let C = 0, R = 0, I = this.h1, w = this.h2;
              const N = 3432918353, F = 461845907, M = N & c, x = F & c;
              for (let P = 0; P < A; P++)
                P & 1 ? (C = v[P], C = C * N & u | C * M & c, C = C << 15 | C >>> 17, C = C * F & u | C * x & c, I ^= C, I = I << 13 | I >>> 19, I = I * 5 + 3864292196) : (R = v[P], R = R * N & u | R * M & c, R = R << 15 | R >>> 17, R = R * F & u | R * x & c, w ^= R, w = w << 13 | w >>> 19, w = w * 5 + 3864292196);
              switch (C = 0, E) {
                case 3:
                  C ^= _[A * 4 + 2] << 16;
                case 2:
                  C ^= _[A * 4 + 1] << 8;
                case 1:
                  C ^= _[A * 4], C = C * N & u | C * M & c, C = C << 15 | C >>> 17, C = C * F & u | C * x & c, A & 1 ? I ^= C : w ^= C;
              }
              this.h1 = I, this.h2 = w;
            }
            hexdigest() {
              let b = this.h1, _ = this.h2;
              return b ^= _ >>> 1, b = b * 3981806797 & u | b * 36045 & c, _ = _ * 4283543511 & u | ((_ << 16 | b >>> 16) * 2950163797 & u) >>> 16, b ^= _ >>> 1, b = b * 444984403 & u | b * 60499 & c, _ = _ * 3301882366 & u | ((_ << 16 | b >>> 16) * 3120437893 & u) >>> 16, b ^= _ >>> 1, (b >>> 0).toString(16).padStart(8, "0") + (_ >>> 0).toString(16).padStart(8, "0");
            }
          }
          t.MurmurHash3_64 = d;
        },
        /* 9 */
        /***/
        (e, t, r) => {
          var c;
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.FontLoader = t.FontFaceObject = void 0;
          var a = r(1);
          class o {
            constructor({
              ownerDocument: g = globalThis.document,
              styleElement: b = null
            }) {
              we(this, c, /* @__PURE__ */ new Set());
              this._document = g, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
            }
            addNativeFontFace(g) {
              this.nativeFontFaces.add(g), this._document.fonts.add(g);
            }
            removeNativeFontFace(g) {
              this.nativeFontFaces.delete(g), this._document.fonts.delete(g);
            }
            insertRule(g) {
              this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement));
              const b = this.styleElement.sheet;
              b.insertRule(g, b.cssRules.length);
            }
            clear() {
              for (const g of this.nativeFontFaces)
                this._document.fonts.delete(g);
              this.nativeFontFaces.clear(), G(this, c).clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
            }
            async loadSystemFont(g) {
              if (!(!g || G(this, c).has(g.loadedName))) {
                if ((0, a.assert)(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
                  const {
                    loadedName: b,
                    src: _,
                    style: y
                  } = g, A = new FontFace(b, _, y);
                  this.addNativeFontFace(A);
                  try {
                    await A.load(), G(this, c).add(b);
                  } catch {
                    (0, a.warn)(`Cannot load system font: ${g.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(A);
                  }
                  return;
                }
                (0, a.unreachable)("Not implemented: loadSystemFont without the Font Loading API.");
              }
            }
            async bind(g) {
              if (g.attached || g.missingFile && !g.systemFontInfo)
                return;
              if (g.attached = !0, g.systemFontInfo) {
                await this.loadSystemFont(g.systemFontInfo);
                return;
              }
              if (this.isFontLoadingAPISupported) {
                const _ = g.createNativeFontFace();
                if (_) {
                  this.addNativeFontFace(_);
                  try {
                    await _.loaded;
                  } catch (y) {
                    throw (0, a.warn)(`Failed to load font '${_.family}': '${y}'.`), g.disableFontFace = !0, y;
                  }
                }
                return;
              }
              const b = g.createFontFaceRule();
              if (b) {
                if (this.insertRule(b), this.isSyncFontLoadingSupported)
                  return;
                await new Promise((_) => {
                  const y = this._queueLoadingCallback(_);
                  this._prepareFontLoadEvent(g, y);
                });
              }
            }
            get isFontLoadingAPISupported() {
              var b;
              const g = !!((b = this._document) != null && b.fonts);
              return (0, a.shadow)(this, "isFontLoadingAPISupported", g);
            }
            get isSyncFontLoadingSupported() {
              let g = !1;
              return (a.isNodeJS || typeof navigator < "u" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (g = !0), (0, a.shadow)(this, "isSyncFontLoadingSupported", g);
            }
            _queueLoadingCallback(g) {
              function b() {
                for ((0, a.assert)(!y.done, "completeRequest() cannot be called twice."), y.done = !0; _.length > 0 && _[0].done; ) {
                  const A = _.shift();
                  setTimeout(A.callback, 0);
                }
              }
              const {
                loadingRequests: _
              } = this, y = {
                done: !1,
                complete: b,
                callback: g
              };
              return _.push(y), y;
            }
            get _loadTestFont() {
              const g = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
              return (0, a.shadow)(this, "_loadTestFont", g);
            }
            _prepareFontLoadEvent(g, b) {
              function _(B, V) {
                return B.charCodeAt(V) << 24 | B.charCodeAt(V + 1) << 16 | B.charCodeAt(V + 2) << 8 | B.charCodeAt(V + 3) & 255;
              }
              function y(B, V, X, de) {
                const Y = B.substring(0, V), se = B.substring(V + X);
                return Y + de + se;
              }
              let A, E;
              const v = this._document.createElement("canvas");
              v.width = 1, v.height = 1;
              const C = v.getContext("2d");
              let R = 0;
              function I(B, V) {
                if (++R > 30) {
                  (0, a.warn)("Load test font never loaded."), V();
                  return;
                }
                if (C.font = "30px " + B, C.fillText(".", 0, 20), C.getImageData(0, 0, 1, 1).data[3] > 0) {
                  V();
                  return;
                }
                setTimeout(I.bind(null, B, V));
              }
              const w = `lt${Date.now()}${this.loadTestFontId++}`;
              let N = this._loadTestFont;
              N = y(N, 976, w.length, w);
              const M = 16, x = 1482184792;
              let P = _(N, M);
              for (A = 0, E = w.length - 3; A < E; A += 4)
                P = P - x + _(w, A) | 0;
              A < w.length && (P = P - x + _(w + "XXX", A) | 0), N = y(N, M, 4, (0, a.string32)(P));
              const U = `url(data:font/opentype;base64,${btoa(N)});`, L = `@font-face {font-family:"${w}";src:${U}}`;
              this.insertRule(L);
              const H = this._document.createElement("div");
              H.style.visibility = "hidden", H.style.width = H.style.height = "10px", H.style.position = "absolute", H.style.top = H.style.left = "0px";
              for (const B of [g.loadedName, w]) {
                const V = this._document.createElement("span");
                V.textContent = "Hi", V.style.fontFamily = B, H.append(V);
              }
              this._document.body.append(H), I(w, () => {
                H.remove(), b.complete();
              });
            }
          }
          c = new WeakMap(), t.FontLoader = o;
          class u {
            constructor(g, {
              isEvalSupported: b = !0,
              disableFontFace: _ = !1,
              ignoreErrors: y = !1,
              inspectFont: A = null
            }) {
              this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
              for (const E in g)
                this[E] = g[E];
              this.isEvalSupported = b !== !1, this.disableFontFace = _ === !0, this.ignoreErrors = y === !0, this._inspectFont = A;
            }
            createNativeFontFace() {
              var b;
              if (!this.data || this.disableFontFace)
                return null;
              let g;
              if (!this.cssFontInfo)
                g = new FontFace(this.loadedName, this.data, {});
              else {
                const _ = {
                  weight: this.cssFontInfo.fontWeight
                };
                this.cssFontInfo.italicAngle && (_.style = `oblique ${this.cssFontInfo.italicAngle}deg`), g = new FontFace(this.cssFontInfo.fontFamily, this.data, _);
              }
              return (b = this._inspectFont) == null || b.call(this, this), g;
            }
            createFontFaceRule() {
              var y;
              if (!this.data || this.disableFontFace)
                return null;
              const g = (0, a.bytesToString)(this.data), b = `url(data:${this.mimetype};base64,${btoa(g)});`;
              let _;
              if (!this.cssFontInfo)
                _ = `@font-face {font-family:"${this.loadedName}";src:${b}}`;
              else {
                let A = `font-weight: ${this.cssFontInfo.fontWeight};`;
                this.cssFontInfo.italicAngle && (A += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), _ = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${A}src:${b}}`;
              }
              return (y = this._inspectFont) == null || y.call(this, this, b), _;
            }
            getPathGenerator(g, b) {
              if (this.compiledGlyphs[b] !== void 0)
                return this.compiledGlyphs[b];
              let _;
              try {
                _ = g.get(this.loadedName + "_path_" + b);
              } catch (y) {
                if (!this.ignoreErrors)
                  throw y;
                return (0, a.warn)(`getPathGenerator - ignoring character: "${y}".`), this.compiledGlyphs[b] = function(A, E) {
                };
              }
              if (this.isEvalSupported && a.FeatureTest.isEvalSupported) {
                const y = [];
                for (const A of _) {
                  const E = A.args !== void 0 ? A.args.join(",") : "";
                  y.push("c.", A.cmd, "(", E, `);
`);
                }
                return this.compiledGlyphs[b] = new Function("c", "size", y.join(""));
              }
              return this.compiledGlyphs[b] = function(y, A) {
                for (const E of _)
                  E.cmd === "scale" && (E.args = [A, -A]), y[E.cmd].apply(y, E.args);
              };
            }
          }
          t.FontFaceObject = u;
        },
        /* 10 */
        /***/
        (e, t, r) => {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.NodeStandardFontDataFactory = t.NodeFilterFactory = t.NodeCanvasFactory = t.NodeCMapReaderFactory = void 0;
          var a = r(7);
          r(1);
          const o = function(b) {
            return new Promise((_, y) => {
              require$$5.readFile(b, (E, v) => {
                if (E || !v) {
                  y(new Error(E));
                  return;
                }
                _(new Uint8Array(v));
              });
            });
          };
          class u extends a.BaseFilterFactory {
          }
          t.NodeFilterFactory = u;
          class c extends a.BaseCanvasFactory {
            _createCanvas(_, y) {
              return require$$5.createCanvas(_, y);
            }
          }
          t.NodeCanvasFactory = c;
          class d extends a.BaseCMapReaderFactory {
            _fetchData(_, y) {
              return o(_).then((A) => ({
                cMapData: A,
                compressionType: y
              }));
            }
          }
          t.NodeCMapReaderFactory = d;
          class g extends a.BaseStandardFontDataFactory {
            _fetchData(_) {
              return o(_);
            }
          }
          t.NodeStandardFontDataFactory = g;
        },
        /* 11 */
        /***/
        (e, t, r) => {
          var pe, yn, En;
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.CanvasGraphics = void 0;
          var a = r(1), o = r(6), u = r(12), c = r(13);
          const d = 16, g = 100, b = 4096, _ = 15, y = 10, A = 1e3, E = 16;
          function v(Z, O) {
            if (Z._removeMirroring)
              throw new Error("Context is already forwarding operations.");
            Z.__originalSave = Z.save, Z.__originalRestore = Z.restore, Z.__originalRotate = Z.rotate, Z.__originalScale = Z.scale, Z.__originalTranslate = Z.translate, Z.__originalTransform = Z.transform, Z.__originalSetTransform = Z.setTransform, Z.__originalResetTransform = Z.resetTransform, Z.__originalClip = Z.clip, Z.__originalMoveTo = Z.moveTo, Z.__originalLineTo = Z.lineTo, Z.__originalBezierCurveTo = Z.bezierCurveTo, Z.__originalRect = Z.rect, Z.__originalClosePath = Z.closePath, Z.__originalBeginPath = Z.beginPath, Z._removeMirroring = () => {
              Z.save = Z.__originalSave, Z.restore = Z.__originalRestore, Z.rotate = Z.__originalRotate, Z.scale = Z.__originalScale, Z.translate = Z.__originalTranslate, Z.transform = Z.__originalTransform, Z.setTransform = Z.__originalSetTransform, Z.resetTransform = Z.__originalResetTransform, Z.clip = Z.__originalClip, Z.moveTo = Z.__originalMoveTo, Z.lineTo = Z.__originalLineTo, Z.bezierCurveTo = Z.__originalBezierCurveTo, Z.rect = Z.__originalRect, Z.closePath = Z.__originalClosePath, Z.beginPath = Z.__originalBeginPath, delete Z._removeMirroring;
            }, Z.save = function() {
              O.save(), this.__originalSave();
            }, Z.restore = function() {
              O.restore(), this.__originalRestore();
            }, Z.translate = function(W, ee) {
              O.translate(W, ee), this.__originalTranslate(W, ee);
            }, Z.scale = function(W, ee) {
              O.scale(W, ee), this.__originalScale(W, ee);
            }, Z.transform = function(W, ee, ae, ie, me, ye) {
              O.transform(W, ee, ae, ie, me, ye), this.__originalTransform(W, ee, ae, ie, me, ye);
            }, Z.setTransform = function(W, ee, ae, ie, me, ye) {
              O.setTransform(W, ee, ae, ie, me, ye), this.__originalSetTransform(W, ee, ae, ie, me, ye);
            }, Z.resetTransform = function() {
              O.resetTransform(), this.__originalResetTransform();
            }, Z.rotate = function(W) {
              O.rotate(W), this.__originalRotate(W);
            }, Z.clip = function(W) {
              O.clip(W), this.__originalClip(W);
            }, Z.moveTo = function(z, W) {
              O.moveTo(z, W), this.__originalMoveTo(z, W);
            }, Z.lineTo = function(z, W) {
              O.lineTo(z, W), this.__originalLineTo(z, W);
            }, Z.bezierCurveTo = function(z, W, ee, ae, ie, me) {
              O.bezierCurveTo(z, W, ee, ae, ie, me), this.__originalBezierCurveTo(z, W, ee, ae, ie, me);
            }, Z.rect = function(z, W, ee, ae) {
              O.rect(z, W, ee, ae), this.__originalRect(z, W, ee, ae);
            }, Z.closePath = function() {
              O.closePath(), this.__originalClosePath();
            }, Z.beginPath = function() {
              O.beginPath(), this.__originalBeginPath();
            };
          }
          class C {
            constructor(O) {
              this.canvasFactory = O, this.cache = /* @__PURE__ */ Object.create(null);
            }
            getCanvas(O, z, W) {
              let ee;
              return this.cache[O] !== void 0 ? (ee = this.cache[O], this.canvasFactory.reset(ee, z, W)) : (ee = this.canvasFactory.create(z, W), this.cache[O] = ee), ee;
            }
            delete(O) {
              delete this.cache[O];
            }
            clear() {
              for (const O in this.cache) {
                const z = this.cache[O];
                this.canvasFactory.destroy(z), delete this.cache[O];
              }
            }
          }
          function R(Z, O, z, W, ee, ae, ie, me, ye, Re) {
            const [De, Pe, he, Le, Ee, Se] = (0, o.getCurrentTransform)(Z);
            if (Pe === 0 && he === 0) {
              const fe = ie * De + Ee, be = Math.round(fe), ke = me * Le + Se, Fe = Math.round(ke), Be = (ie + ye) * De + Ee, te = Math.abs(Math.round(Be) - be) || 1, Ce = (me + Re) * Le + Se, Me = Math.abs(Math.round(Ce) - Fe) || 1;
              return Z.setTransform(Math.sign(De), 0, 0, Math.sign(Le), be, Fe), Z.drawImage(O, z, W, ee, ae, 0, 0, te, Me), Z.setTransform(De, Pe, he, Le, Ee, Se), [te, Me];
            }
            if (De === 0 && Le === 0) {
              const fe = me * he + Ee, be = Math.round(fe), ke = ie * Pe + Se, Fe = Math.round(ke), Be = (me + Re) * he + Ee, te = Math.abs(Math.round(Be) - be) || 1, Ce = (ie + ye) * Pe + Se, Me = Math.abs(Math.round(Ce) - Fe) || 1;
              return Z.setTransform(0, Math.sign(Pe), Math.sign(he), 0, be, Fe), Z.drawImage(O, z, W, ee, ae, 0, 0, Me, te), Z.setTransform(De, Pe, he, Le, Ee, Se), [Me, te];
            }
            Z.drawImage(O, z, W, ee, ae, ie, me, ye, Re);
            const Q = Math.hypot(De, Pe), K = Math.hypot(he, Le);
            return [Q * ye, K * Re];
          }
          function I(Z) {
            const {
              width: O,
              height: z
            } = Z;
            if (O > A || z > A)
              return null;
            const W = 1e3, ee = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), ae = O + 1;
            let ie = new Uint8Array(ae * (z + 1)), me, ye, Re;
            const De = O + 7 & -8;
            let Pe = new Uint8Array(De * z), he = 0;
            for (const K of Z.data) {
              let fe = 128;
              for (; fe > 0; )
                Pe[he++] = K & fe ? 0 : 255, fe >>= 1;
            }
            let Le = 0;
            for (he = 0, Pe[he] !== 0 && (ie[0] = 1, ++Le), ye = 1; ye < O; ye++)
              Pe[he] !== Pe[he + 1] && (ie[ye] = Pe[he] ? 2 : 1, ++Le), he++;
            for (Pe[he] !== 0 && (ie[ye] = 2, ++Le), me = 1; me < z; me++) {
              he = me * De, Re = me * ae, Pe[he - De] !== Pe[he] && (ie[Re] = Pe[he] ? 1 : 8, ++Le);
              let K = (Pe[he] ? 4 : 0) + (Pe[he - De] ? 8 : 0);
              for (ye = 1; ye < O; ye++)
                K = (K >> 2) + (Pe[he + 1] ? 4 : 0) + (Pe[he - De + 1] ? 8 : 0), ee[K] && (ie[Re + ye] = ee[K], ++Le), he++;
              if (Pe[he - De] !== Pe[he] && (ie[Re + ye] = Pe[he] ? 2 : 4, ++Le), Le > W)
                return null;
            }
            for (he = De * (z - 1), Re = me * ae, Pe[he] !== 0 && (ie[Re] = 8, ++Le), ye = 1; ye < O; ye++)
              Pe[he] !== Pe[he + 1] && (ie[Re + ye] = Pe[he] ? 4 : 8, ++Le), he++;
            if (Pe[he] !== 0 && (ie[Re + ye] = 4, ++Le), Le > W)
              return null;
            const Ee = new Int32Array([0, ae, -1, 0, -ae, 0, 0, 0, 1]), Se = new Path2D();
            for (me = 0; Le && me <= z; me++) {
              let K = me * ae;
              const fe = K + O;
              for (; K < fe && !ie[K]; )
                K++;
              if (K === fe)
                continue;
              Se.moveTo(K % ae, me);
              const be = K;
              let ke = ie[K];
              do {
                const Fe = Ee[ke];
                do
                  K += Fe;
                while (!ie[K]);
                const Be = ie[K];
                Be !== 5 && Be !== 10 ? (ke = Be, ie[K] = 0) : (ke = Be & 51 * ke >> 4, ie[K] &= ke >> 2 | ke << 2), Se.lineTo(K % ae, K / ae | 0), ie[K] || --Le;
              } while (be !== K);
              --me;
            }
            return Pe = null, ie = null, function(K) {
              K.save(), K.scale(1 / O, -1 / z), K.translate(0, -z), K.fill(Se), K.beginPath(), K.restore();
            };
          }
          class w {
            constructor(O, z) {
              this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = a.IDENTITY_MATRIX, this.textMatrixScale = 1, this.fontMatrix = a.FONT_IDENTITY_MATRIX, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = a.TextRenderingMode.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, O, z]);
            }
            clone() {
              const O = Object.create(this);
              return O.clipBox = this.clipBox.slice(), O;
            }
            setCurrentPoint(O, z) {
              this.x = O, this.y = z;
            }
            updatePathMinMax(O, z, W) {
              [z, W] = a.Util.applyTransform([z, W], O), this.minX = Math.min(this.minX, z), this.minY = Math.min(this.minY, W), this.maxX = Math.max(this.maxX, z), this.maxY = Math.max(this.maxY, W);
            }
            updateRectMinMax(O, z) {
              const W = a.Util.applyTransform(z, O), ee = a.Util.applyTransform(z.slice(2), O);
              this.minX = Math.min(this.minX, W[0], ee[0]), this.minY = Math.min(this.minY, W[1], ee[1]), this.maxX = Math.max(this.maxX, W[0], ee[0]), this.maxY = Math.max(this.maxY, W[1], ee[1]);
            }
            updateScalingPathMinMax(O, z) {
              a.Util.scaleMinMax(O, z), this.minX = Math.min(this.minX, z[0]), this.maxX = Math.max(this.maxX, z[1]), this.minY = Math.min(this.minY, z[2]), this.maxY = Math.max(this.maxY, z[3]);
            }
            updateCurvePathMinMax(O, z, W, ee, ae, ie, me, ye, Re, De) {
              const Pe = a.Util.bezierBoundingBox(z, W, ee, ae, ie, me, ye, Re);
              if (De) {
                De[0] = Math.min(De[0], Pe[0], Pe[2]), De[1] = Math.max(De[1], Pe[0], Pe[2]), De[2] = Math.min(De[2], Pe[1], Pe[3]), De[3] = Math.max(De[3], Pe[1], Pe[3]);
                return;
              }
              this.updateRectMinMax(O, Pe);
            }
            getPathBoundingBox(O = u.PathType.FILL, z = null) {
              const W = [this.minX, this.minY, this.maxX, this.maxY];
              if (O === u.PathType.STROKE) {
                z || (0, a.unreachable)("Stroke bounding box must include transform.");
                const ee = a.Util.singularValueDecompose2dScale(z), ae = ee[0] * this.lineWidth / 2, ie = ee[1] * this.lineWidth / 2;
                W[0] -= ae, W[1] -= ie, W[2] += ae, W[3] += ie;
              }
              return W;
            }
            updateClipFromPath() {
              const O = a.Util.intersect(this.clipBox, this.getPathBoundingBox());
              this.startNewPathAndClipBox(O || [0, 0, 0, 0]);
            }
            isEmptyClip() {
              return this.minX === 1 / 0;
            }
            startNewPathAndClipBox(O) {
              this.clipBox = O, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
            }
            getClippedPathBoundingBox(O = u.PathType.FILL, z = null) {
              return a.Util.intersect(this.clipBox, this.getPathBoundingBox(O, z));
            }
          }
          function N(Z, O) {
            if (typeof ImageData < "u" && O instanceof ImageData) {
              Z.putImageData(O, 0, 0);
              return;
            }
            const z = O.height, W = O.width, ee = z % E, ae = (z - ee) / E, ie = ee === 0 ? ae : ae + 1, me = Z.createImageData(W, E);
            let ye = 0, Re;
            const De = O.data, Pe = me.data;
            let he, Le, Ee, Se;
            if (O.kind === a.ImageKind.GRAYSCALE_1BPP) {
              const Q = De.byteLength, K = new Uint32Array(Pe.buffer, 0, Pe.byteLength >> 2), fe = K.length, be = W + 7 >> 3, ke = 4294967295, Fe = a.FeatureTest.isLittleEndian ? 4278190080 : 255;
              for (he = 0; he < ie; he++) {
                for (Ee = he < ae ? E : ee, Re = 0, Le = 0; Le < Ee; Le++) {
                  const Be = Q - ye;
                  let te = 0;
                  const Ce = Be > be ? W : Be * 8 - 7, Me = Ce & -8;
                  let Ve = 0, je = 0;
                  for (; te < Me; te += 8)
                    je = De[ye++], K[Re++] = je & 128 ? ke : Fe, K[Re++] = je & 64 ? ke : Fe, K[Re++] = je & 32 ? ke : Fe, K[Re++] = je & 16 ? ke : Fe, K[Re++] = je & 8 ? ke : Fe, K[Re++] = je & 4 ? ke : Fe, K[Re++] = je & 2 ? ke : Fe, K[Re++] = je & 1 ? ke : Fe;
                  for (; te < Ce; te++)
                    Ve === 0 && (je = De[ye++], Ve = 128), K[Re++] = je & Ve ? ke : Fe, Ve >>= 1;
                }
                for (; Re < fe; )
                  K[Re++] = 0;
                Z.putImageData(me, 0, he * E);
              }
            } else if (O.kind === a.ImageKind.RGBA_32BPP) {
              for (Le = 0, Se = W * E * 4, he = 0; he < ae; he++)
                Pe.set(De.subarray(ye, ye + Se)), ye += Se, Z.putImageData(me, 0, Le), Le += E;
              he < ie && (Se = W * ee * 4, Pe.set(De.subarray(ye, ye + Se)), Z.putImageData(me, 0, Le));
            } else if (O.kind === a.ImageKind.RGB_24BPP)
              for (Ee = E, Se = W * Ee, he = 0; he < ie; he++) {
                for (he >= ae && (Ee = ee, Se = W * Ee), Re = 0, Le = Se; Le--; )
                  Pe[Re++] = De[ye++], Pe[Re++] = De[ye++], Pe[Re++] = De[ye++], Pe[Re++] = 255;
                Z.putImageData(me, 0, he * E);
              }
            else
              throw new Error(`bad image kind: ${O.kind}`);
          }
          function F(Z, O) {
            if (O.bitmap) {
              Z.drawImage(O.bitmap, 0, 0);
              return;
            }
            const z = O.height, W = O.width, ee = z % E, ae = (z - ee) / E, ie = ee === 0 ? ae : ae + 1, me = Z.createImageData(W, E);
            let ye = 0;
            const Re = O.data, De = me.data;
            for (let Pe = 0; Pe < ie; Pe++) {
              const he = Pe < ae ? E : ee;
              ({
                srcPos: ye
              } = (0, c.convertBlackAndWhiteToRGBA)({
                src: Re,
                srcPos: ye,
                dest: De,
                width: W,
                height: he,
                nonBlackColor: 0
              })), Z.putImageData(me, 0, Pe * E);
            }
          }
          function M(Z, O) {
            const z = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
            for (const W of z)
              Z[W] !== void 0 && (O[W] = Z[W]);
            Z.setLineDash !== void 0 && (O.setLineDash(Z.getLineDash()), O.lineDashOffset = Z.lineDashOffset);
          }
          function x(Z) {
            if (Z.strokeStyle = Z.fillStyle = "#000000", Z.fillRule = "nonzero", Z.globalAlpha = 1, Z.lineWidth = 1, Z.lineCap = "butt", Z.lineJoin = "miter", Z.miterLimit = 10, Z.globalCompositeOperation = "source-over", Z.font = "10px sans-serif", Z.setLineDash !== void 0 && (Z.setLineDash([]), Z.lineDashOffset = 0), !a.isNodeJS) {
              const {
                filter: O
              } = Z;
              O !== "none" && O !== "" && (Z.filter = "none");
            }
          }
          function P(Z, O, z, W) {
            const ee = Z.length;
            for (let ae = 3; ae < ee; ae += 4) {
              const ie = Z[ae];
              if (ie === 0)
                Z[ae - 3] = O, Z[ae - 2] = z, Z[ae - 1] = W;
              else if (ie < 255) {
                const me = 255 - ie;
                Z[ae - 3] = Z[ae - 3] * ie + O * me >> 8, Z[ae - 2] = Z[ae - 2] * ie + z * me >> 8, Z[ae - 1] = Z[ae - 1] * ie + W * me >> 8;
              }
            }
          }
          function U(Z, O, z) {
            const W = Z.length, ee = 1 / 255;
            for (let ae = 3; ae < W; ae += 4) {
              const ie = z ? z[Z[ae]] : Z[ae];
              O[ae] = O[ae] * ie * ee | 0;
            }
          }
          function L(Z, O, z) {
            const W = Z.length;
            for (let ee = 3; ee < W; ee += 4) {
              const ae = Z[ee - 3] * 77 + Z[ee - 2] * 152 + Z[ee - 1] * 28;
              O[ee] = z ? O[ee] * z[ae >> 8] >> 8 : O[ee] * ae >> 16;
            }
          }
          function H(Z, O, z, W, ee, ae, ie, me, ye, Re, De) {
            const Pe = !!ae, he = Pe ? ae[0] : 0, Le = Pe ? ae[1] : 0, Ee = Pe ? ae[2] : 0, Se = ee === "Luminosity" ? L : U, K = Math.min(W, Math.ceil(1048576 / z));
            for (let fe = 0; fe < W; fe += K) {
              const be = Math.min(K, W - fe), ke = Z.getImageData(me - Re, fe + (ye - De), z, be), Fe = O.getImageData(me, fe + ye, z, be);
              Pe && P(ke.data, he, Le, Ee), Se(ke.data, Fe.data, ie), O.putImageData(Fe, me, fe + ye);
            }
          }
          function B(Z, O, z, W) {
            const ee = W[0], ae = W[1], ie = W[2] - ee, me = W[3] - ae;
            ie === 0 || me === 0 || (H(O.context, z, ie, me, O.subtype, O.backdrop, O.transferMap, ee, ae, O.offsetX, O.offsetY), Z.save(), Z.globalAlpha = 1, Z.globalCompositeOperation = "source-over", Z.setTransform(1, 0, 0, 1, 0, 0), Z.drawImage(z.canvas, 0, 0), Z.restore());
          }
          function V(Z, O) {
            const z = a.Util.singularValueDecompose2dScale(Z);
            z[0] = Math.fround(z[0]), z[1] = Math.fround(z[1]);
            const W = Math.fround((globalThis.devicePixelRatio || 1) * o.PixelsPerInch.PDF_TO_CSS_UNITS);
            return O !== void 0 ? O : z[0] <= W || z[1] <= W;
          }
          const X = ["butt", "round", "square"], de = ["miter", "round", "bevel"], Y = {}, se = {}, le = class le {
            constructor(O, z, W, ee, ae, {
              optionalContentConfig: ie,
              markedContentStack: me = null
            }, ye, Re) {
              we(this, pe);
              this.ctx = O, this.current = new w(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = z, this.objs = W, this.canvasFactory = ee, this.filterFactory = ae, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = me || [], this.optionalContentConfig = ie, this.cachedCanvases = new C(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = ye, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = Re, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
            }
            getObject(O, z = null) {
              return typeof O == "string" ? O.startsWith("g_") ? this.commonObjs.get(O) : this.objs.get(O) : z;
            }
            beginDrawing({
              transform: O,
              viewport: z,
              transparency: W = !1,
              background: ee = null
            }) {
              const ae = this.ctx.canvas.width, ie = this.ctx.canvas.height, me = this.ctx.fillStyle;
              if (this.ctx.fillStyle = ee || "#ffffff", this.ctx.fillRect(0, 0, ae, ie), this.ctx.fillStyle = me, W) {
                const ye = this.cachedCanvases.getCanvas("transparent", ae, ie);
                this.compositeCtx = this.ctx, this.transparentCanvas = ye.canvas, this.ctx = ye.context, this.ctx.save(), this.ctx.transform(...(0, o.getCurrentTransform)(this.compositeCtx));
              }
              this.ctx.save(), x(this.ctx), O && (this.ctx.transform(...O), this.outputScaleX = O[0], this.outputScaleY = O[0]), this.ctx.transform(...z.transform), this.viewportScale = z.scale, this.baseTransform = (0, o.getCurrentTransform)(this.ctx);
            }
            executeOperatorList(O, z, W, ee) {
              const ae = O.argsArray, ie = O.fnArray;
              let me = z || 0;
              const ye = ae.length;
              if (ye === me)
                return me;
              const Re = ye - me > y && typeof W == "function", De = Re ? Date.now() + _ : 0;
              let Pe = 0;
              const he = this.commonObjs, Le = this.objs;
              let Ee;
              for (; ; ) {
                if (ee !== void 0 && me === ee.nextBreakPoint)
                  return ee.breakIt(me, W), me;
                if (Ee = ie[me], Ee !== a.OPS.dependency)
                  this[Ee].apply(this, ae[me]);
                else
                  for (const Se of ae[me]) {
                    const Q = Se.startsWith("g_") ? he : Le;
                    if (!Q.has(Se))
                      return Q.get(Se, W), me;
                  }
                if (me++, me === ye)
                  return me;
                if (Re && ++Pe > y) {
                  if (Date.now() > De)
                    return W(), me;
                  Pe = 0;
                }
              }
            }
            endDrawing() {
              _e(this, pe, yn).call(this), this.cachedCanvases.clear(), this.cachedPatterns.clear();
              for (const O of this._cachedBitmapsMap.values()) {
                for (const z of O.values())
                  typeof HTMLCanvasElement < "u" && z instanceof HTMLCanvasElement && (z.width = z.height = 0);
                O.clear();
              }
              this._cachedBitmapsMap.clear(), _e(this, pe, En).call(this);
            }
            _scaleImage(O, z) {
              const W = O.width, ee = O.height;
              let ae = Math.max(Math.hypot(z[0], z[1]), 1), ie = Math.max(Math.hypot(z[2], z[3]), 1), me = W, ye = ee, Re = "prescale1", De, Pe;
              for (; ae > 2 && me > 1 || ie > 2 && ye > 1; ) {
                let he = me, Le = ye;
                ae > 2 && me > 1 && (he = me >= 16384 ? Math.floor(me / 2) - 1 || 1 : Math.ceil(me / 2), ae /= me / he), ie > 2 && ye > 1 && (Le = ye >= 16384 ? Math.floor(ye / 2) - 1 || 1 : Math.ceil(ye) / 2, ie /= ye / Le), De = this.cachedCanvases.getCanvas(Re, he, Le), Pe = De.context, Pe.clearRect(0, 0, he, Le), Pe.drawImage(O, 0, 0, me, ye, 0, 0, he, Le), O = De.canvas, me = he, ye = Le, Re = Re === "prescale1" ? "prescale2" : "prescale1";
              }
              return {
                img: O,
                paintWidth: me,
                paintHeight: ye
              };
            }
            _createMaskCanvas(O) {
              const z = this.ctx, {
                width: W,
                height: ee
              } = O, ae = this.current.fillColor, ie = this.current.patternFill, me = (0, o.getCurrentTransform)(z);
              let ye, Re, De, Pe;
              if ((O.bitmap || O.data) && O.count > 1) {
                const te = O.bitmap || O.data.buffer;
                Re = JSON.stringify(ie ? me : [me.slice(0, 4), ae]), ye = this._cachedBitmapsMap.get(te), ye || (ye = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(te, ye));
                const Ce = ye.get(Re);
                if (Ce && !ie) {
                  const Me = Math.round(Math.min(me[0], me[2]) + me[4]), Ve = Math.round(Math.min(me[1], me[3]) + me[5]);
                  return {
                    canvas: Ce,
                    offsetX: Me,
                    offsetY: Ve
                  };
                }
                De = Ce;
              }
              De || (Pe = this.cachedCanvases.getCanvas("maskCanvas", W, ee), F(Pe.context, O));
              let he = a.Util.transform(me, [1 / W, 0, 0, -1 / ee, 0, 0]);
              he = a.Util.transform(he, [1, 0, 0, 1, 0, -ee]);
              const Le = a.Util.applyTransform([0, 0], he), Ee = a.Util.applyTransform([W, ee], he), Se = a.Util.normalizeRect([Le[0], Le[1], Ee[0], Ee[1]]), Q = Math.round(Se[2] - Se[0]) || 1, K = Math.round(Se[3] - Se[1]) || 1, fe = this.cachedCanvases.getCanvas("fillCanvas", Q, K), be = fe.context, ke = Math.min(Le[0], Ee[0]), Fe = Math.min(Le[1], Ee[1]);
              be.translate(-ke, -Fe), be.transform(...he), De || (De = this._scaleImage(Pe.canvas, (0, o.getCurrentTransformInverse)(be)), De = De.img, ye && ie && ye.set(Re, De)), be.imageSmoothingEnabled = V((0, o.getCurrentTransform)(be), O.interpolate), R(be, De, 0, 0, De.width, De.height, 0, 0, W, ee), be.globalCompositeOperation = "source-in";
              const Be = a.Util.transform((0, o.getCurrentTransformInverse)(be), [1, 0, 0, 1, -ke, -Fe]);
              return be.fillStyle = ie ? ae.getPattern(z, this, Be, u.PathType.FILL) : ae, be.fillRect(0, 0, W, ee), ye && !ie && (this.cachedCanvases.delete("fillCanvas"), ye.set(Re, fe.canvas)), {
                canvas: fe.canvas,
                offsetX: Math.round(ke),
                offsetY: Math.round(Fe)
              };
            }
            setLineWidth(O) {
              O !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = O, this.ctx.lineWidth = O;
            }
            setLineCap(O) {
              this.ctx.lineCap = X[O];
            }
            setLineJoin(O) {
              this.ctx.lineJoin = de[O];
            }
            setMiterLimit(O) {
              this.ctx.miterLimit = O;
            }
            setDash(O, z) {
              const W = this.ctx;
              W.setLineDash !== void 0 && (W.setLineDash(O), W.lineDashOffset = z);
            }
            setRenderingIntent(O) {
            }
            setFlatness(O) {
            }
            setGState(O) {
              for (const [z, W] of O)
                switch (z) {
                  case "LW":
                    this.setLineWidth(W);
                    break;
                  case "LC":
                    this.setLineCap(W);
                    break;
                  case "LJ":
                    this.setLineJoin(W);
                    break;
                  case "ML":
                    this.setMiterLimit(W);
                    break;
                  case "D":
                    this.setDash(W[0], W[1]);
                    break;
                  case "RI":
                    this.setRenderingIntent(W);
                    break;
                  case "FL":
                    this.setFlatness(W);
                    break;
                  case "Font":
                    this.setFont(W[0], W[1]);
                    break;
                  case "CA":
                    this.current.strokeAlpha = W;
                    break;
                  case "ca":
                    this.current.fillAlpha = W, this.ctx.globalAlpha = W;
                    break;
                  case "BM":
                    this.ctx.globalCompositeOperation = W;
                    break;
                  case "SMask":
                    this.current.activeSMask = W ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
                    break;
                  case "TR":
                    this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(W);
                    break;
                }
            }
            get inSMaskMode() {
              return !!this.suspendedCtx;
            }
            checkSMaskState() {
              const O = this.inSMaskMode;
              this.current.activeSMask && !O ? this.beginSMaskMode() : !this.current.activeSMask && O && this.endSMaskMode();
            }
            beginSMaskMode() {
              if (this.inSMaskMode)
                throw new Error("beginSMaskMode called while already in smask mode");
              const O = this.ctx.canvas.width, z = this.ctx.canvas.height, W = "smaskGroupAt" + this.groupLevel, ee = this.cachedCanvases.getCanvas(W, O, z);
              this.suspendedCtx = this.ctx, this.ctx = ee.context;
              const ae = this.ctx;
              ae.setTransform(...(0, o.getCurrentTransform)(this.suspendedCtx)), M(this.suspendedCtx, ae), v(ae, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
            }
            endSMaskMode() {
              if (!this.inSMaskMode)
                throw new Error("endSMaskMode called while not in smask mode");
              this.ctx._removeMirroring(), M(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
            }
            compose(O) {
              if (!this.current.activeSMask)
                return;
              O ? (O[0] = Math.floor(O[0]), O[1] = Math.floor(O[1]), O[2] = Math.ceil(O[2]), O[3] = Math.ceil(O[3])) : O = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
              const z = this.current.activeSMask, W = this.suspendedCtx;
              B(W, z, this.ctx, O), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
            }
            save() {
              this.inSMaskMode ? (M(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
              const O = this.current;
              this.stateStack.push(O), this.current = O.clone();
            }
            restore() {
              this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), M(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null);
            }
            transform(O, z, W, ee, ae, ie) {
              this.ctx.transform(O, z, W, ee, ae, ie), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
            }
            constructPath(O, z, W) {
              const ee = this.ctx, ae = this.current;
              let ie = ae.x, me = ae.y, ye, Re;
              const De = (0, o.getCurrentTransform)(ee), Pe = De[0] === 0 && De[3] === 0 || De[1] === 0 && De[2] === 0, he = Pe ? W.slice(0) : null;
              for (let Le = 0, Ee = 0, Se = O.length; Le < Se; Le++)
                switch (O[Le] | 0) {
                  case a.OPS.rectangle:
                    ie = z[Ee++], me = z[Ee++];
                    const Q = z[Ee++], K = z[Ee++], fe = ie + Q, be = me + K;
                    ee.moveTo(ie, me), Q === 0 || K === 0 ? ee.lineTo(fe, be) : (ee.lineTo(fe, me), ee.lineTo(fe, be), ee.lineTo(ie, be)), Pe || ae.updateRectMinMax(De, [ie, me, fe, be]), ee.closePath();
                    break;
                  case a.OPS.moveTo:
                    ie = z[Ee++], me = z[Ee++], ee.moveTo(ie, me), Pe || ae.updatePathMinMax(De, ie, me);
                    break;
                  case a.OPS.lineTo:
                    ie = z[Ee++], me = z[Ee++], ee.lineTo(ie, me), Pe || ae.updatePathMinMax(De, ie, me);
                    break;
                  case a.OPS.curveTo:
                    ye = ie, Re = me, ie = z[Ee + 4], me = z[Ee + 5], ee.bezierCurveTo(z[Ee], z[Ee + 1], z[Ee + 2], z[Ee + 3], ie, me), ae.updateCurvePathMinMax(De, ye, Re, z[Ee], z[Ee + 1], z[Ee + 2], z[Ee + 3], ie, me, he), Ee += 6;
                    break;
                  case a.OPS.curveTo2:
                    ye = ie, Re = me, ee.bezierCurveTo(ie, me, z[Ee], z[Ee + 1], z[Ee + 2], z[Ee + 3]), ae.updateCurvePathMinMax(De, ye, Re, ie, me, z[Ee], z[Ee + 1], z[Ee + 2], z[Ee + 3], he), ie = z[Ee + 2], me = z[Ee + 3], Ee += 4;
                    break;
                  case a.OPS.curveTo3:
                    ye = ie, Re = me, ie = z[Ee + 2], me = z[Ee + 3], ee.bezierCurveTo(z[Ee], z[Ee + 1], ie, me, ie, me), ae.updateCurvePathMinMax(De, ye, Re, z[Ee], z[Ee + 1], ie, me, ie, me, he), Ee += 4;
                    break;
                  case a.OPS.closePath:
                    ee.closePath();
                    break;
                }
              Pe && ae.updateScalingPathMinMax(De, he), ae.setCurrentPoint(ie, me);
            }
            closePath() {
              this.ctx.closePath();
            }
            stroke(O = !0) {
              const z = this.ctx, W = this.current.strokeColor;
              z.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof W == "object" && (W != null && W.getPattern) ? (z.save(), z.strokeStyle = W.getPattern(z, this, (0, o.getCurrentTransformInverse)(z), u.PathType.STROKE), this.rescaleAndStroke(!1), z.restore()) : this.rescaleAndStroke(!0)), O && this.consumePath(this.current.getClippedPathBoundingBox()), z.globalAlpha = this.current.fillAlpha;
            }
            closeStroke() {
              this.closePath(), this.stroke();
            }
            fill(O = !0) {
              const z = this.ctx, W = this.current.fillColor, ee = this.current.patternFill;
              let ae = !1;
              ee && (z.save(), z.fillStyle = W.getPattern(z, this, (0, o.getCurrentTransformInverse)(z), u.PathType.FILL), ae = !0);
              const ie = this.current.getClippedPathBoundingBox();
              this.contentVisible && ie !== null && (this.pendingEOFill ? (z.fill("evenodd"), this.pendingEOFill = !1) : z.fill()), ae && z.restore(), O && this.consumePath(ie);
            }
            eoFill() {
              this.pendingEOFill = !0, this.fill();
            }
            fillStroke() {
              this.fill(!1), this.stroke(!1), this.consumePath();
            }
            eoFillStroke() {
              this.pendingEOFill = !0, this.fillStroke();
            }
            closeFillStroke() {
              this.closePath(), this.fillStroke();
            }
            closeEOFillStroke() {
              this.pendingEOFill = !0, this.closePath(), this.fillStroke();
            }
            endPath() {
              this.consumePath();
            }
            clip() {
              this.pendingClip = Y;
            }
            eoClip() {
              this.pendingClip = se;
            }
            beginText() {
              this.current.textMatrix = a.IDENTITY_MATRIX, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
            }
            endText() {
              const O = this.pendingTextPaths, z = this.ctx;
              if (O === void 0) {
                z.beginPath();
                return;
              }
              z.save(), z.beginPath();
              for (const W of O)
                z.setTransform(...W.transform), z.translate(W.x, W.y), W.addToPath(z, W.fontSize);
              z.restore(), z.clip(), z.beginPath(), delete this.pendingTextPaths;
            }
            setCharSpacing(O) {
              this.current.charSpacing = O;
            }
            setWordSpacing(O) {
              this.current.wordSpacing = O;
            }
            setHScale(O) {
              this.current.textHScale = O / 100;
            }
            setLeading(O) {
              this.current.leading = -O;
            }
            setFont(O, z) {
              var De;
              const W = this.commonObjs.get(O), ee = this.current;
              if (!W)
                throw new Error(`Can't find font for ${O}`);
              if (ee.fontMatrix = W.fontMatrix || a.FONT_IDENTITY_MATRIX, (ee.fontMatrix[0] === 0 || ee.fontMatrix[3] === 0) && (0, a.warn)("Invalid font matrix for font " + O), z < 0 ? (z = -z, ee.fontDirection = -1) : ee.fontDirection = 1, this.current.font = W, this.current.fontSize = z, W.isType3Font)
                return;
              const ae = W.loadedName || "sans-serif", ie = ((De = W.systemFontInfo) == null ? void 0 : De.css) || `"${ae}", ${W.fallbackName}`;
              let me = "normal";
              W.black ? me = "900" : W.bold && (me = "bold");
              const ye = W.italic ? "italic" : "normal";
              let Re = z;
              z < d ? Re = d : z > g && (Re = g), this.current.fontSizeScale = z / Re, this.ctx.font = `${ye} ${me} ${Re}px ${ie}`;
            }
            setTextRenderingMode(O) {
              this.current.textRenderingMode = O;
            }
            setTextRise(O) {
              this.current.textRise = O;
            }
            moveText(O, z) {
              this.current.x = this.current.lineX += O, this.current.y = this.current.lineY += z;
            }
            setLeadingMoveText(O, z) {
              this.setLeading(-z), this.moveText(O, z);
            }
            setTextMatrix(O, z, W, ee, ae, ie) {
              this.current.textMatrix = [O, z, W, ee, ae, ie], this.current.textMatrixScale = Math.hypot(O, z), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
            }
            nextLine() {
              this.moveText(0, this.current.leading);
            }
            paintChar(O, z, W, ee) {
              const ae = this.ctx, ie = this.current, me = ie.font, ye = ie.textRenderingMode, Re = ie.fontSize / ie.fontSizeScale, De = ye & a.TextRenderingMode.FILL_STROKE_MASK, Pe = !!(ye & a.TextRenderingMode.ADD_TO_PATH_FLAG), he = ie.patternFill && !me.missingFile;
              let Le;
              (me.disableFontFace || Pe || he) && (Le = me.getPathGenerator(this.commonObjs, O)), me.disableFontFace || he ? (ae.save(), ae.translate(z, W), ae.beginPath(), Le(ae, Re), ee && ae.setTransform(...ee), (De === a.TextRenderingMode.FILL || De === a.TextRenderingMode.FILL_STROKE) && ae.fill(), (De === a.TextRenderingMode.STROKE || De === a.TextRenderingMode.FILL_STROKE) && ae.stroke(), ae.restore()) : ((De === a.TextRenderingMode.FILL || De === a.TextRenderingMode.FILL_STROKE) && ae.fillText(O, z, W), (De === a.TextRenderingMode.STROKE || De === a.TextRenderingMode.FILL_STROKE) && ae.strokeText(O, z, W)), Pe && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
                transform: (0, o.getCurrentTransform)(ae),
                x: z,
                y: W,
                fontSize: Re,
                addToPath: Le
              });
            }
            get isFontSubpixelAAEnabled() {
              const {
                context: O
              } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
              O.scale(1.5, 1), O.fillText("I", 0, 10);
              const z = O.getImageData(0, 0, 10, 10).data;
              let W = !1;
              for (let ee = 3; ee < z.length; ee += 4)
                if (z[ee] > 0 && z[ee] < 255) {
                  W = !0;
                  break;
                }
              return (0, a.shadow)(this, "isFontSubpixelAAEnabled", W);
            }
            showText(O) {
              const z = this.current, W = z.font;
              if (W.isType3Font)
                return this.showType3Text(O);
              const ee = z.fontSize;
              if (ee === 0)
                return;
              const ae = this.ctx, ie = z.fontSizeScale, me = z.charSpacing, ye = z.wordSpacing, Re = z.fontDirection, De = z.textHScale * Re, Pe = O.length, he = W.vertical, Le = he ? 1 : -1, Ee = W.defaultVMetrics, Se = ee * z.fontMatrix[0], Q = z.textRenderingMode === a.TextRenderingMode.FILL && !W.disableFontFace && !z.patternFill;
              ae.save(), ae.transform(...z.textMatrix), ae.translate(z.x, z.y + z.textRise), Re > 0 ? ae.scale(De, -1) : ae.scale(De, 1);
              let K;
              if (z.patternFill) {
                ae.save();
                const Be = z.fillColor.getPattern(ae, this, (0, o.getCurrentTransformInverse)(ae), u.PathType.FILL);
                K = (0, o.getCurrentTransform)(ae), ae.restore(), ae.fillStyle = Be;
              }
              let fe = z.lineWidth;
              const be = z.textMatrixScale;
              if (be === 0 || fe === 0) {
                const Be = z.textRenderingMode & a.TextRenderingMode.FILL_STROKE_MASK;
                (Be === a.TextRenderingMode.STROKE || Be === a.TextRenderingMode.FILL_STROKE) && (fe = this.getSinglePixelWidth());
              } else
                fe /= be;
              if (ie !== 1 && (ae.scale(ie, ie), fe /= ie), ae.lineWidth = fe, W.isInvalidPDFjsFont) {
                const Be = [];
                let te = 0;
                for (const Ce of O)
                  Be.push(Ce.unicode), te += Ce.width;
                ae.fillText(Be.join(""), 0, 0), z.x += te * Se * De, ae.restore(), this.compose();
                return;
              }
              let ke = 0, Fe;
              for (Fe = 0; Fe < Pe; ++Fe) {
                const Be = O[Fe];
                if (typeof Be == "number") {
                  ke += Le * Be * ee / 1e3;
                  continue;
                }
                let te = !1;
                const Ce = (Be.isSpace ? ye : 0) + me, Me = Be.fontChar, Ve = Be.accent;
                let je, ot, We = Be.width;
                if (he) {
                  const ut = Be.vmetric || Ee, ct = -(Be.vmetric ? ut[1] : We * 0.5) * Se, $e = ut[2] * Se;
                  We = ut ? -ut[0] : We, je = ct / ie, ot = (ke + $e) / ie;
                } else
                  je = ke / ie, ot = 0;
                if (W.remeasure && We > 0) {
                  const ut = ae.measureText(Me).width * 1e3 / ee * ie;
                  if (We < ut && this.isFontSubpixelAAEnabled) {
                    const ct = We / ut;
                    te = !0, ae.save(), ae.scale(ct, 1), je /= ct;
                  } else We !== ut && (je += (We - ut) / 2e3 * ee / ie);
                }
                if (this.contentVisible && (Be.isInFont || W.missingFile)) {
                  if (Q && !Ve)
                    ae.fillText(Me, je, ot);
                  else if (this.paintChar(Me, je, ot, K), Ve) {
                    const ut = je + ee * Ve.offset.x / ie, ct = ot - ee * Ve.offset.y / ie;
                    this.paintChar(Ve.fontChar, ut, ct, K);
                  }
                }
                const Xe = he ? We * Se - Ce * Re : We * Se + Ce * Re;
                ke += Xe, te && ae.restore();
              }
              he ? z.y -= ke : z.x += ke * De, ae.restore(), this.compose();
            }
            showType3Text(O) {
              const z = this.ctx, W = this.current, ee = W.font, ae = W.fontSize, ie = W.fontDirection, me = ee.vertical ? 1 : -1, ye = W.charSpacing, Re = W.wordSpacing, De = W.textHScale * ie, Pe = W.fontMatrix || a.FONT_IDENTITY_MATRIX, he = O.length, Le = W.textRenderingMode === a.TextRenderingMode.INVISIBLE;
              let Ee, Se, Q, K;
              if (!(Le || ae === 0)) {
                for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, z.save(), z.transform(...W.textMatrix), z.translate(W.x, W.y), z.scale(De, ie), Ee = 0; Ee < he; ++Ee) {
                  if (Se = O[Ee], typeof Se == "number") {
                    K = me * Se * ae / 1e3, this.ctx.translate(K, 0), W.x += K * De;
                    continue;
                  }
                  const fe = (Se.isSpace ? Re : 0) + ye, be = ee.charProcOperatorList[Se.operatorListId];
                  if (!be) {
                    (0, a.warn)(`Type3 character "${Se.operatorListId}" is not available.`);
                    continue;
                  }
                  this.contentVisible && (this.processingType3 = Se, this.save(), z.scale(ae, ae), z.transform(...Pe), this.executeOperatorList(be), this.restore()), Q = a.Util.applyTransform([Se.width, 0], Pe)[0] * ae + fe, z.translate(Q, 0), W.x += Q * De;
                }
                z.restore(), this.processingType3 = null;
              }
            }
            setCharWidth(O, z) {
            }
            setCharWidthAndBounds(O, z, W, ee, ae, ie) {
              this.ctx.rect(W, ee, ae - W, ie - ee), this.ctx.clip(), this.endPath();
            }
            getColorN_Pattern(O) {
              let z;
              if (O[0] === "TilingPattern") {
                const W = O[1], ee = this.baseTransform || (0, o.getCurrentTransform)(this.ctx), ae = {
                  createCanvasGraphics: (ie) => new le(ie, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                    optionalContentConfig: this.optionalContentConfig,
                    markedContentStack: this.markedContentStack
                  })
                };
                z = new u.TilingPattern(O, W, this.ctx, ae, ee);
              } else
                z = this._getPattern(O[1], O[2]);
              return z;
            }
            setStrokeColorN() {
              this.current.strokeColor = this.getColorN_Pattern(arguments);
            }
            setFillColorN() {
              this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0;
            }
            setStrokeRGBColor(O, z, W) {
              const ee = a.Util.makeHexColor(O, z, W);
              this.ctx.strokeStyle = ee, this.current.strokeColor = ee;
            }
            setFillRGBColor(O, z, W) {
              const ee = a.Util.makeHexColor(O, z, W);
              this.ctx.fillStyle = ee, this.current.fillColor = ee, this.current.patternFill = !1;
            }
            _getPattern(O, z = null) {
              let W;
              return this.cachedPatterns.has(O) ? W = this.cachedPatterns.get(O) : (W = (0, u.getShadingPattern)(this.getObject(O)), this.cachedPatterns.set(O, W)), z && (W.matrix = z), W;
            }
            shadingFill(O) {
              if (!this.contentVisible)
                return;
              const z = this.ctx;
              this.save();
              const W = this._getPattern(O);
              z.fillStyle = W.getPattern(z, this, (0, o.getCurrentTransformInverse)(z), u.PathType.SHADING);
              const ee = (0, o.getCurrentTransformInverse)(z);
              if (ee) {
                const {
                  width: ae,
                  height: ie
                } = z.canvas, [me, ye, Re, De] = a.Util.getAxialAlignedBoundingBox([0, 0, ae, ie], ee);
                this.ctx.fillRect(me, ye, Re - me, De - ye);
              } else
                this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
              this.compose(this.current.getClippedPathBoundingBox()), this.restore();
            }
            beginInlineImage() {
              (0, a.unreachable)("Should not call beginInlineImage");
            }
            beginImageData() {
              (0, a.unreachable)("Should not call beginImageData");
            }
            paintFormXObjectBegin(O, z) {
              if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), Array.isArray(O) && O.length === 6 && this.transform(...O), this.baseTransform = (0, o.getCurrentTransform)(this.ctx), z)) {
                const W = z[2] - z[0], ee = z[3] - z[1];
                this.ctx.rect(z[0], z[1], W, ee), this.current.updateRectMinMax((0, o.getCurrentTransform)(this.ctx), z), this.clip(), this.endPath();
              }
            }
            paintFormXObjectEnd() {
              this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
            }
            beginGroup(O) {
              if (!this.contentVisible)
                return;
              this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
              const z = this.ctx;
              O.isolated || (0, a.info)("TODO: Support non-isolated groups."), O.knockout && (0, a.warn)("Knockout groups not supported.");
              const W = (0, o.getCurrentTransform)(z);
              if (O.matrix && z.transform(...O.matrix), !O.bbox)
                throw new Error("Bounding box is required.");
              let ee = a.Util.getAxialAlignedBoundingBox(O.bbox, (0, o.getCurrentTransform)(z));
              const ae = [0, 0, z.canvas.width, z.canvas.height];
              ee = a.Util.intersect(ee, ae) || [0, 0, 0, 0];
              const ie = Math.floor(ee[0]), me = Math.floor(ee[1]);
              let ye = Math.max(Math.ceil(ee[2]) - ie, 1), Re = Math.max(Math.ceil(ee[3]) - me, 1), De = 1, Pe = 1;
              ye > b && (De = ye / b, ye = b), Re > b && (Pe = Re / b, Re = b), this.current.startNewPathAndClipBox([0, 0, ye, Re]);
              let he = "groupAt" + this.groupLevel;
              O.smask && (he += "_smask_" + this.smaskCounter++ % 2);
              const Le = this.cachedCanvases.getCanvas(he, ye, Re), Ee = Le.context;
              Ee.scale(1 / De, 1 / Pe), Ee.translate(-ie, -me), Ee.transform(...W), O.smask ? this.smaskStack.push({
                canvas: Le.canvas,
                context: Ee,
                offsetX: ie,
                offsetY: me,
                scaleX: De,
                scaleY: Pe,
                subtype: O.smask.subtype,
                backdrop: O.smask.backdrop,
                transferMap: O.smask.transferMap || null,
                startTransformInverse: null
              }) : (z.setTransform(1, 0, 0, 1, 0, 0), z.translate(ie, me), z.scale(De, Pe), z.save()), M(z, Ee), this.ctx = Ee, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(z), this.groupLevel++;
            }
            endGroup(O) {
              if (!this.contentVisible)
                return;
              this.groupLevel--;
              const z = this.ctx, W = this.groupStack.pop();
              if (this.ctx = W, this.ctx.imageSmoothingEnabled = !1, O.smask)
                this.tempSMask = this.smaskStack.pop(), this.restore();
              else {
                this.ctx.restore();
                const ee = (0, o.getCurrentTransform)(this.ctx);
                this.restore(), this.ctx.save(), this.ctx.setTransform(...ee);
                const ae = a.Util.getAxialAlignedBoundingBox([0, 0, z.canvas.width, z.canvas.height], ee);
                this.ctx.drawImage(z.canvas, 0, 0), this.ctx.restore(), this.compose(ae);
              }
            }
            beginAnnotation(O, z, W, ee, ae) {
              if (_e(this, pe, yn).call(this), x(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), Array.isArray(z) && z.length === 4) {
                const ie = z[2] - z[0], me = z[3] - z[1];
                if (ae && this.annotationCanvasMap) {
                  W = W.slice(), W[4] -= z[0], W[5] -= z[1], z = z.slice(), z[0] = z[1] = 0, z[2] = ie, z[3] = me;
                  const [ye, Re] = a.Util.singularValueDecompose2dScale((0, o.getCurrentTransform)(this.ctx)), {
                    viewportScale: De
                  } = this, Pe = Math.ceil(ie * this.outputScaleX * De), he = Math.ceil(me * this.outputScaleY * De);
                  this.annotationCanvas = this.canvasFactory.create(Pe, he);
                  const {
                    canvas: Le,
                    context: Ee
                  } = this.annotationCanvas;
                  this.annotationCanvasMap.set(O, Le), this.annotationCanvas.savedCtx = this.ctx, this.ctx = Ee, this.ctx.save(), this.ctx.setTransform(ye, 0, 0, -Re, 0, me * Re), x(this.ctx);
                } else
                  x(this.ctx), this.ctx.rect(z[0], z[1], ie, me), this.ctx.clip(), this.endPath();
              }
              this.current = new w(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...W), this.transform(...ee);
            }
            endAnnotation() {
              this.annotationCanvas && (this.ctx.restore(), _e(this, pe, En).call(this), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
            }
            paintImageMaskXObject(O) {
              if (!this.contentVisible)
                return;
              const z = O.count;
              O = this.getObject(O.data, O), O.count = z;
              const W = this.ctx, ee = this.processingType3;
              if (ee && (ee.compiled === void 0 && (ee.compiled = I(O)), ee.compiled)) {
                ee.compiled(W);
                return;
              }
              const ae = this._createMaskCanvas(O), ie = ae.canvas;
              W.save(), W.setTransform(1, 0, 0, 1, 0, 0), W.drawImage(ie, ae.offsetX, ae.offsetY), W.restore(), this.compose();
            }
            paintImageMaskXObjectRepeat(O, z, W = 0, ee = 0, ae, ie) {
              if (!this.contentVisible)
                return;
              O = this.getObject(O.data, O);
              const me = this.ctx;
              me.save();
              const ye = (0, o.getCurrentTransform)(me);
              me.transform(z, W, ee, ae, 0, 0);
              const Re = this._createMaskCanvas(O);
              me.setTransform(1, 0, 0, 1, Re.offsetX - ye[4], Re.offsetY - ye[5]);
              for (let De = 0, Pe = ie.length; De < Pe; De += 2) {
                const he = a.Util.transform(ye, [z, W, ee, ae, ie[De], ie[De + 1]]), [Le, Ee] = a.Util.applyTransform([0, 0], he);
                me.drawImage(Re.canvas, Le, Ee);
              }
              me.restore(), this.compose();
            }
            paintImageMaskXObjectGroup(O) {
              if (!this.contentVisible)
                return;
              const z = this.ctx, W = this.current.fillColor, ee = this.current.patternFill;
              for (const ae of O) {
                const {
                  data: ie,
                  width: me,
                  height: ye,
                  transform: Re
                } = ae, De = this.cachedCanvases.getCanvas("maskCanvas", me, ye), Pe = De.context;
                Pe.save();
                const he = this.getObject(ie, ae);
                F(Pe, he), Pe.globalCompositeOperation = "source-in", Pe.fillStyle = ee ? W.getPattern(Pe, this, (0, o.getCurrentTransformInverse)(z), u.PathType.FILL) : W, Pe.fillRect(0, 0, me, ye), Pe.restore(), z.save(), z.transform(...Re), z.scale(1, -1), R(z, De.canvas, 0, 0, me, ye, 0, -1, 1, 1), z.restore();
              }
              this.compose();
            }
            paintImageXObject(O) {
              if (!this.contentVisible)
                return;
              const z = this.getObject(O);
              if (!z) {
                (0, a.warn)("Dependent image isn't ready yet");
                return;
              }
              this.paintInlineImageXObject(z);
            }
            paintImageXObjectRepeat(O, z, W, ee) {
              if (!this.contentVisible)
                return;
              const ae = this.getObject(O);
              if (!ae) {
                (0, a.warn)("Dependent image isn't ready yet");
                return;
              }
              const ie = ae.width, me = ae.height, ye = [];
              for (let Re = 0, De = ee.length; Re < De; Re += 2)
                ye.push({
                  transform: [z, 0, 0, W, ee[Re], ee[Re + 1]],
                  x: 0,
                  y: 0,
                  w: ie,
                  h: me
                });
              this.paintInlineImageXObjectGroup(ae, ye);
            }
            applyTransferMapsToCanvas(O) {
              return this.current.transferMaps !== "none" && (O.filter = this.current.transferMaps, O.drawImage(O.canvas, 0, 0), O.filter = "none"), O.canvas;
            }
            applyTransferMapsToBitmap(O) {
              if (this.current.transferMaps === "none")
                return O.bitmap;
              const {
                bitmap: z,
                width: W,
                height: ee
              } = O, ae = this.cachedCanvases.getCanvas("inlineImage", W, ee), ie = ae.context;
              return ie.filter = this.current.transferMaps, ie.drawImage(z, 0, 0), ie.filter = "none", ae.canvas;
            }
            paintInlineImageXObject(O) {
              if (!this.contentVisible)
                return;
              const z = O.width, W = O.height, ee = this.ctx;
              if (this.save(), !a.isNodeJS) {
                const {
                  filter: me
                } = ee;
                me !== "none" && me !== "" && (ee.filter = "none");
              }
              ee.scale(1 / z, -1 / W);
              let ae;
              if (O.bitmap)
                ae = this.applyTransferMapsToBitmap(O);
              else if (typeof HTMLElement == "function" && O instanceof HTMLElement || !O.data)
                ae = O;
              else {
                const ye = this.cachedCanvases.getCanvas("inlineImage", z, W).context;
                N(ye, O), ae = this.applyTransferMapsToCanvas(ye);
              }
              const ie = this._scaleImage(ae, (0, o.getCurrentTransformInverse)(ee));
              ee.imageSmoothingEnabled = V((0, o.getCurrentTransform)(ee), O.interpolate), R(ee, ie.img, 0, 0, ie.paintWidth, ie.paintHeight, 0, -W, z, W), this.compose(), this.restore();
            }
            paintInlineImageXObjectGroup(O, z) {
              if (!this.contentVisible)
                return;
              const W = this.ctx;
              let ee;
              if (O.bitmap)
                ee = O.bitmap;
              else {
                const ae = O.width, ie = O.height, ye = this.cachedCanvases.getCanvas("inlineImage", ae, ie).context;
                N(ye, O), ee = this.applyTransferMapsToCanvas(ye);
              }
              for (const ae of z)
                W.save(), W.transform(...ae.transform), W.scale(1, -1), R(W, ee, ae.x, ae.y, ae.w, ae.h, 0, -1, 1, 1), W.restore();
              this.compose();
            }
            paintSolidColorImageMask() {
              this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
            }
            markPoint(O) {
            }
            markPointProps(O, z) {
            }
            beginMarkedContent(O) {
              this.markedContentStack.push({
                visible: !0
              });
            }
            beginMarkedContentProps(O, z) {
              O === "OC" ? this.markedContentStack.push({
                visible: this.optionalContentConfig.isVisible(z)
              }) : this.markedContentStack.push({
                visible: !0
              }), this.contentVisible = this.isContentVisible();
            }
            endMarkedContent() {
              this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
            }
            beginCompat() {
            }
            endCompat() {
            }
            consumePath(O) {
              const z = this.current.isEmptyClip();
              this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(O);
              const W = this.ctx;
              this.pendingClip && (z || (this.pendingClip === se ? W.clip("evenodd") : W.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), W.beginPath();
            }
            getSinglePixelWidth() {
              if (!this._cachedGetSinglePixelWidth) {
                const O = (0, o.getCurrentTransform)(this.ctx);
                if (O[1] === 0 && O[2] === 0)
                  this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(O[0]), Math.abs(O[3]));
                else {
                  const z = Math.abs(O[0] * O[3] - O[2] * O[1]), W = Math.hypot(O[0], O[2]), ee = Math.hypot(O[1], O[3]);
                  this._cachedGetSinglePixelWidth = Math.max(W, ee) / z;
                }
              }
              return this._cachedGetSinglePixelWidth;
            }
            getScaleForStroking() {
              if (this._cachedScaleForStroking[0] === -1) {
                const {
                  lineWidth: O
                } = this.current, {
                  a: z,
                  b: W,
                  c: ee,
                  d: ae
                } = this.ctx.getTransform();
                let ie, me;
                if (W === 0 && ee === 0) {
                  const ye = Math.abs(z), Re = Math.abs(ae);
                  if (ye === Re)
                    if (O === 0)
                      ie = me = 1 / ye;
                    else {
                      const De = ye * O;
                      ie = me = De < 1 ? 1 / De : 1;
                    }
                  else if (O === 0)
                    ie = 1 / ye, me = 1 / Re;
                  else {
                    const De = ye * O, Pe = Re * O;
                    ie = De < 1 ? 1 / De : 1, me = Pe < 1 ? 1 / Pe : 1;
                  }
                } else {
                  const ye = Math.abs(z * ae - W * ee), Re = Math.hypot(z, W), De = Math.hypot(ee, ae);
                  if (O === 0)
                    ie = De / ye, me = Re / ye;
                  else {
                    const Pe = O * ye;
                    ie = De > Pe ? De / Pe : 1, me = Re > Pe ? Re / Pe : 1;
                  }
                }
                this._cachedScaleForStroking[0] = ie, this._cachedScaleForStroking[1] = me;
              }
              return this._cachedScaleForStroking;
            }
            rescaleAndStroke(O) {
              const {
                ctx: z
              } = this, {
                lineWidth: W
              } = this.current, [ee, ae] = this.getScaleForStroking();
              if (z.lineWidth = W || 1, ee === 1 && ae === 1) {
                z.stroke();
                return;
              }
              const ie = z.getLineDash();
              if (O && z.save(), z.scale(ee, ae), ie.length > 0) {
                const me = Math.max(ee, ae);
                z.setLineDash(ie.map((ye) => ye / me)), z.lineDashOffset /= me;
              }
              z.stroke(), O && z.restore();
            }
            isContentVisible() {
              for (let O = this.markedContentStack.length - 1; O >= 0; O--)
                if (!this.markedContentStack[O].visible)
                  return !1;
              return !0;
            }
          };
          pe = new WeakSet(), yn = function() {
            for (; this.stateStack.length || this.inSMaskMode; )
              this.restore();
            this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
          }, En = function() {
            if (this.pageColors) {
              const O = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
              if (O !== "none") {
                const z = this.ctx.filter;
                this.ctx.filter = O, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = z;
              }
            }
          };
          let ue = le;
          t.CanvasGraphics = ue;
          for (const Z in a.OPS)
            ue.prototype[Z] !== void 0 && (ue.prototype[a.OPS[Z]] = ue.prototype[Z]);
        },
        /* 12 */
        /***/
        (e, t, r) => {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.TilingPattern = t.PathType = void 0, t.getShadingPattern = E;
          var a = r(1), o = r(6);
          const u = {
            FILL: "Fill",
            STROKE: "Stroke",
            SHADING: "Shading"
          };
          t.PathType = u;
          function c(I, w) {
            if (!w)
              return;
            const N = w[2] - w[0], F = w[3] - w[1], M = new Path2D();
            M.rect(w[0], w[1], N, F), I.clip(M);
          }
          class d {
            constructor() {
              this.constructor === d && (0, a.unreachable)("Cannot initialize BaseShadingPattern.");
            }
            getPattern() {
              (0, a.unreachable)("Abstract method `getPattern` called.");
            }
          }
          class g extends d {
            constructor(w) {
              super(), this._type = w[1], this._bbox = w[2], this._colorStops = w[3], this._p0 = w[4], this._p1 = w[5], this._r0 = w[6], this._r1 = w[7], this.matrix = null;
            }
            _createGradient(w) {
              let N;
              this._type === "axial" ? N = w.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (N = w.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
              for (const F of this._colorStops)
                N.addColorStop(F[0], F[1]);
              return N;
            }
            getPattern(w, N, F, M) {
              let x;
              if (M === u.STROKE || M === u.FILL) {
                const P = N.current.getClippedPathBoundingBox(M, (0, o.getCurrentTransform)(w)) || [0, 0, 0, 0], U = Math.ceil(P[2] - P[0]) || 1, L = Math.ceil(P[3] - P[1]) || 1, H = N.cachedCanvases.getCanvas("pattern", U, L, !0), B = H.context;
                B.clearRect(0, 0, B.canvas.width, B.canvas.height), B.beginPath(), B.rect(0, 0, B.canvas.width, B.canvas.height), B.translate(-P[0], -P[1]), F = a.Util.transform(F, [1, 0, 0, 1, P[0], P[1]]), B.transform(...N.baseTransform), this.matrix && B.transform(...this.matrix), c(B, this._bbox), B.fillStyle = this._createGradient(B), B.fill(), x = w.createPattern(H.canvas, "no-repeat");
                const V = new DOMMatrix(F);
                x.setTransform(V);
              } else
                c(w, this._bbox), x = this._createGradient(w);
              return x;
            }
          }
          function b(I, w, N, F, M, x, P, U) {
            const L = w.coords, H = w.colors, B = I.data, V = I.width * 4;
            let X;
            L[N + 1] > L[F + 1] && (X = N, N = F, F = X, X = x, x = P, P = X), L[F + 1] > L[M + 1] && (X = F, F = M, M = X, X = P, P = U, U = X), L[N + 1] > L[F + 1] && (X = N, N = F, F = X, X = x, x = P, P = X);
            const de = (L[N] + w.offsetX) * w.scaleX, Y = (L[N + 1] + w.offsetY) * w.scaleY, se = (L[F] + w.offsetX) * w.scaleX, ue = (L[F + 1] + w.offsetY) * w.scaleY, pe = (L[M] + w.offsetX) * w.scaleX, J = (L[M + 1] + w.offsetY) * w.scaleY;
            if (Y >= J)
              return;
            const j = H[x], le = H[x + 1], Z = H[x + 2], O = H[P], z = H[P + 1], W = H[P + 2], ee = H[U], ae = H[U + 1], ie = H[U + 2], me = Math.round(Y), ye = Math.round(J);
            let Re, De, Pe, he, Le, Ee, Se, Q;
            for (let K = me; K <= ye; K++) {
              if (K < ue) {
                const Be = K < Y ? 0 : (Y - K) / (Y - ue);
                Re = de - (de - se) * Be, De = j - (j - O) * Be, Pe = le - (le - z) * Be, he = Z - (Z - W) * Be;
              } else {
                let Be;
                K > J ? Be = 1 : ue === J ? Be = 0 : Be = (ue - K) / (ue - J), Re = se - (se - pe) * Be, De = O - (O - ee) * Be, Pe = z - (z - ae) * Be, he = W - (W - ie) * Be;
              }
              let fe;
              K < Y ? fe = 0 : K > J ? fe = 1 : fe = (Y - K) / (Y - J), Le = de - (de - pe) * fe, Ee = j - (j - ee) * fe, Se = le - (le - ae) * fe, Q = Z - (Z - ie) * fe;
              const be = Math.round(Math.min(Re, Le)), ke = Math.round(Math.max(Re, Le));
              let Fe = V * K + be * 4;
              for (let Be = be; Be <= ke; Be++)
                fe = (Re - Be) / (Re - Le), fe < 0 ? fe = 0 : fe > 1 && (fe = 1), B[Fe++] = De - (De - Ee) * fe | 0, B[Fe++] = Pe - (Pe - Se) * fe | 0, B[Fe++] = he - (he - Q) * fe | 0, B[Fe++] = 255;
            }
          }
          function _(I, w, N) {
            const F = w.coords, M = w.colors;
            let x, P;
            switch (w.type) {
              case "lattice":
                const U = w.verticesPerRow, L = Math.floor(F.length / U) - 1, H = U - 1;
                for (x = 0; x < L; x++) {
                  let B = x * U;
                  for (let V = 0; V < H; V++, B++)
                    b(I, N, F[B], F[B + 1], F[B + U], M[B], M[B + 1], M[B + U]), b(I, N, F[B + U + 1], F[B + 1], F[B + U], M[B + U + 1], M[B + 1], M[B + U]);
                }
                break;
              case "triangles":
                for (x = 0, P = F.length; x < P; x += 3)
                  b(I, N, F[x], F[x + 1], F[x + 2], M[x], M[x + 1], M[x + 2]);
                break;
              default:
                throw new Error("illegal figure");
            }
          }
          class y extends d {
            constructor(w) {
              super(), this._coords = w[2], this._colors = w[3], this._figures = w[4], this._bounds = w[5], this._bbox = w[7], this._background = w[8], this.matrix = null;
            }
            _createMeshCanvas(w, N, F) {
              const U = Math.floor(this._bounds[0]), L = Math.floor(this._bounds[1]), H = Math.ceil(this._bounds[2]) - U, B = Math.ceil(this._bounds[3]) - L, V = Math.min(Math.ceil(Math.abs(H * w[0] * 1.1)), 3e3), X = Math.min(Math.ceil(Math.abs(B * w[1] * 1.1)), 3e3), de = H / V, Y = B / X, se = {
                coords: this._coords,
                colors: this._colors,
                offsetX: -U,
                offsetY: -L,
                scaleX: 1 / de,
                scaleY: 1 / Y
              }, ue = V + 2 * 2, pe = X + 2 * 2, J = F.getCanvas("mesh", ue, pe, !1), j = J.context, le = j.createImageData(V, X);
              if (N) {
                const O = le.data;
                for (let z = 0, W = O.length; z < W; z += 4)
                  O[z] = N[0], O[z + 1] = N[1], O[z + 2] = N[2], O[z + 3] = 255;
              }
              for (const O of this._figures)
                _(le, O, se);
              return j.putImageData(le, 2, 2), {
                canvas: J.canvas,
                offsetX: U - 2 * de,
                offsetY: L - 2 * Y,
                scaleX: de,
                scaleY: Y
              };
            }
            getPattern(w, N, F, M) {
              c(w, this._bbox);
              let x;
              if (M === u.SHADING)
                x = a.Util.singularValueDecompose2dScale((0, o.getCurrentTransform)(w));
              else if (x = a.Util.singularValueDecompose2dScale(N.baseTransform), this.matrix) {
                const U = a.Util.singularValueDecompose2dScale(this.matrix);
                x = [x[0] * U[0], x[1] * U[1]];
              }
              const P = this._createMeshCanvas(x, M === u.SHADING ? null : this._background, N.cachedCanvases);
              return M !== u.SHADING && (w.setTransform(...N.baseTransform), this.matrix && w.transform(...this.matrix)), w.translate(P.offsetX, P.offsetY), w.scale(P.scaleX, P.scaleY), w.createPattern(P.canvas, "no-repeat");
            }
          }
          class A extends d {
            getPattern() {
              return "hotpink";
            }
          }
          function E(I) {
            switch (I[0]) {
              case "RadialAxial":
                return new g(I);
              case "Mesh":
                return new y(I);
              case "Dummy":
                return new A();
            }
            throw new Error(`Unknown IR type: ${I[0]}`);
          }
          const v = {
            COLORED: 1,
            UNCOLORED: 2
          }, R = class R {
            constructor(w, N, F, M, x) {
              this.operatorList = w[2], this.matrix = w[3] || [1, 0, 0, 1, 0, 0], this.bbox = w[4], this.xstep = w[5], this.ystep = w[6], this.paintType = w[7], this.tilingType = w[8], this.color = N, this.ctx = F, this.canvasGraphicsFactory = M, this.baseTransform = x;
            }
            createPatternCanvas(w) {
              const N = this.operatorList, F = this.bbox, M = this.xstep, x = this.ystep, P = this.paintType, U = this.tilingType, L = this.color, H = this.canvasGraphicsFactory;
              (0, a.info)("TilingType: " + U);
              const B = F[0], V = F[1], X = F[2], de = F[3], Y = a.Util.singularValueDecompose2dScale(this.matrix), se = a.Util.singularValueDecompose2dScale(this.baseTransform), ue = [Y[0] * se[0], Y[1] * se[1]], pe = this.getSizeAndScale(M, this.ctx.canvas.width, ue[0]), J = this.getSizeAndScale(x, this.ctx.canvas.height, ue[1]), j = w.cachedCanvases.getCanvas("pattern", pe.size, J.size, !0), le = j.context, Z = H.createCanvasGraphics(le);
              Z.groupLevel = w.groupLevel, this.setFillAndStrokeStyleToContext(Z, P, L);
              let O = B, z = V, W = X, ee = de;
              return B < 0 && (O = 0, W += Math.abs(B)), V < 0 && (z = 0, ee += Math.abs(V)), le.translate(-(pe.scale * O), -(J.scale * z)), Z.transform(pe.scale, 0, 0, J.scale, 0, 0), le.save(), this.clipBbox(Z, O, z, W, ee), Z.baseTransform = (0, o.getCurrentTransform)(Z.ctx), Z.executeOperatorList(N), Z.endDrawing(), {
                canvas: j.canvas,
                scaleX: pe.scale,
                scaleY: J.scale,
                offsetX: O,
                offsetY: z
              };
            }
            getSizeAndScale(w, N, F) {
              w = Math.abs(w);
              const M = Math.max(R.MAX_PATTERN_SIZE, N);
              let x = Math.ceil(w * F);
              return x >= M ? x = M : F = x / w, {
                scale: F,
                size: x
              };
            }
            clipBbox(w, N, F, M, x) {
              const P = M - N, U = x - F;
              w.ctx.rect(N, F, P, U), w.current.updateRectMinMax((0, o.getCurrentTransform)(w.ctx), [N, F, M, x]), w.clip(), w.endPath();
            }
            setFillAndStrokeStyleToContext(w, N, F) {
              const M = w.ctx, x = w.current;
              switch (N) {
                case v.COLORED:
                  const P = this.ctx;
                  M.fillStyle = P.fillStyle, M.strokeStyle = P.strokeStyle, x.fillColor = P.fillStyle, x.strokeColor = P.strokeStyle;
                  break;
                case v.UNCOLORED:
                  const U = a.Util.makeHexColor(F[0], F[1], F[2]);
                  M.fillStyle = U, M.strokeStyle = U, x.fillColor = U, x.strokeColor = U;
                  break;
                default:
                  throw new a.FormatError(`Unsupported paint type: ${N}`);
              }
            }
            getPattern(w, N, F, M) {
              let x = F;
              M !== u.SHADING && (x = a.Util.transform(x, N.baseTransform), this.matrix && (x = a.Util.transform(x, this.matrix)));
              const P = this.createPatternCanvas(N);
              let U = new DOMMatrix(x);
              U = U.translate(P.offsetX, P.offsetY), U = U.scale(1 / P.scaleX, 1 / P.scaleY);
              const L = w.createPattern(P.canvas, "repeat");
              return L.setTransform(U), L;
            }
          };
          ft(R, "MAX_PATTERN_SIZE", 3e3);
          let C = R;
          t.TilingPattern = C;
        },
        /* 13 */
        /***/
        (e, t, r) => {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.convertBlackAndWhiteToRGBA = u, t.convertToRGBA = o, t.grayToRGBA = d;
          var a = r(1);
          function o(g) {
            switch (g.kind) {
              case a.ImageKind.GRAYSCALE_1BPP:
                return u(g);
              case a.ImageKind.RGB_24BPP:
                return c(g);
            }
            return null;
          }
          function u({
            src: g,
            srcPos: b = 0,
            dest: _,
            width: y,
            height: A,
            nonBlackColor: E = 4294967295,
            inverseDecode: v = !1
          }) {
            const C = a.FeatureTest.isLittleEndian ? 4278190080 : 255, [R, I] = v ? [E, C] : [C, E], w = y >> 3, N = y & 7, F = g.length;
            _ = new Uint32Array(_.buffer);
            let M = 0;
            for (let x = 0; x < A; x++) {
              for (const U = b + w; b < U; b++) {
                const L = b < F ? g[b] : 255;
                _[M++] = L & 128 ? I : R, _[M++] = L & 64 ? I : R, _[M++] = L & 32 ? I : R, _[M++] = L & 16 ? I : R, _[M++] = L & 8 ? I : R, _[M++] = L & 4 ? I : R, _[M++] = L & 2 ? I : R, _[M++] = L & 1 ? I : R;
              }
              if (N === 0)
                continue;
              const P = b < F ? g[b++] : 255;
              for (let U = 0; U < N; U++)
                _[M++] = P & 1 << 7 - U ? I : R;
            }
            return {
              srcPos: b,
              destPos: M
            };
          }
          function c({
            src: g,
            srcPos: b = 0,
            dest: _,
            destPos: y = 0,
            width: A,
            height: E
          }) {
            let v = 0;
            const C = g.length >> 2, R = new Uint32Array(g.buffer, b, C);
            if (a.FeatureTest.isLittleEndian) {
              for (; v < C - 2; v += 3, y += 4) {
                const I = R[v], w = R[v + 1], N = R[v + 2];
                _[y] = I | 4278190080, _[y + 1] = I >>> 24 | w << 8 | 4278190080, _[y + 2] = w >>> 16 | N << 16 | 4278190080, _[y + 3] = N >>> 8 | 4278190080;
              }
              for (let I = v * 4, w = g.length; I < w; I += 3)
                _[y++] = g[I] | g[I + 1] << 8 | g[I + 2] << 16 | 4278190080;
            } else {
              for (; v < C - 2; v += 3, y += 4) {
                const I = R[v], w = R[v + 1], N = R[v + 2];
                _[y] = I | 255, _[y + 1] = I << 24 | w >>> 8 | 255, _[y + 2] = w << 16 | N >>> 16 | 255, _[y + 3] = N << 8 | 255;
              }
              for (let I = v * 4, w = g.length; I < w; I += 3)
                _[y++] = g[I] << 24 | g[I + 1] << 16 | g[I + 2] << 8 | 255;
            }
            return {
              srcPos: b,
              destPos: y
            };
          }
          function d(g, b) {
            if (a.FeatureTest.isLittleEndian)
              for (let _ = 0, y = g.length; _ < y; _++)
                b[_] = g[_] * 65793 | 4278190080;
            else
              for (let _ = 0, y = g.length; _ < y; _++)
                b[_] = g[_] * 16843008 | 255;
          }
        },
        /* 14 */
        /***/
        (e, t) => {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.GlobalWorkerOptions = void 0;
          const r = /* @__PURE__ */ Object.create(null);
          t.GlobalWorkerOptions = r, r.workerPort = null, r.workerSrc = "";
        },
        /* 15 */
        /***/
        (e, t, r) => {
          var g, Zn, Qn, Yt;
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.MessageHandler = void 0;
          var a = r(1);
          const o = {
            DATA: 1,
            ERROR: 2
          }, u = {
            CANCEL: 1,
            CANCEL_COMPLETE: 2,
            CLOSE: 3,
            ENQUEUE: 4,
            ERROR: 5,
            PULL: 6,
            PULL_COMPLETE: 7,
            START_COMPLETE: 8
          };
          function c(A) {
            switch (A instanceof Error || typeof A == "object" && A !== null || (0, a.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), A.name) {
              case "AbortException":
                return new a.AbortException(A.message);
              case "MissingPDFException":
                return new a.MissingPDFException(A.message);
              case "PasswordException":
                return new a.PasswordException(A.message, A.code);
              case "UnexpectedResponseException":
                return new a.UnexpectedResponseException(A.message, A.status);
              case "UnknownErrorException":
                return new a.UnknownErrorException(A.message, A.details);
              default:
                return new a.UnknownErrorException(A.message, A.toString());
            }
          }
          class d {
            constructor(E, v, C) {
              we(this, g);
              this.sourceName = E, this.targetName = v, this.comObj = C, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (R) => {
                const I = R.data;
                if (I.targetName !== this.sourceName)
                  return;
                if (I.stream) {
                  _e(this, g, Qn).call(this, I);
                  return;
                }
                if (I.callback) {
                  const N = I.callbackId, F = this.callbackCapabilities[N];
                  if (!F)
                    throw new Error(`Cannot resolve callback ${N}`);
                  if (delete this.callbackCapabilities[N], I.callback === o.DATA)
                    F.resolve(I.data);
                  else if (I.callback === o.ERROR)
                    F.reject(c(I.reason));
                  else
                    throw new Error("Unexpected callback case");
                  return;
                }
                const w = this.actionHandler[I.action];
                if (!w)
                  throw new Error(`Unknown action from worker: ${I.action}`);
                if (I.callbackId) {
                  const N = this.sourceName, F = I.sourceName;
                  new Promise(function(M) {
                    M(w(I.data));
                  }).then(function(M) {
                    C.postMessage({
                      sourceName: N,
                      targetName: F,
                      callback: o.DATA,
                      callbackId: I.callbackId,
                      data: M
                    });
                  }, function(M) {
                    C.postMessage({
                      sourceName: N,
                      targetName: F,
                      callback: o.ERROR,
                      callbackId: I.callbackId,
                      reason: c(M)
                    });
                  });
                  return;
                }
                if (I.streamId) {
                  _e(this, g, Zn).call(this, I);
                  return;
                }
                w(I.data);
              }, C.addEventListener("message", this._onComObjOnMessage);
            }
            on(E, v) {
              const C = this.actionHandler;
              if (C[E])
                throw new Error(`There is already an actionName called "${E}"`);
              C[E] = v;
            }
            send(E, v, C) {
              this.comObj.postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: E,
                data: v
              }, C);
            }
            sendWithPromise(E, v, C) {
              const R = this.callbackId++, I = new a.PromiseCapability();
              this.callbackCapabilities[R] = I;
              try {
                this.comObj.postMessage({
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: E,
                  callbackId: R,
                  data: v
                }, C);
              } catch (w) {
                I.reject(w);
              }
              return I.promise;
            }
            sendWithStream(E, v, C, R) {
              const I = this.streamId++, w = this.sourceName, N = this.targetName, F = this.comObj;
              return new ReadableStream({
                start: (M) => {
                  const x = new a.PromiseCapability();
                  return this.streamControllers[I] = {
                    controller: M,
                    startCall: x,
                    pullCall: null,
                    cancelCall: null,
                    isClosed: !1
                  }, F.postMessage({
                    sourceName: w,
                    targetName: N,
                    action: E,
                    streamId: I,
                    data: v,
                    desiredSize: M.desiredSize
                  }, R), x.promise;
                },
                pull: (M) => {
                  const x = new a.PromiseCapability();
                  return this.streamControllers[I].pullCall = x, F.postMessage({
                    sourceName: w,
                    targetName: N,
                    stream: u.PULL,
                    streamId: I,
                    desiredSize: M.desiredSize
                  }), x.promise;
                },
                cancel: (M) => {
                  (0, a.assert)(M instanceof Error, "cancel must have a valid reason");
                  const x = new a.PromiseCapability();
                  return this.streamControllers[I].cancelCall = x, this.streamControllers[I].isClosed = !0, F.postMessage({
                    sourceName: w,
                    targetName: N,
                    stream: u.CANCEL,
                    streamId: I,
                    reason: c(M)
                  }), x.promise;
                }
              }, C);
            }
            destroy() {
              this.comObj.removeEventListener("message", this._onComObjOnMessage);
            }
          }
          g = new WeakSet(), Zn = function(E) {
            const v = E.streamId, C = this.sourceName, R = E.sourceName, I = this.comObj, w = this, N = this.actionHandler[E.action], F = {
              enqueue(M, x = 1, P) {
                if (this.isCancelled)
                  return;
                const U = this.desiredSize;
                this.desiredSize -= x, U > 0 && this.desiredSize <= 0 && (this.sinkCapability = new a.PromiseCapability(), this.ready = this.sinkCapability.promise), I.postMessage({
                  sourceName: C,
                  targetName: R,
                  stream: u.ENQUEUE,
                  streamId: v,
                  chunk: M
                }, P);
              },
              close() {
                this.isCancelled || (this.isCancelled = !0, I.postMessage({
                  sourceName: C,
                  targetName: R,
                  stream: u.CLOSE,
                  streamId: v
                }), delete w.streamSinks[v]);
              },
              error(M) {
                (0, a.assert)(M instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, I.postMessage({
                  sourceName: C,
                  targetName: R,
                  stream: u.ERROR,
                  streamId: v,
                  reason: c(M)
                }));
              },
              sinkCapability: new a.PromiseCapability(),
              onPull: null,
              onCancel: null,
              isCancelled: !1,
              desiredSize: E.desiredSize,
              ready: null
            };
            F.sinkCapability.resolve(), F.ready = F.sinkCapability.promise, this.streamSinks[v] = F, new Promise(function(M) {
              M(N(E.data, F));
            }).then(function() {
              I.postMessage({
                sourceName: C,
                targetName: R,
                stream: u.START_COMPLETE,
                streamId: v,
                success: !0
              });
            }, function(M) {
              I.postMessage({
                sourceName: C,
                targetName: R,
                stream: u.START_COMPLETE,
                streamId: v,
                reason: c(M)
              });
            });
          }, Qn = function(E) {
            const v = E.streamId, C = this.sourceName, R = E.sourceName, I = this.comObj, w = this.streamControllers[v], N = this.streamSinks[v];
            switch (E.stream) {
              case u.START_COMPLETE:
                E.success ? w.startCall.resolve() : w.startCall.reject(c(E.reason));
                break;
              case u.PULL_COMPLETE:
                E.success ? w.pullCall.resolve() : w.pullCall.reject(c(E.reason));
                break;
              case u.PULL:
                if (!N) {
                  I.postMessage({
                    sourceName: C,
                    targetName: R,
                    stream: u.PULL_COMPLETE,
                    streamId: v,
                    success: !0
                  });
                  break;
                }
                N.desiredSize <= 0 && E.desiredSize > 0 && N.sinkCapability.resolve(), N.desiredSize = E.desiredSize, new Promise(function(F) {
                  var M;
                  F((M = N.onPull) == null ? void 0 : M.call(N));
                }).then(function() {
                  I.postMessage({
                    sourceName: C,
                    targetName: R,
                    stream: u.PULL_COMPLETE,
                    streamId: v,
                    success: !0
                  });
                }, function(F) {
                  I.postMessage({
                    sourceName: C,
                    targetName: R,
                    stream: u.PULL_COMPLETE,
                    streamId: v,
                    reason: c(F)
                  });
                });
                break;
              case u.ENQUEUE:
                if ((0, a.assert)(w, "enqueue should have stream controller"), w.isClosed)
                  break;
                w.controller.enqueue(E.chunk);
                break;
              case u.CLOSE:
                if ((0, a.assert)(w, "close should have stream controller"), w.isClosed)
                  break;
                w.isClosed = !0, w.controller.close(), _e(this, g, Yt).call(this, w, v);
                break;
              case u.ERROR:
                (0, a.assert)(w, "error should have stream controller"), w.controller.error(c(E.reason)), _e(this, g, Yt).call(this, w, v);
                break;
              case u.CANCEL_COMPLETE:
                E.success ? w.cancelCall.resolve() : w.cancelCall.reject(c(E.reason)), _e(this, g, Yt).call(this, w, v);
                break;
              case u.CANCEL:
                if (!N)
                  break;
                new Promise(function(F) {
                  var M;
                  F((M = N.onCancel) == null ? void 0 : M.call(N, c(E.reason)));
                }).then(function() {
                  I.postMessage({
                    sourceName: C,
                    targetName: R,
                    stream: u.CANCEL_COMPLETE,
                    streamId: v,
                    success: !0
                  });
                }, function(F) {
                  I.postMessage({
                    sourceName: C,
                    targetName: R,
                    stream: u.CANCEL_COMPLETE,
                    streamId: v,
                    reason: c(F)
                  });
                }), N.sinkCapability.reject(c(E.reason)), N.isCancelled = !0, delete this.streamSinks[v];
                break;
              default:
                throw new Error("Unexpected stream case");
            }
          }, Yt = async function(E, v) {
            var C, R, I;
            await Promise.allSettled([(C = E.startCall) == null ? void 0 : C.promise, (R = E.pullCall) == null ? void 0 : R.promise, (I = E.cancelCall) == null ? void 0 : I.promise]), delete this.streamControllers[v];
          }, t.MessageHandler = d;
        },
        /* 16 */
        /***/
        (e, t, r) => {
          var u, c;
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.Metadata = void 0;
          var a = r(1);
          class o {
            constructor({
              parsedData: g,
              rawData: b
            }) {
              we(this, u);
              we(this, c);
              Ie(this, u, g), Ie(this, c, b);
            }
            getRaw() {
              return G(this, c);
            }
            get(g) {
              return G(this, u).get(g) ?? null;
            }
            getAll() {
              return (0, a.objectFromMap)(G(this, u));
            }
            has(g) {
              return G(this, u).has(g);
            }
          }
          u = new WeakMap(), c = new WeakMap(), t.Metadata = o;
        },
        /* 17 */
        /***/
        (e, t, r) => {
          var g, b, _, y, A, E, Sn;
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.OptionalContentConfig = void 0;
          var a = r(1), o = r(8);
          const u = Symbol("INTERNAL");
          class c {
            constructor(R, I) {
              we(this, g, !0);
              this.name = R, this.intent = I;
            }
            get visible() {
              return G(this, g);
            }
            _setVisible(R, I) {
              R !== u && (0, a.unreachable)("Internal method `_setVisible` called."), Ie(this, g, I);
            }
          }
          g = new WeakMap();
          class d {
            constructor(R) {
              we(this, E);
              we(this, b, null);
              we(this, _, /* @__PURE__ */ new Map());
              we(this, y, null);
              we(this, A, null);
              if (this.name = null, this.creator = null, R !== null) {
                this.name = R.name, this.creator = R.creator, Ie(this, A, R.order);
                for (const I of R.groups)
                  G(this, _).set(I.id, new c(I.name, I.intent));
                if (R.baseState === "OFF")
                  for (const I of G(this, _).values())
                    I._setVisible(u, !1);
                for (const I of R.on)
                  G(this, _).get(I)._setVisible(u, !0);
                for (const I of R.off)
                  G(this, _).get(I)._setVisible(u, !1);
                Ie(this, y, this.getHash());
              }
            }
            isVisible(R) {
              if (G(this, _).size === 0)
                return !0;
              if (!R)
                return (0, a.warn)("Optional content group not defined."), !0;
              if (R.type === "OCG")
                return G(this, _).has(R.id) ? G(this, _).get(R.id).visible : ((0, a.warn)(`Optional content group not found: ${R.id}`), !0);
              if (R.type === "OCMD") {
                if (R.expression)
                  return _e(this, E, Sn).call(this, R.expression);
                if (!R.policy || R.policy === "AnyOn") {
                  for (const I of R.ids) {
                    if (!G(this, _).has(I))
                      return (0, a.warn)(`Optional content group not found: ${I}`), !0;
                    if (G(this, _).get(I).visible)
                      return !0;
                  }
                  return !1;
                } else if (R.policy === "AllOn") {
                  for (const I of R.ids) {
                    if (!G(this, _).has(I))
                      return (0, a.warn)(`Optional content group not found: ${I}`), !0;
                    if (!G(this, _).get(I).visible)
                      return !1;
                  }
                  return !0;
                } else if (R.policy === "AnyOff") {
                  for (const I of R.ids) {
                    if (!G(this, _).has(I))
                      return (0, a.warn)(`Optional content group not found: ${I}`), !0;
                    if (!G(this, _).get(I).visible)
                      return !0;
                  }
                  return !1;
                } else if (R.policy === "AllOff") {
                  for (const I of R.ids) {
                    if (!G(this, _).has(I))
                      return (0, a.warn)(`Optional content group not found: ${I}`), !0;
                    if (G(this, _).get(I).visible)
                      return !1;
                  }
                  return !0;
                }
                return (0, a.warn)(`Unknown optional content policy ${R.policy}.`), !0;
              }
              return (0, a.warn)(`Unknown group type ${R.type}.`), !0;
            }
            setVisibility(R, I = !0) {
              if (!G(this, _).has(R)) {
                (0, a.warn)(`Optional content group not found: ${R}`);
                return;
              }
              G(this, _).get(R)._setVisible(u, !!I), Ie(this, b, null);
            }
            get hasInitialVisibility() {
              return G(this, y) === null || this.getHash() === G(this, y);
            }
            getOrder() {
              return G(this, _).size ? G(this, A) ? G(this, A).slice() : [...G(this, _).keys()] : null;
            }
            getGroups() {
              return G(this, _).size > 0 ? (0, a.objectFromMap)(G(this, _)) : null;
            }
            getGroup(R) {
              return G(this, _).get(R) || null;
            }
            getHash() {
              if (G(this, b) !== null)
                return G(this, b);
              const R = new o.MurmurHash3_64();
              for (const [I, w] of G(this, _))
                R.update(`${I}:${w.visible}`);
              return Ie(this, b, R.hexdigest());
            }
          }
          b = new WeakMap(), _ = new WeakMap(), y = new WeakMap(), A = new WeakMap(), E = new WeakSet(), Sn = function(R) {
            const I = R.length;
            if (I < 2)
              return !0;
            const w = R[0];
            for (let N = 1; N < I; N++) {
              const F = R[N];
              let M;
              if (Array.isArray(F))
                M = _e(this, E, Sn).call(this, F);
              else if (G(this, _).has(F))
                M = G(this, _).get(F).visible;
              else
                return (0, a.warn)(`Optional content group not found: ${F}`), !0;
              switch (w) {
                case "And":
                  if (!M)
                    return !1;
                  break;
                case "Or":
                  if (M)
                    return !0;
                  break;
                case "Not":
                  return !M;
                default:
                  return !0;
              }
            }
            return w === "And";
          }, t.OptionalContentConfig = d;
        },
        /* 18 */
        /***/
        (e, t, r) => {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.PDFDataTransportStream = void 0;
          var a = r(1), o = r(6);
          class u {
            constructor({
              length: b,
              initialData: _,
              progressiveDone: y = !1,
              contentDispositionFilename: A = null,
              disableRange: E = !1,
              disableStream: v = !1
            }, C) {
              if ((0, a.assert)(C, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'), this._queuedChunks = [], this._progressiveDone = y, this._contentDispositionFilename = A, (_ == null ? void 0 : _.length) > 0) {
                const R = _ instanceof Uint8Array && _.byteLength === _.buffer.byteLength ? _.buffer : new Uint8Array(_).buffer;
                this._queuedChunks.push(R);
              }
              this._pdfDataRangeTransport = C, this._isStreamingSupported = !v, this._isRangeSupported = !E, this._contentLength = b, this._fullRequestReader = null, this._rangeReaders = [], this._pdfDataRangeTransport.addRangeListener((R, I) => {
                this._onReceiveData({
                  begin: R,
                  chunk: I
                });
              }), this._pdfDataRangeTransport.addProgressListener((R, I) => {
                this._onProgress({
                  loaded: R,
                  total: I
                });
              }), this._pdfDataRangeTransport.addProgressiveReadListener((R) => {
                this._onReceiveData({
                  chunk: R
                });
              }), this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                this._onProgressiveDone();
              }), this._pdfDataRangeTransport.transportReady();
            }
            _onReceiveData({
              begin: b,
              chunk: _
            }) {
              const y = _ instanceof Uint8Array && _.byteLength === _.buffer.byteLength ? _.buffer : new Uint8Array(_).buffer;
              if (b === void 0)
                this._fullRequestReader ? this._fullRequestReader._enqueue(y) : this._queuedChunks.push(y);
              else {
                const A = this._rangeReaders.some(function(E) {
                  return E._begin !== b ? !1 : (E._enqueue(y), !0);
                });
                (0, a.assert)(A, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
              }
            }
            get _progressiveDataLength() {
              var b;
              return ((b = this._fullRequestReader) == null ? void 0 : b._loaded) ?? 0;
            }
            _onProgress(b) {
              var _, y, A, E;
              b.total === void 0 ? (y = (_ = this._rangeReaders[0]) == null ? void 0 : _.onProgress) == null || y.call(_, {
                loaded: b.loaded
              }) : (E = (A = this._fullRequestReader) == null ? void 0 : A.onProgress) == null || E.call(A, {
                loaded: b.loaded,
                total: b.total
              });
            }
            _onProgressiveDone() {
              var b;
              (b = this._fullRequestReader) == null || b.progressiveDone(), this._progressiveDone = !0;
            }
            _removeRangeReader(b) {
              const _ = this._rangeReaders.indexOf(b);
              _ >= 0 && this._rangeReaders.splice(_, 1);
            }
            getFullReader() {
              (0, a.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
              const b = this._queuedChunks;
              return this._queuedChunks = null, new c(this, b, this._progressiveDone, this._contentDispositionFilename);
            }
            getRangeReader(b, _) {
              if (_ <= this._progressiveDataLength)
                return null;
              const y = new d(this, b, _);
              return this._pdfDataRangeTransport.requestDataRange(b, _), this._rangeReaders.push(y), y;
            }
            cancelAllRequests(b) {
              var _;
              (_ = this._fullRequestReader) == null || _.cancel(b);
              for (const y of this._rangeReaders.slice(0))
                y.cancel(b);
              this._pdfDataRangeTransport.abort();
            }
          }
          t.PDFDataTransportStream = u;
          class c {
            constructor(b, _, y = !1, A = null) {
              this._stream = b, this._done = y || !1, this._filename = (0, o.isPdfFile)(A) ? A : null, this._queuedChunks = _ || [], this._loaded = 0;
              for (const E of this._queuedChunks)
                this._loaded += E.byteLength;
              this._requests = [], this._headersReady = Promise.resolve(), b._fullRequestReader = this, this.onProgress = null;
            }
            _enqueue(b) {
              this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
                value: b,
                done: !1
              }) : this._queuedChunks.push(b), this._loaded += b.byteLength);
            }
            get headersReady() {
              return this._headersReady;
            }
            get filename() {
              return this._filename;
            }
            get isRangeSupported() {
              return this._stream._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._stream._isStreamingSupported;
            }
            get contentLength() {
              return this._stream._contentLength;
            }
            async read() {
              if (this._queuedChunks.length > 0)
                return {
                  value: this._queuedChunks.shift(),
                  done: !1
                };
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const b = new a.PromiseCapability();
              return this._requests.push(b), b.promise;
            }
            cancel(b) {
              this._done = !0;
              for (const _ of this._requests)
                _.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0;
            }
            progressiveDone() {
              this._done || (this._done = !0);
            }
          }
          class d {
            constructor(b, _, y) {
              this._stream = b, this._begin = _, this._end = y, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
            }
            _enqueue(b) {
              if (!this._done) {
                if (this._requests.length === 0)
                  this._queuedChunk = b;
                else {
                  this._requests.shift().resolve({
                    value: b,
                    done: !1
                  });
                  for (const y of this._requests)
                    y.resolve({
                      value: void 0,
                      done: !0
                    });
                  this._requests.length = 0;
                }
                this._done = !0, this._stream._removeRangeReader(this);
              }
            }
            get isStreamingSupported() {
              return !1;
            }
            async read() {
              if (this._queuedChunk) {
                const _ = this._queuedChunk;
                return this._queuedChunk = null, {
                  value: _,
                  done: !1
                };
              }
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const b = new a.PromiseCapability();
              return this._requests.push(b), b.promise;
            }
            cancel(b) {
              this._done = !0;
              for (const _ of this._requests)
                _.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._stream._removeRangeReader(this);
            }
          }
        },
        /* 19 */
        /***/
        (e, t, r) => {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.PDFFetchStream = void 0;
          var a = r(1), o = r(20);
          function u(y, A, E) {
            return {
              method: "GET",
              headers: y,
              signal: E.signal,
              mode: "cors",
              credentials: A ? "include" : "same-origin",
              redirect: "follow"
            };
          }
          function c(y) {
            const A = new Headers();
            for (const E in y) {
              const v = y[E];
              v !== void 0 && A.append(E, v);
            }
            return A;
          }
          function d(y) {
            return y instanceof Uint8Array ? y.buffer : y instanceof ArrayBuffer ? y : ((0, a.warn)(`getArrayBuffer - unexpected data format: ${y}`), new Uint8Array(y).buffer);
          }
          class g {
            constructor(A) {
              this.source = A, this.isHttp = /^https?:/i.test(A.url), this.httpHeaders = this.isHttp && A.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            get _progressiveDataLength() {
              var A;
              return ((A = this._fullRequestReader) == null ? void 0 : A._loaded) ?? 0;
            }
            getFullReader() {
              return (0, a.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new b(this), this._fullRequestReader;
            }
            getRangeReader(A, E) {
              if (E <= this._progressiveDataLength)
                return null;
              const v = new _(this, A, E);
              return this._rangeRequestReaders.push(v), v;
            }
            cancelAllRequests(A) {
              var E;
              (E = this._fullRequestReader) == null || E.cancel(A);
              for (const v of this._rangeRequestReaders.slice(0))
                v.cancel(A);
            }
          }
          t.PDFFetchStream = g;
          class b {
            constructor(A) {
              this._stream = A, this._reader = null, this._loaded = 0, this._filename = null;
              const E = A.source;
              this._withCredentials = E.withCredentials || !1, this._contentLength = E.length, this._headersCapability = new a.PromiseCapability(), this._disableRange = E.disableRange || !1, this._rangeChunkSize = E.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !E.disableStream, this._isRangeSupported = !E.disableRange, this._headers = c(this._stream.httpHeaders);
              const v = E.url;
              fetch(v, u(this._headers, this._withCredentials, this._abortController)).then((C) => {
                if (!(0, o.validateResponseStatus)(C.status))
                  throw (0, o.createResponseStatusError)(C.status, v);
                this._reader = C.body.getReader(), this._headersCapability.resolve();
                const R = (N) => C.headers.get(N), {
                  allowRangeRequests: I,
                  suggestedLength: w
                } = (0, o.validateRangeRequestCapabilities)({
                  getResponseHeader: R,
                  isHttp: this._stream.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                });
                this._isRangeSupported = I, this._contentLength = w || this._contentLength, this._filename = (0, o.extractFilenameFromHeader)(R), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new a.AbortException("Streaming is disabled."));
              }).catch(this._headersCapability.reject), this.onProgress = null;
            }
            get headersReady() {
              return this._headersCapability.promise;
            }
            get filename() {
              return this._filename;
            }
            get contentLength() {
              return this._contentLength;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              var v;
              await this._headersCapability.promise;
              const {
                value: A,
                done: E
              } = await this._reader.read();
              return E ? {
                value: A,
                done: E
              } : (this._loaded += A.byteLength, (v = this.onProgress) == null || v.call(this, {
                loaded: this._loaded,
                total: this._contentLength
              }), {
                value: d(A),
                done: !1
              });
            }
            cancel(A) {
              var E;
              (E = this._reader) == null || E.cancel(A), this._abortController.abort();
            }
          }
          class _ {
            constructor(A, E, v) {
              this._stream = A, this._reader = null, this._loaded = 0;
              const C = A.source;
              this._withCredentials = C.withCredentials || !1, this._readCapability = new a.PromiseCapability(), this._isStreamingSupported = !C.disableStream, this._abortController = new AbortController(), this._headers = c(this._stream.httpHeaders), this._headers.append("Range", `bytes=${E}-${v - 1}`);
              const R = C.url;
              fetch(R, u(this._headers, this._withCredentials, this._abortController)).then((I) => {
                if (!(0, o.validateResponseStatus)(I.status))
                  throw (0, o.createResponseStatusError)(I.status, R);
                this._readCapability.resolve(), this._reader = I.body.getReader();
              }).catch(this._readCapability.reject), this.onProgress = null;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              var v;
              await this._readCapability.promise;
              const {
                value: A,
                done: E
              } = await this._reader.read();
              return E ? {
                value: A,
                done: E
              } : (this._loaded += A.byteLength, (v = this.onProgress) == null || v.call(this, {
                loaded: this._loaded
              }), {
                value: d(A),
                done: !1
              });
            }
            cancel(A) {
              var E;
              (E = this._reader) == null || E.cancel(A), this._abortController.abort();
            }
          }
        },
        /* 20 */
        /***/
        (e, t, r) => {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.createResponseStatusError = g, t.extractFilenameFromHeader = d, t.validateRangeRequestCapabilities = c, t.validateResponseStatus = b;
          var a = r(1), o = r(21), u = r(6);
          function c({
            getResponseHeader: _,
            isHttp: y,
            rangeChunkSize: A,
            disableRange: E
          }) {
            const v = {
              allowRangeRequests: !1,
              suggestedLength: void 0
            }, C = parseInt(_("Content-Length"), 10);
            return !Number.isInteger(C) || (v.suggestedLength = C, C <= 2 * A) || E || !y || _("Accept-Ranges") !== "bytes" || (_("Content-Encoding") || "identity") !== "identity" || (v.allowRangeRequests = !0), v;
          }
          function d(_) {
            const y = _("Content-Disposition");
            if (y) {
              let A = (0, o.getFilenameFromContentDispositionHeader)(y);
              if (A.includes("%"))
                try {
                  A = decodeURIComponent(A);
                } catch {
                }
              if ((0, u.isPdfFile)(A))
                return A;
            }
            return null;
          }
          function g(_, y) {
            return _ === 404 || _ === 0 && y.startsWith("file:") ? new a.MissingPDFException('Missing PDF "' + y + '".') : new a.UnexpectedResponseException(`Unexpected server response (${_}) while retrieving PDF "${y}".`, _);
          }
          function b(_) {
            return _ === 200 || _ === 206;
          }
        },
        /* 21 */
        /***/
        (e, t, r) => {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.getFilenameFromContentDispositionHeader = o;
          var a = r(1);
          function o(u) {
            let c = !0, d = g("filename\\*", "i").exec(u);
            if (d) {
              d = d[1];
              let C = A(d);
              return C = unescape(C), C = E(C), C = v(C), _(C);
            }
            if (d = y(u), d) {
              const C = v(d);
              return _(C);
            }
            if (d = g("filename", "i").exec(u), d) {
              d = d[1];
              let C = A(d);
              return C = v(C), _(C);
            }
            function g(C, R) {
              return new RegExp("(?:^|;)\\s*" + C + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', R);
            }
            function b(C, R) {
              if (C) {
                if (!/^[\x00-\xFF]+$/.test(R))
                  return R;
                try {
                  const I = new TextDecoder(C, {
                    fatal: !0
                  }), w = (0, a.stringToBytes)(R);
                  R = I.decode(w), c = !1;
                } catch {
                }
              }
              return R;
            }
            function _(C) {
              return c && /[\x80-\xff]/.test(C) && (C = b("utf-8", C), c && (C = b("iso-8859-1", C))), C;
            }
            function y(C) {
              const R = [];
              let I;
              const w = g("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
              for (; (I = w.exec(C)) !== null; ) {
                let [, F, M, x] = I;
                if (F = parseInt(F, 10), F in R) {
                  if (F === 0)
                    break;
                  continue;
                }
                R[F] = [M, x];
              }
              const N = [];
              for (let F = 0; F < R.length && F in R; ++F) {
                let [M, x] = R[F];
                x = A(x), M && (x = unescape(x), F === 0 && (x = E(x))), N.push(x);
              }
              return N.join("");
            }
            function A(C) {
              if (C.startsWith('"')) {
                const R = C.slice(1).split('\\"');
                for (let I = 0; I < R.length; ++I) {
                  const w = R[I].indexOf('"');
                  w !== -1 && (R[I] = R[I].slice(0, w), R.length = I + 1), R[I] = R[I].replaceAll(/\\(.)/g, "$1");
                }
                C = R.join('"');
              }
              return C;
            }
            function E(C) {
              const R = C.indexOf("'");
              if (R === -1)
                return C;
              const I = C.slice(0, R), N = C.slice(R + 1).replace(/^[^']*'/, "");
              return b(I, N);
            }
            function v(C) {
              return !C.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(C) ? C : C.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(R, I, w, N) {
                if (w === "q" || w === "Q")
                  return N = N.replaceAll("_", " "), N = N.replaceAll(/=([0-9a-fA-F]{2})/g, function(F, M) {
                    return String.fromCharCode(parseInt(M, 16));
                  }), b(I, N);
                try {
                  N = atob(N);
                } catch {
                }
                return b(I, N);
              });
            }
            return "";
          }
        },
        /* 22 */
        /***/
        (e, t, r) => {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.PDFNetworkStream = void 0;
          var a = r(1), o = r(20);
          const u = 200, c = 206;
          function d(A) {
            const E = A.response;
            return typeof E != "string" ? E : (0, a.stringToBytes)(E).buffer;
          }
          class g {
            constructor(E, v = {}) {
              this.url = E, this.isHttp = /^https?:/i.test(E), this.httpHeaders = this.isHttp && v.httpHeaders || /* @__PURE__ */ Object.create(null), this.withCredentials = v.withCredentials || !1, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
            }
            requestRange(E, v, C) {
              const R = {
                begin: E,
                end: v
              };
              for (const I in C)
                R[I] = C[I];
              return this.request(R);
            }
            requestFull(E) {
              return this.request(E);
            }
            request(E) {
              const v = new XMLHttpRequest(), C = this.currXhrId++, R = this.pendingRequests[C] = {
                xhr: v
              };
              v.open("GET", this.url), v.withCredentials = this.withCredentials;
              for (const I in this.httpHeaders) {
                const w = this.httpHeaders[I];
                w !== void 0 && v.setRequestHeader(I, w);
              }
              return this.isHttp && "begin" in E && "end" in E ? (v.setRequestHeader("Range", `bytes=${E.begin}-${E.end - 1}`), R.expectedStatus = c) : R.expectedStatus = u, v.responseType = "arraybuffer", E.onError && (v.onerror = function(I) {
                E.onError(v.status);
              }), v.onreadystatechange = this.onStateChange.bind(this, C), v.onprogress = this.onProgress.bind(this, C), R.onHeadersReceived = E.onHeadersReceived, R.onDone = E.onDone, R.onError = E.onError, R.onProgress = E.onProgress, v.send(null), C;
            }
            onProgress(E, v) {
              var R;
              const C = this.pendingRequests[E];
              C && ((R = C.onProgress) == null || R.call(C, v));
            }
            onStateChange(E, v) {
              var F, M, x;
              const C = this.pendingRequests[E];
              if (!C)
                return;
              const R = C.xhr;
              if (R.readyState >= 2 && C.onHeadersReceived && (C.onHeadersReceived(), delete C.onHeadersReceived), R.readyState !== 4 || !(E in this.pendingRequests))
                return;
              if (delete this.pendingRequests[E], R.status === 0 && this.isHttp) {
                (F = C.onError) == null || F.call(C, R.status);
                return;
              }
              const I = R.status || u;
              if (!(I === u && C.expectedStatus === c) && I !== C.expectedStatus) {
                (M = C.onError) == null || M.call(C, R.status);
                return;
              }
              const N = d(R);
              if (I === c) {
                const P = R.getResponseHeader("Content-Range"), U = /bytes (\d+)-(\d+)\/(\d+)/.exec(P);
                C.onDone({
                  begin: parseInt(U[1], 10),
                  chunk: N
                });
              } else N ? C.onDone({
                begin: 0,
                chunk: N
              }) : (x = C.onError) == null || x.call(C, R.status);
            }
            getRequestXhr(E) {
              return this.pendingRequests[E].xhr;
            }
            isPendingRequest(E) {
              return E in this.pendingRequests;
            }
            abortRequest(E) {
              const v = this.pendingRequests[E].xhr;
              delete this.pendingRequests[E], v.abort();
            }
          }
          class b {
            constructor(E) {
              this._source = E, this._manager = new g(E.url, {
                httpHeaders: E.httpHeaders,
                withCredentials: E.withCredentials
              }), this._rangeChunkSize = E.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            _onRangeRequestReaderClosed(E) {
              const v = this._rangeRequestReaders.indexOf(E);
              v >= 0 && this._rangeRequestReaders.splice(v, 1);
            }
            getFullReader() {
              return (0, a.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new _(this._manager, this._source), this._fullRequestReader;
            }
            getRangeReader(E, v) {
              const C = new y(this._manager, E, v);
              return C.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(C), C;
            }
            cancelAllRequests(E) {
              var v;
              (v = this._fullRequestReader) == null || v.cancel(E);
              for (const C of this._rangeRequestReaders.slice(0))
                C.cancel(E);
            }
          }
          t.PDFNetworkStream = b;
          class _ {
            constructor(E, v) {
              this._manager = E;
              const C = {
                onHeadersReceived: this._onHeadersReceived.bind(this),
                onDone: this._onDone.bind(this),
                onError: this._onError.bind(this),
                onProgress: this._onProgress.bind(this)
              };
              this._url = v.url, this._fullRequestId = E.requestFull(C), this._headersReceivedCapability = new a.PromiseCapability(), this._disableRange = v.disableRange || !1, this._contentLength = v.length, this._rangeChunkSize = v.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
            }
            _onHeadersReceived() {
              const E = this._fullRequestId, v = this._manager.getRequestXhr(E), C = (w) => v.getResponseHeader(w), {
                allowRangeRequests: R,
                suggestedLength: I
              } = (0, o.validateRangeRequestCapabilities)({
                getResponseHeader: C,
                isHttp: this._manager.isHttp,
                rangeChunkSize: this._rangeChunkSize,
                disableRange: this._disableRange
              });
              R && (this._isRangeSupported = !0), this._contentLength = I || this._contentLength, this._filename = (0, o.extractFilenameFromHeader)(C), this._isRangeSupported && this._manager.abortRequest(E), this._headersReceivedCapability.resolve();
            }
            _onDone(E) {
              if (E && (this._requests.length > 0 ? this._requests.shift().resolve({
                value: E.chunk,
                done: !1
              }) : this._cachedChunks.push(E.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
                for (const v of this._requests)
                  v.resolve({
                    value: void 0,
                    done: !0
                  });
                this._requests.length = 0;
              }
            }
            _onError(E) {
              this._storedError = (0, o.createResponseStatusError)(E, this._url), this._headersReceivedCapability.reject(this._storedError);
              for (const v of this._requests)
                v.reject(this._storedError);
              this._requests.length = 0, this._cachedChunks.length = 0;
            }
            _onProgress(E) {
              var v;
              (v = this.onProgress) == null || v.call(this, {
                loaded: E.loaded,
                total: E.lengthComputable ? E.total : this._contentLength
              });
            }
            get filename() {
              return this._filename;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            get contentLength() {
              return this._contentLength;
            }
            get headersReady() {
              return this._headersReceivedCapability.promise;
            }
            async read() {
              if (this._storedError)
                throw this._storedError;
              if (this._cachedChunks.length > 0)
                return {
                  value: this._cachedChunks.shift(),
                  done: !1
                };
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const E = new a.PromiseCapability();
              return this._requests.push(E), E.promise;
            }
            cancel(E) {
              this._done = !0, this._headersReceivedCapability.reject(E);
              for (const v of this._requests)
                v.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
            }
          }
          class y {
            constructor(E, v, C) {
              this._manager = E;
              const R = {
                onDone: this._onDone.bind(this),
                onError: this._onError.bind(this),
                onProgress: this._onProgress.bind(this)
              };
              this._url = E.url, this._requestId = E.requestRange(v, C, R), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
            }
            _close() {
              var E;
              (E = this.onClosed) == null || E.call(this, this);
            }
            _onDone(E) {
              const v = E.chunk;
              this._requests.length > 0 ? this._requests.shift().resolve({
                value: v,
                done: !1
              }) : this._queuedChunk = v, this._done = !0;
              for (const C of this._requests)
                C.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._close();
            }
            _onError(E) {
              this._storedError = (0, o.createResponseStatusError)(E, this._url);
              for (const v of this._requests)
                v.reject(this._storedError);
              this._requests.length = 0, this._queuedChunk = null;
            }
            _onProgress(E) {
              var v;
              this.isStreamingSupported || (v = this.onProgress) == null || v.call(this, {
                loaded: E.loaded
              });
            }
            get isStreamingSupported() {
              return !1;
            }
            async read() {
              if (this._storedError)
                throw this._storedError;
              if (this._queuedChunk !== null) {
                const v = this._queuedChunk;
                return this._queuedChunk = null, {
                  value: v,
                  done: !1
                };
              }
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const E = new a.PromiseCapability();
              return this._requests.push(E), E.promise;
            }
            cancel(E) {
              this._done = !0;
              for (const v of this._requests)
                v.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
            }
          }
        },
        /* 23 */
        /***/
        (e, t, r) => {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.PDFNodeStream = void 0;
          var a = r(1), o = r(20);
          const u = /^file:\/\/\/[a-zA-Z]:\//;
          function c(C) {
            const R = require$$5, I = R.parse(C);
            return I.protocol === "file:" || I.host ? I : /^[a-z]:[/\\]/i.test(C) ? R.parse(`file:///${C}`) : (I.host || (I.protocol = "file:"), I);
          }
          class d {
            constructor(R) {
              this.source = R, this.url = c(R.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.httpHeaders = this.isHttp && R.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            get _progressiveDataLength() {
              var R;
              return ((R = this._fullRequestReader) == null ? void 0 : R._loaded) ?? 0;
            }
            getFullReader() {
              return (0, a.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new E(this) : new y(this), this._fullRequestReader;
            }
            getRangeReader(R, I) {
              if (I <= this._progressiveDataLength)
                return null;
              const w = this.isFsUrl ? new v(this, R, I) : new A(this, R, I);
              return this._rangeRequestReaders.push(w), w;
            }
            cancelAllRequests(R) {
              var I;
              (I = this._fullRequestReader) == null || I.cancel(R);
              for (const w of this._rangeRequestReaders.slice(0))
                w.cancel(R);
            }
          }
          t.PDFNodeStream = d;
          class g {
            constructor(R) {
              this._url = R.url, this._done = !1, this._storedError = null, this.onProgress = null;
              const I = R.source;
              this._contentLength = I.length, this._loaded = 0, this._filename = null, this._disableRange = I.disableRange || !1, this._rangeChunkSize = I.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !I.disableStream, this._isRangeSupported = !I.disableRange, this._readableStream = null, this._readCapability = new a.PromiseCapability(), this._headersCapability = new a.PromiseCapability();
            }
            get headersReady() {
              return this._headersCapability.promise;
            }
            get filename() {
              return this._filename;
            }
            get contentLength() {
              return this._contentLength;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              var w;
              if (await this._readCapability.promise, this._done)
                return {
                  value: void 0,
                  done: !0
                };
              if (this._storedError)
                throw this._storedError;
              const R = this._readableStream.read();
              return R === null ? (this._readCapability = new a.PromiseCapability(), this.read()) : (this._loaded += R.length, (w = this.onProgress) == null || w.call(this, {
                loaded: this._loaded,
                total: this._contentLength
              }), {
                value: new Uint8Array(R).buffer,
                done: !1
              });
            }
            cancel(R) {
              if (!this._readableStream) {
                this._error(R);
                return;
              }
              this._readableStream.destroy(R);
            }
            _error(R) {
              this._storedError = R, this._readCapability.resolve();
            }
            _setReadableStream(R) {
              this._readableStream = R, R.on("readable", () => {
                this._readCapability.resolve();
              }), R.on("end", () => {
                R.destroy(), this._done = !0, this._readCapability.resolve();
              }), R.on("error", (I) => {
                this._error(I);
              }), !this._isStreamingSupported && this._isRangeSupported && this._error(new a.AbortException("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
            }
          }
          class b {
            constructor(R) {
              this._url = R.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = new a.PromiseCapability();
              const I = R.source;
              this._isStreamingSupported = !I.disableStream;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              var w;
              if (await this._readCapability.promise, this._done)
                return {
                  value: void 0,
                  done: !0
                };
              if (this._storedError)
                throw this._storedError;
              const R = this._readableStream.read();
              return R === null ? (this._readCapability = new a.PromiseCapability(), this.read()) : (this._loaded += R.length, (w = this.onProgress) == null || w.call(this, {
                loaded: this._loaded
              }), {
                value: new Uint8Array(R).buffer,
                done: !1
              });
            }
            cancel(R) {
              if (!this._readableStream) {
                this._error(R);
                return;
              }
              this._readableStream.destroy(R);
            }
            _error(R) {
              this._storedError = R, this._readCapability.resolve();
            }
            _setReadableStream(R) {
              this._readableStream = R, R.on("readable", () => {
                this._readCapability.resolve();
              }), R.on("end", () => {
                R.destroy(), this._done = !0, this._readCapability.resolve();
              }), R.on("error", (I) => {
                this._error(I);
              }), this._storedError && this._readableStream.destroy(this._storedError);
            }
          }
          function _(C, R) {
            return {
              protocol: C.protocol,
              auth: C.auth,
              host: C.hostname,
              port: C.port,
              path: C.path,
              method: "GET",
              headers: R
            };
          }
          class y extends g {
            constructor(R) {
              super(R);
              const I = (w) => {
                if (w.statusCode === 404) {
                  const x = new a.MissingPDFException(`Missing PDF "${this._url}".`);
                  this._storedError = x, this._headersCapability.reject(x);
                  return;
                }
                this._headersCapability.resolve(), this._setReadableStream(w);
                const N = (x) => this._readableStream.headers[x.toLowerCase()], {
                  allowRangeRequests: F,
                  suggestedLength: M
                } = (0, o.validateRangeRequestCapabilities)({
                  getResponseHeader: N,
                  isHttp: R.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                });
                this._isRangeSupported = F, this._contentLength = M || this._contentLength, this._filename = (0, o.extractFilenameFromHeader)(N);
              };
              if (this._request = null, this._url.protocol === "http:") {
                const w = require$$5;
                this._request = w.request(_(this._url, R.httpHeaders), I);
              } else {
                const w = require$$5;
                this._request = w.request(_(this._url, R.httpHeaders), I);
              }
              this._request.on("error", (w) => {
                this._storedError = w, this._headersCapability.reject(w);
              }), this._request.end();
            }
          }
          class A extends b {
            constructor(R, I, w) {
              super(R), this._httpHeaders = {};
              for (const F in R.httpHeaders) {
                const M = R.httpHeaders[F];
                M !== void 0 && (this._httpHeaders[F] = M);
              }
              this._httpHeaders.Range = `bytes=${I}-${w - 1}`;
              const N = (F) => {
                if (F.statusCode === 404) {
                  const M = new a.MissingPDFException(`Missing PDF "${this._url}".`);
                  this._storedError = M;
                  return;
                }
                this._setReadableStream(F);
              };
              if (this._request = null, this._url.protocol === "http:") {
                const F = require$$5;
                this._request = F.request(_(this._url, this._httpHeaders), N);
              } else {
                const F = require$$5;
                this._request = F.request(_(this._url, this._httpHeaders), N);
              }
              this._request.on("error", (F) => {
                this._storedError = F;
              }), this._request.end();
            }
          }
          class E extends g {
            constructor(R) {
              super(R);
              let I = decodeURIComponent(this._url.path);
              u.test(this._url.href) && (I = I.replace(/^\//, ""));
              const w = require$$5;
              w.lstat(I, (N, F) => {
                if (N) {
                  N.code === "ENOENT" && (N = new a.MissingPDFException(`Missing PDF "${I}".`)), this._storedError = N, this._headersCapability.reject(N);
                  return;
                }
                this._contentLength = F.size, this._setReadableStream(w.createReadStream(I)), this._headersCapability.resolve();
              });
            }
          }
          class v extends b {
            constructor(R, I, w) {
              super(R);
              let N = decodeURIComponent(this._url.path);
              u.test(this._url.href) && (N = N.replace(/^\//, ""));
              const F = require$$5;
              this._setReadableStream(F.createReadStream(N, {
                start: I,
                end: w - 1
              }));
            }
          }
        },
        /* 24 */
        /***/
        (e, t, r) => {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.SVGGraphics = void 0;
          var a = r(6), o = r(1);
          const u = {
            fontStyle: "normal",
            fontWeight: "normal",
            fillColor: "#000000"
          }, c = "http://www.w3.org/XML/1998/namespace", d = "http://www.w3.org/1999/xlink", g = ["butt", "round", "square"], b = ["miter", "round", "bevel"], _ = function(F, M = "", x = !1) {
            if (URL.createObjectURL && typeof Blob < "u" && !x)
              return URL.createObjectURL(new Blob([F], {
                type: M
              }));
            const P = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            let U = `data:${M};base64,`;
            for (let L = 0, H = F.length; L < H; L += 3) {
              const B = F[L] & 255, V = F[L + 1] & 255, X = F[L + 2] & 255, de = B >> 2, Y = (B & 3) << 4 | V >> 4, se = L + 1 < H ? (V & 15) << 2 | X >> 6 : 64, ue = L + 2 < H ? X & 63 : 64;
              U += P[de] + P[Y] + P[se] + P[ue];
            }
            return U;
          }, y = function() {
            const F = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]), M = 12, x = new Int32Array(256);
            for (let X = 0; X < 256; X++) {
              let de = X;
              for (let Y = 0; Y < 8; Y++)
                de = de & 1 ? 3988292384 ^ de >> 1 & 2147483647 : de >> 1 & 2147483647;
              x[X] = de;
            }
            function P(X, de, Y) {
              let se = -1;
              for (let ue = de; ue < Y; ue++) {
                const pe = (se ^ X[ue]) & 255, J = x[pe];
                se = se >>> 8 ^ J;
              }
              return se ^ -1;
            }
            function U(X, de, Y, se) {
              let ue = se;
              const pe = de.length;
              Y[ue] = pe >> 24 & 255, Y[ue + 1] = pe >> 16 & 255, Y[ue + 2] = pe >> 8 & 255, Y[ue + 3] = pe & 255, ue += 4, Y[ue] = X.charCodeAt(0) & 255, Y[ue + 1] = X.charCodeAt(1) & 255, Y[ue + 2] = X.charCodeAt(2) & 255, Y[ue + 3] = X.charCodeAt(3) & 255, ue += 4, Y.set(de, ue), ue += de.length;
              const J = P(Y, se + 4, ue);
              Y[ue] = J >> 24 & 255, Y[ue + 1] = J >> 16 & 255, Y[ue + 2] = J >> 8 & 255, Y[ue + 3] = J & 255;
            }
            function L(X, de, Y) {
              let se = 1, ue = 0;
              for (let pe = de; pe < Y; ++pe)
                se = (se + (X[pe] & 255)) % 65521, ue = (ue + se) % 65521;
              return ue << 16 | se;
            }
            function H(X) {
              if (!o.isNodeJS)
                return B(X);
              try {
                const de = parseInt(process.versions.node) >= 8 ? X : Buffer.from(X), Y = require$$5.deflateSync(de, {
                  level: 9
                });
                return Y instanceof Uint8Array ? Y : new Uint8Array(Y);
              } catch (de) {
                (0, o.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + de);
              }
              return B(X);
            }
            function B(X) {
              let de = X.length;
              const Y = 65535, se = Math.ceil(de / Y), ue = new Uint8Array(2 + de + se * 5 + 4);
              let pe = 0;
              ue[pe++] = 120, ue[pe++] = 156;
              let J = 0;
              for (; de > Y; )
                ue[pe++] = 0, ue[pe++] = 255, ue[pe++] = 255, ue[pe++] = 0, ue[pe++] = 0, ue.set(X.subarray(J, J + Y), pe), pe += Y, J += Y, de -= Y;
              ue[pe++] = 1, ue[pe++] = de & 255, ue[pe++] = de >> 8 & 255, ue[pe++] = ~de & 65535 & 255, ue[pe++] = (~de & 65535) >> 8 & 255, ue.set(X.subarray(J), pe), pe += X.length - J;
              const j = L(X, 0, X.length);
              return ue[pe++] = j >> 24 & 255, ue[pe++] = j >> 16 & 255, ue[pe++] = j >> 8 & 255, ue[pe++] = j & 255, ue;
            }
            function V(X, de, Y, se) {
              const ue = X.width, pe = X.height;
              let J, j, le;
              const Z = X.data;
              switch (de) {
                case o.ImageKind.GRAYSCALE_1BPP:
                  j = 0, J = 1, le = ue + 7 >> 3;
                  break;
                case o.ImageKind.RGB_24BPP:
                  j = 2, J = 8, le = ue * 3;
                  break;
                case o.ImageKind.RGBA_32BPP:
                  j = 6, J = 8, le = ue * 4;
                  break;
                default:
                  throw new Error("invalid format");
              }
              const O = new Uint8Array((1 + le) * pe);
              let z = 0, W = 0;
              for (let Re = 0; Re < pe; ++Re)
                O[z++] = 0, O.set(Z.subarray(W, W + le), z), W += le, z += le;
              if (de === o.ImageKind.GRAYSCALE_1BPP && se) {
                z = 0;
                for (let Re = 0; Re < pe; Re++) {
                  z++;
                  for (let De = 0; De < le; De++)
                    O[z++] ^= 255;
                }
              }
              const ee = new Uint8Array([ue >> 24 & 255, ue >> 16 & 255, ue >> 8 & 255, ue & 255, pe >> 24 & 255, pe >> 16 & 255, pe >> 8 & 255, pe & 255, J, j, 0, 0, 0]), ae = H(O), ie = F.length + M * 3 + ee.length + ae.length, me = new Uint8Array(ie);
              let ye = 0;
              return me.set(F, ye), ye += F.length, U("IHDR", ee, me, ye), ye += M + ee.length, U("IDATA", ae, me, ye), ye += M + ae.length, U("IEND", new Uint8Array(0), me, ye), _(me, "image/png", Y);
            }
            return function(de, Y, se) {
              const ue = de.kind === void 0 ? o.ImageKind.GRAYSCALE_1BPP : de.kind;
              return V(de, ue, Y, se);
            };
          }();
          class A {
            constructor() {
              this.fontSizeScale = 1, this.fontWeight = u.fontWeight, this.fontSize = 0, this.textMatrix = o.IDENTITY_MATRIX, this.fontMatrix = o.FONT_IDENTITY_MATRIX, this.leading = 0, this.textRenderingMode = o.TextRenderingMode.FILL, this.textMatrixScale = 1, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRise = 0, this.fillColor = u.fillColor, this.strokeColor = "#000000", this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.lineJoin = "", this.lineCap = "", this.miterLimit = 0, this.dashArray = [], this.dashPhase = 0, this.dependencies = [], this.activeClipUrl = null, this.clipGroup = null, this.maskId = "";
            }
            clone() {
              return Object.create(this);
            }
            setCurrentPoint(M, x) {
              this.x = M, this.y = x;
            }
          }
          function E(F) {
            let M = [];
            const x = [];
            for (const P of F) {
              if (P.fn === "save") {
                M.push({
                  fnId: 92,
                  fn: "group",
                  items: []
                }), x.push(M), M = M.at(-1).items;
                continue;
              }
              P.fn === "restore" ? M = x.pop() : M.push(P);
            }
            return M;
          }
          function v(F) {
            if (Number.isInteger(F))
              return F.toString();
            const M = F.toFixed(10);
            let x = M.length - 1;
            if (M[x] !== "0")
              return M;
            do
              x--;
            while (M[x] === "0");
            return M.substring(0, M[x] === "." ? x : x + 1);
          }
          function C(F) {
            if (F[4] === 0 && F[5] === 0) {
              if (F[1] === 0 && F[2] === 0)
                return F[0] === 1 && F[3] === 1 ? "" : `scale(${v(F[0])} ${v(F[3])})`;
              if (F[0] === F[3] && F[1] === -F[2]) {
                const M = Math.acos(F[0]) * 180 / Math.PI;
                return `rotate(${v(M)})`;
              }
            } else if (F[0] === 1 && F[1] === 0 && F[2] === 0 && F[3] === 1)
              return `translate(${v(F[4])} ${v(F[5])})`;
            return `matrix(${v(F[0])} ${v(F[1])} ${v(F[2])} ${v(F[3])} ${v(F[4])} ${v(F[5])})`;
          }
          let R = 0, I = 0, w = 0;
          class N {
            constructor(M, x, P = !1) {
              (0, a.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future."), this.svgFactory = new a.DOMSVGFactory(), this.current = new A(), this.transformMatrix = o.IDENTITY_MATRIX, this.transformStack = [], this.extraStack = [], this.commonObjs = M, this.objs = x, this.pendingClip = null, this.pendingEOFill = !1, this.embedFonts = !1, this.embeddedFonts = /* @__PURE__ */ Object.create(null), this.cssStyle = null, this.forceDataSchema = !!P, this._operatorIdMapping = [];
              for (const U in o.OPS)
                this._operatorIdMapping[o.OPS[U]] = U;
            }
            getObject(M, x = null) {
              return typeof M == "string" ? M.startsWith("g_") ? this.commonObjs.get(M) : this.objs.get(M) : x;
            }
            save() {
              this.transformStack.push(this.transformMatrix);
              const M = this.current;
              this.extraStack.push(M), this.current = M.clone();
            }
            restore() {
              this.transformMatrix = this.transformStack.pop(), this.current = this.extraStack.pop(), this.pendingClip = null, this.tgrp = null;
            }
            group(M) {
              this.save(), this.executeOpTree(M), this.restore();
            }
            loadDependencies(M) {
              const x = M.fnArray, P = M.argsArray;
              for (let U = 0, L = x.length; U < L; U++)
                if (x[U] === o.OPS.dependency)
                  for (const H of P[U]) {
                    const B = H.startsWith("g_") ? this.commonObjs : this.objs, V = new Promise((X) => {
                      B.get(H, X);
                    });
                    this.current.dependencies.push(V);
                  }
              return Promise.all(this.current.dependencies);
            }
            transform(M, x, P, U, L, H) {
              const B = [M, x, P, U, L, H];
              this.transformMatrix = o.Util.transform(this.transformMatrix, B), this.tgrp = null;
            }
            getSVG(M, x) {
              this.viewport = x;
              const P = this._initialize(x);
              return this.loadDependencies(M).then(() => (this.transformMatrix = o.IDENTITY_MATRIX, this.executeOpTree(this.convertOpList(M)), P));
            }
            convertOpList(M) {
              const x = this._operatorIdMapping, P = M.argsArray, U = M.fnArray, L = [];
              for (let H = 0, B = U.length; H < B; H++) {
                const V = U[H];
                L.push({
                  fnId: V,
                  fn: x[V],
                  args: P[H]
                });
              }
              return E(L);
            }
            executeOpTree(M) {
              for (const x of M) {
                const P = x.fn, U = x.fnId, L = x.args;
                switch (U | 0) {
                  case o.OPS.beginText:
                    this.beginText();
                    break;
                  case o.OPS.dependency:
                    break;
                  case o.OPS.setLeading:
                    this.setLeading(L);
                    break;
                  case o.OPS.setLeadingMoveText:
                    this.setLeadingMoveText(L[0], L[1]);
                    break;
                  case o.OPS.setFont:
                    this.setFont(L);
                    break;
                  case o.OPS.showText:
                    this.showText(L[0]);
                    break;
                  case o.OPS.showSpacedText:
                    this.showText(L[0]);
                    break;
                  case o.OPS.endText:
                    this.endText();
                    break;
                  case o.OPS.moveText:
                    this.moveText(L[0], L[1]);
                    break;
                  case o.OPS.setCharSpacing:
                    this.setCharSpacing(L[0]);
                    break;
                  case o.OPS.setWordSpacing:
                    this.setWordSpacing(L[0]);
                    break;
                  case o.OPS.setHScale:
                    this.setHScale(L[0]);
                    break;
                  case o.OPS.setTextMatrix:
                    this.setTextMatrix(L[0], L[1], L[2], L[3], L[4], L[5]);
                    break;
                  case o.OPS.setTextRise:
                    this.setTextRise(L[0]);
                    break;
                  case o.OPS.setTextRenderingMode:
                    this.setTextRenderingMode(L[0]);
                    break;
                  case o.OPS.setLineWidth:
                    this.setLineWidth(L[0]);
                    break;
                  case o.OPS.setLineJoin:
                    this.setLineJoin(L[0]);
                    break;
                  case o.OPS.setLineCap:
                    this.setLineCap(L[0]);
                    break;
                  case o.OPS.setMiterLimit:
                    this.setMiterLimit(L[0]);
                    break;
                  case o.OPS.setFillRGBColor:
                    this.setFillRGBColor(L[0], L[1], L[2]);
                    break;
                  case o.OPS.setStrokeRGBColor:
                    this.setStrokeRGBColor(L[0], L[1], L[2]);
                    break;
                  case o.OPS.setStrokeColorN:
                    this.setStrokeColorN(L);
                    break;
                  case o.OPS.setFillColorN:
                    this.setFillColorN(L);
                    break;
                  case o.OPS.shadingFill:
                    this.shadingFill(L[0]);
                    break;
                  case o.OPS.setDash:
                    this.setDash(L[0], L[1]);
                    break;
                  case o.OPS.setRenderingIntent:
                    this.setRenderingIntent(L[0]);
                    break;
                  case o.OPS.setFlatness:
                    this.setFlatness(L[0]);
                    break;
                  case o.OPS.setGState:
                    this.setGState(L[0]);
                    break;
                  case o.OPS.fill:
                    this.fill();
                    break;
                  case o.OPS.eoFill:
                    this.eoFill();
                    break;
                  case o.OPS.stroke:
                    this.stroke();
                    break;
                  case o.OPS.fillStroke:
                    this.fillStroke();
                    break;
                  case o.OPS.eoFillStroke:
                    this.eoFillStroke();
                    break;
                  case o.OPS.clip:
                    this.clip("nonzero");
                    break;
                  case o.OPS.eoClip:
                    this.clip("evenodd");
                    break;
                  case o.OPS.paintSolidColorImageMask:
                    this.paintSolidColorImageMask();
                    break;
                  case o.OPS.paintImageXObject:
                    this.paintImageXObject(L[0]);
                    break;
                  case o.OPS.paintInlineImageXObject:
                    this.paintInlineImageXObject(L[0]);
                    break;
                  case o.OPS.paintImageMaskXObject:
                    this.paintImageMaskXObject(L[0]);
                    break;
                  case o.OPS.paintFormXObjectBegin:
                    this.paintFormXObjectBegin(L[0], L[1]);
                    break;
                  case o.OPS.paintFormXObjectEnd:
                    this.paintFormXObjectEnd();
                    break;
                  case o.OPS.closePath:
                    this.closePath();
                    break;
                  case o.OPS.closeStroke:
                    this.closeStroke();
                    break;
                  case o.OPS.closeFillStroke:
                    this.closeFillStroke();
                    break;
                  case o.OPS.closeEOFillStroke:
                    this.closeEOFillStroke();
                    break;
                  case o.OPS.nextLine:
                    this.nextLine();
                    break;
                  case o.OPS.transform:
                    this.transform(L[0], L[1], L[2], L[3], L[4], L[5]);
                    break;
                  case o.OPS.constructPath:
                    this.constructPath(L[0], L[1]);
                    break;
                  case o.OPS.endPath:
                    this.endPath();
                    break;
                  case 92:
                    this.group(x.items);
                    break;
                  default:
                    (0, o.warn)(`Unimplemented operator ${P}`);
                    break;
                }
              }
            }
            setWordSpacing(M) {
              this.current.wordSpacing = M;
            }
            setCharSpacing(M) {
              this.current.charSpacing = M;
            }
            nextLine() {
              this.moveText(0, this.current.leading);
            }
            setTextMatrix(M, x, P, U, L, H) {
              const B = this.current;
              B.textMatrix = B.lineMatrix = [M, x, P, U, L, H], B.textMatrixScale = Math.hypot(M, x), B.x = B.lineX = 0, B.y = B.lineY = 0, B.xcoords = [], B.ycoords = [], B.tspan = this.svgFactory.createElement("svg:tspan"), B.tspan.setAttributeNS(null, "font-family", B.fontFamily), B.tspan.setAttributeNS(null, "font-size", `${v(B.fontSize)}px`), B.tspan.setAttributeNS(null, "y", v(-B.y)), B.txtElement = this.svgFactory.createElement("svg:text"), B.txtElement.append(B.tspan);
            }
            beginText() {
              const M = this.current;
              M.x = M.lineX = 0, M.y = M.lineY = 0, M.textMatrix = o.IDENTITY_MATRIX, M.lineMatrix = o.IDENTITY_MATRIX, M.textMatrixScale = 1, M.tspan = this.svgFactory.createElement("svg:tspan"), M.txtElement = this.svgFactory.createElement("svg:text"), M.txtgrp = this.svgFactory.createElement("svg:g"), M.xcoords = [], M.ycoords = [];
            }
            moveText(M, x) {
              const P = this.current;
              P.x = P.lineX += M, P.y = P.lineY += x, P.xcoords = [], P.ycoords = [], P.tspan = this.svgFactory.createElement("svg:tspan"), P.tspan.setAttributeNS(null, "font-family", P.fontFamily), P.tspan.setAttributeNS(null, "font-size", `${v(P.fontSize)}px`), P.tspan.setAttributeNS(null, "y", v(-P.y));
            }
            showText(M) {
              const x = this.current, P = x.font, U = x.fontSize;
              if (U === 0)
                return;
              const L = x.fontSizeScale, H = x.charSpacing, B = x.wordSpacing, V = x.fontDirection, X = x.textHScale * V, de = P.vertical, Y = de ? 1 : -1, se = P.defaultVMetrics, ue = U * x.fontMatrix[0];
              let pe = 0;
              for (const le of M) {
                if (le === null) {
                  pe += V * B;
                  continue;
                } else if (typeof le == "number") {
                  pe += Y * le * U / 1e3;
                  continue;
                }
                const Z = (le.isSpace ? B : 0) + H, O = le.fontChar;
                let z, W, ee = le.width;
                if (de) {
                  let ie;
                  const me = le.vmetric || se;
                  ie = le.vmetric ? me[1] : ee * 0.5, ie = -ie * ue;
                  const ye = me[2] * ue;
                  ee = me ? -me[0] : ee, z = ie / L, W = (pe + ye) / L;
                } else
                  z = pe / L, W = 0;
                (le.isInFont || P.missingFile) && (x.xcoords.push(x.x + z), de && x.ycoords.push(-x.y + W), x.tspan.textContent += O);
                const ae = de ? ee * ue - Z * V : ee * ue + Z * V;
                pe += ae;
              }
              x.tspan.setAttributeNS(null, "x", x.xcoords.map(v).join(" ")), de ? x.tspan.setAttributeNS(null, "y", x.ycoords.map(v).join(" ")) : x.tspan.setAttributeNS(null, "y", v(-x.y)), de ? x.y -= pe : x.x += pe * X, x.tspan.setAttributeNS(null, "font-family", x.fontFamily), x.tspan.setAttributeNS(null, "font-size", `${v(x.fontSize)}px`), x.fontStyle !== u.fontStyle && x.tspan.setAttributeNS(null, "font-style", x.fontStyle), x.fontWeight !== u.fontWeight && x.tspan.setAttributeNS(null, "font-weight", x.fontWeight);
              const J = x.textRenderingMode & o.TextRenderingMode.FILL_STROKE_MASK;
              if (J === o.TextRenderingMode.FILL || J === o.TextRenderingMode.FILL_STROKE ? (x.fillColor !== u.fillColor && x.tspan.setAttributeNS(null, "fill", x.fillColor), x.fillAlpha < 1 && x.tspan.setAttributeNS(null, "fill-opacity", x.fillAlpha)) : x.textRenderingMode === o.TextRenderingMode.ADD_TO_PATH ? x.tspan.setAttributeNS(null, "fill", "transparent") : x.tspan.setAttributeNS(null, "fill", "none"), J === o.TextRenderingMode.STROKE || J === o.TextRenderingMode.FILL_STROKE) {
                const le = 1 / (x.textMatrixScale || 1);
                this._setStrokeAttributes(x.tspan, le);
              }
              let j = x.textMatrix;
              x.textRise !== 0 && (j = j.slice(), j[5] += x.textRise), x.txtElement.setAttributeNS(null, "transform", `${C(j)} scale(${v(X)}, -1)`), x.txtElement.setAttributeNS(c, "xml:space", "preserve"), x.txtElement.append(x.tspan), x.txtgrp.append(x.txtElement), this._ensureTransformGroup().append(x.txtElement);
            }
            setLeadingMoveText(M, x) {
              this.setLeading(-x), this.moveText(M, x);
            }
            addFontStyle(M) {
              if (!M.data)
                throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
              this.cssStyle || (this.cssStyle = this.svgFactory.createElement("svg:style"), this.cssStyle.setAttributeNS(null, "type", "text/css"), this.defs.append(this.cssStyle));
              const x = _(M.data, M.mimetype, this.forceDataSchema);
              this.cssStyle.textContent += `@font-face { font-family: "${M.loadedName}"; src: url(${x}); }
`;
            }
            setFont(M) {
              const x = this.current, P = this.commonObjs.get(M[0]);
              let U = M[1];
              x.font = P, this.embedFonts && !P.missingFile && !this.embeddedFonts[P.loadedName] && (this.addFontStyle(P), this.embeddedFonts[P.loadedName] = P), x.fontMatrix = P.fontMatrix || o.FONT_IDENTITY_MATRIX;
              let L = "normal";
              P.black ? L = "900" : P.bold && (L = "bold");
              const H = P.italic ? "italic" : "normal";
              U < 0 ? (U = -U, x.fontDirection = -1) : x.fontDirection = 1, x.fontSize = U, x.fontFamily = P.loadedName, x.fontWeight = L, x.fontStyle = H, x.tspan = this.svgFactory.createElement("svg:tspan"), x.tspan.setAttributeNS(null, "y", v(-x.y)), x.xcoords = [], x.ycoords = [];
            }
            endText() {
              var x;
              const M = this.current;
              M.textRenderingMode & o.TextRenderingMode.ADD_TO_PATH_FLAG && ((x = M.txtElement) != null && x.hasChildNodes()) && (M.element = M.txtElement, this.clip("nonzero"), this.endPath());
            }
            setLineWidth(M) {
              M > 0 && (this.current.lineWidth = M);
            }
            setLineCap(M) {
              this.current.lineCap = g[M];
            }
            setLineJoin(M) {
              this.current.lineJoin = b[M];
            }
            setMiterLimit(M) {
              this.current.miterLimit = M;
            }
            setStrokeAlpha(M) {
              this.current.strokeAlpha = M;
            }
            setStrokeRGBColor(M, x, P) {
              this.current.strokeColor = o.Util.makeHexColor(M, x, P);
            }
            setFillAlpha(M) {
              this.current.fillAlpha = M;
            }
            setFillRGBColor(M, x, P) {
              this.current.fillColor = o.Util.makeHexColor(M, x, P), this.current.tspan = this.svgFactory.createElement("svg:tspan"), this.current.xcoords = [], this.current.ycoords = [];
            }
            setStrokeColorN(M) {
              this.current.strokeColor = this._makeColorN_Pattern(M);
            }
            setFillColorN(M) {
              this.current.fillColor = this._makeColorN_Pattern(M);
            }
            shadingFill(M) {
              const {
                width: x,
                height: P
              } = this.viewport, U = o.Util.inverseTransform(this.transformMatrix), [L, H, B, V] = o.Util.getAxialAlignedBoundingBox([0, 0, x, P], U), X = this.svgFactory.createElement("svg:rect");
              X.setAttributeNS(null, "x", L), X.setAttributeNS(null, "y", H), X.setAttributeNS(null, "width", B - L), X.setAttributeNS(null, "height", V - H), X.setAttributeNS(null, "fill", this._makeShadingPattern(M)), this.current.fillAlpha < 1 && X.setAttributeNS(null, "fill-opacity", this.current.fillAlpha), this._ensureTransformGroup().append(X);
            }
            _makeColorN_Pattern(M) {
              return M[0] === "TilingPattern" ? this._makeTilingPattern(M) : this._makeShadingPattern(M);
            }
            _makeTilingPattern(M) {
              const x = M[1], P = M[2], U = M[3] || o.IDENTITY_MATRIX, [L, H, B, V] = M[4], X = M[5], de = M[6], Y = M[7], se = `shading${w++}`, [ue, pe, J, j] = o.Util.normalizeRect([...o.Util.applyTransform([L, H], U), ...o.Util.applyTransform([B, V], U)]), [le, Z] = o.Util.singularValueDecompose2dScale(U), O = X * le, z = de * Z, W = this.svgFactory.createElement("svg:pattern");
              W.setAttributeNS(null, "id", se), W.setAttributeNS(null, "patternUnits", "userSpaceOnUse"), W.setAttributeNS(null, "width", O), W.setAttributeNS(null, "height", z), W.setAttributeNS(null, "x", `${ue}`), W.setAttributeNS(null, "y", `${pe}`);
              const ee = this.svg, ae = this.transformMatrix, ie = this.current.fillColor, me = this.current.strokeColor, ye = this.svgFactory.create(J - ue, j - pe);
              if (this.svg = ye, this.transformMatrix = U, Y === 2) {
                const Re = o.Util.makeHexColor(...x);
                this.current.fillColor = Re, this.current.strokeColor = Re;
              }
              return this.executeOpTree(this.convertOpList(P)), this.svg = ee, this.transformMatrix = ae, this.current.fillColor = ie, this.current.strokeColor = me, W.append(ye.childNodes[0]), this.defs.append(W), `url(#${se})`;
            }
            _makeShadingPattern(M) {
              switch (typeof M == "string" && (M = this.objs.get(M)), M[0]) {
                case "RadialAxial":
                  const x = `shading${w++}`, P = M[3];
                  let U;
                  switch (M[1]) {
                    case "axial":
                      const L = M[4], H = M[5];
                      U = this.svgFactory.createElement("svg:linearGradient"), U.setAttributeNS(null, "id", x), U.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), U.setAttributeNS(null, "x1", L[0]), U.setAttributeNS(null, "y1", L[1]), U.setAttributeNS(null, "x2", H[0]), U.setAttributeNS(null, "y2", H[1]);
                      break;
                    case "radial":
                      const B = M[4], V = M[5], X = M[6], de = M[7];
                      U = this.svgFactory.createElement("svg:radialGradient"), U.setAttributeNS(null, "id", x), U.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), U.setAttributeNS(null, "cx", V[0]), U.setAttributeNS(null, "cy", V[1]), U.setAttributeNS(null, "r", de), U.setAttributeNS(null, "fx", B[0]), U.setAttributeNS(null, "fy", B[1]), U.setAttributeNS(null, "fr", X);
                      break;
                    default:
                      throw new Error(`Unknown RadialAxial type: ${M[1]}`);
                  }
                  for (const L of P) {
                    const H = this.svgFactory.createElement("svg:stop");
                    H.setAttributeNS(null, "offset", L[0]), H.setAttributeNS(null, "stop-color", L[1]), U.append(H);
                  }
                  return this.defs.append(U), `url(#${x})`;
                case "Mesh":
                  return (0, o.warn)("Unimplemented pattern Mesh"), null;
                case "Dummy":
                  return "hotpink";
                default:
                  throw new Error(`Unknown IR type: ${M[0]}`);
              }
            }
            setDash(M, x) {
              this.current.dashArray = M, this.current.dashPhase = x;
            }
            constructPath(M, x) {
              const P = this.current;
              let U = P.x, L = P.y, H = [], B = 0;
              for (const V of M)
                switch (V | 0) {
                  case o.OPS.rectangle:
                    U = x[B++], L = x[B++];
                    const X = x[B++], de = x[B++], Y = U + X, se = L + de;
                    H.push("M", v(U), v(L), "L", v(Y), v(L), "L", v(Y), v(se), "L", v(U), v(se), "Z");
                    break;
                  case o.OPS.moveTo:
                    U = x[B++], L = x[B++], H.push("M", v(U), v(L));
                    break;
                  case o.OPS.lineTo:
                    U = x[B++], L = x[B++], H.push("L", v(U), v(L));
                    break;
                  case o.OPS.curveTo:
                    U = x[B + 4], L = x[B + 5], H.push("C", v(x[B]), v(x[B + 1]), v(x[B + 2]), v(x[B + 3]), v(U), v(L)), B += 6;
                    break;
                  case o.OPS.curveTo2:
                    H.push("C", v(U), v(L), v(x[B]), v(x[B + 1]), v(x[B + 2]), v(x[B + 3])), U = x[B + 2], L = x[B + 3], B += 4;
                    break;
                  case o.OPS.curveTo3:
                    U = x[B + 2], L = x[B + 3], H.push("C", v(x[B]), v(x[B + 1]), v(U), v(L), v(U), v(L)), B += 4;
                    break;
                  case o.OPS.closePath:
                    H.push("Z");
                    break;
                }
              H = H.join(" "), P.path && M.length > 0 && M[0] !== o.OPS.rectangle && M[0] !== o.OPS.moveTo ? H = P.path.getAttributeNS(null, "d") + H : (P.path = this.svgFactory.createElement("svg:path"), this._ensureTransformGroup().append(P.path)), P.path.setAttributeNS(null, "d", H), P.path.setAttributeNS(null, "fill", "none"), P.element = P.path, P.setCurrentPoint(U, L);
            }
            endPath() {
              const M = this.current;
              if (M.path = null, !this.pendingClip)
                return;
              if (!M.element) {
                this.pendingClip = null;
                return;
              }
              const x = `clippath${R++}`, P = this.svgFactory.createElement("svg:clipPath");
              P.setAttributeNS(null, "id", x), P.setAttributeNS(null, "transform", C(this.transformMatrix));
              const U = M.element.cloneNode(!0);
              if (this.pendingClip === "evenodd" ? U.setAttributeNS(null, "clip-rule", "evenodd") : U.setAttributeNS(null, "clip-rule", "nonzero"), this.pendingClip = null, P.append(U), this.defs.append(P), M.activeClipUrl) {
                M.clipGroup = null;
                for (const L of this.extraStack)
                  L.clipGroup = null;
                P.setAttributeNS(null, "clip-path", M.activeClipUrl);
              }
              M.activeClipUrl = `url(#${x})`, this.tgrp = null;
            }
            clip(M) {
              this.pendingClip = M;
            }
            closePath() {
              const M = this.current;
              if (M.path) {
                const x = `${M.path.getAttributeNS(null, "d")}Z`;
                M.path.setAttributeNS(null, "d", x);
              }
            }
            setLeading(M) {
              this.current.leading = -M;
            }
            setTextRise(M) {
              this.current.textRise = M;
            }
            setTextRenderingMode(M) {
              this.current.textRenderingMode = M;
            }
            setHScale(M) {
              this.current.textHScale = M / 100;
            }
            setRenderingIntent(M) {
            }
            setFlatness(M) {
            }
            setGState(M) {
              for (const [x, P] of M)
                switch (x) {
                  case "LW":
                    this.setLineWidth(P);
                    break;
                  case "LC":
                    this.setLineCap(P);
                    break;
                  case "LJ":
                    this.setLineJoin(P);
                    break;
                  case "ML":
                    this.setMiterLimit(P);
                    break;
                  case "D":
                    this.setDash(P[0], P[1]);
                    break;
                  case "RI":
                    this.setRenderingIntent(P);
                    break;
                  case "FL":
                    this.setFlatness(P);
                    break;
                  case "Font":
                    this.setFont(P);
                    break;
                  case "CA":
                    this.setStrokeAlpha(P);
                    break;
                  case "ca":
                    this.setFillAlpha(P);
                    break;
                  default:
                    (0, o.warn)(`Unimplemented graphic state operator ${x}`);
                    break;
                }
            }
            fill() {
              const M = this.current;
              M.element && (M.element.setAttributeNS(null, "fill", M.fillColor), M.element.setAttributeNS(null, "fill-opacity", M.fillAlpha), this.endPath());
            }
            stroke() {
              const M = this.current;
              M.element && (this._setStrokeAttributes(M.element), M.element.setAttributeNS(null, "fill", "none"), this.endPath());
            }
            _setStrokeAttributes(M, x = 1) {
              const P = this.current;
              let U = P.dashArray;
              x !== 1 && U.length > 0 && (U = U.map(function(L) {
                return x * L;
              })), M.setAttributeNS(null, "stroke", P.strokeColor), M.setAttributeNS(null, "stroke-opacity", P.strokeAlpha), M.setAttributeNS(null, "stroke-miterlimit", v(P.miterLimit)), M.setAttributeNS(null, "stroke-linecap", P.lineCap), M.setAttributeNS(null, "stroke-linejoin", P.lineJoin), M.setAttributeNS(null, "stroke-width", v(x * P.lineWidth) + "px"), M.setAttributeNS(null, "stroke-dasharray", U.map(v).join(" ")), M.setAttributeNS(null, "stroke-dashoffset", v(x * P.dashPhase) + "px");
            }
            eoFill() {
              var M;
              (M = this.current.element) == null || M.setAttributeNS(null, "fill-rule", "evenodd"), this.fill();
            }
            fillStroke() {
              this.stroke(), this.fill();
            }
            eoFillStroke() {
              var M;
              (M = this.current.element) == null || M.setAttributeNS(null, "fill-rule", "evenodd"), this.fillStroke();
            }
            closeStroke() {
              this.closePath(), this.stroke();
            }
            closeFillStroke() {
              this.closePath(), this.fillStroke();
            }
            closeEOFillStroke() {
              this.closePath(), this.eoFillStroke();
            }
            paintSolidColorImageMask() {
              const M = this.svgFactory.createElement("svg:rect");
              M.setAttributeNS(null, "x", "0"), M.setAttributeNS(null, "y", "0"), M.setAttributeNS(null, "width", "1px"), M.setAttributeNS(null, "height", "1px"), M.setAttributeNS(null, "fill", this.current.fillColor), this._ensureTransformGroup().append(M);
            }
            paintImageXObject(M) {
              const x = this.getObject(M);
              if (!x) {
                (0, o.warn)(`Dependent image with object ID ${M} is not ready yet`);
                return;
              }
              this.paintInlineImageXObject(x);
            }
            paintInlineImageXObject(M, x) {
              const P = M.width, U = M.height, L = y(M, this.forceDataSchema, !!x), H = this.svgFactory.createElement("svg:rect");
              H.setAttributeNS(null, "x", "0"), H.setAttributeNS(null, "y", "0"), H.setAttributeNS(null, "width", v(P)), H.setAttributeNS(null, "height", v(U)), this.current.element = H, this.clip("nonzero");
              const B = this.svgFactory.createElement("svg:image");
              B.setAttributeNS(d, "xlink:href", L), B.setAttributeNS(null, "x", "0"), B.setAttributeNS(null, "y", v(-U)), B.setAttributeNS(null, "width", v(P) + "px"), B.setAttributeNS(null, "height", v(U) + "px"), B.setAttributeNS(null, "transform", `scale(${v(1 / P)} ${v(-1 / U)})`), x ? x.append(B) : this._ensureTransformGroup().append(B);
            }
            paintImageMaskXObject(M) {
              const x = this.getObject(M.data, M);
              if (x.bitmap) {
                (0, o.warn)("paintImageMaskXObject: ImageBitmap support is not implemented, ensure that the `isOffscreenCanvasSupported` API parameter is disabled.");
                return;
              }
              const P = this.current, U = x.width, L = x.height, H = P.fillColor;
              P.maskId = `mask${I++}`;
              const B = this.svgFactory.createElement("svg:mask");
              B.setAttributeNS(null, "id", P.maskId);
              const V = this.svgFactory.createElement("svg:rect");
              V.setAttributeNS(null, "x", "0"), V.setAttributeNS(null, "y", "0"), V.setAttributeNS(null, "width", v(U)), V.setAttributeNS(null, "height", v(L)), V.setAttributeNS(null, "fill", H), V.setAttributeNS(null, "mask", `url(#${P.maskId})`), this.defs.append(B), this._ensureTransformGroup().append(V), this.paintInlineImageXObject(x, B);
            }
            paintFormXObjectBegin(M, x) {
              if (Array.isArray(M) && M.length === 6 && this.transform(M[0], M[1], M[2], M[3], M[4], M[5]), x) {
                const P = x[2] - x[0], U = x[3] - x[1], L = this.svgFactory.createElement("svg:rect");
                L.setAttributeNS(null, "x", x[0]), L.setAttributeNS(null, "y", x[1]), L.setAttributeNS(null, "width", v(P)), L.setAttributeNS(null, "height", v(U)), this.current.element = L, this.clip("nonzero"), this.endPath();
              }
            }
            paintFormXObjectEnd() {
            }
            _initialize(M) {
              const x = this.svgFactory.create(M.width, M.height), P = this.svgFactory.createElement("svg:defs");
              x.append(P), this.defs = P;
              const U = this.svgFactory.createElement("svg:g");
              return U.setAttributeNS(null, "transform", C(M.transform)), x.append(U), this.svg = U, x;
            }
            _ensureClipGroup() {
              if (!this.current.clipGroup) {
                const M = this.svgFactory.createElement("svg:g");
                M.setAttributeNS(null, "clip-path", this.current.activeClipUrl), this.svg.append(M), this.current.clipGroup = M;
              }
              return this.current.clipGroup;
            }
            _ensureTransformGroup() {
              return this.tgrp || (this.tgrp = this.svgFactory.createElement("svg:g"), this.tgrp.setAttributeNS(null, "transform", C(this.transformMatrix)), this.current.activeClipUrl ? this._ensureClipGroup().append(this.tgrp) : this.svg.append(this.tgrp)), this.tgrp;
            }
          }
          t.SVGGraphics = N;
        },
        /* 25 */
        /***/
        (e, t) => {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.XfaText = void 0;
          class r {
            static textContent(o) {
              const u = [], c = {
                items: u,
                styles: /* @__PURE__ */ Object.create(null)
              };
              function d(g) {
                var y;
                if (!g)
                  return;
                let b = null;
                const _ = g.name;
                if (_ === "#text")
                  b = g.value;
                else if (r.shouldBuildText(_))
                  (y = g == null ? void 0 : g.attributes) != null && y.textContent ? b = g.attributes.textContent : g.value && (b = g.value);
                else return;
                if (b !== null && u.push({
                  str: b
                }), !!g.children)
                  for (const A of g.children)
                    d(A);
              }
              return d(o), c;
            }
            static shouldBuildText(o) {
              return !(o === "textarea" || o === "input" || o === "option" || o === "select");
            }
          }
          t.XfaText = r;
        },
        /* 26 */
        /***/
        (e, t, r) => {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.TextLayerRenderTask = void 0, t.renderTextLayer = C, t.updateTextLayer = R;
          var a = r(1), o = r(6);
          const u = 1e5, c = 30, d = 0.8, g = /* @__PURE__ */ new Map();
          function b(I, w) {
            let N;
            if (w && a.FeatureTest.isOffscreenCanvasSupported)
              N = new OffscreenCanvas(I, I).getContext("2d", {
                alpha: !1
              });
            else {
              const F = document.createElement("canvas");
              F.width = F.height = I, N = F.getContext("2d", {
                alpha: !1
              });
            }
            return N;
          }
          function _(I, w) {
            const N = g.get(I);
            if (N)
              return N;
            const F = b(c, w);
            F.font = `${c}px ${I}`;
            const M = F.measureText("");
            let x = M.fontBoundingBoxAscent, P = Math.abs(M.fontBoundingBoxDescent);
            if (x) {
              const L = x / (x + P);
              return g.set(I, L), F.canvas.width = F.canvas.height = 0, L;
            }
            F.strokeStyle = "red", F.clearRect(0, 0, c, c), F.strokeText("g", 0, 0);
            let U = F.getImageData(0, 0, c, c).data;
            P = 0;
            for (let L = U.length - 1 - 3; L >= 0; L -= 4)
              if (U[L] > 0) {
                P = Math.ceil(L / 4 / c);
                break;
              }
            F.clearRect(0, 0, c, c), F.strokeText("A", 0, c), U = F.getImageData(0, 0, c, c).data, x = 0;
            for (let L = 0, H = U.length; L < H; L += 4)
              if (U[L] > 0) {
                x = c - Math.floor(L / 4 / c);
                break;
              }
            if (F.canvas.width = F.canvas.height = 0, x) {
              const L = x / (x + P);
              return g.set(I, L), L;
            }
            return g.set(I, d), d;
          }
          function y(I, w, N) {
            const F = document.createElement("span"), M = {
              angle: 0,
              canvasWidth: 0,
              hasText: w.str !== "",
              hasEOL: w.hasEOL,
              fontSize: 0
            };
            I._textDivs.push(F);
            const x = a.Util.transform(I._transform, w.transform);
            let P = Math.atan2(x[1], x[0]);
            const U = N[w.fontName];
            U.vertical && (P += Math.PI / 2);
            const L = Math.hypot(x[2], x[3]), H = L * _(U.fontFamily, I._isOffscreenCanvasSupported);
            let B, V;
            P === 0 ? (B = x[4], V = x[5] - H) : (B = x[4] + H * Math.sin(P), V = x[5] - H * Math.cos(P));
            const X = "calc(var(--scale-factor)*", de = F.style;
            I._container === I._rootContainer ? (de.left = `${(100 * B / I._pageWidth).toFixed(2)}%`, de.top = `${(100 * V / I._pageHeight).toFixed(2)}%`) : (de.left = `${X}${B.toFixed(2)}px)`, de.top = `${X}${V.toFixed(2)}px)`), de.fontSize = `${X}${L.toFixed(2)}px)`, de.fontFamily = U.fontFamily, M.fontSize = L, F.setAttribute("role", "presentation"), F.textContent = w.str, F.dir = w.dir, I._fontInspectorEnabled && (F.dataset.fontName = w.fontName), P !== 0 && (M.angle = P * (180 / Math.PI));
            let Y = !1;
            if (w.str.length > 1)
              Y = !0;
            else if (w.str !== " " && w.transform[0] !== w.transform[3]) {
              const se = Math.abs(w.transform[0]), ue = Math.abs(w.transform[3]);
              se !== ue && Math.max(se, ue) / Math.min(se, ue) > 1.5 && (Y = !0);
            }
            Y && (M.canvasWidth = U.vertical ? w.height : w.width), I._textDivProperties.set(F, M), I._isReadableStream && I._layoutText(F);
          }
          function A(I) {
            const {
              div: w,
              scale: N,
              properties: F,
              ctx: M,
              prevFontSize: x,
              prevFontFamily: P
            } = I, {
              style: U
            } = w;
            let L = "";
            if (F.canvasWidth !== 0 && F.hasText) {
              const {
                fontFamily: H
              } = U, {
                canvasWidth: B,
                fontSize: V
              } = F;
              (x !== V || P !== H) && (M.font = `${V * N}px ${H}`, I.prevFontSize = V, I.prevFontFamily = H);
              const {
                width: X
              } = M.measureText(w.textContent);
              X > 0 && (L = `scaleX(${B * N / X})`);
            }
            F.angle !== 0 && (L = `rotate(${F.angle}deg) ${L}`), L.length > 0 && (U.transform = L);
          }
          function E(I) {
            if (I._canceled)
              return;
            const w = I._textDivs, N = I._capability;
            if (w.length > u) {
              N.resolve();
              return;
            }
            if (!I._isReadableStream)
              for (const M of w)
                I._layoutText(M);
            N.resolve();
          }
          class v {
            constructor({
              textContentSource: w,
              container: N,
              viewport: F,
              textDivs: M,
              textDivProperties: x,
              textContentItemsStr: P,
              isOffscreenCanvasSupported: U
            }) {
              var X;
              this._textContentSource = w, this._isReadableStream = w instanceof ReadableStream, this._container = this._rootContainer = N, this._textDivs = M || [], this._textContentItemsStr = P || [], this._isOffscreenCanvasSupported = U, this._fontInspectorEnabled = !!((X = globalThis.FontInspector) != null && X.enabled), this._reader = null, this._textDivProperties = x || /* @__PURE__ */ new WeakMap(), this._canceled = !1, this._capability = new a.PromiseCapability(), this._layoutTextParams = {
                prevFontSize: null,
                prevFontFamily: null,
                div: null,
                scale: F.scale * (globalThis.devicePixelRatio || 1),
                properties: null,
                ctx: b(0, U)
              };
              const {
                pageWidth: L,
                pageHeight: H,
                pageX: B,
                pageY: V
              } = F.rawDims;
              this._transform = [1, 0, 0, -1, -B, V + H], this._pageWidth = L, this._pageHeight = H, (0, o.setLayerDimensions)(N, F), this._capability.promise.finally(() => {
                this._layoutTextParams = null;
              }).catch(() => {
              });
            }
            get promise() {
              return this._capability.promise;
            }
            cancel() {
              this._canceled = !0, this._reader && (this._reader.cancel(new a.AbortException("TextLayer task cancelled.")).catch(() => {
              }), this._reader = null), this._capability.reject(new a.AbortException("TextLayer task cancelled."));
            }
            _processItems(w, N) {
              for (const F of w) {
                if (F.str === void 0) {
                  if (F.type === "beginMarkedContentProps" || F.type === "beginMarkedContent") {
                    const M = this._container;
                    this._container = document.createElement("span"), this._container.classList.add("markedContent"), F.id !== null && this._container.setAttribute("id", `${F.id}`), M.append(this._container);
                  } else F.type === "endMarkedContent" && (this._container = this._container.parentNode);
                  continue;
                }
                this._textContentItemsStr.push(F.str), y(this, F, N);
              }
            }
            _layoutText(w) {
              const N = this._layoutTextParams.properties = this._textDivProperties.get(w);
              if (this._layoutTextParams.div = w, A(this._layoutTextParams), N.hasText && this._container.append(w), N.hasEOL) {
                const F = document.createElement("br");
                F.setAttribute("role", "presentation"), this._container.append(F);
              }
            }
            _render() {
              const w = new a.PromiseCapability();
              let N = /* @__PURE__ */ Object.create(null);
              if (this._isReadableStream) {
                const F = () => {
                  this._reader.read().then(({
                    value: M,
                    done: x
                  }) => {
                    if (x) {
                      w.resolve();
                      return;
                    }
                    Object.assign(N, M.styles), this._processItems(M.items, N), F();
                  }, w.reject);
                };
                this._reader = this._textContentSource.getReader(), F();
              } else if (this._textContentSource) {
                const {
                  items: F,
                  styles: M
                } = this._textContentSource;
                this._processItems(F, M), w.resolve();
              } else
                throw new Error('No "textContentSource" parameter specified.');
              w.promise.then(() => {
                N = null, E(this);
              }, this._capability.reject);
            }
          }
          t.TextLayerRenderTask = v;
          function C(I) {
            !I.textContentSource && (I.textContent || I.textContentStream) && ((0, o.deprecated)("The TextLayerRender `textContent`/`textContentStream` parameters will be removed in the future, please use `textContentSource` instead."), I.textContentSource = I.textContent || I.textContentStream);
            const {
              container: w,
              viewport: N
            } = I, F = getComputedStyle(w), M = F.getPropertyValue("visibility"), x = parseFloat(F.getPropertyValue("--scale-factor"));
            M === "visible" && (!x || Math.abs(x - N.scale) > 1e-5) && console.error("The `--scale-factor` CSS-variable must be set, to the same value as `viewport.scale`, either on the `container`-element itself or higher up in the DOM.");
            const P = new v(I);
            return P._render(), P;
          }
          function R({
            container: I,
            viewport: w,
            textDivs: N,
            textDivProperties: F,
            isOffscreenCanvasSupported: M,
            mustRotate: x = !0,
            mustRescale: P = !0
          }) {
            if (x && (0, o.setLayerDimensions)(I, {
              rotation: w.rotation
            }), P) {
              const U = b(0, M), H = {
                prevFontSize: null,
                prevFontFamily: null,
                div: null,
                scale: w.scale * (globalThis.devicePixelRatio || 1),
                properties: null,
                ctx: U
              };
              for (const B of N)
                H.properties = F.get(B), H.div = B, A(H);
            }
          }
        },
        /* 27 */
        /***/
        (e, t, r) => {
          var _, y, A, E, v, C, R, I, w, N, F, Tn, Xt, An, vn;
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.AnnotationEditorLayer = void 0;
          var a = r(1), o = r(4), u = r(28), c = r(33), d = r(6), g = r(34);
          const L = class L {
            constructor({
              uiManager: B,
              pageIndex: V,
              div: X,
              accessibilityManager: de,
              annotationLayer: Y,
              viewport: se,
              l10n: ue
            }) {
              we(this, F);
              we(this, _);
              we(this, y, !1);
              we(this, A, null);
              we(this, E, this.pointerup.bind(this));
              we(this, v, this.pointerdown.bind(this));
              we(this, C, /* @__PURE__ */ new Map());
              we(this, R, !1);
              we(this, I, !1);
              we(this, w, !1);
              we(this, N);
              const pe = [u.FreeTextEditor, c.InkEditor, g.StampEditor];
              if (!L._initialized) {
                L._initialized = !0;
                for (const J of pe)
                  J.initialize(ue);
              }
              B.registerEditorTypes(pe), Ie(this, N, B), this.pageIndex = V, this.div = X, Ie(this, _, de), Ie(this, A, Y), this.viewport = se, G(this, N).addLayer(this);
            }
            get isEmpty() {
              return G(this, C).size === 0;
            }
            updateToolbar(B) {
              G(this, N).updateToolbar(B);
            }
            updateMode(B = G(this, N).getMode()) {
              _e(this, F, vn).call(this), B === a.AnnotationEditorType.INK ? (this.addInkEditorIfNeeded(!1), this.disableClick()) : this.enableClick(), B !== a.AnnotationEditorType.NONE && (this.div.classList.toggle("freeTextEditing", B === a.AnnotationEditorType.FREETEXT), this.div.classList.toggle("inkEditing", B === a.AnnotationEditorType.INK), this.div.classList.toggle("stampEditing", B === a.AnnotationEditorType.STAMP), this.div.hidden = !1);
            }
            addInkEditorIfNeeded(B) {
              if (!B && G(this, N).getMode() !== a.AnnotationEditorType.INK)
                return;
              if (!B) {
                for (const X of G(this, C).values())
                  if (X.isEmpty()) {
                    X.setInBackground();
                    return;
                  }
              }
              _e(this, F, Xt).call(this, {
                offsetX: 0,
                offsetY: 0
              }, !1).setInBackground();
            }
            setEditingState(B) {
              G(this, N).setEditingState(B);
            }
            addCommands(B) {
              G(this, N).addCommands(B);
            }
            enable() {
              this.div.style.pointerEvents = "auto";
              const B = /* @__PURE__ */ new Set();
              for (const X of G(this, C).values())
                X.enableEditing(), X.annotationElementId && B.add(X.annotationElementId);
              if (!G(this, A))
                return;
              const V = G(this, A).getEditableAnnotations();
              for (const X of V) {
                if (X.hide(), G(this, N).isDeletedAnnotationElement(X.data.id) || B.has(X.data.id))
                  continue;
                const de = this.deserialize(X);
                de && (this.addOrRebuild(de), de.enableEditing());
              }
            }
            disable() {
              var V;
              Ie(this, w, !0), this.div.style.pointerEvents = "none";
              const B = /* @__PURE__ */ new Set();
              for (const X of G(this, C).values()) {
                if (X.disableEditing(), !X.annotationElementId || X.serialize() !== null) {
                  B.add(X.annotationElementId);
                  continue;
                }
                (V = this.getEditableAnnotation(X.annotationElementId)) == null || V.show(), X.remove();
              }
              if (G(this, A)) {
                const X = G(this, A).getEditableAnnotations();
                for (const de of X) {
                  const {
                    id: Y
                  } = de.data;
                  B.has(Y) || G(this, N).isDeletedAnnotationElement(Y) || de.show();
                }
              }
              _e(this, F, vn).call(this), this.isEmpty && (this.div.hidden = !0), Ie(this, w, !1);
            }
            getEditableAnnotation(B) {
              var V;
              return ((V = G(this, A)) == null ? void 0 : V.getEditableAnnotation(B)) || null;
            }
            setActiveEditor(B) {
              G(this, N).getActive() !== B && G(this, N).setActiveEditor(B);
            }
            enableClick() {
              this.div.addEventListener("pointerdown", G(this, v)), this.div.addEventListener("pointerup", G(this, E));
            }
            disableClick() {
              this.div.removeEventListener("pointerdown", G(this, v)), this.div.removeEventListener("pointerup", G(this, E));
            }
            attach(B) {
              G(this, C).set(B.id, B);
              const {
                annotationElementId: V
              } = B;
              V && G(this, N).isDeletedAnnotationElement(V) && G(this, N).removeDeletedAnnotationElement(B);
            }
            detach(B) {
              var V;
              G(this, C).delete(B.id), (V = G(this, _)) == null || V.removePointerInTextLayer(B.contentDiv), !G(this, w) && B.annotationElementId && G(this, N).addDeletedAnnotationElement(B);
            }
            remove(B) {
              this.detach(B), G(this, N).removeEditor(B), B.div.contains(document.activeElement) && setTimeout(() => {
                G(this, N).focusMainContainer();
              }, 0), B.div.remove(), B.isAttachedToDOM = !1, G(this, I) || this.addInkEditorIfNeeded(!1);
            }
            changeParent(B) {
              var V;
              B.parent !== this && (B.annotationElementId && (G(this, N).addDeletedAnnotationElement(B.annotationElementId), o.AnnotationEditor.deleteAnnotationElement(B), B.annotationElementId = null), this.attach(B), (V = B.parent) == null || V.detach(B), B.setParent(this), B.div && B.isAttachedToDOM && (B.div.remove(), this.div.append(B.div)));
            }
            add(B) {
              if (this.changeParent(B), G(this, N).addEditor(B), this.attach(B), !B.isAttachedToDOM) {
                const V = B.render();
                this.div.append(V), B.isAttachedToDOM = !0;
              }
              B.fixAndSetPosition(), B.onceAdded(), G(this, N).addToAnnotationStorage(B);
            }
            moveEditorInDOM(B) {
              var X;
              if (!B.isAttachedToDOM)
                return;
              const {
                activeElement: V
              } = document;
              B.div.contains(V) && (B._focusEventsAllowed = !1, setTimeout(() => {
                B.div.contains(document.activeElement) ? B._focusEventsAllowed = !0 : (B.div.addEventListener("focusin", () => {
                  B._focusEventsAllowed = !0;
                }, {
                  once: !0
                }), V.focus());
              }, 0)), B._structTreeParentId = (X = G(this, _)) == null ? void 0 : X.moveElementInDOM(this.div, B.div, B.contentDiv, !0);
            }
            addOrRebuild(B) {
              B.needsToBeRebuilt() ? B.rebuild() : this.add(B);
            }
            addUndoableEditor(B) {
              const V = () => B._uiManager.rebuild(B), X = () => {
                B.remove();
              };
              this.addCommands({
                cmd: V,
                undo: X,
                mustExec: !1
              });
            }
            getNextId() {
              return G(this, N).getId();
            }
            pasteEditor(B, V) {
              G(this, N).updateToolbar(B), G(this, N).updateMode(B);
              const {
                offsetX: X,
                offsetY: de
              } = _e(this, F, An).call(this), Y = this.getNextId(), se = _e(this, F, Tn).call(this, {
                parent: this,
                id: Y,
                x: X,
                y: de,
                uiManager: G(this, N),
                isCentered: !0,
                ...V
              });
              se && this.add(se);
            }
            deserialize(B) {
              switch (B.annotationType ?? B.annotationEditorType) {
                case a.AnnotationEditorType.FREETEXT:
                  return u.FreeTextEditor.deserialize(B, this, G(this, N));
                case a.AnnotationEditorType.INK:
                  return c.InkEditor.deserialize(B, this, G(this, N));
                case a.AnnotationEditorType.STAMP:
                  return g.StampEditor.deserialize(B, this, G(this, N));
              }
              return null;
            }
            addNewEditor() {
              _e(this, F, Xt).call(this, _e(this, F, An).call(this), !0);
            }
            setSelected(B) {
              G(this, N).setSelected(B);
            }
            toggleSelected(B) {
              G(this, N).toggleSelected(B);
            }
            isSelected(B) {
              return G(this, N).isSelected(B);
            }
            unselect(B) {
              G(this, N).unselect(B);
            }
            pointerup(B) {
              const {
                isMac: V
              } = a.FeatureTest.platform;
              if (!(B.button !== 0 || B.ctrlKey && V) && B.target === this.div && G(this, R)) {
                if (Ie(this, R, !1), !G(this, y)) {
                  Ie(this, y, !0);
                  return;
                }
                if (G(this, N).getMode() === a.AnnotationEditorType.STAMP) {
                  G(this, N).unselectAll();
                  return;
                }
                _e(this, F, Xt).call(this, B, !1);
              }
            }
            pointerdown(B) {
              if (G(this, R)) {
                Ie(this, R, !1);
                return;
              }
              const {
                isMac: V
              } = a.FeatureTest.platform;
              if (B.button !== 0 || B.ctrlKey && V || B.target !== this.div)
                return;
              Ie(this, R, !0);
              const X = G(this, N).getActive();
              Ie(this, y, !X || X.isEmpty());
            }
            findNewParent(B, V, X) {
              const de = G(this, N).findParent(V, X);
              return de === null || de === this ? !1 : (de.changeParent(B), !0);
            }
            destroy() {
              var B, V;
              ((B = G(this, N).getActive()) == null ? void 0 : B.parent) === this && (G(this, N).commitOrRemove(), G(this, N).setActiveEditor(null));
              for (const X of G(this, C).values())
                (V = G(this, _)) == null || V.removePointerInTextLayer(X.contentDiv), X.setParent(null), X.isAttachedToDOM = !1, X.div.remove();
              this.div = null, G(this, C).clear(), G(this, N).removeLayer(this);
            }
            render({
              viewport: B
            }) {
              this.viewport = B, (0, d.setLayerDimensions)(this.div, B);
              for (const V of G(this, N).getEditors(this.pageIndex))
                this.add(V);
              this.updateMode();
            }
            update({
              viewport: B
            }) {
              G(this, N).commitOrRemove(), this.viewport = B, (0, d.setLayerDimensions)(this.div, {
                rotation: B.rotation
              }), this.updateMode();
            }
            get pageDimensions() {
              const {
                pageWidth: B,
                pageHeight: V
              } = this.viewport.rawDims;
              return [B, V];
            }
          };
          _ = new WeakMap(), y = new WeakMap(), A = new WeakMap(), E = new WeakMap(), v = new WeakMap(), C = new WeakMap(), R = new WeakMap(), I = new WeakMap(), w = new WeakMap(), N = new WeakMap(), F = new WeakSet(), Tn = function(B) {
            switch (G(this, N).getMode()) {
              case a.AnnotationEditorType.FREETEXT:
                return new u.FreeTextEditor(B);
              case a.AnnotationEditorType.INK:
                return new c.InkEditor(B);
              case a.AnnotationEditorType.STAMP:
                return new g.StampEditor(B);
            }
            return null;
          }, Xt = function(B, V) {
            const X = this.getNextId(), de = _e(this, F, Tn).call(this, {
              parent: this,
              id: X,
              x: B.offsetX,
              y: B.offsetY,
              uiManager: G(this, N),
              isCentered: V
            });
            return de && this.add(de), de;
          }, An = function() {
            const {
              x: B,
              y: V,
              width: X,
              height: de
            } = this.div.getBoundingClientRect(), Y = Math.max(0, B), se = Math.max(0, V), ue = Math.min(window.innerWidth, B + X), pe = Math.min(window.innerHeight, V + de), J = (Y + ue) / 2 - B, j = (se + pe) / 2 - V, [le, Z] = this.viewport.rotation % 180 === 0 ? [J, j] : [j, J];
            return {
              offsetX: le,
              offsetY: Z
            };
          }, vn = function() {
            Ie(this, I, !0);
            for (const B of G(this, C).values())
              B.isEmpty() && B.remove();
            Ie(this, I, !1);
          }, ft(L, "_initialized", !1);
          let b = L;
          t.AnnotationEditorLayer = b;
        },
        /* 28 */
        /***/
        (e, t, r) => {
          var g, b, _, y, A, E, v, C, R, I, Jn, er, tr, Ut, kn, nr, wn;
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.FreeTextEditor = void 0;
          var a = r(1), o = r(5), u = r(4), c = r(29);
          const L = class L extends u.AnnotationEditor {
            constructor(V) {
              super({
                ...V,
                name: "freeTextEditor"
              });
              we(this, I);
              we(this, g, this.editorDivBlur.bind(this));
              we(this, b, this.editorDivFocus.bind(this));
              we(this, _, this.editorDivInput.bind(this));
              we(this, y, this.editorDivKeydown.bind(this));
              we(this, A);
              we(this, E, "");
              we(this, v, `${this.id}-editor`);
              we(this, C);
              we(this, R, null);
              Ie(this, A, V.color || L._defaultColor || u.AnnotationEditor._defaultLineColor), Ie(this, C, V.fontSize || L._defaultFontSize);
            }
            static get _keyboardManager() {
              const V = L.prototype, X = (se) => se.isEmpty(), de = o.AnnotationEditorUIManager.TRANSLATE_SMALL, Y = o.AnnotationEditorUIManager.TRANSLATE_BIG;
              return (0, a.shadow)(this, "_keyboardManager", new o.KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], V.commitOrRemove, {
                bubbles: !0
              }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], V.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], V._translateEmpty, {
                args: [-de, 0],
                checker: X
              }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], V._translateEmpty, {
                args: [-Y, 0],
                checker: X
              }], [["ArrowRight", "mac+ArrowRight"], V._translateEmpty, {
                args: [de, 0],
                checker: X
              }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], V._translateEmpty, {
                args: [Y, 0],
                checker: X
              }], [["ArrowUp", "mac+ArrowUp"], V._translateEmpty, {
                args: [0, -de],
                checker: X
              }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], V._translateEmpty, {
                args: [0, -Y],
                checker: X
              }], [["ArrowDown", "mac+ArrowDown"], V._translateEmpty, {
                args: [0, de],
                checker: X
              }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], V._translateEmpty, {
                args: [0, Y],
                checker: X
              }]]));
            }
            static initialize(V) {
              u.AnnotationEditor.initialize(V, {
                strings: ["free_text2_default_content", "editor_free_text2_aria_label"]
              });
              const X = getComputedStyle(document.documentElement);
              this._internalPadding = parseFloat(X.getPropertyValue("--freetext-padding"));
            }
            static updateDefaultParams(V, X) {
              switch (V) {
                case a.AnnotationEditorParamsType.FREETEXT_SIZE:
                  L._defaultFontSize = X;
                  break;
                case a.AnnotationEditorParamsType.FREETEXT_COLOR:
                  L._defaultColor = X;
                  break;
              }
            }
            updateParams(V, X) {
              switch (V) {
                case a.AnnotationEditorParamsType.FREETEXT_SIZE:
                  _e(this, I, Jn).call(this, X);
                  break;
                case a.AnnotationEditorParamsType.FREETEXT_COLOR:
                  _e(this, I, er).call(this, X);
                  break;
              }
            }
            static get defaultPropertiesToUpdate() {
              return [[a.AnnotationEditorParamsType.FREETEXT_SIZE, L._defaultFontSize], [a.AnnotationEditorParamsType.FREETEXT_COLOR, L._defaultColor || u.AnnotationEditor._defaultLineColor]];
            }
            get propertiesToUpdate() {
              return [[a.AnnotationEditorParamsType.FREETEXT_SIZE, G(this, C)], [a.AnnotationEditorParamsType.FREETEXT_COLOR, G(this, A)]];
            }
            _translateEmpty(V, X) {
              this._uiManager.translateSelectedEditors(V, X, !0);
            }
            getInitialTranslation() {
              const V = this.parentScale;
              return [-L._internalPadding * V, -(L._internalPadding + G(this, C)) * V];
            }
            rebuild() {
              this.parent && (super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this)));
            }
            enableEditMode() {
              this.isInEditMode() || (this.parent.setEditingState(!1), this.parent.updateToolbar(a.AnnotationEditorType.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant"), this.editorDiv.addEventListener("keydown", G(this, y)), this.editorDiv.addEventListener("focus", G(this, b)), this.editorDiv.addEventListener("blur", G(this, g)), this.editorDiv.addEventListener("input", G(this, _)));
            }
            disableEditMode() {
              this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", G(this, v)), this._isDraggable = !0, this.editorDiv.removeEventListener("keydown", G(this, y)), this.editorDiv.removeEventListener("focus", G(this, b)), this.editorDiv.removeEventListener("blur", G(this, g)), this.editorDiv.removeEventListener("input", G(this, _)), this.div.focus({
                preventScroll: !0
              }), this.isEditing = !1, this.parent.div.classList.add("freeTextEditing"));
            }
            focusin(V) {
              this._focusEventsAllowed && (super.focusin(V), V.target !== this.editorDiv && this.editorDiv.focus());
            }
            onceAdded() {
              var V;
              if (this.width) {
                _e(this, I, wn).call(this);
                return;
              }
              this.enableEditMode(), this.editorDiv.focus(), (V = this._initialOptions) != null && V.isCentered && this.center(), this._initialOptions = null;
            }
            isEmpty() {
              return !this.editorDiv || this.editorDiv.innerText.trim() === "";
            }
            remove() {
              this.isEditing = !1, this.parent && (this.parent.setEditingState(!0), this.parent.div.classList.add("freeTextEditing")), super.remove();
            }
            commit() {
              if (!this.isInEditMode())
                return;
              super.commit(), this.disableEditMode();
              const V = G(this, E), X = Ie(this, E, _e(this, I, tr).call(this).trimEnd());
              if (V === X)
                return;
              const de = (Y) => {
                if (Ie(this, E, Y), !Y) {
                  this.remove();
                  return;
                }
                _e(this, I, kn).call(this), this._uiManager.rebuild(this), _e(this, I, Ut).call(this);
              };
              this.addCommands({
                cmd: () => {
                  de(X);
                },
                undo: () => {
                  de(V);
                },
                mustExec: !1
              }), _e(this, I, Ut).call(this);
            }
            shouldGetKeyboardEvents() {
              return this.isInEditMode();
            }
            enterInEditMode() {
              this.enableEditMode(), this.editorDiv.focus();
            }
            dblclick(V) {
              this.enterInEditMode();
            }
            keydown(V) {
              V.target === this.div && V.key === "Enter" && (this.enterInEditMode(), V.preventDefault());
            }
            editorDivKeydown(V) {
              L._keyboardManager.exec(this, V);
            }
            editorDivFocus(V) {
              this.isEditing = !0;
            }
            editorDivBlur(V) {
              this.isEditing = !1;
            }
            editorDivInput(V) {
              this.parent.div.classList.toggle("freeTextEditing", this.isEmpty());
            }
            disableEditing() {
              this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
            }
            enableEditing() {
              this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
            }
            render() {
              if (this.div)
                return this.div;
              let V, X;
              this.width && (V = this.x, X = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", G(this, v)), this.enableEditing(), u.AnnotationEditor._l10nPromise.get("editor_free_text2_aria_label").then((Y) => {
                var se;
                return (se = this.editorDiv) == null ? void 0 : se.setAttribute("aria-label", Y);
              }), u.AnnotationEditor._l10nPromise.get("free_text2_default_content").then((Y) => {
                var se;
                return (se = this.editorDiv) == null ? void 0 : se.setAttribute("default-content", Y);
              }), this.editorDiv.contentEditable = !0;
              const {
                style: de
              } = this.editorDiv;
              if (de.fontSize = `calc(${G(this, C)}px * var(--scale-factor))`, de.color = G(this, A), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), (0, o.bindEvents)(this, this.div, ["dblclick", "keydown"]), this.width) {
                const [Y, se] = this.parentDimensions;
                if (this.annotationElementId) {
                  const {
                    position: ue
                  } = G(this, R);
                  let [pe, J] = this.getInitialTranslation();
                  [pe, J] = this.pageTranslationToScreen(pe, J);
                  const [j, le] = this.pageDimensions, [Z, O] = this.pageTranslation;
                  let z, W;
                  switch (this.rotation) {
                    case 0:
                      z = V + (ue[0] - Z) / j, W = X + this.height - (ue[1] - O) / le;
                      break;
                    case 90:
                      z = V + (ue[0] - Z) / j, W = X - (ue[1] - O) / le, [pe, J] = [J, -pe];
                      break;
                    case 180:
                      z = V - this.width + (ue[0] - Z) / j, W = X - (ue[1] - O) / le, [pe, J] = [-pe, -J];
                      break;
                    case 270:
                      z = V + (ue[0] - Z - this.height * le) / j, W = X + (ue[1] - O - this.width * j) / le, [pe, J] = [-J, pe];
                      break;
                  }
                  this.setAt(z * Y, W * se, pe, J);
                } else
                  this.setAt(V * Y, X * se, this.width * Y, this.height * se);
                _e(this, I, kn).call(this), this._isDraggable = !0, this.editorDiv.contentEditable = !1;
              } else
                this._isDraggable = !1, this.editorDiv.contentEditable = !0;
              return this.div;
            }
            get contentDiv() {
              return this.editorDiv;
            }
            static deserialize(V, X, de) {
              let Y = null;
              if (V instanceof c.FreeTextAnnotationElement) {
                const {
                  data: {
                    defaultAppearanceData: {
                      fontSize: ue,
                      fontColor: pe
                    },
                    rect: J,
                    rotation: j,
                    id: le
                  },
                  textContent: Z,
                  textPosition: O,
                  parent: {
                    page: {
                      pageNumber: z
                    }
                  }
                } = V;
                if (!Z || Z.length === 0)
                  return null;
                Y = V = {
                  annotationType: a.AnnotationEditorType.FREETEXT,
                  color: Array.from(pe),
                  fontSize: ue,
                  value: Z.join(`
`),
                  position: O,
                  pageIndex: z - 1,
                  rect: J,
                  rotation: j,
                  id: le,
                  deleted: !1
                };
              }
              const se = super.deserialize(V, X, de);
              return Ie(se, C, V.fontSize), Ie(se, A, a.Util.makeHexColor(...V.color)), Ie(se, E, V.value), se.annotationElementId = V.id || null, Ie(se, R, Y), se;
            }
            serialize(V = !1) {
              if (this.isEmpty())
                return null;
              if (this.deleted)
                return {
                  pageIndex: this.pageIndex,
                  id: this.annotationElementId,
                  deleted: !0
                };
              const X = L._internalPadding * this.parentScale, de = this.getRect(X, X), Y = u.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : G(this, A)), se = {
                annotationType: a.AnnotationEditorType.FREETEXT,
                color: Y,
                fontSize: G(this, C),
                value: G(this, E),
                pageIndex: this.pageIndex,
                rect: de,
                rotation: this.rotation,
                structTreeParentId: this._structTreeParentId
              };
              return V ? se : this.annotationElementId && !_e(this, I, nr).call(this, se) ? null : (se.id = this.annotationElementId, se);
            }
          };
          g = new WeakMap(), b = new WeakMap(), _ = new WeakMap(), y = new WeakMap(), A = new WeakMap(), E = new WeakMap(), v = new WeakMap(), C = new WeakMap(), R = new WeakMap(), I = new WeakSet(), Jn = function(V) {
            const X = (Y) => {
              this.editorDiv.style.fontSize = `calc(${Y}px * var(--scale-factor))`, this.translate(0, -(Y - G(this, C)) * this.parentScale), Ie(this, C, Y), _e(this, I, Ut).call(this);
            }, de = G(this, C);
            this.addCommands({
              cmd: () => {
                X(V);
              },
              undo: () => {
                X(de);
              },
              mustExec: !0,
              type: a.AnnotationEditorParamsType.FREETEXT_SIZE,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, er = function(V) {
            const X = G(this, A);
            this.addCommands({
              cmd: () => {
                Ie(this, A, this.editorDiv.style.color = V);
              },
              undo: () => {
                Ie(this, A, this.editorDiv.style.color = X);
              },
              mustExec: !0,
              type: a.AnnotationEditorParamsType.FREETEXT_COLOR,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, tr = function() {
            const V = this.editorDiv.getElementsByTagName("div");
            if (V.length === 0)
              return this.editorDiv.innerText;
            const X = [];
            for (const de of V)
              X.push(de.innerText.replace(/\r\n?|\n/, ""));
            return X.join(`
`);
          }, Ut = function() {
            const [V, X] = this.parentDimensions;
            let de;
            if (this.isAttachedToDOM)
              de = this.div.getBoundingClientRect();
            else {
              const {
                currentLayer: Y,
                div: se
              } = this, ue = se.style.display;
              se.style.display = "hidden", Y.div.append(this.div), de = se.getBoundingClientRect(), se.remove(), se.style.display = ue;
            }
            this.rotation % 180 === this.parentRotation % 180 ? (this.width = de.width / V, this.height = de.height / X) : (this.width = de.height / V, this.height = de.width / X), this.fixAndSetPosition();
          }, kn = function() {
            if (this.editorDiv.replaceChildren(), !!G(this, E))
              for (const V of G(this, E).split(`
`)) {
                const X = document.createElement("div");
                X.append(V ? document.createTextNode(V) : document.createElement("br")), this.editorDiv.append(X);
              }
          }, nr = function(V) {
            const {
              value: X,
              fontSize: de,
              color: Y,
              rect: se,
              pageIndex: ue
            } = G(this, R);
            return V.value !== X || V.fontSize !== de || V.rect.some((pe, J) => Math.abs(pe - se[J]) >= 1) || V.color.some((pe, J) => pe !== Y[J]) || V.pageIndex !== ue;
          }, wn = function(V = !1) {
            if (!this.annotationElementId)
              return;
            if (_e(this, I, Ut).call(this), !V && (this.width === 0 || this.height === 0)) {
              setTimeout(() => _e(this, I, wn).call(this, !0), 0);
              return;
            }
            const X = L._internalPadding * this.parentScale;
            G(this, R).rect = this.getRect(X, X);
          }, ft(L, "_freeTextDefaultContent", ""), ft(L, "_internalPadding", 0), ft(L, "_defaultColor", null), ft(L, "_defaultFontSize", 10), ft(L, "_type", "freetext");
          let d = L;
          t.FreeTextEditor = d;
        },
        /* 29 */
        /***/
        (e, t, r) => {
          var W, ae, It, rr, ye, Re, De, Pe, he, Le, Ee, Se, Q, K, fe, be, ke, Fe, Be, te, Ce, Me, ar, Kt, Cn, In, Xe, ut, ct, $e, Ae, ve, Ke, xn, pt, ce, Ne, Ge, ir, Rn;
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.StampAnnotationElement = t.InkAnnotationElement = t.FreeTextAnnotationElement = t.AnnotationLayer = void 0;
          var a = r(1), o = r(6), u = r(3), c = r(30), d = r(31), g = r(32);
          const b = 1e3, _ = 9, y = /* @__PURE__ */ new WeakSet();
          function A(Ye) {
            return {
              width: Ye[2] - Ye[0],
              height: Ye[3] - Ye[1]
            };
          }
          class E {
            static create(oe) {
              switch (oe.data.annotationType) {
                case a.AnnotationType.LINK:
                  return new C(oe);
                case a.AnnotationType.TEXT:
                  return new R(oe);
                case a.AnnotationType.WIDGET:
                  switch (oe.data.fieldType) {
                    case "Tx":
                      return new w(oe);
                    case "Btn":
                      return oe.data.radioButton ? new M(oe) : oe.data.checkBox ? new F(oe) : new x(oe);
                    case "Ch":
                      return new P(oe);
                    case "Sig":
                      return new N(oe);
                  }
                  return new I(oe);
                case a.AnnotationType.POPUP:
                  return new U(oe);
                case a.AnnotationType.FREETEXT:
                  return new H(oe);
                case a.AnnotationType.LINE:
                  return new B(oe);
                case a.AnnotationType.SQUARE:
                  return new V(oe);
                case a.AnnotationType.CIRCLE:
                  return new X(oe);
                case a.AnnotationType.POLYLINE:
                  return new de(oe);
                case a.AnnotationType.CARET:
                  return new se(oe);
                case a.AnnotationType.INK:
                  return new ue(oe);
                case a.AnnotationType.POLYGON:
                  return new Y(oe);
                case a.AnnotationType.HIGHLIGHT:
                  return new pe(oe);
                case a.AnnotationType.UNDERLINE:
                  return new J(oe);
                case a.AnnotationType.SQUIGGLY:
                  return new j(oe);
                case a.AnnotationType.STRIKEOUT:
                  return new le(oe);
                case a.AnnotationType.STAMP:
                  return new Z(oe);
                case a.AnnotationType.FILEATTACHMENT:
                  return new O(oe);
                default:
                  return new v(oe);
              }
            }
          }
          const ee = class ee {
            constructor(oe, {
              isRenderable: ne = !1,
              ignoreBorder: ge = !1,
              createQuadrilaterals: xe = !1
            } = {}) {
              we(this, W, !1);
              this.isRenderable = ne, this.data = oe.data, this.layer = oe.layer, this.linkService = oe.linkService, this.downloadManager = oe.downloadManager, this.imageResourcesPath = oe.imageResourcesPath, this.renderForms = oe.renderForms, this.svgFactory = oe.svgFactory, this.annotationStorage = oe.annotationStorage, this.enableScripting = oe.enableScripting, this.hasJSActions = oe.hasJSActions, this._fieldObjects = oe.fieldObjects, this.parent = oe.parent, ne && (this.container = this._createContainer(ge)), xe && this._createQuadrilaterals();
            }
            static _hasPopupData({
              titleObj: oe,
              contentsObj: ne,
              richText: ge
            }) {
              return !!(oe != null && oe.str || ne != null && ne.str || ge != null && ge.str);
            }
            get hasPopupData() {
              return ee._hasPopupData(this.data);
            }
            _createContainer(oe) {
              const {
                data: ne,
                parent: {
                  page: ge,
                  viewport: xe
                }
              } = this, Oe = document.createElement("section");
              Oe.setAttribute("data-annotation-id", ne.id), this instanceof I || (Oe.tabIndex = b), Oe.style.zIndex = this.parent.zIndex++, this.data.popupRef && Oe.setAttribute("aria-haspopup", "dialog"), ne.noRotate && Oe.classList.add("norotate");
              const {
                pageWidth: Ue,
                pageHeight: qe,
                pageX: Qe,
                pageY: Je
              } = xe.rawDims;
              if (!ne.rect || this instanceof U) {
                const {
                  rotation: it
                } = ne;
                return !ne.hasOwnCanvas && it !== 0 && this.setRotation(it, Oe), Oe;
              }
              const {
                width: He,
                height: st
              } = A(ne.rect), et = a.Util.normalizeRect([ne.rect[0], ge.view[3] - ne.rect[1] + ge.view[1], ne.rect[2], ge.view[3] - ne.rect[3] + ge.view[1]]);
              if (!oe && ne.borderStyle.width > 0) {
                Oe.style.borderWidth = `${ne.borderStyle.width}px`;
                const it = ne.borderStyle.horizontalCornerRadius, ht = ne.borderStyle.verticalCornerRadius;
                if (it > 0 || ht > 0) {
                  const bt = `calc(${it}px * var(--scale-factor)) / calc(${ht}px * var(--scale-factor))`;
                  Oe.style.borderRadius = bt;
                } else if (this instanceof M) {
                  const bt = `calc(${He}px * var(--scale-factor)) / calc(${st}px * var(--scale-factor))`;
                  Oe.style.borderRadius = bt;
                }
                switch (ne.borderStyle.style) {
                  case a.AnnotationBorderStyleType.SOLID:
                    Oe.style.borderStyle = "solid";
                    break;
                  case a.AnnotationBorderStyleType.DASHED:
                    Oe.style.borderStyle = "dashed";
                    break;
                  case a.AnnotationBorderStyleType.BEVELED:
                    (0, a.warn)("Unimplemented border style: beveled");
                    break;
                  case a.AnnotationBorderStyleType.INSET:
                    (0, a.warn)("Unimplemented border style: inset");
                    break;
                  case a.AnnotationBorderStyleType.UNDERLINE:
                    Oe.style.borderBottomStyle = "solid";
                    break;
                }
                const mt = ne.borderColor || null;
                mt ? (Ie(this, W, !0), Oe.style.borderColor = a.Util.makeHexColor(mt[0] | 0, mt[1] | 0, mt[2] | 0)) : Oe.style.borderWidth = 0;
              }
              Oe.style.left = `${100 * (et[0] - Qe) / Ue}%`, Oe.style.top = `${100 * (et[1] - Je) / qe}%`;
              const {
                rotation: Ze
              } = ne;
              return ne.hasOwnCanvas || Ze === 0 ? (Oe.style.width = `${100 * He / Ue}%`, Oe.style.height = `${100 * st / qe}%`) : this.setRotation(Ze, Oe), Oe;
            }
            setRotation(oe, ne = this.container) {
              if (!this.data.rect)
                return;
              const {
                pageWidth: ge,
                pageHeight: xe
              } = this.parent.viewport.rawDims, {
                width: Oe,
                height: Ue
              } = A(this.data.rect);
              let qe, Qe;
              oe % 180 === 0 ? (qe = 100 * Oe / ge, Qe = 100 * Ue / xe) : (qe = 100 * Ue / ge, Qe = 100 * Oe / xe), ne.style.width = `${qe}%`, ne.style.height = `${Qe}%`, ne.setAttribute("data-main-rotation", (360 - oe) % 360);
            }
            get _commonActions() {
              const oe = (ne, ge, xe) => {
                const Oe = xe.detail[ne], Ue = Oe[0], qe = Oe.slice(1);
                xe.target.style[ge] = c.ColorConverters[`${Ue}_HTML`](qe), this.annotationStorage.setValue(this.data.id, {
                  [ge]: c.ColorConverters[`${Ue}_rgb`](qe)
                });
              };
              return (0, a.shadow)(this, "_commonActions", {
                display: (ne) => {
                  const {
                    display: ge
                  } = ne.detail, xe = ge % 2 === 1;
                  this.container.style.visibility = xe ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                    noView: xe,
                    noPrint: ge === 1 || ge === 2
                  });
                },
                print: (ne) => {
                  this.annotationStorage.setValue(this.data.id, {
                    noPrint: !ne.detail.print
                  });
                },
                hidden: (ne) => {
                  const {
                    hidden: ge
                  } = ne.detail;
                  this.container.style.visibility = ge ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                    noPrint: ge,
                    noView: ge
                  });
                },
                focus: (ne) => {
                  setTimeout(() => ne.target.focus({
                    preventScroll: !1
                  }), 0);
                },
                userName: (ne) => {
                  ne.target.title = ne.detail.userName;
                },
                readonly: (ne) => {
                  ne.target.disabled = ne.detail.readonly;
                },
                required: (ne) => {
                  this._setRequired(ne.target, ne.detail.required);
                },
                bgColor: (ne) => {
                  oe("bgColor", "backgroundColor", ne);
                },
                fillColor: (ne) => {
                  oe("fillColor", "backgroundColor", ne);
                },
                fgColor: (ne) => {
                  oe("fgColor", "color", ne);
                },
                textColor: (ne) => {
                  oe("textColor", "color", ne);
                },
                borderColor: (ne) => {
                  oe("borderColor", "borderColor", ne);
                },
                strokeColor: (ne) => {
                  oe("strokeColor", "borderColor", ne);
                },
                rotation: (ne) => {
                  const ge = ne.detail.rotation;
                  this.setRotation(ge), this.annotationStorage.setValue(this.data.id, {
                    rotation: ge
                  });
                }
              });
            }
            _dispatchEventFromSandbox(oe, ne) {
              const ge = this._commonActions;
              for (const xe of Object.keys(ne.detail)) {
                const Oe = oe[xe] || ge[xe];
                Oe == null || Oe(ne);
              }
            }
            _setDefaultPropertiesFromJS(oe) {
              if (!this.enableScripting)
                return;
              const ne = this.annotationStorage.getRawValue(this.data.id);
              if (!ne)
                return;
              const ge = this._commonActions;
              for (const [xe, Oe] of Object.entries(ne)) {
                const Ue = ge[xe];
                if (Ue) {
                  const qe = {
                    detail: {
                      [xe]: Oe
                    },
                    target: oe
                  };
                  Ue(qe), delete ne[xe];
                }
              }
            }
            _createQuadrilaterals() {
              if (!this.container)
                return;
              const {
                quadPoints: oe
              } = this.data;
              if (!oe)
                return;
              const [ne, ge, xe, Oe] = this.data.rect;
              if (oe.length === 1) {
                const [, {
                  x: ht,
                  y: mt
                }, {
                  x: bt,
                  y: yt
                }] = oe[0];
                if (xe === ht && Oe === mt && ne === bt && ge === yt)
                  return;
              }
              const {
                style: Ue
              } = this.container;
              let qe;
              if (G(this, W)) {
                const {
                  borderColor: ht,
                  borderWidth: mt
                } = Ue;
                Ue.borderWidth = 0, qe = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${ht}" stroke-width="${mt}">`], this.container.classList.add("hasBorder");
              }
              const Qe = xe - ne, Je = Oe - ge, {
                svgFactory: He
              } = this, st = He.createElement("svg");
              st.classList.add("quadrilateralsContainer"), st.setAttribute("width", 0), st.setAttribute("height", 0);
              const et = He.createElement("defs");
              st.append(et);
              const Ze = He.createElement("clipPath"), it = `clippath_${this.data.id}`;
              Ze.setAttribute("id", it), Ze.setAttribute("clipPathUnits", "objectBoundingBox"), et.append(Ze);
              for (const [, {
                x: ht,
                y: mt
              }, {
                x: bt,
                y: yt
              }] of oe) {
                const tt = He.createElement("rect"), Te = (bt - ne) / Qe, ze = (Oe - mt) / Je, at = (ht - bt) / Qe, _t = (mt - yt) / Je;
                tt.setAttribute("x", Te), tt.setAttribute("y", ze), tt.setAttribute("width", at), tt.setAttribute("height", _t), Ze.append(tt), qe == null || qe.push(`<rect vector-effect="non-scaling-stroke" x="${Te}" y="${ze}" width="${at}" height="${_t}"/>`);
              }
              G(this, W) && (qe.push("</g></svg>')"), Ue.backgroundImage = qe.join("")), this.container.append(st), this.container.style.clipPath = `url(#${it})`;
            }
            _createPopup() {
              const {
                container: oe,
                data: ne
              } = this;
              oe.setAttribute("aria-haspopup", "dialog");
              const ge = new U({
                data: {
                  color: ne.color,
                  titleObj: ne.titleObj,
                  modificationDate: ne.modificationDate,
                  contentsObj: ne.contentsObj,
                  richText: ne.richText,
                  parentRect: ne.rect,
                  borderStyle: 0,
                  id: `popup_${ne.id}`,
                  rotation: ne.rotation
                },
                parent: this.parent,
                elements: [this]
              });
              this.parent.div.append(ge.render());
            }
            render() {
              (0, a.unreachable)("Abstract method `AnnotationElement.render` called");
            }
            _getElementsByName(oe, ne = null) {
              const ge = [];
              if (this._fieldObjects) {
                const xe = this._fieldObjects[oe];
                if (xe)
                  for (const {
                    page: Oe,
                    id: Ue,
                    exportValues: qe
                  } of xe) {
                    if (Oe === -1 || Ue === ne)
                      continue;
                    const Qe = typeof qe == "string" ? qe : null, Je = document.querySelector(`[data-element-id="${Ue}"]`);
                    if (Je && !y.has(Je)) {
                      (0, a.warn)(`_getElementsByName - element not allowed: ${Ue}`);
                      continue;
                    }
                    ge.push({
                      id: Ue,
                      exportValue: Qe,
                      domElement: Je
                    });
                  }
                return ge;
              }
              for (const xe of document.getElementsByName(oe)) {
                const {
                  exportValue: Oe
                } = xe, Ue = xe.getAttribute("data-element-id");
                Ue !== ne && y.has(xe) && ge.push({
                  id: Ue,
                  exportValue: Oe,
                  domElement: xe
                });
              }
              return ge;
            }
            show() {
              var oe;
              this.container && (this.container.hidden = !1), (oe = this.popup) == null || oe.maybeShow();
            }
            hide() {
              var oe;
              this.container && (this.container.hidden = !0), (oe = this.popup) == null || oe.forceHide();
            }
            getElementsToTriggerPopup() {
              return this.container;
            }
            addHighlightArea() {
              const oe = this.getElementsToTriggerPopup();
              if (Array.isArray(oe))
                for (const ne of oe)
                  ne.classList.add("highlightArea");
              else
                oe.classList.add("highlightArea");
            }
            _editOnDoubleClick() {
              const {
                annotationEditorType: oe,
                data: {
                  id: ne
                }
              } = this;
              this.container.addEventListener("dblclick", () => {
                var ge;
                (ge = this.linkService.eventBus) == null || ge.dispatch("switchannotationeditormode", {
                  source: this,
                  mode: oe,
                  editId: ne
                });
              });
            }
          };
          W = new WeakMap();
          let v = ee;
          class C extends v {
            constructor(ne, ge = null) {
              super(ne, {
                isRenderable: !0,
                ignoreBorder: !!(ge != null && ge.ignoreBorder),
                createQuadrilaterals: !0
              });
              we(this, ae);
              this.isTooltipOnly = ne.data.isTooltipOnly;
            }
            render() {
              const {
                data: ne,
                linkService: ge
              } = this, xe = document.createElement("a");
              xe.setAttribute("data-element-id", ne.id);
              let Oe = !1;
              return ne.url ? (ge.addLinkAttributes(xe, ne.url, ne.newWindow), Oe = !0) : ne.action ? (this._bindNamedAction(xe, ne.action), Oe = !0) : ne.attachment ? (this._bindAttachment(xe, ne.attachment), Oe = !0) : ne.setOCGState ? (_e(this, ae, rr).call(this, xe, ne.setOCGState), Oe = !0) : ne.dest ? (this._bindLink(xe, ne.dest), Oe = !0) : (ne.actions && (ne.actions.Action || ne.actions["Mouse Up"] || ne.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(xe, ne), Oe = !0), ne.resetForm ? (this._bindResetFormAction(xe, ne.resetForm), Oe = !0) : this.isTooltipOnly && !Oe && (this._bindLink(xe, ""), Oe = !0)), this.container.classList.add("linkAnnotation"), Oe && this.container.append(xe), this.container;
            }
            _bindLink(ne, ge) {
              ne.href = this.linkService.getDestinationHash(ge), ne.onclick = () => (ge && this.linkService.goToDestination(ge), !1), (ge || ge === "") && _e(this, ae, It).call(this);
            }
            _bindNamedAction(ne, ge) {
              ne.href = this.linkService.getAnchorUrl(""), ne.onclick = () => (this.linkService.executeNamedAction(ge), !1), _e(this, ae, It).call(this);
            }
            _bindAttachment(ne, ge) {
              ne.href = this.linkService.getAnchorUrl(""), ne.onclick = () => {
                var xe;
                return (xe = this.downloadManager) == null || xe.openOrDownloadData(this.container, ge.content, ge.filename), !1;
              }, _e(this, ae, It).call(this);
            }
            _bindJSAction(ne, ge) {
              ne.href = this.linkService.getAnchorUrl("");
              const xe = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
              for (const Oe of Object.keys(ge.actions)) {
                const Ue = xe.get(Oe);
                Ue && (ne[Ue] = () => {
                  var qe;
                  return (qe = this.linkService.eventBus) == null || qe.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                      id: ge.id,
                      name: Oe
                    }
                  }), !1;
                });
              }
              ne.onclick || (ne.onclick = () => !1), _e(this, ae, It).call(this);
            }
            _bindResetFormAction(ne, ge) {
              const xe = ne.onclick;
              if (xe || (ne.href = this.linkService.getAnchorUrl("")), _e(this, ae, It).call(this), !this._fieldObjects) {
                (0, a.warn)('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), xe || (ne.onclick = () => !1);
                return;
              }
              ne.onclick = () => {
                var st;
                xe == null || xe();
                const {
                  fields: Oe,
                  refs: Ue,
                  include: qe
                } = ge, Qe = [];
                if (Oe.length !== 0 || Ue.length !== 0) {
                  const et = new Set(Ue);
                  for (const Ze of Oe) {
                    const it = this._fieldObjects[Ze] || [];
                    for (const {
                      id: ht
                    } of it)
                      et.add(ht);
                  }
                  for (const Ze of Object.values(this._fieldObjects))
                    for (const it of Ze)
                      et.has(it.id) === qe && Qe.push(it);
                } else
                  for (const et of Object.values(this._fieldObjects))
                    Qe.push(...et);
                const Je = this.annotationStorage, He = [];
                for (const et of Qe) {
                  const {
                    id: Ze
                  } = et;
                  switch (He.push(Ze), et.type) {
                    case "text": {
                      const ht = et.defaultValue || "";
                      Je.setValue(Ze, {
                        value: ht
                      });
                      break;
                    }
                    case "checkbox":
                    case "radiobutton": {
                      const ht = et.defaultValue === et.exportValues;
                      Je.setValue(Ze, {
                        value: ht
                      });
                      break;
                    }
                    case "combobox":
                    case "listbox": {
                      const ht = et.defaultValue || "";
                      Je.setValue(Ze, {
                        value: ht
                      });
                      break;
                    }
                    default:
                      continue;
                  }
                  const it = document.querySelector(`[data-element-id="${Ze}"]`);
                  if (it) {
                    if (!y.has(it)) {
                      (0, a.warn)(`_bindResetFormAction - element not allowed: ${Ze}`);
                      continue;
                    }
                  } else continue;
                  it.dispatchEvent(new Event("resetform"));
                }
                return this.enableScripting && ((st = this.linkService.eventBus) == null || st.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: "app",
                    ids: He,
                    name: "ResetForm"
                  }
                })), !1;
              };
            }
          }
          ae = new WeakSet(), It = function() {
            this.container.setAttribute("data-internal-link", "");
          }, rr = function(ne, ge) {
            ne.href = this.linkService.getAnchorUrl(""), ne.onclick = () => (this.linkService.executeSetOCGState(ge), !1), _e(this, ae, It).call(this);
          };
          class R extends v {
            constructor(oe) {
              super(oe, {
                isRenderable: !0
              });
            }
            render() {
              this.container.classList.add("textAnnotation");
              const oe = document.createElement("img");
              return oe.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", oe.alt = "[{{type}} Annotation]", oe.dataset.l10nId = "text_annotation_type", oe.dataset.l10nArgs = JSON.stringify({
                type: this.data.name
              }), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(oe), this.container;
            }
          }
          class I extends v {
            render() {
              return this.data.alternativeText && (this.container.title = this.data.alternativeText), this.container;
            }
            showElementAndHideCanvas(oe) {
              var ne;
              this.data.hasOwnCanvas && (((ne = oe.previousSibling) == null ? void 0 : ne.nodeName) === "CANVAS" && (oe.previousSibling.hidden = !0), oe.hidden = !1);
            }
            _getKeyModifier(oe) {
              const {
                isWin: ne,
                isMac: ge
              } = a.FeatureTest.platform;
              return ne && oe.ctrlKey || ge && oe.metaKey;
            }
            _setEventListener(oe, ne, ge, xe, Oe) {
              ge.includes("mouse") ? oe.addEventListener(ge, (Ue) => {
                var qe;
                (qe = this.linkService.eventBus) == null || qe.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: this.data.id,
                    name: xe,
                    value: Oe(Ue),
                    shift: Ue.shiftKey,
                    modifier: this._getKeyModifier(Ue)
                  }
                });
              }) : oe.addEventListener(ge, (Ue) => {
                var qe;
                if (ge === "blur") {
                  if (!ne.focused || !Ue.relatedTarget)
                    return;
                  ne.focused = !1;
                } else if (ge === "focus") {
                  if (ne.focused)
                    return;
                  ne.focused = !0;
                }
                Oe && ((qe = this.linkService.eventBus) == null || qe.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: this.data.id,
                    name: xe,
                    value: Oe(Ue)
                  }
                }));
              });
            }
            _setEventListeners(oe, ne, ge, xe) {
              var Oe, Ue, qe;
              for (const [Qe, Je] of ge)
                (Je === "Action" || (Oe = this.data.actions) != null && Oe[Je]) && ((Je === "Focus" || Je === "Blur") && (ne || (ne = {
                  focused: !1
                })), this._setEventListener(oe, ne, Qe, Je, xe), Je === "Focus" && !((Ue = this.data.actions) != null && Ue.Blur) ? this._setEventListener(oe, ne, "blur", "Blur", null) : Je === "Blur" && !((qe = this.data.actions) != null && qe.Focus) && this._setEventListener(oe, ne, "focus", "Focus", null));
            }
            _setBackgroundColor(oe) {
              const ne = this.data.backgroundColor || null;
              oe.style.backgroundColor = ne === null ? "transparent" : a.Util.makeHexColor(ne[0], ne[1], ne[2]);
            }
            _setTextStyle(oe) {
              const ne = ["left", "center", "right"], {
                fontColor: ge
              } = this.data.defaultAppearanceData, xe = this.data.defaultAppearanceData.fontSize || _, Oe = oe.style;
              let Ue;
              const qe = 2, Qe = (Je) => Math.round(10 * Je) / 10;
              if (this.data.multiLine) {
                const Je = Math.abs(this.data.rect[3] - this.data.rect[1] - qe), He = Math.round(Je / (a.LINE_FACTOR * xe)) || 1, st = Je / He;
                Ue = Math.min(xe, Qe(st / a.LINE_FACTOR));
              } else {
                const Je = Math.abs(this.data.rect[3] - this.data.rect[1] - qe);
                Ue = Math.min(xe, Qe(Je / a.LINE_FACTOR));
              }
              Oe.fontSize = `calc(${Ue}px * var(--scale-factor))`, Oe.color = a.Util.makeHexColor(ge[0], ge[1], ge[2]), this.data.textAlignment !== null && (Oe.textAlign = ne[this.data.textAlignment]);
            }
            _setRequired(oe, ne) {
              ne ? oe.setAttribute("required", !0) : oe.removeAttribute("required"), oe.setAttribute("aria-required", ne);
            }
          }
          class w extends I {
            constructor(oe) {
              const ne = oe.renderForms || !oe.data.hasAppearance && !!oe.data.fieldValue;
              super(oe, {
                isRenderable: ne
              });
            }
            setPropertyOnSiblings(oe, ne, ge, xe) {
              const Oe = this.annotationStorage;
              for (const Ue of this._getElementsByName(oe.name, oe.id))
                Ue.domElement && (Ue.domElement[ne] = ge), Oe.setValue(Ue.id, {
                  [xe]: ge
                });
            }
            render() {
              var xe, Oe;
              const oe = this.annotationStorage, ne = this.data.id;
              this.container.classList.add("textWidgetAnnotation");
              let ge = null;
              if (this.renderForms) {
                const Ue = oe.getValue(ne, {
                  value: this.data.fieldValue
                });
                let qe = Ue.value || "";
                const Qe = oe.getValue(ne, {
                  charLimit: this.data.maxLen
                }).charLimit;
                Qe && qe.length > Qe && (qe = qe.slice(0, Qe));
                let Je = Ue.formattedValue || ((xe = this.data.textContent) == null ? void 0 : xe.join(`
`)) || null;
                Je && this.data.comb && (Je = Je.replaceAll(/\s+/g, ""));
                const He = {
                  userValue: qe,
                  formattedValue: Je,
                  lastCommittedValue: null,
                  commitKey: 1,
                  focused: !1
                };
                this.data.multiLine ? (ge = document.createElement("textarea"), ge.textContent = Je ?? qe, this.data.doNotScroll && (ge.style.overflowY = "hidden")) : (ge = document.createElement("input"), ge.type = "text", ge.setAttribute("value", Je ?? qe), this.data.doNotScroll && (ge.style.overflowX = "hidden")), this.data.hasOwnCanvas && (ge.hidden = !0), y.add(ge), ge.setAttribute("data-element-id", ne), ge.disabled = this.data.readOnly, ge.name = this.data.fieldName, ge.tabIndex = b, this._setRequired(ge, this.data.required), Qe && (ge.maxLength = Qe), ge.addEventListener("input", (et) => {
                  oe.setValue(ne, {
                    value: et.target.value
                  }), this.setPropertyOnSiblings(ge, "value", et.target.value, "value"), He.formattedValue = null;
                }), ge.addEventListener("resetform", (et) => {
                  const Ze = this.data.defaultFieldValue ?? "";
                  ge.value = He.userValue = Ze, He.formattedValue = null;
                });
                let st = (et) => {
                  const {
                    formattedValue: Ze
                  } = He;
                  Ze != null && (et.target.value = Ze), et.target.scrollLeft = 0;
                };
                if (this.enableScripting && this.hasJSActions) {
                  ge.addEventListener("focus", (Ze) => {
                    if (He.focused)
                      return;
                    const {
                      target: it
                    } = Ze;
                    He.userValue && (it.value = He.userValue), He.lastCommittedValue = it.value, He.commitKey = 1, He.focused = !0;
                  }), ge.addEventListener("updatefromsandbox", (Ze) => {
                    this.showElementAndHideCanvas(Ze.target);
                    const it = {
                      value(ht) {
                        He.userValue = ht.detail.value ?? "", oe.setValue(ne, {
                          value: He.userValue.toString()
                        }), ht.target.value = He.userValue;
                      },
                      formattedValue(ht) {
                        const {
                          formattedValue: mt
                        } = ht.detail;
                        He.formattedValue = mt, mt != null && ht.target !== document.activeElement && (ht.target.value = mt), oe.setValue(ne, {
                          formattedValue: mt
                        });
                      },
                      selRange(ht) {
                        ht.target.setSelectionRange(...ht.detail.selRange);
                      },
                      charLimit: (ht) => {
                        var tt;
                        const {
                          charLimit: mt
                        } = ht.detail, {
                          target: bt
                        } = ht;
                        if (mt === 0) {
                          bt.removeAttribute("maxLength");
                          return;
                        }
                        bt.setAttribute("maxLength", mt);
                        let yt = He.userValue;
                        !yt || yt.length <= mt || (yt = yt.slice(0, mt), bt.value = He.userValue = yt, oe.setValue(ne, {
                          value: yt
                        }), (tt = this.linkService.eventBus) == null || tt.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id: ne,
                            name: "Keystroke",
                            value: yt,
                            willCommit: !0,
                            commitKey: 1,
                            selStart: bt.selectionStart,
                            selEnd: bt.selectionEnd
                          }
                        }));
                      }
                    };
                    this._dispatchEventFromSandbox(it, Ze);
                  }), ge.addEventListener("keydown", (Ze) => {
                    var mt;
                    He.commitKey = 1;
                    let it = -1;
                    if (Ze.key === "Escape" ? it = 0 : Ze.key === "Enter" && !this.data.multiLine ? it = 2 : Ze.key === "Tab" && (He.commitKey = 3), it === -1)
                      return;
                    const {
                      value: ht
                    } = Ze.target;
                    He.lastCommittedValue !== ht && (He.lastCommittedValue = ht, He.userValue = ht, (mt = this.linkService.eventBus) == null || mt.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: ne,
                        name: "Keystroke",
                        value: ht,
                        willCommit: !0,
                        commitKey: it,
                        selStart: Ze.target.selectionStart,
                        selEnd: Ze.target.selectionEnd
                      }
                    }));
                  });
                  const et = st;
                  st = null, ge.addEventListener("blur", (Ze) => {
                    var ht;
                    if (!He.focused || !Ze.relatedTarget)
                      return;
                    He.focused = !1;
                    const {
                      value: it
                    } = Ze.target;
                    He.userValue = it, He.lastCommittedValue !== it && ((ht = this.linkService.eventBus) == null || ht.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: ne,
                        name: "Keystroke",
                        value: it,
                        willCommit: !0,
                        commitKey: He.commitKey,
                        selStart: Ze.target.selectionStart,
                        selEnd: Ze.target.selectionEnd
                      }
                    })), et(Ze);
                  }), (Oe = this.data.actions) != null && Oe.Keystroke && ge.addEventListener("beforeinput", (Ze) => {
                    var ze;
                    He.lastCommittedValue = null;
                    const {
                      data: it,
                      target: ht
                    } = Ze, {
                      value: mt,
                      selectionStart: bt,
                      selectionEnd: yt
                    } = ht;
                    let tt = bt, Te = yt;
                    switch (Ze.inputType) {
                      case "deleteWordBackward": {
                        const at = mt.substring(0, bt).match(/\w*[^\w]*$/);
                        at && (tt -= at[0].length);
                        break;
                      }
                      case "deleteWordForward": {
                        const at = mt.substring(bt).match(/^[^\w]*\w*/);
                        at && (Te += at[0].length);
                        break;
                      }
                      case "deleteContentBackward":
                        bt === yt && (tt -= 1);
                        break;
                      case "deleteContentForward":
                        bt === yt && (Te += 1);
                        break;
                    }
                    Ze.preventDefault(), (ze = this.linkService.eventBus) == null || ze.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: ne,
                        name: "Keystroke",
                        value: mt,
                        change: it || "",
                        willCommit: !1,
                        selStart: tt,
                        selEnd: Te
                      }
                    });
                  }), this._setEventListeners(ge, He, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (Ze) => Ze.target.value);
                }
                if (st && ge.addEventListener("blur", st), this.data.comb) {
                  const Ze = (this.data.rect[2] - this.data.rect[0]) / Qe;
                  ge.classList.add("comb"), ge.style.letterSpacing = `calc(${Ze}px * var(--scale-factor) - 1ch)`;
                }
              } else
                ge = document.createElement("div"), ge.textContent = this.data.fieldValue, ge.style.verticalAlign = "middle", ge.style.display = "table-cell";
              return this._setTextStyle(ge), this._setBackgroundColor(ge), this._setDefaultPropertiesFromJS(ge), this.container.append(ge), this.container;
            }
          }
          class N extends I {
            constructor(oe) {
              super(oe, {
                isRenderable: !!oe.data.hasOwnCanvas
              });
            }
          }
          class F extends I {
            constructor(oe) {
              super(oe, {
                isRenderable: oe.renderForms
              });
            }
            render() {
              const oe = this.annotationStorage, ne = this.data, ge = ne.id;
              let xe = oe.getValue(ge, {
                value: ne.exportValue === ne.fieldValue
              }).value;
              typeof xe == "string" && (xe = xe !== "Off", oe.setValue(ge, {
                value: xe
              })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
              const Oe = document.createElement("input");
              return y.add(Oe), Oe.setAttribute("data-element-id", ge), Oe.disabled = ne.readOnly, this._setRequired(Oe, this.data.required), Oe.type = "checkbox", Oe.name = ne.fieldName, xe && Oe.setAttribute("checked", !0), Oe.setAttribute("exportValue", ne.exportValue), Oe.tabIndex = b, Oe.addEventListener("change", (Ue) => {
                const {
                  name: qe,
                  checked: Qe
                } = Ue.target;
                for (const Je of this._getElementsByName(qe, ge)) {
                  const He = Qe && Je.exportValue === ne.exportValue;
                  Je.domElement && (Je.domElement.checked = He), oe.setValue(Je.id, {
                    value: He
                  });
                }
                oe.setValue(ge, {
                  value: Qe
                });
              }), Oe.addEventListener("resetform", (Ue) => {
                const qe = ne.defaultFieldValue || "Off";
                Ue.target.checked = qe === ne.exportValue;
              }), this.enableScripting && this.hasJSActions && (Oe.addEventListener("updatefromsandbox", (Ue) => {
                const qe = {
                  value(Qe) {
                    Qe.target.checked = Qe.detail.value !== "Off", oe.setValue(ge, {
                      value: Qe.target.checked
                    });
                  }
                };
                this._dispatchEventFromSandbox(qe, Ue);
              }), this._setEventListeners(Oe, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (Ue) => Ue.target.checked)), this._setBackgroundColor(Oe), this._setDefaultPropertiesFromJS(Oe), this.container.append(Oe), this.container;
            }
          }
          class M extends I {
            constructor(oe) {
              super(oe, {
                isRenderable: oe.renderForms
              });
            }
            render() {
              this.container.classList.add("buttonWidgetAnnotation", "radioButton");
              const oe = this.annotationStorage, ne = this.data, ge = ne.id;
              let xe = oe.getValue(ge, {
                value: ne.fieldValue === ne.buttonValue
              }).value;
              typeof xe == "string" && (xe = xe !== ne.buttonValue, oe.setValue(ge, {
                value: xe
              }));
              const Oe = document.createElement("input");
              if (y.add(Oe), Oe.setAttribute("data-element-id", ge), Oe.disabled = ne.readOnly, this._setRequired(Oe, this.data.required), Oe.type = "radio", Oe.name = ne.fieldName, xe && Oe.setAttribute("checked", !0), Oe.tabIndex = b, Oe.addEventListener("change", (Ue) => {
                const {
                  name: qe,
                  checked: Qe
                } = Ue.target;
                for (const Je of this._getElementsByName(qe, ge))
                  oe.setValue(Je.id, {
                    value: !1
                  });
                oe.setValue(ge, {
                  value: Qe
                });
              }), Oe.addEventListener("resetform", (Ue) => {
                const qe = ne.defaultFieldValue;
                Ue.target.checked = qe != null && qe === ne.buttonValue;
              }), this.enableScripting && this.hasJSActions) {
                const Ue = ne.buttonValue;
                Oe.addEventListener("updatefromsandbox", (qe) => {
                  const Qe = {
                    value: (Je) => {
                      const He = Ue === Je.detail.value;
                      for (const st of this._getElementsByName(Je.target.name)) {
                        const et = He && st.id === ge;
                        st.domElement && (st.domElement.checked = et), oe.setValue(st.id, {
                          value: et
                        });
                      }
                    }
                  };
                  this._dispatchEventFromSandbox(Qe, qe);
                }), this._setEventListeners(Oe, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (qe) => qe.target.checked);
              }
              return this._setBackgroundColor(Oe), this._setDefaultPropertiesFromJS(Oe), this.container.append(Oe), this.container;
            }
          }
          class x extends C {
            constructor(oe) {
              super(oe, {
                ignoreBorder: oe.data.hasAppearance
              });
            }
            render() {
              const oe = super.render();
              oe.classList.add("buttonWidgetAnnotation", "pushButton"), this.data.alternativeText && (oe.title = this.data.alternativeText);
              const ne = oe.lastChild;
              return this.enableScripting && this.hasJSActions && ne && (this._setDefaultPropertiesFromJS(ne), ne.addEventListener("updatefromsandbox", (ge) => {
                this._dispatchEventFromSandbox({}, ge);
              })), oe;
            }
          }
          class P extends I {
            constructor(oe) {
              super(oe, {
                isRenderable: oe.renderForms
              });
            }
            render() {
              this.container.classList.add("choiceWidgetAnnotation");
              const oe = this.annotationStorage, ne = this.data.id, ge = oe.getValue(ne, {
                value: this.data.fieldValue
              }), xe = document.createElement("select");
              y.add(xe), xe.setAttribute("data-element-id", ne), xe.disabled = this.data.readOnly, this._setRequired(xe, this.data.required), xe.name = this.data.fieldName, xe.tabIndex = b;
              let Oe = this.data.combo && this.data.options.length > 0;
              this.data.combo || (xe.size = this.data.options.length, this.data.multiSelect && (xe.multiple = !0)), xe.addEventListener("resetform", (He) => {
                const st = this.data.defaultFieldValue;
                for (const et of xe.options)
                  et.selected = et.value === st;
              });
              for (const He of this.data.options) {
                const st = document.createElement("option");
                st.textContent = He.displayValue, st.value = He.exportValue, ge.value.includes(He.exportValue) && (st.setAttribute("selected", !0), Oe = !1), xe.append(st);
              }
              let Ue = null;
              if (Oe) {
                const He = document.createElement("option");
                He.value = " ", He.setAttribute("hidden", !0), He.setAttribute("selected", !0), xe.prepend(He), Ue = () => {
                  He.remove(), xe.removeEventListener("input", Ue), Ue = null;
                }, xe.addEventListener("input", Ue);
              }
              const qe = (He) => {
                const st = He ? "value" : "textContent", {
                  options: et,
                  multiple: Ze
                } = xe;
                return Ze ? Array.prototype.filter.call(et, (it) => it.selected).map((it) => it[st]) : et.selectedIndex === -1 ? null : et[et.selectedIndex][st];
              };
              let Qe = qe(!1);
              const Je = (He) => {
                const st = He.target.options;
                return Array.prototype.map.call(st, (et) => ({
                  displayValue: et.textContent,
                  exportValue: et.value
                }));
              };
              return this.enableScripting && this.hasJSActions ? (xe.addEventListener("updatefromsandbox", (He) => {
                const st = {
                  value(et) {
                    Ue == null || Ue();
                    const Ze = et.detail.value, it = new Set(Array.isArray(Ze) ? Ze : [Ze]);
                    for (const ht of xe.options)
                      ht.selected = it.has(ht.value);
                    oe.setValue(ne, {
                      value: qe(!0)
                    }), Qe = qe(!1);
                  },
                  multipleSelection(et) {
                    xe.multiple = !0;
                  },
                  remove(et) {
                    const Ze = xe.options, it = et.detail.remove;
                    Ze[it].selected = !1, xe.remove(it), Ze.length > 0 && Array.prototype.findIndex.call(Ze, (mt) => mt.selected) === -1 && (Ze[0].selected = !0), oe.setValue(ne, {
                      value: qe(!0),
                      items: Je(et)
                    }), Qe = qe(!1);
                  },
                  clear(et) {
                    for (; xe.length !== 0; )
                      xe.remove(0);
                    oe.setValue(ne, {
                      value: null,
                      items: []
                    }), Qe = qe(!1);
                  },
                  insert(et) {
                    const {
                      index: Ze,
                      displayValue: it,
                      exportValue: ht
                    } = et.detail.insert, mt = xe.children[Ze], bt = document.createElement("option");
                    bt.textContent = it, bt.value = ht, mt ? mt.before(bt) : xe.append(bt), oe.setValue(ne, {
                      value: qe(!0),
                      items: Je(et)
                    }), Qe = qe(!1);
                  },
                  items(et) {
                    const {
                      items: Ze
                    } = et.detail;
                    for (; xe.length !== 0; )
                      xe.remove(0);
                    for (const it of Ze) {
                      const {
                        displayValue: ht,
                        exportValue: mt
                      } = it, bt = document.createElement("option");
                      bt.textContent = ht, bt.value = mt, xe.append(bt);
                    }
                    xe.options.length > 0 && (xe.options[0].selected = !0), oe.setValue(ne, {
                      value: qe(!0),
                      items: Je(et)
                    }), Qe = qe(!1);
                  },
                  indices(et) {
                    const Ze = new Set(et.detail.indices);
                    for (const it of et.target.options)
                      it.selected = Ze.has(it.index);
                    oe.setValue(ne, {
                      value: qe(!0)
                    }), Qe = qe(!1);
                  },
                  editable(et) {
                    et.target.disabled = !et.detail.editable;
                  }
                };
                this._dispatchEventFromSandbox(st, He);
              }), xe.addEventListener("input", (He) => {
                var et;
                const st = qe(!0);
                oe.setValue(ne, {
                  value: st
                }), He.preventDefault(), (et = this.linkService.eventBus) == null || et.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: ne,
                    name: "Keystroke",
                    value: Qe,
                    changeEx: st,
                    willCommit: !1,
                    commitKey: 1,
                    keyDown: !1
                  }
                });
              }), this._setEventListeners(xe, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (He) => He.target.value)) : xe.addEventListener("input", function(He) {
                oe.setValue(ne, {
                  value: qe(!0)
                });
              }), this.data.combo && this._setTextStyle(xe), this._setBackgroundColor(xe), this._setDefaultPropertiesFromJS(xe), this.container.append(xe), this.container;
            }
          }
          class U extends v {
            constructor(oe) {
              const {
                data: ne,
                elements: ge
              } = oe;
              super(oe, {
                isRenderable: v._hasPopupData(ne)
              }), this.elements = ge;
            }
            render() {
              this.container.classList.add("popupAnnotation");
              const oe = new L({
                container: this.container,
                color: this.data.color,
                titleObj: this.data.titleObj,
                modificationDate: this.data.modificationDate,
                contentsObj: this.data.contentsObj,
                richText: this.data.richText,
                rect: this.data.rect,
                parentRect: this.data.parentRect || null,
                parent: this.parent,
                elements: this.elements,
                open: this.data.open
              }), ne = [];
              for (const ge of this.elements)
                ge.popup = oe, ne.push(ge.data.id), ge.addHighlightArea();
              return this.container.setAttribute("aria-controls", ne.map((ge) => `${a.AnnotationPrefix}${ge}`).join(",")), this.container;
            }
          }
          class L {
            constructor({
              container: oe,
              color: ne,
              elements: ge,
              titleObj: xe,
              modificationDate: Oe,
              contentsObj: Ue,
              richText: qe,
              parent: Qe,
              rect: Je,
              parentRect: He,
              open: st
            }) {
              we(this, Me);
              we(this, ye, null);
              we(this, Re, _e(this, Me, ar).bind(this));
              we(this, De, _e(this, Me, In).bind(this));
              we(this, Pe, _e(this, Me, Cn).bind(this));
              we(this, he, _e(this, Me, Kt).bind(this));
              we(this, Le, null);
              we(this, Ee, null);
              we(this, Se, null);
              we(this, Q, null);
              we(this, K, null);
              we(this, fe, null);
              we(this, be, !1);
              we(this, ke, null);
              we(this, Fe, null);
              we(this, Be, null);
              we(this, te, null);
              we(this, Ce, !1);
              var Ze;
              Ie(this, Ee, oe), Ie(this, te, xe), Ie(this, Se, Ue), Ie(this, Be, qe), Ie(this, K, Qe), Ie(this, Le, ne), Ie(this, Fe, Je), Ie(this, fe, He), Ie(this, Q, ge);
              const et = o.PDFDateString.toDateObject(Oe);
              et && Ie(this, ye, Qe.l10n.get("annotation_date_string", {
                date: et.toLocaleDateString(),
                time: et.toLocaleTimeString()
              })), this.trigger = ge.flatMap((it) => it.getElementsToTriggerPopup());
              for (const it of this.trigger)
                it.addEventListener("click", G(this, he)), it.addEventListener("mouseenter", G(this, Pe)), it.addEventListener("mouseleave", G(this, De)), it.classList.add("popupTriggerArea");
              for (const it of ge)
                (Ze = it.container) == null || Ze.addEventListener("keydown", G(this, Re));
              G(this, Ee).hidden = !0, st && _e(this, Me, Kt).call(this);
            }
            render() {
              if (G(this, ke))
                return;
              const {
                page: {
                  view: oe
                },
                viewport: {
                  rawDims: {
                    pageWidth: ne,
                    pageHeight: ge,
                    pageX: xe,
                    pageY: Oe
                  }
                }
              } = G(this, K), Ue = Ie(this, ke, document.createElement("div"));
              if (Ue.className = "popup", G(this, Le)) {
                const tt = Ue.style.outlineColor = a.Util.makeHexColor(...G(this, Le));
                CSS.supports("background-color", "color-mix(in srgb, red 30%, white)") ? Ue.style.backgroundColor = `color-mix(in srgb, ${tt} 30%, white)` : Ue.style.backgroundColor = a.Util.makeHexColor(...G(this, Le).map((ze) => Math.floor(0.7 * (255 - ze) + ze)));
              }
              const qe = document.createElement("span");
              qe.className = "header";
              const Qe = document.createElement("h1");
              if (qe.append(Qe), {
                dir: Qe.dir,
                str: Qe.textContent
              } = G(this, te), Ue.append(qe), G(this, ye)) {
                const tt = document.createElement("span");
                tt.classList.add("popupDate"), G(this, ye).then((Te) => {
                  tt.textContent = Te;
                }), qe.append(tt);
              }
              const Je = G(this, Se), He = G(this, Be);
              if (He != null && He.str && (!(Je != null && Je.str) || Je.str === He.str))
                g.XfaLayer.render({
                  xfaHtml: He.html,
                  intent: "richText",
                  div: Ue
                }), Ue.lastChild.classList.add("richText", "popupContent");
              else {
                const tt = this._formatContents(Je);
                Ue.append(tt);
              }
              let st = !!G(this, fe), et = st ? G(this, fe) : G(this, Fe);
              for (const tt of G(this, Q))
                if (!et || a.Util.intersect(tt.data.rect, et) !== null) {
                  et = tt.data.rect, st = !0;
                  break;
                }
              const Ze = a.Util.normalizeRect([et[0], oe[3] - et[1] + oe[1], et[2], oe[3] - et[3] + oe[1]]), ht = st ? et[2] - et[0] + 5 : 0, mt = Ze[0] + ht, bt = Ze[1], {
                style: yt
              } = G(this, Ee);
              yt.left = `${100 * (mt - xe) / ne}%`, yt.top = `${100 * (bt - Oe) / ge}%`, G(this, Ee).append(Ue);
            }
            _formatContents({
              str: oe,
              dir: ne
            }) {
              const ge = document.createElement("p");
              ge.classList.add("popupContent"), ge.dir = ne;
              const xe = oe.split(/(?:\r\n?|\n)/);
              for (let Oe = 0, Ue = xe.length; Oe < Ue; ++Oe) {
                const qe = xe[Oe];
                ge.append(document.createTextNode(qe)), Oe < Ue - 1 && ge.append(document.createElement("br"));
              }
              return ge;
            }
            forceHide() {
              Ie(this, Ce, this.isVisible), G(this, Ce) && (G(this, Ee).hidden = !0);
            }
            maybeShow() {
              G(this, Ce) && (Ie(this, Ce, !1), G(this, Ee).hidden = !1);
            }
            get isVisible() {
              return G(this, Ee).hidden === !1;
            }
          }
          ye = new WeakMap(), Re = new WeakMap(), De = new WeakMap(), Pe = new WeakMap(), he = new WeakMap(), Le = new WeakMap(), Ee = new WeakMap(), Se = new WeakMap(), Q = new WeakMap(), K = new WeakMap(), fe = new WeakMap(), be = new WeakMap(), ke = new WeakMap(), Fe = new WeakMap(), Be = new WeakMap(), te = new WeakMap(), Ce = new WeakMap(), Me = new WeakSet(), ar = function(oe) {
            oe.altKey || oe.shiftKey || oe.ctrlKey || oe.metaKey || (oe.key === "Enter" || oe.key === "Escape" && G(this, be)) && _e(this, Me, Kt).call(this);
          }, Kt = function() {
            Ie(this, be, !G(this, be)), G(this, be) ? (_e(this, Me, Cn).call(this), G(this, Ee).addEventListener("click", G(this, he)), G(this, Ee).addEventListener("keydown", G(this, Re))) : (_e(this, Me, In).call(this), G(this, Ee).removeEventListener("click", G(this, he)), G(this, Ee).removeEventListener("keydown", G(this, Re)));
          }, Cn = function() {
            G(this, ke) || this.render(), this.isVisible ? G(this, be) && G(this, Ee).classList.add("focused") : (G(this, Ee).hidden = !1, G(this, Ee).style.zIndex = parseInt(G(this, Ee).style.zIndex) + 1e3);
          }, In = function() {
            G(this, Ee).classList.remove("focused"), !(G(this, be) || !this.isVisible) && (G(this, Ee).hidden = !0, G(this, Ee).style.zIndex = parseInt(G(this, Ee).style.zIndex) - 1e3);
          };
          class H extends v {
            constructor(oe) {
              super(oe, {
                isRenderable: !0,
                ignoreBorder: !0
              }), this.textContent = oe.data.textContent, this.textPosition = oe.data.textPosition, this.annotationEditorType = a.AnnotationEditorType.FREETEXT;
            }
            render() {
              if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
                const oe = document.createElement("div");
                oe.classList.add("annotationTextContent"), oe.setAttribute("role", "comment");
                for (const ne of this.textContent) {
                  const ge = document.createElement("span");
                  ge.textContent = ne, oe.append(ge);
                }
                this.container.append(oe);
              }
              return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
            }
          }
          t.FreeTextAnnotationElement = H;
          class B extends v {
            constructor(ne) {
              super(ne, {
                isRenderable: !0,
                ignoreBorder: !0
              });
              we(this, Xe, null);
            }
            render() {
              this.container.classList.add("lineAnnotation");
              const ne = this.data, {
                width: ge,
                height: xe
              } = A(ne.rect), Oe = this.svgFactory.create(ge, xe, !0), Ue = Ie(this, Xe, this.svgFactory.createElement("svg:line"));
              return Ue.setAttribute("x1", ne.rect[2] - ne.lineCoordinates[0]), Ue.setAttribute("y1", ne.rect[3] - ne.lineCoordinates[1]), Ue.setAttribute("x2", ne.rect[2] - ne.lineCoordinates[2]), Ue.setAttribute("y2", ne.rect[3] - ne.lineCoordinates[3]), Ue.setAttribute("stroke-width", ne.borderStyle.width || 1), Ue.setAttribute("stroke", "transparent"), Ue.setAttribute("fill", "transparent"), Oe.append(Ue), this.container.append(Oe), !ne.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
            getElementsToTriggerPopup() {
              return G(this, Xe);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          Xe = new WeakMap();
          class V extends v {
            constructor(ne) {
              super(ne, {
                isRenderable: !0,
                ignoreBorder: !0
              });
              we(this, ut, null);
            }
            render() {
              this.container.classList.add("squareAnnotation");
              const ne = this.data, {
                width: ge,
                height: xe
              } = A(ne.rect), Oe = this.svgFactory.create(ge, xe, !0), Ue = ne.borderStyle.width, qe = Ie(this, ut, this.svgFactory.createElement("svg:rect"));
              return qe.setAttribute("x", Ue / 2), qe.setAttribute("y", Ue / 2), qe.setAttribute("width", ge - Ue), qe.setAttribute("height", xe - Ue), qe.setAttribute("stroke-width", Ue || 1), qe.setAttribute("stroke", "transparent"), qe.setAttribute("fill", "transparent"), Oe.append(qe), this.container.append(Oe), !ne.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
            getElementsToTriggerPopup() {
              return G(this, ut);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          ut = new WeakMap();
          class X extends v {
            constructor(ne) {
              super(ne, {
                isRenderable: !0,
                ignoreBorder: !0
              });
              we(this, ct, null);
            }
            render() {
              this.container.classList.add("circleAnnotation");
              const ne = this.data, {
                width: ge,
                height: xe
              } = A(ne.rect), Oe = this.svgFactory.create(ge, xe, !0), Ue = ne.borderStyle.width, qe = Ie(this, ct, this.svgFactory.createElement("svg:ellipse"));
              return qe.setAttribute("cx", ge / 2), qe.setAttribute("cy", xe / 2), qe.setAttribute("rx", ge / 2 - Ue / 2), qe.setAttribute("ry", xe / 2 - Ue / 2), qe.setAttribute("stroke-width", Ue || 1), qe.setAttribute("stroke", "transparent"), qe.setAttribute("fill", "transparent"), Oe.append(qe), this.container.append(Oe), !ne.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
            getElementsToTriggerPopup() {
              return G(this, ct);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          ct = new WeakMap();
          class de extends v {
            constructor(ne) {
              super(ne, {
                isRenderable: !0,
                ignoreBorder: !0
              });
              we(this, $e, null);
              this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
            }
            render() {
              this.container.classList.add(this.containerClassName);
              const ne = this.data, {
                width: ge,
                height: xe
              } = A(ne.rect), Oe = this.svgFactory.create(ge, xe, !0);
              let Ue = [];
              for (const Qe of ne.vertices) {
                const Je = Qe.x - ne.rect[0], He = ne.rect[3] - Qe.y;
                Ue.push(Je + "," + He);
              }
              Ue = Ue.join(" ");
              const qe = Ie(this, $e, this.svgFactory.createElement(this.svgElementName));
              return qe.setAttribute("points", Ue), qe.setAttribute("stroke-width", ne.borderStyle.width || 1), qe.setAttribute("stroke", "transparent"), qe.setAttribute("fill", "transparent"), Oe.append(qe), this.container.append(Oe), !ne.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
            getElementsToTriggerPopup() {
              return G(this, $e);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          $e = new WeakMap();
          class Y extends de {
            constructor(oe) {
              super(oe), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
            }
          }
          class se extends v {
            constructor(oe) {
              super(oe, {
                isRenderable: !0,
                ignoreBorder: !0
              });
            }
            render() {
              return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
          }
          class ue extends v {
            constructor(ne) {
              super(ne, {
                isRenderable: !0,
                ignoreBorder: !0
              });
              we(this, Ae, []);
              this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = a.AnnotationEditorType.INK;
            }
            render() {
              this.container.classList.add(this.containerClassName);
              const ne = this.data, {
                width: ge,
                height: xe
              } = A(ne.rect), Oe = this.svgFactory.create(ge, xe, !0);
              for (const Ue of ne.inkLists) {
                let qe = [];
                for (const Je of Ue) {
                  const He = Je.x - ne.rect[0], st = ne.rect[3] - Je.y;
                  qe.push(`${He},${st}`);
                }
                qe = qe.join(" ");
                const Qe = this.svgFactory.createElement(this.svgElementName);
                G(this, Ae).push(Qe), Qe.setAttribute("points", qe), Qe.setAttribute("stroke-width", ne.borderStyle.width || 1), Qe.setAttribute("stroke", "transparent"), Qe.setAttribute("fill", "transparent"), !ne.popupRef && this.hasPopupData && this._createPopup(), Oe.append(Qe);
              }
              return this.container.append(Oe), this.container;
            }
            getElementsToTriggerPopup() {
              return G(this, Ae);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          Ae = new WeakMap(), t.InkAnnotationElement = ue;
          class pe extends v {
            constructor(oe) {
              super(oe, {
                isRenderable: !0,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this.container;
            }
          }
          class J extends v {
            constructor(oe) {
              super(oe, {
                isRenderable: !0,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), this.container;
            }
          }
          class j extends v {
            constructor(oe) {
              super(oe, {
                isRenderable: !0,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), this.container;
            }
          }
          class le extends v {
            constructor(oe) {
              super(oe, {
                isRenderable: !0,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), this.container;
            }
          }
          class Z extends v {
            constructor(oe) {
              super(oe, {
                isRenderable: !0,
                ignoreBorder: !0
              });
            }
            render() {
              return this.container.classList.add("stampAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
          }
          t.StampAnnotationElement = Z;
          class O extends v {
            constructor(ne) {
              var Oe;
              super(ne, {
                isRenderable: !0
              });
              we(this, Ke);
              we(this, ve, null);
              const {
                filename: ge,
                content: xe
              } = this.data.file;
              this.filename = (0, o.getFilenameFromUrl)(ge, !0), this.content = xe, (Oe = this.linkService.eventBus) == null || Oe.dispatch("fileattachmentannotation", {
                source: this,
                filename: ge,
                content: xe
              });
            }
            render() {
              this.container.classList.add("fileAttachmentAnnotation");
              const {
                container: ne,
                data: ge
              } = this;
              let xe;
              ge.hasAppearance || ge.fillAlpha === 0 ? xe = document.createElement("div") : (xe = document.createElement("img"), xe.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(ge.name) ? "paperclip" : "pushpin"}.svg`, ge.fillAlpha && ge.fillAlpha < 1 && (xe.style = `filter: opacity(${Math.round(ge.fillAlpha * 100)}%);`)), xe.addEventListener("dblclick", _e(this, Ke, xn).bind(this)), Ie(this, ve, xe);
              const {
                isMac: Oe
              } = a.FeatureTest.platform;
              return ne.addEventListener("keydown", (Ue) => {
                Ue.key === "Enter" && (Oe ? Ue.metaKey : Ue.ctrlKey) && _e(this, Ke, xn).call(this);
              }), !ge.popupRef && this.hasPopupData ? this._createPopup() : xe.classList.add("popupTriggerArea"), ne.append(xe), ne;
            }
            getElementsToTriggerPopup() {
              return G(this, ve);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          ve = new WeakMap(), Ke = new WeakSet(), xn = function() {
            var ne;
            (ne = this.downloadManager) == null || ne.openOrDownloadData(this.container, this.content, this.filename);
          };
          class z {
            constructor({
              div: oe,
              accessibilityManager: ne,
              annotationCanvasMap: ge,
              l10n: xe,
              page: Oe,
              viewport: Ue
            }) {
              we(this, Ge);
              we(this, pt, null);
              we(this, ce, null);
              we(this, Ne, /* @__PURE__ */ new Map());
              this.div = oe, Ie(this, pt, ne), Ie(this, ce, ge), this.l10n = xe, this.page = Oe, this.viewport = Ue, this.zIndex = 0, this.l10n || (this.l10n = d.NullL10n);
            }
            async render(oe) {
              const {
                annotations: ne
              } = oe, ge = this.div;
              (0, o.setLayerDimensions)(ge, this.viewport);
              const xe = /* @__PURE__ */ new Map(), Oe = {
                data: null,
                layer: ge,
                linkService: oe.linkService,
                downloadManager: oe.downloadManager,
                imageResourcesPath: oe.imageResourcesPath || "",
                renderForms: oe.renderForms !== !1,
                svgFactory: new o.DOMSVGFactory(),
                annotationStorage: oe.annotationStorage || new u.AnnotationStorage(),
                enableScripting: oe.enableScripting === !0,
                hasJSActions: oe.hasJSActions,
                fieldObjects: oe.fieldObjects,
                parent: this,
                elements: null
              };
              for (const Ue of ne) {
                if (Ue.noHTML)
                  continue;
                const qe = Ue.annotationType === a.AnnotationType.POPUP;
                if (qe) {
                  const He = xe.get(Ue.id);
                  if (!He)
                    continue;
                  Oe.elements = He;
                } else {
                  const {
                    width: He,
                    height: st
                  } = A(Ue.rect);
                  if (He <= 0 || st <= 0)
                    continue;
                }
                Oe.data = Ue;
                const Qe = E.create(Oe);
                if (!Qe.isRenderable)
                  continue;
                if (!qe && Ue.popupRef) {
                  const He = xe.get(Ue.popupRef);
                  He ? He.push(Qe) : xe.set(Ue.popupRef, [Qe]);
                }
                Qe.annotationEditorType > 0 && G(this, Ne).set(Qe.data.id, Qe);
                const Je = Qe.render();
                Ue.hidden && (Je.style.visibility = "hidden"), _e(this, Ge, ir).call(this, Je, Ue.id);
              }
              _e(this, Ge, Rn).call(this), await this.l10n.translate(ge);
            }
            update({
              viewport: oe
            }) {
              const ne = this.div;
              this.viewport = oe, (0, o.setLayerDimensions)(ne, {
                rotation: oe.rotation
              }), _e(this, Ge, Rn).call(this), ne.hidden = !1;
            }
            getEditableAnnotations() {
              return Array.from(G(this, Ne).values());
            }
            getEditableAnnotation(oe) {
              return G(this, Ne).get(oe);
            }
          }
          pt = new WeakMap(), ce = new WeakMap(), Ne = new WeakMap(), Ge = new WeakSet(), ir = function(oe, ne) {
            var xe;
            const ge = oe.firstChild || oe;
            ge.id = `${a.AnnotationPrefix}${ne}`, this.div.append(oe), (xe = G(this, pt)) == null || xe.moveElementInDOM(this.div, oe, ge, !1);
          }, Rn = function() {
            if (!G(this, ce))
              return;
            const oe = this.div;
            for (const [ne, ge] of G(this, ce)) {
              const xe = oe.querySelector(`[data-annotation-id="${ne}"]`);
              if (!xe)
                continue;
              const {
                firstChild: Oe
              } = xe;
              Oe ? Oe.nodeName === "CANVAS" ? Oe.replaceWith(ge) : Oe.before(ge) : xe.append(ge);
            }
            G(this, ce).clear();
          }, t.AnnotationLayer = z;
        },
        /* 30 */
        /***/
        (e, t) => {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.ColorConverters = void 0;
          function r(u) {
            return Math.floor(Math.max(0, Math.min(1, u)) * 255).toString(16).padStart(2, "0");
          }
          function a(u) {
            return Math.max(0, Math.min(255, 255 * u));
          }
          class o {
            static CMYK_G([c, d, g, b]) {
              return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * g + 0.11 * d + b)];
            }
            static G_CMYK([c]) {
              return ["CMYK", 0, 0, 0, 1 - c];
            }
            static G_RGB([c]) {
              return ["RGB", c, c, c];
            }
            static G_rgb([c]) {
              return c = a(c), [c, c, c];
            }
            static G_HTML([c]) {
              const d = r(c);
              return `#${d}${d}${d}`;
            }
            static RGB_G([c, d, g]) {
              return ["G", 0.3 * c + 0.59 * d + 0.11 * g];
            }
            static RGB_rgb(c) {
              return c.map(a);
            }
            static RGB_HTML(c) {
              return `#${c.map(r).join("")}`;
            }
            static T_HTML() {
              return "#00000000";
            }
            static T_rgb() {
              return [null];
            }
            static CMYK_RGB([c, d, g, b]) {
              return ["RGB", 1 - Math.min(1, c + b), 1 - Math.min(1, g + b), 1 - Math.min(1, d + b)];
            }
            static CMYK_rgb([c, d, g, b]) {
              return [a(1 - Math.min(1, c + b)), a(1 - Math.min(1, g + b)), a(1 - Math.min(1, d + b))];
            }
            static CMYK_HTML(c) {
              const d = this.CMYK_RGB(c).slice(1);
              return this.RGB_HTML(d);
            }
            static RGB_CMYK([c, d, g]) {
              const b = 1 - c, _ = 1 - d, y = 1 - g, A = Math.min(b, _, y);
              return ["CMYK", b, _, y, A];
            }
          }
          t.ColorConverters = o;
        },
        /* 31 */
        /***/
        (e, t) => {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.NullL10n = void 0, t.getL10nFallback = a;
          const r = {
            of_pages: "of {{pagesCount}}",
            page_of_pages: "({{pageNumber}} of {{pagesCount}})",
            document_properties_kb: "{{size_kb}} KB ({{size_b}} bytes)",
            document_properties_mb: "{{size_mb}} MB ({{size_b}} bytes)",
            document_properties_date_string: "{{date}}, {{time}}",
            document_properties_page_size_unit_inches: "in",
            document_properties_page_size_unit_millimeters: "mm",
            document_properties_page_size_orientation_portrait: "portrait",
            document_properties_page_size_orientation_landscape: "landscape",
            document_properties_page_size_name_a3: "A3",
            document_properties_page_size_name_a4: "A4",
            document_properties_page_size_name_letter: "Letter",
            document_properties_page_size_name_legal: "Legal",
            document_properties_page_size_dimension_string: "{{width}}  {{height}} {{unit}} ({{orientation}})",
            document_properties_page_size_dimension_name_string: "{{width}}  {{height}} {{unit}} ({{name}}, {{orientation}})",
            document_properties_linearized_yes: "Yes",
            document_properties_linearized_no: "No",
            additional_layers: "Additional Layers",
            page_landmark: "Page {{page}}",
            thumb_page_title: "Page {{page}}",
            thumb_page_canvas: "Thumbnail of Page {{page}}",
            find_reached_top: "Reached top of document, continued from bottom",
            find_reached_bottom: "Reached end of document, continued from top",
            "find_match_count[one]": "{{current}} of {{total}} match",
            "find_match_count[other]": "{{current}} of {{total}} matches",
            "find_match_count_limit[one]": "More than {{limit}} match",
            "find_match_count_limit[other]": "More than {{limit}} matches",
            find_not_found: "Phrase not found",
            page_scale_width: "Page Width",
            page_scale_fit: "Page Fit",
            page_scale_auto: "Automatic Zoom",
            page_scale_actual: "Actual Size",
            page_scale_percent: "{{scale}}%",
            loading_error: "An error occurred while loading the PDF.",
            invalid_file_error: "Invalid or corrupted PDF file.",
            missing_file_error: "Missing PDF file.",
            unexpected_response_error: "Unexpected server response.",
            rendering_error: "An error occurred while rendering the page.",
            annotation_date_string: "{{date}}, {{time}}",
            printing_not_supported: "Warning: Printing is not fully supported by this browser.",
            printing_not_ready: "Warning: The PDF is not fully loaded for printing.",
            web_fonts_disabled: "Web fonts are disabled: unable to use embedded PDF fonts.",
            free_text2_default_content: "Start typing",
            editor_free_text2_aria_label: "Text Editor",
            editor_ink2_aria_label: "Draw Editor",
            editor_ink_canvas_aria_label: "User-created image",
            editor_alt_text_button_label: "Alt text",
            editor_alt_text_edit_button_label: "Edit alt text",
            editor_alt_text_decorative_tooltip: "Marked as decorative"
          };
          r.print_progress_percent = "{{progress}}%";
          function a(c, d) {
            switch (c) {
              case "find_match_count":
                c = `find_match_count[${d.total === 1 ? "one" : "other"}]`;
                break;
              case "find_match_count_limit":
                c = `find_match_count_limit[${d.limit === 1 ? "one" : "other"}]`;
                break;
            }
            return r[c] || "";
          }
          function o(c, d) {
            return d ? c.replaceAll(/\{\{\s*(\w+)\s*\}\}/g, (g, b) => b in d ? d[b] : "{{" + b + "}}") : c;
          }
          const u = {
            async getLanguage() {
              return "en-us";
            },
            async getDirection() {
              return "ltr";
            },
            async get(c, d = null, g = a(c, d)) {
              return o(g, d);
            },
            async translate(c) {
            }
          };
          t.NullL10n = u;
        },
        /* 32 */
        /***/
        (e, t, r) => {
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.XfaLayer = void 0;
          var a = r(25);
          class o {
            static setupStorage(c, d, g, b, _) {
              const y = b.getValue(d, {
                value: null
              });
              switch (g.name) {
                case "textarea":
                  if (y.value !== null && (c.textContent = y.value), _ === "print")
                    break;
                  c.addEventListener("input", (A) => {
                    b.setValue(d, {
                      value: A.target.value
                    });
                  });
                  break;
                case "input":
                  if (g.attributes.type === "radio" || g.attributes.type === "checkbox") {
                    if (y.value === g.attributes.xfaOn ? c.setAttribute("checked", !0) : y.value === g.attributes.xfaOff && c.removeAttribute("checked"), _ === "print")
                      break;
                    c.addEventListener("change", (A) => {
                      b.setValue(d, {
                        value: A.target.checked ? A.target.getAttribute("xfaOn") : A.target.getAttribute("xfaOff")
                      });
                    });
                  } else {
                    if (y.value !== null && c.setAttribute("value", y.value), _ === "print")
                      break;
                    c.addEventListener("input", (A) => {
                      b.setValue(d, {
                        value: A.target.value
                      });
                    });
                  }
                  break;
                case "select":
                  if (y.value !== null) {
                    c.setAttribute("value", y.value);
                    for (const A of g.children)
                      A.attributes.value === y.value ? A.attributes.selected = !0 : A.attributes.hasOwnProperty("selected") && delete A.attributes.selected;
                  }
                  c.addEventListener("input", (A) => {
                    const E = A.target.options, v = E.selectedIndex === -1 ? "" : E[E.selectedIndex].value;
                    b.setValue(d, {
                      value: v
                    });
                  });
                  break;
              }
            }
            static setAttributes({
              html: c,
              element: d,
              storage: g = null,
              intent: b,
              linkService: _
            }) {
              const {
                attributes: y
              } = d, A = c instanceof HTMLAnchorElement;
              y.type === "radio" && (y.name = `${y.name}-${b}`);
              for (const [E, v] of Object.entries(y))
                if (v != null)
                  switch (E) {
                    case "class":
                      v.length && c.setAttribute(E, v.join(" "));
                      break;
                    case "dataId":
                      break;
                    case "id":
                      c.setAttribute("data-element-id", v);
                      break;
                    case "style":
                      Object.assign(c.style, v);
                      break;
                    case "textContent":
                      c.textContent = v;
                      break;
                    default:
                      (!A || E !== "href" && E !== "newWindow") && c.setAttribute(E, v);
                  }
              A && _.addLinkAttributes(c, y.href, y.newWindow), g && y.dataId && this.setupStorage(c, y.dataId, d, g);
            }
            static render(c) {
              var C;
              const d = c.annotationStorage, g = c.linkService, b = c.xfaHtml, _ = c.intent || "display", y = document.createElement(b.name);
              b.attributes && this.setAttributes({
                html: y,
                element: b,
                intent: _,
                linkService: g
              });
              const A = [[b, -1, y]], E = c.div;
              if (E.append(y), c.viewport) {
                const R = `matrix(${c.viewport.transform.join(",")})`;
                E.style.transform = R;
              }
              _ !== "richText" && E.setAttribute("class", "xfaLayer xfaFont");
              const v = [];
              for (; A.length > 0; ) {
                const [R, I, w] = A.at(-1);
                if (I + 1 === R.children.length) {
                  A.pop();
                  continue;
                }
                const N = R.children[++A.at(-1)[1]];
                if (N === null)
                  continue;
                const {
                  name: F
                } = N;
                if (F === "#text") {
                  const x = document.createTextNode(N.value);
                  v.push(x), w.append(x);
                  continue;
                }
                const M = (C = N == null ? void 0 : N.attributes) != null && C.xmlns ? document.createElementNS(N.attributes.xmlns, F) : document.createElement(F);
                if (w.append(M), N.attributes && this.setAttributes({
                  html: M,
                  element: N,
                  storage: d,
                  intent: _,
                  linkService: g
                }), N.children && N.children.length > 0)
                  A.push([N, -1, M]);
                else if (N.value) {
                  const x = document.createTextNode(N.value);
                  a.XfaText.shouldBuildText(F) && v.push(x), M.append(x);
                }
              }
              for (const R of E.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
                R.setAttribute("readOnly", !0);
              return {
                textDivs: v
              };
            }
            static update(c) {
              const d = `matrix(${c.viewport.transform.join(",")})`;
              c.div.style.transform = d, c.div.hidden = !1;
            }
          }
          t.XfaLayer = o;
        },
        /* 33 */
        /***/
        (e, t, r) => {
          var b, _, y, A, E, v, C, R, I, w, N, F, M, x, P, or, sr, lr, ur, Dn, cr, Nn, dr, hr, pr, mr, fr, wt, On, Zt, Qt, Nt, Ln, Jt, ae, gr, Mn, _r, yr, $n, en, Ot;
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.InkEditor = void 0;
          var a = r(1), o = r(4), u = r(29), c = r(6), d = r(5);
          const Le = class Le extends o.AnnotationEditor {
            constructor(Q) {
              super({
                ...Q,
                name: "inkEditor"
              });
              we(this, P);
              we(this, b, 0);
              we(this, _, 0);
              we(this, y, this.canvasPointermove.bind(this));
              we(this, A, this.canvasPointerleave.bind(this));
              we(this, E, this.canvasPointerup.bind(this));
              we(this, v, this.canvasPointerdown.bind(this));
              we(this, C, new Path2D());
              we(this, R, !1);
              we(this, I, !1);
              we(this, w, !1);
              we(this, N, null);
              we(this, F, 0);
              we(this, M, 0);
              we(this, x, null);
              this.color = Q.color || null, this.thickness = Q.thickness || null, this.opacity = Q.opacity || null, this.paths = [], this.bezierPath2D = [], this.allRawPaths = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0, this._willKeepAspectRatio = !0;
            }
            static initialize(Q) {
              o.AnnotationEditor.initialize(Q, {
                strings: ["editor_ink_canvas_aria_label", "editor_ink2_aria_label"]
              });
            }
            static updateDefaultParams(Q, K) {
              switch (Q) {
                case a.AnnotationEditorParamsType.INK_THICKNESS:
                  Le._defaultThickness = K;
                  break;
                case a.AnnotationEditorParamsType.INK_COLOR:
                  Le._defaultColor = K;
                  break;
                case a.AnnotationEditorParamsType.INK_OPACITY:
                  Le._defaultOpacity = K / 100;
                  break;
              }
            }
            updateParams(Q, K) {
              switch (Q) {
                case a.AnnotationEditorParamsType.INK_THICKNESS:
                  _e(this, P, or).call(this, K);
                  break;
                case a.AnnotationEditorParamsType.INK_COLOR:
                  _e(this, P, sr).call(this, K);
                  break;
                case a.AnnotationEditorParamsType.INK_OPACITY:
                  _e(this, P, lr).call(this, K);
                  break;
              }
            }
            static get defaultPropertiesToUpdate() {
              return [[a.AnnotationEditorParamsType.INK_THICKNESS, Le._defaultThickness], [a.AnnotationEditorParamsType.INK_COLOR, Le._defaultColor || o.AnnotationEditor._defaultLineColor], [a.AnnotationEditorParamsType.INK_OPACITY, Math.round(Le._defaultOpacity * 100)]];
            }
            get propertiesToUpdate() {
              return [[a.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || Le._defaultThickness], [a.AnnotationEditorParamsType.INK_COLOR, this.color || Le._defaultColor || o.AnnotationEditor._defaultLineColor], [a.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? Le._defaultOpacity))]];
            }
            rebuild() {
              this.parent && (super.rebuild(), this.div !== null && (this.canvas || (_e(this, P, Zt).call(this), _e(this, P, Qt).call(this)), this.isAttachedToDOM || (this.parent.add(this), _e(this, P, Nt).call(this)), _e(this, P, Ot).call(this)));
            }
            remove() {
              this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, G(this, N).disconnect(), Ie(this, N, null), super.remove());
            }
            setParent(Q) {
              !this.parent && Q ? this._uiManager.removeShouldRescale(this) : this.parent && Q === null && this._uiManager.addShouldRescale(this), super.setParent(Q);
            }
            onScaleChanging() {
              const [Q, K] = this.parentDimensions, fe = this.width * Q, be = this.height * K;
              this.setDimensions(fe, be);
            }
            enableEditMode() {
              G(this, R) || this.canvas === null || (super.enableEditMode(), this._isDraggable = !1, this.canvas.addEventListener("pointerdown", G(this, v)));
            }
            disableEditMode() {
              !this.isInEditMode() || this.canvas === null || (super.disableEditMode(), this._isDraggable = !this.isEmpty(), this.div.classList.remove("editing"), this.canvas.removeEventListener("pointerdown", G(this, v)));
            }
            onceAdded() {
              this._isDraggable = !this.isEmpty();
            }
            isEmpty() {
              return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
            }
            commit() {
              G(this, R) || (super.commit(), this.isEditing = !1, this.disableEditMode(), this.setInForeground(), Ie(this, R, !0), this.div.classList.add("disabled"), _e(this, P, Ot).call(this, !0), this.makeResizable(), this.parent.addInkEditorIfNeeded(!0), this.moveInDOM(), this.div.focus({
                preventScroll: !0
              }));
            }
            focusin(Q) {
              this._focusEventsAllowed && (super.focusin(Q), this.enableEditMode());
            }
            canvasPointerdown(Q) {
              Q.button !== 0 || !this.isInEditMode() || G(this, R) || (this.setInForeground(), Q.preventDefault(), Q.type !== "mouse" && this.div.focus(), _e(this, P, cr).call(this, Q.offsetX, Q.offsetY));
            }
            canvasPointermove(Q) {
              Q.preventDefault(), _e(this, P, Nn).call(this, Q.offsetX, Q.offsetY);
            }
            canvasPointerup(Q) {
              Q.preventDefault(), _e(this, P, On).call(this, Q);
            }
            canvasPointerleave(Q) {
              _e(this, P, On).call(this, Q);
            }
            get isResizable() {
              return !this.isEmpty() && G(this, R);
            }
            render() {
              if (this.div)
                return this.div;
              let Q, K;
              this.width && (Q = this.x, K = this.y), super.render(), o.AnnotationEditor._l10nPromise.get("editor_ink2_aria_label").then((Be) => {
                var te;
                return (te = this.div) == null ? void 0 : te.setAttribute("aria-label", Be);
              });
              const [fe, be, ke, Fe] = _e(this, P, ur).call(this);
              if (this.setAt(fe, be, 0, 0), this.setDims(ke, Fe), _e(this, P, Zt).call(this), this.width) {
                const [Be, te] = this.parentDimensions;
                this.setAspectRatio(this.width * Be, this.height * te), this.setAt(Q * Be, K * te, this.width * Be, this.height * te), Ie(this, w, !0), _e(this, P, Nt).call(this), this.setDims(this.width * Be, this.height * te), _e(this, P, wt).call(this), this.div.classList.add("disabled");
              } else
                this.div.classList.add("editing"), this.enableEditMode();
              return _e(this, P, Qt).call(this), this.div;
            }
            setDimensions(Q, K) {
              const fe = Math.round(Q), be = Math.round(K);
              if (G(this, F) === fe && G(this, M) === be)
                return;
              Ie(this, F, fe), Ie(this, M, be), this.canvas.style.visibility = "hidden";
              const [ke, Fe] = this.parentDimensions;
              this.width = Q / ke, this.height = K / Fe, this.fixAndSetPosition(), G(this, R) && _e(this, P, Ln).call(this, Q, K), _e(this, P, Nt).call(this), _e(this, P, wt).call(this), this.canvas.style.visibility = "visible", this.fixDims();
            }
            static deserialize(Q, K, fe) {
              var Xe, ut, ct;
              if (Q instanceof u.InkAnnotationElement)
                return null;
              const be = super.deserialize(Q, K, fe);
              be.thickness = Q.thickness, be.color = a.Util.makeHexColor(...Q.color), be.opacity = Q.opacity;
              const [ke, Fe] = be.pageDimensions, Be = be.width * ke, te = be.height * Fe, Ce = be.parentScale, Me = Q.thickness / 2;
              Ie(be, R, !0), Ie(be, F, Math.round(Be)), Ie(be, M, Math.round(te));
              const {
                paths: Ve,
                rect: je,
                rotation: ot
              } = Q;
              for (let {
                bezier: $e
              } of Ve) {
                $e = _e(Xe = Le, ae, _r).call(Xe, $e, je, ot);
                const Ae = [];
                be.paths.push(Ae);
                let ve = Ce * ($e[0] - Me), Ke = Ce * ($e[1] - Me);
                for (let pt = 2, ce = $e.length; pt < ce; pt += 6) {
                  const Ne = Ce * ($e[pt] - Me), Ge = Ce * ($e[pt + 1] - Me), nt = Ce * ($e[pt + 2] - Me), rt = Ce * ($e[pt + 3] - Me), Ye = Ce * ($e[pt + 4] - Me), oe = Ce * ($e[pt + 5] - Me);
                  Ae.push([[ve, Ke], [Ne, Ge], [nt, rt], [Ye, oe]]), ve = Ye, Ke = oe;
                }
                const dt = _e(this, ae, gr).call(this, Ae);
                be.bezierPath2D.push(dt);
              }
              const We = _e(ut = be, P, $n).call(ut);
              return Ie(be, _, Math.max(o.AnnotationEditor.MIN_SIZE, We[2] - We[0])), Ie(be, b, Math.max(o.AnnotationEditor.MIN_SIZE, We[3] - We[1])), _e(ct = be, P, Ln).call(ct, Be, te), be;
            }
            serialize() {
              if (this.isEmpty())
                return null;
              const Q = this.getRect(0, 0), K = o.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
              return {
                annotationType: a.AnnotationEditorType.INK,
                color: K,
                thickness: this.thickness,
                opacity: this.opacity,
                paths: _e(this, P, yr).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, Q),
                pageIndex: this.pageIndex,
                rect: Q,
                rotation: this.rotation,
                structTreeParentId: this._structTreeParentId
              };
            }
          };
          b = new WeakMap(), _ = new WeakMap(), y = new WeakMap(), A = new WeakMap(), E = new WeakMap(), v = new WeakMap(), C = new WeakMap(), R = new WeakMap(), I = new WeakMap(), w = new WeakMap(), N = new WeakMap(), F = new WeakMap(), M = new WeakMap(), x = new WeakMap(), P = new WeakSet(), or = function(Q) {
            const K = this.thickness;
            this.addCommands({
              cmd: () => {
                this.thickness = Q, _e(this, P, Ot).call(this);
              },
              undo: () => {
                this.thickness = K, _e(this, P, Ot).call(this);
              },
              mustExec: !0,
              type: a.AnnotationEditorParamsType.INK_THICKNESS,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, sr = function(Q) {
            const K = this.color;
            this.addCommands({
              cmd: () => {
                this.color = Q, _e(this, P, wt).call(this);
              },
              undo: () => {
                this.color = K, _e(this, P, wt).call(this);
              },
              mustExec: !0,
              type: a.AnnotationEditorParamsType.INK_COLOR,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, lr = function(Q) {
            Q /= 100;
            const K = this.opacity;
            this.addCommands({
              cmd: () => {
                this.opacity = Q, _e(this, P, wt).call(this);
              },
              undo: () => {
                this.opacity = K, _e(this, P, wt).call(this);
              },
              mustExec: !0,
              type: a.AnnotationEditorParamsType.INK_OPACITY,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, ur = function() {
            const {
              parentRotation: Q,
              parentDimensions: [K, fe]
            } = this;
            switch (Q) {
              case 90:
                return [0, fe, fe, K];
              case 180:
                return [K, fe, K, fe];
              case 270:
                return [K, 0, fe, K];
              default:
                return [0, 0, K, fe];
            }
          }, Dn = function() {
            const {
              ctx: Q,
              color: K,
              opacity: fe,
              thickness: be,
              parentScale: ke,
              scaleFactor: Fe
            } = this;
            Q.lineWidth = be * ke / Fe, Q.lineCap = "round", Q.lineJoin = "round", Q.miterLimit = 10, Q.strokeStyle = `${K}${(0, d.opacityToHex)(fe)}`;
          }, cr = function(Q, K) {
            this.canvas.addEventListener("contextmenu", c.noContextMenu), this.canvas.addEventListener("pointerleave", G(this, A)), this.canvas.addEventListener("pointermove", G(this, y)), this.canvas.addEventListener("pointerup", G(this, E)), this.canvas.removeEventListener("pointerdown", G(this, v)), this.isEditing = !0, G(this, w) || (Ie(this, w, !0), _e(this, P, Nt).call(this), this.thickness || (this.thickness = Le._defaultThickness), this.color || (this.color = Le._defaultColor || o.AnnotationEditor._defaultLineColor), this.opacity ?? (this.opacity = Le._defaultOpacity)), this.currentPath.push([Q, K]), Ie(this, I, !1), _e(this, P, Dn).call(this), Ie(this, x, () => {
              _e(this, P, pr).call(this), G(this, x) && window.requestAnimationFrame(G(this, x));
            }), window.requestAnimationFrame(G(this, x));
          }, Nn = function(Q, K) {
            const [fe, be] = this.currentPath.at(-1);
            if (this.currentPath.length > 1 && Q === fe && K === be)
              return;
            const ke = this.currentPath;
            let Fe = G(this, C);
            if (ke.push([Q, K]), Ie(this, I, !0), ke.length <= 2) {
              Fe.moveTo(...ke[0]), Fe.lineTo(Q, K);
              return;
            }
            ke.length === 3 && (Ie(this, C, Fe = new Path2D()), Fe.moveTo(...ke[0])), _e(this, P, mr).call(this, Fe, ...ke.at(-3), ...ke.at(-2), Q, K);
          }, dr = function() {
            if (this.currentPath.length === 0)
              return;
            const Q = this.currentPath.at(-1);
            G(this, C).lineTo(...Q);
          }, hr = function(Q, K) {
            Ie(this, x, null), Q = Math.min(Math.max(Q, 0), this.canvas.width), K = Math.min(Math.max(K, 0), this.canvas.height), _e(this, P, Nn).call(this, Q, K), _e(this, P, dr).call(this);
            let fe;
            if (this.currentPath.length !== 1)
              fe = _e(this, P, fr).call(this);
            else {
              const te = [Q, K];
              fe = [[te, te.slice(), te.slice(), te]];
            }
            const be = G(this, C), ke = this.currentPath;
            this.currentPath = [], Ie(this, C, new Path2D());
            const Fe = () => {
              this.allRawPaths.push(ke), this.paths.push(fe), this.bezierPath2D.push(be), this.rebuild();
            }, Be = () => {
              this.allRawPaths.pop(), this.paths.pop(), this.bezierPath2D.pop(), this.paths.length === 0 ? this.remove() : (this.canvas || (_e(this, P, Zt).call(this), _e(this, P, Qt).call(this)), _e(this, P, Ot).call(this));
            };
            this.addCommands({
              cmd: Fe,
              undo: Be,
              mustExec: !0
            });
          }, pr = function() {
            if (!G(this, I))
              return;
            Ie(this, I, !1);
            const Q = Math.ceil(this.thickness * this.parentScale), K = this.currentPath.slice(-3), fe = K.map((Fe) => Fe[0]), be = K.map((Fe) => Fe[1]);
            Math.min(...fe) - Q, Math.max(...fe) + Q, Math.min(...be) - Q, Math.max(...be) + Q;
            const {
              ctx: ke
            } = this;
            ke.save(), ke.clearRect(0, 0, this.canvas.width, this.canvas.height);
            for (const Fe of this.bezierPath2D)
              ke.stroke(Fe);
            ke.stroke(G(this, C)), ke.restore();
          }, mr = function(Q, K, fe, be, ke, Fe, Be) {
            const te = (K + be) / 2, Ce = (fe + ke) / 2, Me = (be + Fe) / 2, Ve = (ke + Be) / 2;
            Q.bezierCurveTo(te + 2 * (be - te) / 3, Ce + 2 * (ke - Ce) / 3, Me + 2 * (be - Me) / 3, Ve + 2 * (ke - Ve) / 3, Me, Ve);
          }, fr = function() {
            const Q = this.currentPath;
            if (Q.length <= 2)
              return [[Q[0], Q[0], Q.at(-1), Q.at(-1)]];
            const K = [];
            let fe, [be, ke] = Q[0];
            for (fe = 1; fe < Q.length - 2; fe++) {
              const [je, ot] = Q[fe], [We, Xe] = Q[fe + 1], ut = (je + We) / 2, ct = (ot + Xe) / 2, $e = [be + 2 * (je - be) / 3, ke + 2 * (ot - ke) / 3], Ae = [ut + 2 * (je - ut) / 3, ct + 2 * (ot - ct) / 3];
              K.push([[be, ke], $e, Ae, [ut, ct]]), [be, ke] = [ut, ct];
            }
            const [Fe, Be] = Q[fe], [te, Ce] = Q[fe + 1], Me = [be + 2 * (Fe - be) / 3, ke + 2 * (Be - ke) / 3], Ve = [te + 2 * (Fe - te) / 3, Ce + 2 * (Be - Ce) / 3];
            return K.push([[be, ke], Me, Ve, [te, Ce]]), K;
          }, wt = function() {
            if (this.isEmpty()) {
              _e(this, P, Jt).call(this);
              return;
            }
            _e(this, P, Dn).call(this);
            const {
              canvas: Q,
              ctx: K
            } = this;
            K.setTransform(1, 0, 0, 1, 0, 0), K.clearRect(0, 0, Q.width, Q.height), _e(this, P, Jt).call(this);
            for (const fe of this.bezierPath2D)
              K.stroke(fe);
          }, On = function(Q) {
            this.canvas.removeEventListener("pointerleave", G(this, A)), this.canvas.removeEventListener("pointermove", G(this, y)), this.canvas.removeEventListener("pointerup", G(this, E)), this.canvas.addEventListener("pointerdown", G(this, v)), setTimeout(() => {
              this.canvas.removeEventListener("contextmenu", c.noContextMenu);
            }, 10), _e(this, P, hr).call(this, Q.offsetX, Q.offsetY), this.addToAnnotationStorage(), this.setInBackground();
          }, Zt = function() {
            this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", o.AnnotationEditor._l10nPromise.get("editor_ink_canvas_aria_label").then((Q) => {
              var K;
              return (K = this.canvas) == null ? void 0 : K.setAttribute("aria-label", Q);
            }), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d");
          }, Qt = function() {
            Ie(this, N, new ResizeObserver((Q) => {
              const K = Q[0].contentRect;
              K.width && K.height && this.setDimensions(K.width, K.height);
            })), G(this, N).observe(this.div);
          }, Nt = function() {
            if (!G(this, w))
              return;
            const [Q, K] = this.parentDimensions;
            this.canvas.width = Math.ceil(this.width * Q), this.canvas.height = Math.ceil(this.height * K), _e(this, P, Jt).call(this);
          }, Ln = function(Q, K) {
            const fe = _e(this, P, en).call(this), be = (Q - fe) / G(this, _), ke = (K - fe) / G(this, b);
            this.scaleFactor = Math.min(be, ke);
          }, Jt = function() {
            const Q = _e(this, P, en).call(this) / 2;
            this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + Q, this.translationY * this.scaleFactor + Q);
          }, ae = new WeakSet(), gr = function(Q) {
            const K = new Path2D();
            for (let fe = 0, be = Q.length; fe < be; fe++) {
              const [ke, Fe, Be, te] = Q[fe];
              fe === 0 && K.moveTo(...ke), K.bezierCurveTo(Fe[0], Fe[1], Be[0], Be[1], te[0], te[1]);
            }
            return K;
          }, Mn = function(Q, K, fe) {
            const [be, ke, Fe, Be] = K;
            switch (fe) {
              case 0:
                for (let te = 0, Ce = Q.length; te < Ce; te += 2)
                  Q[te] += be, Q[te + 1] = Be - Q[te + 1];
                break;
              case 90:
                for (let te = 0, Ce = Q.length; te < Ce; te += 2) {
                  const Me = Q[te];
                  Q[te] = Q[te + 1] + be, Q[te + 1] = Me + ke;
                }
                break;
              case 180:
                for (let te = 0, Ce = Q.length; te < Ce; te += 2)
                  Q[te] = Fe - Q[te], Q[te + 1] += ke;
                break;
              case 270:
                for (let te = 0, Ce = Q.length; te < Ce; te += 2) {
                  const Me = Q[te];
                  Q[te] = Fe - Q[te + 1], Q[te + 1] = Be - Me;
                }
                break;
              default:
                throw new Error("Invalid rotation");
            }
            return Q;
          }, _r = function(Q, K, fe) {
            const [be, ke, Fe, Be] = K;
            switch (fe) {
              case 0:
                for (let te = 0, Ce = Q.length; te < Ce; te += 2)
                  Q[te] -= be, Q[te + 1] = Be - Q[te + 1];
                break;
              case 90:
                for (let te = 0, Ce = Q.length; te < Ce; te += 2) {
                  const Me = Q[te];
                  Q[te] = Q[te + 1] - ke, Q[te + 1] = Me - be;
                }
                break;
              case 180:
                for (let te = 0, Ce = Q.length; te < Ce; te += 2)
                  Q[te] = Fe - Q[te], Q[te + 1] -= ke;
                break;
              case 270:
                for (let te = 0, Ce = Q.length; te < Ce; te += 2) {
                  const Me = Q[te];
                  Q[te] = Be - Q[te + 1], Q[te + 1] = Fe - Me;
                }
                break;
              default:
                throw new Error("Invalid rotation");
            }
            return Q;
          }, yr = function(Q, K, fe, be) {
            var Ce, Me;
            const ke = [], Fe = this.thickness / 2, Be = Q * K + Fe, te = Q * fe + Fe;
            for (const Ve of this.paths) {
              const je = [], ot = [];
              for (let We = 0, Xe = Ve.length; We < Xe; We++) {
                const [ut, ct, $e, Ae] = Ve[We], ve = Q * ut[0] + Be, Ke = Q * ut[1] + te, dt = Q * ct[0] + Be, pt = Q * ct[1] + te, ce = Q * $e[0] + Be, Ne = Q * $e[1] + te, Ge = Q * Ae[0] + Be, nt = Q * Ae[1] + te;
                We === 0 && (je.push(ve, Ke), ot.push(ve, Ke)), je.push(dt, pt, ce, Ne, Ge, nt), ot.push(dt, pt), We === Xe - 1 && ot.push(Ge, nt);
              }
              ke.push({
                bezier: _e(Ce = Le, ae, Mn).call(Ce, je, be, this.rotation),
                points: _e(Me = Le, ae, Mn).call(Me, ot, be, this.rotation)
              });
            }
            return ke;
          }, $n = function() {
            let Q = 1 / 0, K = -1 / 0, fe = 1 / 0, be = -1 / 0;
            for (const ke of this.paths)
              for (const [Fe, Be, te, Ce] of ke) {
                const Me = a.Util.bezierBoundingBox(...Fe, ...Be, ...te, ...Ce);
                Q = Math.min(Q, Me[0]), fe = Math.min(fe, Me[1]), K = Math.max(K, Me[2]), be = Math.max(be, Me[3]);
              }
            return [Q, fe, K, be];
          }, en = function() {
            return G(this, R) ? Math.ceil(this.thickness * this.parentScale) : 0;
          }, Ot = function(Q = !1) {
            if (this.isEmpty())
              return;
            if (!G(this, R)) {
              _e(this, P, wt).call(this);
              return;
            }
            const K = _e(this, P, $n).call(this), fe = _e(this, P, en).call(this);
            Ie(this, _, Math.max(o.AnnotationEditor.MIN_SIZE, K[2] - K[0])), Ie(this, b, Math.max(o.AnnotationEditor.MIN_SIZE, K[3] - K[1]));
            const be = Math.ceil(fe + G(this, _) * this.scaleFactor), ke = Math.ceil(fe + G(this, b) * this.scaleFactor), [Fe, Be] = this.parentDimensions;
            this.width = be / Fe, this.height = ke / Be, this.setAspectRatio(be, ke);
            const te = this.translationX, Ce = this.translationY;
            this.translationX = -K[0], this.translationY = -K[1], _e(this, P, Nt).call(this), _e(this, P, wt).call(this), Ie(this, F, be), Ie(this, M, ke), this.setDims(be, ke);
            const Me = Q ? fe / this.scaleFactor / 2 : 0;
            this.translate(te - this.translationX - Me, Ce - this.translationY - Me);
          }, we(Le, ae), ft(Le, "_defaultColor", null), ft(Le, "_defaultOpacity", 1), ft(Le, "_defaultThickness", 1), ft(Le, "_type", "ink");
          let g = Le;
          t.InkEditor = g;
        },
        /* 34 */
        /***/
        (e, t, r) => {
          var g, b, _, y, A, E, v, C, R, I, w, qt, Gt, tn, Pn, Er, Sr, Fn, nn, Tr;
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.StampEditor = void 0;
          var a = r(1), o = r(4), u = r(6), c = r(29);
          const V = class V extends o.AnnotationEditor {
            constructor(Y) {
              super({
                ...Y,
                name: "stampEditor"
              });
              we(this, w);
              we(this, g, null);
              we(this, b, null);
              we(this, _, null);
              we(this, y, null);
              we(this, A, null);
              we(this, E, null);
              we(this, v, null);
              we(this, C, null);
              we(this, R, !1);
              we(this, I, !1);
              Ie(this, y, Y.bitmapUrl), Ie(this, A, Y.bitmapFile);
            }
            static initialize(Y) {
              o.AnnotationEditor.initialize(Y);
            }
            static get supportedTypes() {
              const Y = ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"];
              return (0, a.shadow)(this, "supportedTypes", Y.map((se) => `image/${se}`));
            }
            static get supportedTypesStr() {
              return (0, a.shadow)(this, "supportedTypesStr", this.supportedTypes.join(","));
            }
            static isHandlingMimeForPasting(Y) {
              return this.supportedTypes.includes(Y);
            }
            static paste(Y, se) {
              se.pasteEditor(a.AnnotationEditorType.STAMP, {
                bitmapFile: Y.getAsFile()
              });
            }
            remove() {
              var Y, se;
              G(this, b) && (Ie(this, g, null), this._uiManager.imageManager.deleteId(G(this, b)), (Y = G(this, E)) == null || Y.remove(), Ie(this, E, null), (se = G(this, v)) == null || se.disconnect(), Ie(this, v, null)), super.remove();
            }
            rebuild() {
              if (!this.parent) {
                G(this, b) && _e(this, w, tn).call(this);
                return;
              }
              super.rebuild(), this.div !== null && (G(this, b) && _e(this, w, tn).call(this), this.isAttachedToDOM || this.parent.add(this));
            }
            onceAdded() {
              this._isDraggable = !0, this.div.focus();
            }
            isEmpty() {
              return !(G(this, _) || G(this, g) || G(this, y) || G(this, A));
            }
            get isResizable() {
              return !0;
            }
            render() {
              if (this.div)
                return this.div;
              let Y, se;
              if (this.width && (Y = this.x, se = this.y), super.render(), this.div.hidden = !0, G(this, g) ? _e(this, w, Pn).call(this) : _e(this, w, tn).call(this), this.width) {
                const [ue, pe] = this.parentDimensions;
                this.setAt(Y * ue, se * pe, this.width * ue, this.height * pe);
              }
              return this.div;
            }
            static deserialize(Y, se, ue) {
              if (Y instanceof c.StampAnnotationElement)
                return null;
              const pe = super.deserialize(Y, se, ue), {
                rect: J,
                bitmapUrl: j,
                bitmapId: le,
                isSvg: Z,
                accessibilityData: O
              } = Y;
              le && ue.imageManager.isValidId(le) ? Ie(pe, b, le) : Ie(pe, y, j), Ie(pe, R, Z);
              const [z, W] = pe.pageDimensions;
              return pe.width = (J[2] - J[0]) / z, pe.height = (J[3] - J[1]) / W, O && (pe.altTextData = O), pe;
            }
            serialize(Y = !1, se = null) {
              if (this.isEmpty())
                return null;
              const ue = {
                annotationType: a.AnnotationEditorType.STAMP,
                bitmapId: G(this, b),
                pageIndex: this.pageIndex,
                rect: this.getRect(0, 0),
                rotation: this.rotation,
                isSvg: G(this, R),
                structTreeParentId: this._structTreeParentId
              };
              if (Y)
                return ue.bitmapUrl = _e(this, w, nn).call(this, !0), ue.accessibilityData = this.altTextData, ue;
              const {
                decorative: pe,
                altText: J
              } = this.altTextData;
              if (!pe && J && (ue.accessibilityData = {
                type: "Figure",
                alt: J
              }), se === null)
                return ue;
              se.stamps || (se.stamps = /* @__PURE__ */ new Map());
              const j = G(this, R) ? (ue.rect[2] - ue.rect[0]) * (ue.rect[3] - ue.rect[1]) : null;
              if (!se.stamps.has(G(this, b)))
                se.stamps.set(G(this, b), {
                  area: j,
                  serialized: ue
                }), ue.bitmap = _e(this, w, nn).call(this, !1);
              else if (G(this, R)) {
                const le = se.stamps.get(G(this, b));
                j > le.area && (le.area = j, le.serialized.bitmap.close(), le.serialized.bitmap = _e(this, w, nn).call(this, !1));
              }
              return ue;
            }
          };
          g = new WeakMap(), b = new WeakMap(), _ = new WeakMap(), y = new WeakMap(), A = new WeakMap(), E = new WeakMap(), v = new WeakMap(), C = new WeakMap(), R = new WeakMap(), I = new WeakMap(), w = new WeakSet(), qt = function(Y, se = !1) {
            if (!Y) {
              this.remove();
              return;
            }
            Ie(this, g, Y.bitmap), se || (Ie(this, b, Y.id), Ie(this, R, Y.isSvg)), _e(this, w, Pn).call(this);
          }, Gt = function() {
            Ie(this, _, null), this._uiManager.enableWaiting(!1), G(this, E) && this.div.focus();
          }, tn = function() {
            if (G(this, b)) {
              this._uiManager.enableWaiting(!0), this._uiManager.imageManager.getFromId(G(this, b)).then((se) => _e(this, w, qt).call(this, se, !0)).finally(() => _e(this, w, Gt).call(this));
              return;
            }
            if (G(this, y)) {
              const se = G(this, y);
              Ie(this, y, null), this._uiManager.enableWaiting(!0), Ie(this, _, this._uiManager.imageManager.getFromUrl(se).then((ue) => _e(this, w, qt).call(this, ue)).finally(() => _e(this, w, Gt).call(this)));
              return;
            }
            if (G(this, A)) {
              const se = G(this, A);
              Ie(this, A, null), this._uiManager.enableWaiting(!0), Ie(this, _, this._uiManager.imageManager.getFromFile(se).then((ue) => _e(this, w, qt).call(this, ue)).finally(() => _e(this, w, Gt).call(this)));
              return;
            }
            const Y = document.createElement("input");
            Y.type = "file", Y.accept = V.supportedTypesStr, Ie(this, _, new Promise((se) => {
              Y.addEventListener("change", async () => {
                if (!Y.files || Y.files.length === 0)
                  this.remove();
                else {
                  this._uiManager.enableWaiting(!0);
                  const ue = await this._uiManager.imageManager.getFromFile(Y.files[0]);
                  _e(this, w, qt).call(this, ue);
                }
                se();
              }), Y.addEventListener("cancel", () => {
                this.remove(), se();
              });
            }).finally(() => _e(this, w, Gt).call(this))), Y.click();
          }, Pn = function() {
            const {
              div: Y
            } = this;
            let {
              width: se,
              height: ue
            } = G(this, g);
            const [pe, J] = this.pageDimensions, j = 0.75;
            if (this.width)
              se = this.width * pe, ue = this.height * J;
            else if (se > j * pe || ue > j * J) {
              const z = Math.min(j * pe / se, j * J / ue);
              se *= z, ue *= z;
            }
            const [le, Z] = this.parentDimensions;
            this.setDims(se * le / pe, ue * Z / J), this._uiManager.enableWaiting(!1);
            const O = Ie(this, E, document.createElement("canvas"));
            Y.append(O), Y.hidden = !1, _e(this, w, Fn).call(this, se, ue), _e(this, w, Tr).call(this), G(this, I) || (this.parent.addUndoableEditor(this), Ie(this, I, !0)), this._uiManager._eventBus.dispatch("reporttelemetry", {
              source: this,
              details: {
                type: "editing",
                subtype: this.editorType,
                data: {
                  action: "inserted_image"
                }
              }
            }), this.addAltTextButton();
          }, Er = function(Y, se) {
            var j;
            const [ue, pe] = this.parentDimensions;
            this.width = Y / ue, this.height = se / pe, this.setDims(Y, se), (j = this._initialOptions) != null && j.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, G(this, C) !== null && clearTimeout(G(this, C)), Ie(this, C, setTimeout(() => {
              Ie(this, C, null), _e(this, w, Fn).call(this, Y, se);
            }, 200));
          }, Sr = function(Y, se) {
            const {
              width: ue,
              height: pe
            } = G(this, g);
            let J = ue, j = pe, le = G(this, g);
            for (; J > 2 * Y || j > 2 * se; ) {
              const Z = J, O = j;
              J > 2 * Y && (J = J >= 16384 ? Math.floor(J / 2) - 1 : Math.ceil(J / 2)), j > 2 * se && (j = j >= 16384 ? Math.floor(j / 2) - 1 : Math.ceil(j / 2));
              const z = new OffscreenCanvas(J, j);
              z.getContext("2d").drawImage(le, 0, 0, Z, O, 0, 0, J, j), le = z.transferToImageBitmap();
            }
            return le;
          }, Fn = function(Y, se) {
            Y = Math.ceil(Y), se = Math.ceil(se);
            const ue = G(this, E);
            if (!ue || ue.width === Y && ue.height === se)
              return;
            ue.width = Y, ue.height = se;
            const pe = G(this, R) ? G(this, g) : _e(this, w, Sr).call(this, Y, se), J = ue.getContext("2d");
            J.filter = this._uiManager.hcmFilter, J.drawImage(pe, 0, 0, pe.width, pe.height, 0, 0, Y, se);
          }, nn = function(Y) {
            if (Y) {
              if (G(this, R)) {
                const pe = this._uiManager.imageManager.getSvgUrl(G(this, b));
                if (pe)
                  return pe;
              }
              const se = document.createElement("canvas");
              return {
                width: se.width,
                height: se.height
              } = G(this, g), se.getContext("2d").drawImage(G(this, g), 0, 0), se.toDataURL();
            }
            if (G(this, R)) {
              const [se, ue] = this.pageDimensions, pe = Math.round(this.width * se * u.PixelsPerInch.PDF_TO_CSS_UNITS), J = Math.round(this.height * ue * u.PixelsPerInch.PDF_TO_CSS_UNITS), j = new OffscreenCanvas(pe, J);
              return j.getContext("2d").drawImage(G(this, g), 0, 0, G(this, g).width, G(this, g).height, 0, 0, pe, J), j.transferToImageBitmap();
            }
            return structuredClone(G(this, g));
          }, Tr = function() {
            Ie(this, v, new ResizeObserver((Y) => {
              const se = Y[0].contentRect;
              se.width && se.height && _e(this, w, Er).call(this, se.width, se.height);
            })), G(this, v).observe(this.div);
          }, ft(V, "_type", "stamp");
          let d = V;
          t.StampEditor = d;
        }
      ], __webpack_module_cache__ = {};
      function __w_pdfjs_require__(e) {
        var t = __webpack_module_cache__[e];
        if (t !== void 0)
          return t.exports;
        var r = __webpack_module_cache__[e] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        return __webpack_modules__[e](r, r.exports, __w_pdfjs_require__), r.exports;
      }
      var __webpack_exports__ = {};
      return (() => {
        var e = __webpack_exports__;
        Object.defineProperty(e, "__esModule", {
          value: !0
        }), Object.defineProperty(e, "AbortException", {
          enumerable: !0,
          get: function() {
            return t.AbortException;
          }
        }), Object.defineProperty(e, "AnnotationEditorLayer", {
          enumerable: !0,
          get: function() {
            return u.AnnotationEditorLayer;
          }
        }), Object.defineProperty(e, "AnnotationEditorParamsType", {
          enumerable: !0,
          get: function() {
            return t.AnnotationEditorParamsType;
          }
        }), Object.defineProperty(e, "AnnotationEditorType", {
          enumerable: !0,
          get: function() {
            return t.AnnotationEditorType;
          }
        }), Object.defineProperty(e, "AnnotationEditorUIManager", {
          enumerable: !0,
          get: function() {
            return c.AnnotationEditorUIManager;
          }
        }), Object.defineProperty(e, "AnnotationLayer", {
          enumerable: !0,
          get: function() {
            return d.AnnotationLayer;
          }
        }), Object.defineProperty(e, "AnnotationMode", {
          enumerable: !0,
          get: function() {
            return t.AnnotationMode;
          }
        }), Object.defineProperty(e, "CMapCompressionType", {
          enumerable: !0,
          get: function() {
            return t.CMapCompressionType;
          }
        }), Object.defineProperty(e, "DOMSVGFactory", {
          enumerable: !0,
          get: function() {
            return a.DOMSVGFactory;
          }
        }), Object.defineProperty(e, "FeatureTest", {
          enumerable: !0,
          get: function() {
            return t.FeatureTest;
          }
        }), Object.defineProperty(e, "GlobalWorkerOptions", {
          enumerable: !0,
          get: function() {
            return g.GlobalWorkerOptions;
          }
        }), Object.defineProperty(e, "ImageKind", {
          enumerable: !0,
          get: function() {
            return t.ImageKind;
          }
        }), Object.defineProperty(e, "InvalidPDFException", {
          enumerable: !0,
          get: function() {
            return t.InvalidPDFException;
          }
        }), Object.defineProperty(e, "MissingPDFException", {
          enumerable: !0,
          get: function() {
            return t.MissingPDFException;
          }
        }), Object.defineProperty(e, "OPS", {
          enumerable: !0,
          get: function() {
            return t.OPS;
          }
        }), Object.defineProperty(e, "PDFDataRangeTransport", {
          enumerable: !0,
          get: function() {
            return r.PDFDataRangeTransport;
          }
        }), Object.defineProperty(e, "PDFDateString", {
          enumerable: !0,
          get: function() {
            return a.PDFDateString;
          }
        }), Object.defineProperty(e, "PDFWorker", {
          enumerable: !0,
          get: function() {
            return r.PDFWorker;
          }
        }), Object.defineProperty(e, "PasswordResponses", {
          enumerable: !0,
          get: function() {
            return t.PasswordResponses;
          }
        }), Object.defineProperty(e, "PermissionFlag", {
          enumerable: !0,
          get: function() {
            return t.PermissionFlag;
          }
        }), Object.defineProperty(e, "PixelsPerInch", {
          enumerable: !0,
          get: function() {
            return a.PixelsPerInch;
          }
        }), Object.defineProperty(e, "PromiseCapability", {
          enumerable: !0,
          get: function() {
            return t.PromiseCapability;
          }
        }), Object.defineProperty(e, "RenderingCancelledException", {
          enumerable: !0,
          get: function() {
            return a.RenderingCancelledException;
          }
        }), Object.defineProperty(e, "SVGGraphics", {
          enumerable: !0,
          get: function() {
            return r.SVGGraphics;
          }
        }), Object.defineProperty(e, "UnexpectedResponseException", {
          enumerable: !0,
          get: function() {
            return t.UnexpectedResponseException;
          }
        }), Object.defineProperty(e, "Util", {
          enumerable: !0,
          get: function() {
            return t.Util;
          }
        }), Object.defineProperty(e, "VerbosityLevel", {
          enumerable: !0,
          get: function() {
            return t.VerbosityLevel;
          }
        }), Object.defineProperty(e, "XfaLayer", {
          enumerable: !0,
          get: function() {
            return b.XfaLayer;
          }
        }), Object.defineProperty(e, "build", {
          enumerable: !0,
          get: function() {
            return r.build;
          }
        }), Object.defineProperty(e, "createValidAbsoluteUrl", {
          enumerable: !0,
          get: function() {
            return t.createValidAbsoluteUrl;
          }
        }), Object.defineProperty(e, "getDocument", {
          enumerable: !0,
          get: function() {
            return r.getDocument;
          }
        }), Object.defineProperty(e, "getFilenameFromUrl", {
          enumerable: !0,
          get: function() {
            return a.getFilenameFromUrl;
          }
        }), Object.defineProperty(e, "getPdfFilenameFromUrl", {
          enumerable: !0,
          get: function() {
            return a.getPdfFilenameFromUrl;
          }
        }), Object.defineProperty(e, "getXfaPageViewport", {
          enumerable: !0,
          get: function() {
            return a.getXfaPageViewport;
          }
        }), Object.defineProperty(e, "isDataScheme", {
          enumerable: !0,
          get: function() {
            return a.isDataScheme;
          }
        }), Object.defineProperty(e, "isPdfFile", {
          enumerable: !0,
          get: function() {
            return a.isPdfFile;
          }
        }), Object.defineProperty(e, "loadScript", {
          enumerable: !0,
          get: function() {
            return a.loadScript;
          }
        }), Object.defineProperty(e, "noContextMenu", {
          enumerable: !0,
          get: function() {
            return a.noContextMenu;
          }
        }), Object.defineProperty(e, "normalizeUnicode", {
          enumerable: !0,
          get: function() {
            return t.normalizeUnicode;
          }
        }), Object.defineProperty(e, "renderTextLayer", {
          enumerable: !0,
          get: function() {
            return o.renderTextLayer;
          }
        }), Object.defineProperty(e, "setLayerDimensions", {
          enumerable: !0,
          get: function() {
            return a.setLayerDimensions;
          }
        }), Object.defineProperty(e, "shadow", {
          enumerable: !0,
          get: function() {
            return t.shadow;
          }
        }), Object.defineProperty(e, "updateTextLayer", {
          enumerable: !0,
          get: function() {
            return o.updateTextLayer;
          }
        }), Object.defineProperty(e, "version", {
          enumerable: !0,
          get: function() {
            return r.version;
          }
        });
        var t = __w_pdfjs_require__(1), r = __w_pdfjs_require__(2), a = __w_pdfjs_require__(6), o = __w_pdfjs_require__(26), u = __w_pdfjs_require__(27), c = __w_pdfjs_require__(5), d = __w_pdfjs_require__(29), g = __w_pdfjs_require__(14), b = __w_pdfjs_require__(32);
      })(), __webpack_exports__;
    })()
  ));
})(pdf);
var pdfExports = pdf.exports;
function getURLFileExtension(e) {
  let t = e.split(".").pop();
  return t = t == null ? void 0 : t.split("?").shift(), t && t.includes("/") && (t = t.split("/")[0]), t;
}
function isMobile() {
  return window.innerWidth <= 576;
}
function safeParseJSON(e, t) {
  try {
    return e ? JSON.parse(e) : t;
  } catch {
    return t;
  }
}
function getCustomProps(e) {
  var a;
  const t = e.node, r = (a = t == null ? void 0 : t.children) == null ? void 0 : a[0];
  return isObject(r) && !r.position ? {
    ...e,
    ...r,
    node: {
      ...t,
      children: t.children.slice(1)
    }
  } : e;
}
pdfExports.GlobalWorkerOptions.workerSrc = "https://g.alicdn.com/code/lib/pdf.js/3.11.174/pdf.worker.min.js";
const Pdf = ({
  src: e,
  height: t,
  width: r = "100%"
}) => {
  const [a, o] = useState(0), [u, c] = useState(0), d = useRef(0), g = useRef(null), b = useRef(null), _ = useRef(null), [y, A] = useState(null);
  function E() {
    y == null || y.getPage(a).then((C) => {
      var L;
      (L = _ == null ? void 0 : _.current) == null || L.cancel();
      const R = b.current, I = g.current, w = R == null ? void 0 : R.getContext("2d");
      if (!I || !R || !w)
        return;
      const N = I.getBoundingClientRect().width;
      w.clearRect(0, 0, R.width, R.height);
      let F = C.getViewport({
        scale: 1
      });
      const M = N / F.width;
      let x = M;
      t ? x = Math.min(t / F.height, M) : (isMobile() || (x = M * 0.6), I.style.height = `${F.height * x}px`), F = C.getViewport({
        scale: x
      });
      const P = {
        canvasContext: w,
        viewport: F
      };
      R.width = F.width, R.height = F.height;
      const U = C.render(P);
      _.current = U, U.promise.catch(() => {
      });
    });
  }
  async function v() {
    if (!e)
      return;
    y == null || y.destroy();
    const R = await pdfExports.getDocument(e).promise;
    o(1), c(R.numPages), A(R);
  }
  return useEffect(() => {
    v();
  }, [e]), useEffect(() => {
    const C = g.current;
    if (!C)
      return;
    d.current = C.getBoundingClientRect().width;
    let R;
    const I = new ResizeObserver((w) => {
      const N = w[0];
      if (!N)
        return;
      const F = N.contentRect;
      F.width !== d.current && (R && clearTimeout(R), d.current = F.width, R = setTimeout(() => {
        E();
      }, 500));
    });
    return I.observe(C), E(), () => {
      I.disconnect();
    };
  }, [y, a, u]), /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: !!u && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
      className: "ms-file-view-pdf",
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
        ref: g,
        className: "ms-file-view-pdf-canvas",
        style: {
          width: r,
          height: t
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("canvas", {
          ref: b
        })
      }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
        className: "ms-file-view-pdf-button-row",
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Button, {
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CaretLeftOutlined, {}),
          disabled: a <= 1,
          onClick: () => {
            a <= 1 || (o(a - 1), E());
          }
        }), /* @__PURE__ */ jsxRuntimeExports.jsxs("span", {
          className: "ms-file-view-pdf-page-count",
          children: [a, " / ", u]
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(Button, {
          disabled: a >= u,
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CaretRightOutlined, {}),
          onClick: () => {
            a >= u || (o(a + 1), E());
          }
        })]
      })]
    })
  });
}, Image$2 = ({
  preview: e = !0,
  ...t
}) => {
  const r = usePreview();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
    style: {
      width: "100%"
    },
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Image$3, {
      preview: e ? r : !1,
      style: {
        maxWidth: "100%",
        width: "auto"
      },
      ...t
    })
  });
}, Video$1 = (e) => /* @__PURE__ */ jsxRuntimeExports.jsx("video", {
  style: {
    maxWidth: "100%"
  },
  preload: "auto",
  controls: !0,
  ...e,
  children: /* @__PURE__ */ jsxRuntimeExports.jsx("track", {
    kind: "captions"
  })
}), Audio$1 = (e) => /* @__PURE__ */ jsxRuntimeExports.jsx("audio", {
  preload: "metadata",
  controls: !0,
  ...e,
  style: {
    maxWidth: "100%",
    ...e.style
  }
}), Link = (e) => {
  const {
    filename: t,
    href: r,
    icon: a = /* @__PURE__ */ jsxRuntimeExports.jsx(FileOutlined, {}),
    disabled: o,
    ...u
  } = e;
  return o ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      style: {
        marginRight: 2
      },
      children: a
    }), t || r]
  }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("a", {
    ...u,
    target: "_blank",
    rel: "noreferrer",
    href: r,
    download: t,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      style: {
        marginRight: 2
      },
      children: a
    }), t || r]
  });
}, FileView = (e) => {
  const {
    url: t,
    type: r,
    ...a
  } = e;
  switch (r) {
    case "image":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Image$2, {
        src: t,
        ...a
      });
    case "video":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Video$1, {
        src: t,
        ...a
      });
    case "audio":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Audio$1, {
        src: t,
        ...a
      });
    case "pdf":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Pdf, {
        src: t,
        ...a
      });
    case "link":
    default:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Link, {
        href: t,
        ...a
      });
  }
};
var classnames = {
  exports: {}
};
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(e) {
  (function() {
    var t = {}.hasOwnProperty;
    function r() {
      for (var u = "", c = 0; c < arguments.length; c++) {
        var d = arguments[c];
        d && (u = o(u, a(d)));
      }
      return u;
    }
    function a(u) {
      if (typeof u == "string" || typeof u == "number")
        return u;
      if (typeof u != "object")
        return "";
      if (Array.isArray(u))
        return r.apply(null, u);
      if (u.toString !== Object.prototype.toString && !u.toString.toString().includes("[native code]"))
        return u.toString();
      var c = "";
      for (var d in u)
        t.call(u, d) && u[d] && (c = o(c, d));
      return c;
    }
    function o(u, c) {
      return c ? u ? u + " " + c : u + c : u;
    }
    e.exports ? (r.default = r, e.exports = r) : window.classNames = r;
  })();
})(classnames);
var classnamesExports = classnames.exports;
const cls = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
function useMemoizedEqualValue(e) {
  const t = useRef();
  return useMemo(() => isEqual(e, t.current) ? t.current : (t.current = e, e), [e]);
}
const useRefValue = (e) => {
  const t = useRef(e);
  return t.current = e, t;
};
function getElementNodes(e, t) {
  const r = (u) => u.replace(/\{(\w+)\}/g, (c, d) => Reflect.has(t, d) ? t[d] : c), a = document.createElement("div");
  a.innerHTML = e.trim();
  const o = (u) => {
    Array.from(u.childNodes).forEach((c) => {
      if (c instanceof Text)
        c.textContent = r(c.nodeValue || "") || null;
      else if (c instanceof HTMLElement) {
        for (const d of c.attributes)
          if (d.name.startsWith("on")) {
            const g = d.name.substring(2), b = d.value.match(/\{(\w+)\}/);
            b && t[b[1]] && (c.addEventListener(g, t[b[1]]), c.removeAttribute(d.name));
          } else
            c.setAttribute(d.name, r(d.value));
        u.childNodes.length && o(c);
      }
    });
  };
  return o(a), Array.from(a.childNodes);
}
function useCustomComponent(e) {
  var R;
  const {
    target: t,
    theme: r,
    locale: a,
    onCustom: o,
    component: u,
    componentProps: c,
    extraProps: d,
    onBeforeRender: g = () => !0
  } = e, b = useRefValue(o), _ = useRefValue(g), y = useRef(), A = useRef(!1), E = u.template || "", v = ((R = u.js) == null ? void 0 : R.trim()) || "", C = useMemoizedEqualValue(useMemo(() => ({
    ...Object.keys(c).reduce((w, N) => {
      var F;
      return (F = u.props) != null && F.includes(N) && (w[N] = c[N]), w;
    }, {}),
    ...d
  }), [u.props, c, d]));
  useEffect(() => {
    const I = t.current;
    if (!I || !_.current())
      return;
    let w = {}, N = () => {
    }, F = () => {
    }, M = !1;
    const x = (U) => {
      N = U;
    }, P = (U, L) => {
      F = U, M = (L == null ? void 0 : L.callAfterMount) || !1;
    };
    if (v) {
      let U = v.trim();
      U.startsWith(";") && (U = U.slice(1)), U.endsWith(";") && (U = U.slice(0, -1)), w = new Function(`return ${U}`)()(
        // props
        C,
        // cc
        {
          dispatch: (L) => b.current(L)
        },
        // el options
        {
          el: I,
          onMount: x,
          onUpdate: P,
          theme: r,
          locale: a
        }
      ) || {};
    }
    if (E) {
      const U = {
        ...C,
        ...w
      }, L = document.createDocumentFragment();
      getElementNodes(E, U).forEach((H) => {
        L.appendChild(H);
      }), I.appendChild(L);
    }
    A.current ? F() : (y.current = N(I) || (() => {
    }), A.current = !0, M && F());
  }, [C, v, a, _, b, t, E, r]), useEffect(() => () => {
    isFunction(y.current) && y.current(), t.current && (t.current.innerHTML = "");
  }, []);
}
function ok$1() {
}
function unreachable() {
}
function parse$7(e) {
  const t = [], r = String(e || "");
  let a = r.indexOf(","), o = 0, u = !1;
  for (; !u; ) {
    a === -1 && (a = r.length, u = !0);
    const c = r.slice(o, a).trim();
    (c || !u) && t.push(c), o = a + 1, a = r.indexOf(",", o);
  }
  return t;
}
function stringify$4(e, t) {
  const r = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join((r.padRight ? " " : "") + "," + (r.padLeft === !1 ? "" : " ")).trim();
}
const nameRe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, nameReJsx = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, emptyOptions$7 = {};
function name$1(e, t) {
  return (emptyOptions$7.jsx ? nameReJsx : nameRe).test(e);
}
const re$1 = /[ \t\n\f\r]/g;
function whitespace(e) {
  return typeof e == "object" ? e.type === "text" ? empty$4(e.value) : !1 : empty$4(e);
}
function empty$4(e) {
  return e.replace(re$1, "") === "";
}
let Schema$4 = class {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, r, a) {
    this.property = t, this.normal = r, a && (this.space = a);
  }
};
Schema$4.prototype.property = {};
Schema$4.prototype.normal = {};
Schema$4.prototype.space = null;
function merge$3(e, t) {
  const r = {}, a = {};
  let o = -1;
  for (; ++o < e.length; )
    Object.assign(r, e[o].property), Object.assign(a, e[o].normal);
  return new Schema$4(r, a, t);
}
function normalize$6(e) {
  return e.toLowerCase();
}
let Info$4 = class {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, r) {
    this.property = t, this.attribute = r;
  }
};
Info$4.prototype.space = null;
Info$4.prototype.boolean = !1;
Info$4.prototype.booleanish = !1;
Info$4.prototype.overloadedBoolean = !1;
Info$4.prototype.number = !1;
Info$4.prototype.commaSeparated = !1;
Info$4.prototype.spaceSeparated = !1;
Info$4.prototype.commaOrSpaceSeparated = !1;
Info$4.prototype.mustUseProperty = !1;
Info$4.prototype.defined = !1;
let powers$2 = 0;
const boolean$2 = increment$2(), booleanish$3 = increment$2(), overloadedBoolean$2 = increment$2(), number$3 = increment$2(), spaceSeparated$3 = increment$2(), commaSeparated$2 = increment$2(), commaOrSpaceSeparated$1 = increment$2();
function increment$2() {
  return 2 ** ++powers$2;
}
const types$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: boolean$2,
  booleanish: booleanish$3,
  commaOrSpaceSeparated: commaOrSpaceSeparated$1,
  commaSeparated: commaSeparated$2,
  number: number$3,
  overloadedBoolean: overloadedBoolean$2,
  spaceSeparated: spaceSeparated$3
}, Symbol.toStringTag, {
  value: "Module"
})), checks$2 = Object.keys(types$5);
let DefinedInfo$4 = class extends Info$4 {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, r, a, o) {
    let u = -1;
    if (super(t, r), mark$2(this, "space", o), typeof a == "number")
      for (; ++u < checks$2.length; ) {
        const c = checks$2[u];
        mark$2(this, checks$2[u], (a & types$5[c]) === types$5[c]);
      }
  }
};
DefinedInfo$4.prototype.defined = !0;
function mark$2(e, t, r) {
  r && (e[t] = r);
}
const own$g = {}.hasOwnProperty;
function create$7(e) {
  const t = {}, r = {};
  let a;
  for (a in e.properties)
    if (own$g.call(e.properties, a)) {
      const o = e.properties[a], u = new DefinedInfo$4(a, e.transform(e.attributes || {}, a), o, e.space);
      e.mustUseProperty && e.mustUseProperty.includes(a) && (u.mustUseProperty = !0), t[a] = u, r[normalize$6(a)] = a, r[normalize$6(u.attribute)] = a;
    }
  return new Schema$4(t, r, e.space);
}
const xlink$3 = create$7({
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), xml$3 = create$7({
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: {
    xmlLang: null,
    xmlBase: null,
    xmlSpace: null
  }
});
function caseSensitiveTransform$3(e, t) {
  return t in e ? e[t] : t;
}
function caseInsensitiveTransform$4(e, t) {
  return caseSensitiveTransform$3(e, t.toLowerCase());
}
const xmlns$3 = create$7({
  space: "xmlns",
  attributes: {
    xmlnsxlink: "xmlns:xlink"
  },
  transform: caseInsensitiveTransform$4,
  properties: {
    xmlns: null,
    xmlnsXLink: null
  }
}), aria$4 = create$7({
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish$3,
    ariaAutoComplete: null,
    ariaBusy: booleanish$3,
    ariaChecked: booleanish$3,
    ariaColCount: number$3,
    ariaColIndex: number$3,
    ariaColSpan: number$3,
    ariaControls: spaceSeparated$3,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated$3,
    ariaDetails: null,
    ariaDisabled: booleanish$3,
    ariaDropEffect: spaceSeparated$3,
    ariaErrorMessage: null,
    ariaExpanded: booleanish$3,
    ariaFlowTo: spaceSeparated$3,
    ariaGrabbed: booleanish$3,
    ariaHasPopup: null,
    ariaHidden: booleanish$3,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated$3,
    ariaLevel: number$3,
    ariaLive: null,
    ariaModal: booleanish$3,
    ariaMultiLine: booleanish$3,
    ariaMultiSelectable: booleanish$3,
    ariaOrientation: null,
    ariaOwns: spaceSeparated$3,
    ariaPlaceholder: null,
    ariaPosInSet: number$3,
    ariaPressed: booleanish$3,
    ariaReadOnly: booleanish$3,
    ariaRelevant: null,
    ariaRequired: booleanish$3,
    ariaRoleDescription: spaceSeparated$3,
    ariaRowCount: number$3,
    ariaRowIndex: number$3,
    ariaRowSpan: number$3,
    ariaSelected: booleanish$3,
    ariaSetSize: number$3,
    ariaSort: null,
    ariaValueMax: number$3,
    ariaValueMin: number$3,
    ariaValueNow: number$3,
    ariaValueText: null,
    role: null
  }
}), html$8 = create$7({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform$4,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated$2,
    acceptCharset: spaceSeparated$3,
    accessKey: spaceSeparated$3,
    action: null,
    allow: null,
    allowFullScreen: boolean$2,
    allowPaymentRequest: boolean$2,
    allowUserMedia: boolean$2,
    alt: null,
    as: null,
    async: boolean$2,
    autoCapitalize: null,
    autoComplete: spaceSeparated$3,
    autoFocus: boolean$2,
    autoPlay: boolean$2,
    blocking: spaceSeparated$3,
    capture: null,
    charSet: null,
    checked: boolean$2,
    cite: null,
    className: spaceSeparated$3,
    cols: number$3,
    colSpan: null,
    content: null,
    contentEditable: booleanish$3,
    controls: boolean$2,
    controlsList: spaceSeparated$3,
    coords: number$3 | commaSeparated$2,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean$2,
    defer: boolean$2,
    dir: null,
    dirName: null,
    disabled: boolean$2,
    download: overloadedBoolean$2,
    draggable: booleanish$3,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean$2,
    formTarget: null,
    headers: spaceSeparated$3,
    height: number$3,
    hidden: boolean$2,
    high: number$3,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated$3,
    httpEquiv: spaceSeparated$3,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean$2,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean$2,
    itemId: null,
    itemProp: spaceSeparated$3,
    itemRef: spaceSeparated$3,
    itemScope: boolean$2,
    itemType: spaceSeparated$3,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean$2,
    low: number$3,
    manifest: null,
    max: null,
    maxLength: number$3,
    media: null,
    method: null,
    min: null,
    minLength: number$3,
    multiple: boolean$2,
    muted: boolean$2,
    name: null,
    nonce: null,
    noModule: boolean$2,
    noValidate: boolean$2,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean$2,
    optimum: number$3,
    pattern: null,
    ping: spaceSeparated$3,
    placeholder: null,
    playsInline: boolean$2,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean$2,
    referrerPolicy: null,
    rel: spaceSeparated$3,
    required: boolean$2,
    reversed: boolean$2,
    rows: number$3,
    rowSpan: number$3,
    sandbox: spaceSeparated$3,
    scope: null,
    scoped: boolean$2,
    seamless: boolean$2,
    selected: boolean$2,
    shadowRootClonable: boolean$2,
    shadowRootDelegatesFocus: boolean$2,
    shadowRootMode: null,
    shape: null,
    size: number$3,
    sizes: null,
    slot: null,
    span: number$3,
    spellCheck: booleanish$3,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number$3,
    step: null,
    style: null,
    tabIndex: number$3,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean$2,
    useMap: null,
    value: booleanish$3,
    width: number$3,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated$3,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number$3,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number$3,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean$2,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean$2,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number$3,
    // `<img>` and `<object>`
    leftMargin: number$3,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number$3,
    // `<body>`
    marginWidth: number$3,
    // `<body>`
    noResize: boolean$2,
    // `<frame>`
    noHref: boolean$2,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean$2,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean$2,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number$3,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish$3,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number$3,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number$3,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean$2,
    disableRemotePlayback: boolean$2,
    prefix: null,
    property: null,
    results: number$3,
    security: null,
    unselectable: null
  }
}), svg$3 = create$7({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: caseSensitiveTransform$3,
  properties: {
    about: commaOrSpaceSeparated$1,
    accentHeight: number$3,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number$3,
    amplitude: number$3,
    arabicForm: null,
    ascent: number$3,
    attributeName: null,
    attributeType: null,
    azimuth: number$3,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number$3,
    by: null,
    calcMode: null,
    capHeight: number$3,
    className: spaceSeparated$3,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number$3,
    diffuseConstant: number$3,
    direction: null,
    display: null,
    dur: null,
    divisor: number$3,
    dominantBaseline: null,
    download: boolean$2,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number$3,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number$3,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number$3,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated$2,
    g2: commaSeparated$2,
    glyphName: commaSeparated$2,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number$3,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number$3,
    horizOriginX: number$3,
    horizOriginY: number$3,
    id: null,
    ideographic: number$3,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number$3,
    k: number$3,
    k1: number$3,
    k2: number$3,
    k3: number$3,
    k4: number$3,
    kernelMatrix: commaOrSpaceSeparated$1,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number$3,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number$3,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number$3,
    overlineThickness: number$3,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number$3,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated$3,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number$3,
    pointsAtY: number$3,
    pointsAtZ: number$3,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated$1,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated$1,
    rev: commaOrSpaceSeparated$1,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated$1,
    requiredFeatures: commaOrSpaceSeparated$1,
    requiredFonts: commaOrSpaceSeparated$1,
    requiredFormats: commaOrSpaceSeparated$1,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number$3,
    specularExponent: number$3,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number$3,
    strikethroughThickness: number$3,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated$1,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number$3,
    strokeOpacity: number$3,
    strokeWidth: null,
    style: null,
    surfaceScale: number$3,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated$1,
    tabIndex: number$3,
    tableValues: null,
    target: null,
    targetX: number$3,
    targetY: number$3,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated$1,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number$3,
    underlineThickness: number$3,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number$3,
    values: null,
    vAlphabetic: number$3,
    vMathematical: number$3,
    vectorEffect: null,
    vHanging: number$3,
    vIdeographic: number$3,
    version: null,
    vertAdvY: number$3,
    vertOriginX: number$3,
    vertOriginY: number$3,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number$3,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), valid$2 = /^data[-\w.:]+$/i, dash$2 = /-[a-z]/g, cap$3 = /[A-Z]/g;
function find$3(e, t) {
  const r = normalize$6(t);
  let a = t, o = Info$4;
  if (r in e.normal)
    return e.property[e.normal[r]];
  if (r.length > 4 && r.slice(0, 4) === "data" && valid$2.test(t)) {
    if (t.charAt(4) === "-") {
      const u = t.slice(5).replace(dash$2, camelcase$2);
      a = "data" + u.charAt(0).toUpperCase() + u.slice(1);
    } else {
      const u = t.slice(4);
      if (!dash$2.test(u)) {
        let c = u.replace(cap$3, kebab$2);
        c.charAt(0) !== "-" && (c = "-" + c), t = "data" + c;
      }
    }
    o = DefinedInfo$4;
  }
  return new o(a, t);
}
function kebab$2(e) {
  return "-" + e.toLowerCase();
}
function camelcase$2(e) {
  return e.charAt(1).toUpperCase();
}
const hastToReact = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, html$7 = merge$3([xml$3, xlink$3, xmlns$3, aria$4, html$8], "html"), svg$2 = merge$3([xml$3, xlink$3, xmlns$3, aria$4, svg$3], "svg");
function parse$6(e) {
  const t = String(e || "").trim();
  return t ? t.split(/[ \t\n\r\f]+/g) : [];
}
function stringify$3(e) {
  return e.join(" ").trim();
}
var cjs$1 = {}, COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, NEWLINE_REGEX = /\n/g, WHITESPACE_REGEX = /^\s*/, PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, COLON_REGEX = /^:\s*/, VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, SEMICOLON_REGEX = /^[;\s]*/, TRIM_REGEX = /^\s+|\s+$/g, NEWLINE = `
`, FORWARD_SLASH = "/", ASTERISK = "*", EMPTY_STRING = "", TYPE_COMMENT = "comment", TYPE_DECLARATION = "declaration", inlineStyleParser = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var r = 1, a = 1;
  function o(v) {
    var C = v.match(NEWLINE_REGEX);
    C && (r += C.length);
    var R = v.lastIndexOf(NEWLINE);
    a = ~R ? v.length - R : a + v.length;
  }
  function u() {
    var v = {
      line: r,
      column: a
    };
    return function(C) {
      return C.position = new c(v), b(), C;
    };
  }
  function c(v) {
    this.start = v, this.end = {
      line: r,
      column: a
    }, this.source = t.source;
  }
  c.prototype.content = e;
  function d(v) {
    var C = new Error(t.source + ":" + r + ":" + a + ": " + v);
    if (C.reason = v, C.filename = t.source, C.line = r, C.column = a, C.source = e, !t.silent) throw C;
  }
  function g(v) {
    var C = v.exec(e);
    if (C) {
      var R = C[0];
      return o(R), e = e.slice(R.length), C;
    }
  }
  function b() {
    g(WHITESPACE_REGEX);
  }
  function _(v) {
    var C;
    for (v = v || []; C = y(); )
      C !== !1 && v.push(C);
    return v;
  }
  function y() {
    var v = u();
    if (!(FORWARD_SLASH != e.charAt(0) || ASTERISK != e.charAt(1))) {
      for (var C = 2; EMPTY_STRING != e.charAt(C) && (ASTERISK != e.charAt(C) || FORWARD_SLASH != e.charAt(C + 1)); )
        ++C;
      if (C += 2, EMPTY_STRING === e.charAt(C - 1))
        return d("End of comment missing");
      var R = e.slice(2, C - 2);
      return a += 2, o(R), e = e.slice(C), a += 2, v({
        type: TYPE_COMMENT,
        comment: R
      });
    }
  }
  function A() {
    var v = u(), C = g(PROPERTY_REGEX);
    if (C) {
      if (y(), !g(COLON_REGEX)) return d("property missing ':'");
      var R = g(VALUE_REGEX), I = v({
        type: TYPE_DECLARATION,
        property: trim(C[0].replace(COMMENT_REGEX, EMPTY_STRING)),
        value: R ? trim(R[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
      });
      return g(SEMICOLON_REGEX), I;
    }
  }
  function E() {
    var v = [];
    _(v);
    for (var C; C = A(); )
      C !== !1 && (v.push(C), _(v));
    return v;
  }
  return b(), E();
};
function trim(e) {
  return e ? e.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
}
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(e) {
  return e && e.__esModule ? e : {
    default: e
  };
};
Object.defineProperty(cjs$1, "__esModule", {
  value: !0
});
var _default = cjs$1.default = StyleToObject, inline_style_parser_1 = __importDefault(inlineStyleParser);
function StyleToObject(e, t) {
  var r = null;
  if (!e || typeof e != "string")
    return r;
  var a = (0, inline_style_parser_1.default)(e), o = typeof t == "function";
  return a.forEach(function(u) {
    if (u.type === "declaration") {
      var c = u.property, d = u.value;
      o ? t(c, d, u) : d && (r = r || {}, r[c] = d);
    }
  }), r;
}
const styleToObject = _default.default || _default, pointEnd = point$3("end"), pointStart = point$3("start");
function point$3(e) {
  return t;
  function t(r) {
    const a = r && r.position && r.position[e] || {};
    if (typeof a.line == "number" && a.line > 0 && typeof a.column == "number" && a.column > 0)
      return {
        line: a.line,
        column: a.column,
        offset: typeof a.offset == "number" && a.offset > -1 ? a.offset : void 0
      };
  }
}
function position$2(e) {
  const t = pointStart(e), r = pointEnd(e);
  if (t && r)
    return {
      start: t,
      end: r
    };
}
function stringifyPosition(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? position$1(e.position) : "start" in e || "end" in e ? position$1(e) : "line" in e || "column" in e ? point$2(e) : "";
}
function point$2(e) {
  return index(e && e.line) + ":" + index(e && e.column);
}
function position$1(e) {
  return point$2(e && e.start) + "-" + point$2(e && e.end);
}
function index(e) {
  return e && typeof e == "number" ? e : 1;
}
class VFileMessage extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, r, a) {
    super(), typeof r == "string" && (a = r, r = void 0);
    let o = "", u = {}, c = !1;
    if (r && ("line" in r && "column" in r ? u = {
      place: r
    } : "start" in r && "end" in r ? u = {
      place: r
    } : "type" in r ? u = {
      ancestors: [r],
      place: r.position
    } : u = {
      ...r
    }), typeof t == "string" ? o = t : !u.cause && t && (c = !0, o = t.message, u.cause = t), !u.ruleId && !u.source && typeof a == "string") {
      const g = a.indexOf(":");
      g === -1 ? u.ruleId = a : (u.source = a.slice(0, g), u.ruleId = a.slice(g + 1));
    }
    if (!u.place && u.ancestors && u.ancestors) {
      const g = u.ancestors[u.ancestors.length - 1];
      g && (u.place = g.position);
    }
    const d = u.place && "start" in u.place ? u.place.start : u.place;
    this.ancestors = u.ancestors || void 0, this.cause = u.cause || void 0, this.column = d ? d.column : void 0, this.fatal = void 0, this.file, this.message = o, this.line = d ? d.line : void 0, this.name = stringifyPosition(u.place) || "1:1", this.place = u.place || void 0, this.reason = this.message, this.ruleId = u.ruleId || void 0, this.source = u.source || void 0, this.stack = c && u.cause && typeof u.cause.stack == "string" ? u.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.column = void 0;
VFileMessage.prototype.line = void 0;
VFileMessage.prototype.ancestors = void 0;
VFileMessage.prototype.cause = void 0;
VFileMessage.prototype.fatal = void 0;
VFileMessage.prototype.place = void 0;
VFileMessage.prototype.ruleId = void 0;
VFileMessage.prototype.source = void 0;
const own$f = {}.hasOwnProperty, emptyMap = /* @__PURE__ */ new Map(), cap$2 = /[A-Z]/g, dashSomething = /-([a-z])/g, tableElements = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), tableCellElement = /* @__PURE__ */ new Set(["td", "th"]), docs = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function toJsxRuntime(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const r = t.filePath || void 0;
  let a;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError("Expected `jsxDEV` in options when `development: true`");
    a = developmentCreate(r, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    a = productionCreate(r, t.jsx, t.jsxs);
  }
  const o = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: a,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: r,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? svg$2 : html$7,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, u = one$4(o, e, void 0);
  return u && typeof u != "string" ? u : o.create(e, o.Fragment, {
    children: u || void 0
  }, void 0);
}
function one$4(e, t, r) {
  if (t.type === "element")
    return element$d(e, t, r);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return mdxExpression(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return mdxJsxElement(e, t, r);
  if (t.type === "mdxjsEsm")
    return mdxEsm(e, t);
  if (t.type === "root")
    return root$6(e, t, r);
  if (t.type === "text")
    return text$b(e, t);
}
function element$d(e, t, r) {
  const a = e.schema;
  let o = a;
  t.tagName.toLowerCase() === "svg" && a.space === "html" && (o = svg$2, e.schema = o), e.ancestors.push(t);
  const u = findComponentFromName(e, t.tagName, !1), c = createElementProps(e, t);
  let d = createChildren$1(e, t);
  return tableElements.has(t.tagName) && (d = d.filter(function(g) {
    return typeof g == "string" ? !whitespace(g) : !0;
  })), addNode(e, c, u, t), addChildren(c, d), e.ancestors.pop(), e.schema = a, e.create(t, u, c, r);
}
function mdxExpression(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const a = t.data.estree.body[0];
    return a.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(a.expression);
  }
  crashEstree(e, t.position);
}
function mdxEsm(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  crashEstree(e, t.position);
}
function mdxJsxElement(e, t, r) {
  const a = e.schema;
  let o = a;
  t.name === "svg" && a.space === "html" && (o = svg$2, e.schema = o), e.ancestors.push(t);
  const u = t.name === null ? e.Fragment : findComponentFromName(e, t.name, !0), c = createJsxElementProps(e, t), d = createChildren$1(e, t);
  return addNode(e, c, u, t), addChildren(c, d), e.ancestors.pop(), e.schema = a, e.create(t, u, c, r);
}
function root$6(e, t, r) {
  const a = {};
  return addChildren(a, createChildren$1(e, t)), e.create(t, e.Fragment, a, r);
}
function text$b(e, t) {
  return t.value;
}
function addNode(e, t, r, a) {
  typeof r != "string" && r !== e.Fragment && e.passNode && (t.node = a);
}
function addChildren(e, t) {
  if (t.length > 0) {
    const r = t.length > 1 ? t : t[0];
    r && (e.children = r);
  }
}
function productionCreate(e, t, r) {
  return a;
  function a(o, u, c, d) {
    const b = Array.isArray(c.children) ? r : t;
    return d ? b(u, c, d) : b(u, c);
  }
}
function developmentCreate(e, t) {
  return r;
  function r(a, o, u, c) {
    const d = Array.isArray(u.children), g = pointStart(a);
    return t(o, u, c, d, {
      columnNumber: g ? g.column - 1 : void 0,
      fileName: e,
      lineNumber: g ? g.line : void 0
    }, void 0);
  }
}
function createElementProps(e, t) {
  const r = {};
  let a, o;
  for (o in t.properties)
    if (o !== "children" && own$f.call(t.properties, o)) {
      const u = createProperty$1(e, o, t.properties[o]);
      if (u) {
        const [c, d] = u;
        e.tableCellAlignToStyle && c === "align" && typeof d == "string" && tableCellElement.has(t.tagName) ? a = d : r[c] = d;
      }
    }
  if (a) {
    const u = (
      /** @type {Style} */
      r.style || (r.style = {})
    );
    u[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = a;
  }
  return r;
}
function createJsxElementProps(e, t) {
  const r = {};
  for (const a of t.attributes)
    if (a.type === "mdxJsxExpressionAttribute")
      if (a.data && a.data.estree && e.evaluater) {
        const u = a.data.estree.body[0];
        u.type;
        const c = u.expression;
        c.type;
        const d = c.properties[0];
        d.type, Object.assign(r, e.evaluater.evaluateExpression(d.argument));
      } else
        crashEstree(e, t.position);
    else {
      const o = a.name;
      let u;
      if (a.value && typeof a.value == "object")
        if (a.value.data && a.value.data.estree && e.evaluater) {
          const d = a.value.data.estree.body[0];
          d.type, u = e.evaluater.evaluateExpression(d.expression);
        } else
          crashEstree(e, t.position);
      else
        u = a.value === null ? !0 : a.value;
      r[o] = /** @type {Props[keyof Props]} */
      u;
    }
  return r;
}
function createChildren$1(e, t) {
  const r = [];
  let a = -1;
  const o = e.passKeys ? /* @__PURE__ */ new Map() : emptyMap;
  for (; ++a < t.children.length; ) {
    const u = t.children[a];
    let c;
    if (e.passKeys) {
      const g = u.type === "element" ? u.tagName : u.type === "mdxJsxFlowElement" || u.type === "mdxJsxTextElement" ? u.name : void 0;
      if (g) {
        const b = o.get(g) || 0;
        c = g + "-" + b, o.set(g, b + 1);
      }
    }
    const d = one$4(e, u, c);
    d !== void 0 && r.push(d);
  }
  return r;
}
function createProperty$1(e, t, r) {
  const a = find$3(e.schema, t);
  if (!(r == null || typeof r == "number" && Number.isNaN(r))) {
    if (Array.isArray(r) && (r = a.commaSeparated ? stringify$4(r) : stringify$3(r)), a.property === "style") {
      let o = typeof r == "object" ? r : parseStyle(e, String(r));
      return e.stylePropertyNameCase === "css" && (o = transformStylesToCssCasing(o)), ["style", o];
    }
    return [e.elementAttributeNameCase === "react" && a.space ? hastToReact[a.property] || a.property : a.attribute, r];
  }
}
function parseStyle(e, t) {
  const r = {};
  try {
    styleToObject(t, a);
  } catch (o) {
    if (!e.ignoreInvalidStyle) {
      const u = (
        /** @type {Error} */
        o
      ), c = new VFileMessage("Cannot parse `style` attribute", {
        ancestors: e.ancestors,
        cause: u,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      throw c.file = e.filePath || void 0, c.url = docs + "#cannot-parse-style-attribute", c;
    }
  }
  return r;
  function a(o, u) {
    let c = o;
    c.slice(0, 2) !== "--" && (c.slice(0, 4) === "-ms-" && (c = "ms-" + c.slice(4)), c = c.replace(dashSomething, toCamel)), r[c] = u;
  }
}
function findComponentFromName(e, t, r) {
  let a;
  if (!r)
    a = {
      type: "Literal",
      value: t
    };
  else if (t.includes(".")) {
    const o = t.split(".");
    let u = -1, c;
    for (; ++u < o.length; ) {
      const d = name$1(o[u]) ? {
        type: "Identifier",
        name: o[u]
      } : {
        type: "Literal",
        value: o[u]
      };
      c = c ? {
        type: "MemberExpression",
        object: c,
        property: d,
        computed: !!(u && d.type === "Literal"),
        optional: !1
      } : d;
    }
    a = c;
  } else
    a = name$1(t) && !/^[a-z]/.test(t) ? {
      type: "Identifier",
      name: t
    } : {
      type: "Literal",
      value: t
    };
  if (a.type === "Literal") {
    const o = (
      /** @type {keyof JSX.IntrinsicElements} */
      a.value
    );
    return own$f.call(e.components, o) ? e.components[o] : o;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(a);
  crashEstree(e);
}
function crashEstree(e, t) {
  const r = new VFileMessage("Cannot handle MDX estrees without `createEvaluater`", {
    ancestors: e.ancestors,
    place: t,
    ruleId: "mdx-estree",
    source: "hast-util-to-jsx-runtime"
  });
  throw r.file = e.filePath || void 0, r.url = docs + "#cannot-handle-mdx-estrees-without-createevaluater", r;
}
function transformStylesToCssCasing(e) {
  const t = {};
  let r;
  for (r in e)
    own$f.call(e, r) && (t[transformStyleToCssCasing(r)] = e[r]);
  return t;
}
function transformStyleToCssCasing(e) {
  let t = e.replace(cap$2, toDash);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function toCamel(e, t) {
  return t.toUpperCase();
}
function toDash(e) {
  return "-" + e.toLowerCase();
}
const urlAttributes = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: ["audio", "embed", "iframe", "img", "input", "script", "source", "track", "video"]
}, emptyOptions$6 = {};
function toString$1(e, t) {
  const r = emptyOptions$6, a = typeof r.includeImageAlt == "boolean" ? r.includeImageAlt : !0, o = typeof r.includeHtml == "boolean" ? r.includeHtml : !0;
  return one$3(e, a, o);
}
function one$3(e, t, r) {
  if (node(e)) {
    if ("value" in e)
      return e.type === "html" && !r ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return all$4(e.children, t, r);
  }
  return Array.isArray(e) ? all$4(e, t, r) : "";
}
function all$4(e, t, r) {
  const a = [];
  let o = -1;
  for (; ++o < e.length; )
    a[o] = one$3(e[o], t, r);
  return a.join("");
}
function node(e) {
  return !!(e && typeof e == "object");
}
const element$c = document.createElement("i");
function decodeNamedCharacterReference(e) {
  const t = "&" + e + ";";
  element$c.innerHTML = t;
  const r = element$c.textContent;
  return r.charCodeAt(r.length - 1) === 59 && e !== "semi" || r === t ? !1 : r;
}
function splice(e, t, r, a) {
  const o = e.length;
  let u = 0, c;
  if (t < 0 ? t = -t > o ? 0 : o + t : t = t > o ? o : t, r = r > 0 ? r : 0, a.length < 1e4)
    c = Array.from(a), c.unshift(t, r), e.splice(...c);
  else
    for (r && e.splice(t, r); u < a.length; )
      c = a.slice(u, u + 1e4), c.unshift(t, 0), e.splice(...c), u += 1e4, t += 1e4;
}
function push(e, t) {
  return e.length > 0 ? (splice(e, e.length, 0, t), e) : t;
}
const hasOwnProperty$1 = {}.hasOwnProperty;
function combineExtensions(e) {
  const t = {};
  let r = -1;
  for (; ++r < e.length; )
    syntaxExtension(t, e[r]);
  return t;
}
function syntaxExtension(e, t) {
  let r;
  for (r in t) {
    const o = (hasOwnProperty$1.call(e, r) ? e[r] : void 0) || (e[r] = {}), u = t[r];
    let c;
    if (u)
      for (c in u) {
        hasOwnProperty$1.call(o, c) || (o[c] = []);
        const d = u[c];
        constructs(
          // @ts-expect-error Looks like a list.
          o[c],
          Array.isArray(d) ? d : d ? [d] : []
        );
      }
  }
}
function constructs(e, t) {
  let r = -1;
  const a = [];
  for (; ++r < t.length; )
    (t[r].add === "after" ? e : a).push(t[r]);
  splice(e, 0, 0, a);
}
function decodeNumericCharacterReference(e, t) {
  const r = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    r < 9 || r === 11 || r > 13 && r < 32 || // Control character (DEL) of C0, and C1 controls.
    r > 126 && r < 160 || // Lone high surrogates and low surrogates.
    r > 55295 && r < 57344 || // Noncharacters.
    r > 64975 && r < 65008 || /* eslint-disable no-bitwise */
    (r & 65535) === 65535 || (r & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    r > 1114111 ? "" : String.fromCodePoint(r)
  );
}
function normalizeIdentifier(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const asciiAlpha = regexCheck(/[A-Za-z]/), asciiAlphanumeric = regexCheck(/[\dA-Za-z]/), asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const asciiDigit = regexCheck(/\d/), asciiHexDigit = regexCheck(/[\dA-Fa-f]/), asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(e) {
  return e !== null && e < -2;
}
function markdownLineEndingOrSpace(e) {
  return e !== null && (e < 0 || e === 32);
}
function markdownSpace(e) {
  return e === -2 || e === -1 || e === 32;
}
const unicodePunctuation = regexCheck(new RegExp("\\p{P}|\\p{S}", "u")), unicodeWhitespace = regexCheck(/\s/);
function regexCheck(e) {
  return t;
  function t(r) {
    return r !== null && r > -1 && e.test(String.fromCharCode(r));
  }
}
function normalizeUri(e) {
  const t = [];
  let r = -1, a = 0, o = 0;
  for (; ++r < e.length; ) {
    const u = e.charCodeAt(r);
    let c = "";
    if (u === 37 && asciiAlphanumeric(e.charCodeAt(r + 1)) && asciiAlphanumeric(e.charCodeAt(r + 2)))
      o = 2;
    else if (u < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(u)) || (c = String.fromCharCode(u));
    else if (u > 55295 && u < 57344) {
      const d = e.charCodeAt(r + 1);
      u < 56320 && d > 56319 && d < 57344 ? (c = String.fromCharCode(u, d), o = 1) : c = "";
    } else
      c = String.fromCharCode(u);
    c && (t.push(e.slice(a, r), encodeURIComponent(c)), a = r + o + 1, c = ""), o && (r += o, o = 0);
  }
  return t.join("") + e.slice(a);
}
function factorySpace(e, t, r, a) {
  const o = a ? a - 1 : Number.POSITIVE_INFINITY;
  let u = 0;
  return c;
  function c(g) {
    return markdownSpace(g) ? (e.enter(r), d(g)) : t(g);
  }
  function d(g) {
    return markdownSpace(g) && u++ < o ? (e.consume(g), d) : (e.exit(r), t(g));
  }
}
const content$1 = {
  tokenize: initializeContent
};
function initializeContent(e) {
  const t = e.attempt(this.parser.constructs.contentInitial, a, o);
  let r;
  return t;
  function a(d) {
    if (d === null) {
      e.consume(d);
      return;
    }
    return e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), factorySpace(e, t, "linePrefix");
  }
  function o(d) {
    return e.enter("paragraph"), u(d);
  }
  function u(d) {
    const g = e.enter("chunkText", {
      contentType: "text",
      previous: r
    });
    return r && (r.next = g), r = g, c(d);
  }
  function c(d) {
    if (d === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(d);
      return;
    }
    return markdownLineEnding(d) ? (e.consume(d), e.exit("chunkText"), u) : (e.consume(d), c);
  }
}
const document$2 = {
  tokenize: initializeDocument
}, containerConstruct = {
  tokenize: tokenizeContainer
};
function initializeDocument(e) {
  const t = this, r = [];
  let a = 0, o, u, c;
  return d;
  function d(N) {
    if (a < r.length) {
      const F = r[a];
      return t.containerState = F[1], e.attempt(F[0].continuation, g, b)(N);
    }
    return b(N);
  }
  function g(N) {
    if (a++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, o && w();
      const F = t.events.length;
      let M = F, x;
      for (; M--; )
        if (t.events[M][0] === "exit" && t.events[M][1].type === "chunkFlow") {
          x = t.events[M][1].end;
          break;
        }
      I(a);
      let P = F;
      for (; P < t.events.length; )
        t.events[P][1].end = Object.assign({}, x), P++;
      return splice(t.events, M + 1, 0, t.events.slice(F)), t.events.length = P, b(N);
    }
    return d(N);
  }
  function b(N) {
    if (a === r.length) {
      if (!o)
        return A(N);
      if (o.currentConstruct && o.currentConstruct.concrete)
        return v(N);
      t.interrupt = !!(o.currentConstruct && !o._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(containerConstruct, _, y)(N);
  }
  function _(N) {
    return o && w(), I(a), A(N);
  }
  function y(N) {
    return t.parser.lazy[t.now().line] = a !== r.length, c = t.now().offset, v(N);
  }
  function A(N) {
    return t.containerState = {}, e.attempt(containerConstruct, E, v)(N);
  }
  function E(N) {
    return a++, r.push([t.currentConstruct, t.containerState]), A(N);
  }
  function v(N) {
    if (N === null) {
      o && w(), I(0), e.consume(N);
      return;
    }
    return o = o || t.parser.flow(t.now()), e.enter("chunkFlow", {
      contentType: "flow",
      previous: u,
      _tokenizer: o
    }), C(N);
  }
  function C(N) {
    if (N === null) {
      R(e.exit("chunkFlow"), !0), I(0), e.consume(N);
      return;
    }
    return markdownLineEnding(N) ? (e.consume(N), R(e.exit("chunkFlow")), a = 0, t.interrupt = void 0, d) : (e.consume(N), C);
  }
  function R(N, F) {
    const M = t.sliceStream(N);
    if (F && M.push(null), N.previous = u, u && (u.next = N), u = N, o.defineSkip(N.start), o.write(M), t.parser.lazy[N.start.line]) {
      let x = o.events.length;
      for (; x--; )
        if (
          // The token starts before the line ending
          o.events[x][1].start.offset < c && // and either is not ended yet
          (!o.events[x][1].end || // or ends after it.
          o.events[x][1].end.offset > c)
        )
          return;
      const P = t.events.length;
      let U = P, L, H;
      for (; U--; )
        if (t.events[U][0] === "exit" && t.events[U][1].type === "chunkFlow") {
          if (L) {
            H = t.events[U][1].end;
            break;
          }
          L = !0;
        }
      for (I(a), x = P; x < t.events.length; )
        t.events[x][1].end = Object.assign({}, H), x++;
      splice(t.events, U + 1, 0, t.events.slice(P)), t.events.length = x;
    }
  }
  function I(N) {
    let F = r.length;
    for (; F-- > N; ) {
      const M = r[F];
      t.containerState = M[1], M[0].exit.call(t, e);
    }
    r.length = N;
  }
  function w() {
    o.write([null]), u = void 0, o = void 0, t.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(e, t, r) {
  return factorySpace(e, e.attempt(this.parser.constructs.document, t, r), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function classifyCharacter(e) {
  if (e === null || markdownLineEndingOrSpace(e) || unicodeWhitespace(e))
    return 1;
  if (unicodePunctuation(e))
    return 2;
}
function resolveAll(e, t, r) {
  const a = [];
  let o = -1;
  for (; ++o < e.length; ) {
    const u = e[o].resolveAll;
    u && !a.includes(u) && (t = u(t, r), a.push(u));
  }
  return t;
}
const attention = {
  name: "attention",
  resolveAll: resolveAllAttention,
  tokenize: tokenizeAttention
};
function resolveAllAttention(e, t) {
  let r = -1, a, o, u, c, d, g, b, _;
  for (; ++r < e.length; )
    if (e[r][0] === "enter" && e[r][1].type === "attentionSequence" && e[r][1]._close) {
      for (a = r; a--; )
        if (e[a][0] === "exit" && e[a][1].type === "attentionSequence" && e[a][1]._open && // If the markers are the same:
        t.sliceSerialize(e[a][1]).charCodeAt(0) === t.sliceSerialize(e[r][1]).charCodeAt(0)) {
          if ((e[a][1]._close || e[r][1]._open) && (e[r][1].end.offset - e[r][1].start.offset) % 3 && !((e[a][1].end.offset - e[a][1].start.offset + e[r][1].end.offset - e[r][1].start.offset) % 3))
            continue;
          g = e[a][1].end.offset - e[a][1].start.offset > 1 && e[r][1].end.offset - e[r][1].start.offset > 1 ? 2 : 1;
          const y = {
            ...e[a][1].end
          }, A = {
            ...e[r][1].start
          };
          movePoint(y, -g), movePoint(A, g), c = {
            type: g > 1 ? "strongSequence" : "emphasisSequence",
            start: y,
            end: {
              ...e[a][1].end
            }
          }, d = {
            type: g > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...e[r][1].start
            },
            end: A
          }, u = {
            type: g > 1 ? "strongText" : "emphasisText",
            start: {
              ...e[a][1].end
            },
            end: {
              ...e[r][1].start
            }
          }, o = {
            type: g > 1 ? "strong" : "emphasis",
            start: {
              ...c.start
            },
            end: {
              ...d.end
            }
          }, e[a][1].end = {
            ...c.start
          }, e[r][1].start = {
            ...d.end
          }, b = [], e[a][1].end.offset - e[a][1].start.offset && (b = push(b, [["enter", e[a][1], t], ["exit", e[a][1], t]])), b = push(b, [["enter", o, t], ["enter", c, t], ["exit", c, t], ["enter", u, t]]), b = push(b, resolveAll(t.parser.constructs.insideSpan.null, e.slice(a + 1, r), t)), b = push(b, [["exit", u, t], ["enter", d, t], ["exit", d, t], ["exit", o, t]]), e[r][1].end.offset - e[r][1].start.offset ? (_ = 2, b = push(b, [["enter", e[r][1], t], ["exit", e[r][1], t]])) : _ = 0, splice(e, a - 1, r - a + 3, b), r = a + b.length - _ - 2;
          break;
        }
    }
  for (r = -1; ++r < e.length; )
    e[r][1].type === "attentionSequence" && (e[r][1].type = "data");
  return e;
}
function tokenizeAttention(e, t) {
  const r = this.parser.constructs.attentionMarkers.null, a = this.previous, o = classifyCharacter(a);
  let u;
  return c;
  function c(g) {
    return u = g, e.enter("attentionSequence"), d(g);
  }
  function d(g) {
    if (g === u)
      return e.consume(g), d;
    const b = e.exit("attentionSequence"), _ = classifyCharacter(g), y = !_ || _ === 2 && o || r.includes(g), A = !o || o === 2 && _ || r.includes(a);
    return b._open = !!(u === 42 ? y : y && (o || !A)), b._close = !!(u === 42 ? A : A && (_ || !y)), t(g);
  }
}
function movePoint(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const autolink = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(e, t, r) {
  let a = 0;
  return o;
  function o(E) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(E), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), u;
  }
  function u(E) {
    return asciiAlpha(E) ? (e.consume(E), c) : E === 64 ? r(E) : b(E);
  }
  function c(E) {
    return E === 43 || E === 45 || E === 46 || asciiAlphanumeric(E) ? (a = 1, d(E)) : b(E);
  }
  function d(E) {
    return E === 58 ? (e.consume(E), a = 0, g) : (E === 43 || E === 45 || E === 46 || asciiAlphanumeric(E)) && a++ < 32 ? (e.consume(E), d) : (a = 0, b(E));
  }
  function g(E) {
    return E === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(E), e.exit("autolinkMarker"), e.exit("autolink"), t) : E === null || E === 32 || E === 60 || asciiControl(E) ? r(E) : (e.consume(E), g);
  }
  function b(E) {
    return E === 64 ? (e.consume(E), _) : asciiAtext(E) ? (e.consume(E), b) : r(E);
  }
  function _(E) {
    return asciiAlphanumeric(E) ? y(E) : r(E);
  }
  function y(E) {
    return E === 46 ? (e.consume(E), a = 0, _) : E === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(E), e.exit("autolinkMarker"), e.exit("autolink"), t) : A(E);
  }
  function A(E) {
    if ((E === 45 || asciiAlphanumeric(E)) && a++ < 63) {
      const v = E === 45 ? A : y;
      return e.consume(E), v;
    }
    return r(E);
  }
}
const blankLine = {
  partial: !0,
  tokenize: tokenizeBlankLine
};
function tokenizeBlankLine(e, t, r) {
  return a;
  function a(u) {
    return markdownSpace(u) ? factorySpace(e, o, "linePrefix")(u) : o(u);
  }
  function o(u) {
    return u === null || markdownLineEnding(u) ? t(u) : r(u);
  }
}
const blockQuote = {
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit: exit$2,
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart
};
function tokenizeBlockQuoteStart(e, t, r) {
  const a = this;
  return o;
  function o(c) {
    if (c === 62) {
      const d = a.containerState;
      return d.open || (e.enter("blockQuote", {
        _container: !0
      }), d.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(c), e.exit("blockQuoteMarker"), u;
    }
    return r(c);
  }
  function u(c) {
    return markdownSpace(c) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(c), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(c));
  }
}
function tokenizeBlockQuoteContinuation(e, t, r) {
  const a = this;
  return o;
  function o(c) {
    return markdownSpace(c) ? factorySpace(e, u, "linePrefix", a.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(c) : u(c);
  }
  function u(c) {
    return e.attempt(blockQuote, t, r)(c);
  }
}
function exit$2(e) {
  e.exit("blockQuote");
}
const characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(e, t, r) {
  return a;
  function a(u) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(u), e.exit("escapeMarker"), o;
  }
  function o(u) {
    return asciiPunctuation(u) ? (e.enter("characterEscapeValue"), e.consume(u), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : r(u);
  }
}
const characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(e, t, r) {
  const a = this;
  let o = 0, u, c;
  return d;
  function d(y) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(y), e.exit("characterReferenceMarker"), g;
  }
  function g(y) {
    return y === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(y), e.exit("characterReferenceMarkerNumeric"), b) : (e.enter("characterReferenceValue"), u = 31, c = asciiAlphanumeric, _(y));
  }
  function b(y) {
    return y === 88 || y === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(y), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), u = 6, c = asciiHexDigit, _) : (e.enter("characterReferenceValue"), u = 7, c = asciiDigit, _(y));
  }
  function _(y) {
    if (y === 59 && o) {
      const A = e.exit("characterReferenceValue");
      return c === asciiAlphanumeric && !decodeNamedCharacterReference(a.sliceSerialize(A)) ? r(y) : (e.enter("characterReferenceMarker"), e.consume(y), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return c(y) && o++ < u ? (e.consume(y), _) : r(y);
  }
}
const nonLazyContinuation$1 = {
  partial: !0,
  tokenize: tokenizeNonLazyContinuation$1
}, codeFenced = {
  concrete: !0,
  name: "codeFenced",
  tokenize: tokenizeCodeFenced
};
function tokenizeCodeFenced(e, t, r) {
  const a = this, o = {
    partial: !0,
    tokenize: M
  };
  let u = 0, c = 0, d;
  return g;
  function g(x) {
    return b(x);
  }
  function b(x) {
    const P = a.events[a.events.length - 1];
    return u = P && P[1].type === "linePrefix" ? P[2].sliceSerialize(P[1], !0).length : 0, d = x, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), _(x);
  }
  function _(x) {
    return x === d ? (c++, e.consume(x), _) : c < 3 ? r(x) : (e.exit("codeFencedFenceSequence"), markdownSpace(x) ? factorySpace(e, y, "whitespace")(x) : y(x));
  }
  function y(x) {
    return x === null || markdownLineEnding(x) ? (e.exit("codeFencedFence"), a.interrupt ? t(x) : e.check(nonLazyContinuation$1, C, F)(x)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), A(x));
  }
  function A(x) {
    return x === null || markdownLineEnding(x) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), y(x)) : markdownSpace(x) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), factorySpace(e, E, "whitespace")(x)) : x === 96 && x === d ? r(x) : (e.consume(x), A);
  }
  function E(x) {
    return x === null || markdownLineEnding(x) ? y(x) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), v(x));
  }
  function v(x) {
    return x === null || markdownLineEnding(x) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), y(x)) : x === 96 && x === d ? r(x) : (e.consume(x), v);
  }
  function C(x) {
    return e.attempt(o, F, R)(x);
  }
  function R(x) {
    return e.enter("lineEnding"), e.consume(x), e.exit("lineEnding"), I;
  }
  function I(x) {
    return u > 0 && markdownSpace(x) ? factorySpace(e, w, "linePrefix", u + 1)(x) : w(x);
  }
  function w(x) {
    return x === null || markdownLineEnding(x) ? e.check(nonLazyContinuation$1, C, F)(x) : (e.enter("codeFlowValue"), N(x));
  }
  function N(x) {
    return x === null || markdownLineEnding(x) ? (e.exit("codeFlowValue"), w(x)) : (e.consume(x), N);
  }
  function F(x) {
    return e.exit("codeFenced"), t(x);
  }
  function M(x, P, U) {
    let L = 0;
    return H;
    function H(Y) {
      return x.enter("lineEnding"), x.consume(Y), x.exit("lineEnding"), B;
    }
    function B(Y) {
      return x.enter("codeFencedFence"), markdownSpace(Y) ? factorySpace(x, V, "linePrefix", a.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(Y) : V(Y);
    }
    function V(Y) {
      return Y === d ? (x.enter("codeFencedFenceSequence"), X(Y)) : U(Y);
    }
    function X(Y) {
      return Y === d ? (L++, x.consume(Y), X) : L >= c ? (x.exit("codeFencedFenceSequence"), markdownSpace(Y) ? factorySpace(x, de, "whitespace")(Y) : de(Y)) : U(Y);
    }
    function de(Y) {
      return Y === null || markdownLineEnding(Y) ? (x.exit("codeFencedFence"), P(Y)) : U(Y);
    }
  }
}
function tokenizeNonLazyContinuation$1(e, t, r) {
  const a = this;
  return o;
  function o(c) {
    return c === null ? r(c) : (e.enter("lineEnding"), e.consume(c), e.exit("lineEnding"), u);
  }
  function u(c) {
    return a.parser.lazy[a.now().line] ? r(c) : t(c);
  }
}
const codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
}, furtherStart = {
  partial: !0,
  tokenize: tokenizeFurtherStart
};
function tokenizeCodeIndented(e, t, r) {
  const a = this;
  return o;
  function o(b) {
    return e.enter("codeIndented"), factorySpace(e, u, "linePrefix", 5)(b);
  }
  function u(b) {
    const _ = a.events[a.events.length - 1];
    return _ && _[1].type === "linePrefix" && _[2].sliceSerialize(_[1], !0).length >= 4 ? c(b) : r(b);
  }
  function c(b) {
    return b === null ? g(b) : markdownLineEnding(b) ? e.attempt(furtherStart, c, g)(b) : (e.enter("codeFlowValue"), d(b));
  }
  function d(b) {
    return b === null || markdownLineEnding(b) ? (e.exit("codeFlowValue"), c(b)) : (e.consume(b), d);
  }
  function g(b) {
    return e.exit("codeIndented"), t(b);
  }
}
function tokenizeFurtherStart(e, t, r) {
  const a = this;
  return o;
  function o(c) {
    return a.parser.lazy[a.now().line] ? r(c) : markdownLineEnding(c) ? (e.enter("lineEnding"), e.consume(c), e.exit("lineEnding"), o) : factorySpace(e, u, "linePrefix", 5)(c);
  }
  function u(c) {
    const d = a.events[a.events.length - 1];
    return d && d[1].type === "linePrefix" && d[2].sliceSerialize(d[1], !0).length >= 4 ? t(c) : markdownLineEnding(c) ? o(c) : r(c);
  }
}
const codeText = {
  name: "codeText",
  previous: previous$3,
  resolve: resolveCodeText,
  tokenize: tokenizeCodeText
};
function resolveCodeText(e) {
  let t = e.length - 4, r = 3, a, o;
  if ((e[r][1].type === "lineEnding" || e[r][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (a = r; ++a < t; )
      if (e[a][1].type === "codeTextData") {
        e[r][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", r += 2, t -= 2;
        break;
      }
  }
  for (a = r - 1, t++; ++a <= t; )
    o === void 0 ? a !== t && e[a][1].type !== "lineEnding" && (o = a) : (a === t || e[a][1].type === "lineEnding") && (e[o][1].type = "codeTextData", a !== o + 2 && (e[o][1].end = e[a - 1][1].end, e.splice(o + 2, a - o - 2), t -= a - o - 2, a = o + 2), o = void 0);
  return e;
}
function previous$3(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(e, t, r) {
  let a = 0, o, u;
  return c;
  function c(y) {
    return e.enter("codeText"), e.enter("codeTextSequence"), d(y);
  }
  function d(y) {
    return y === 96 ? (e.consume(y), a++, d) : (e.exit("codeTextSequence"), g(y));
  }
  function g(y) {
    return y === null ? r(y) : y === 32 ? (e.enter("space"), e.consume(y), e.exit("space"), g) : y === 96 ? (u = e.enter("codeTextSequence"), o = 0, _(y)) : markdownLineEnding(y) ? (e.enter("lineEnding"), e.consume(y), e.exit("lineEnding"), g) : (e.enter("codeTextData"), b(y));
  }
  function b(y) {
    return y === null || y === 32 || y === 96 || markdownLineEnding(y) ? (e.exit("codeTextData"), g(y)) : (e.consume(y), b);
  }
  function _(y) {
    return y === 96 ? (e.consume(y), o++, _) : o === a ? (e.exit("codeTextSequence"), e.exit("codeText"), t(y)) : (u.type = "codeTextData", b(y));
  }
}
class SpliceBuffer {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, r) {
    const a = r ?? Number.POSITIVE_INFINITY;
    return a < this.left.length ? this.left.slice(t, a) : t > this.left.length ? this.right.slice(this.right.length - a + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - a + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, r, a) {
    const o = r || 0;
    this.setCursor(Math.trunc(t));
    const u = this.right.splice(this.right.length - o, Number.POSITIVE_INFINITY);
    return a && chunkedPush(this.left, a), u.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), chunkedPush(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), chunkedPush(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const r = this.left.splice(t, Number.POSITIVE_INFINITY);
        chunkedPush(this.right, r.reverse());
      } else {
        const r = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        chunkedPush(this.left, r.reverse());
      }
  }
}
function chunkedPush(e, t) {
  let r = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; r < t.length; )
      e.push(...t.slice(r, r + 1e4)), r += 1e4;
}
function subtokenize(e) {
  const t = {};
  let r = -1, a, o, u, c, d, g, b;
  const _ = new SpliceBuffer(e);
  for (; ++r < _.length; ) {
    for (; r in t; )
      r = t[r];
    if (a = _.get(r), r && a[1].type === "chunkFlow" && _.get(r - 1)[1].type === "listItemPrefix" && (g = a[1]._tokenizer.events, u = 0, u < g.length && g[u][1].type === "lineEndingBlank" && (u += 2), u < g.length && g[u][1].type === "content"))
      for (; ++u < g.length && g[u][1].type !== "content"; )
        g[u][1].type === "chunkText" && (g[u][1]._isInFirstContentOfListItem = !0, u++);
    if (a[0] === "enter")
      a[1].contentType && (Object.assign(t, subcontent(_, r)), r = t[r], b = !0);
    else if (a[1]._container) {
      for (u = r, o = void 0; u--; )
        if (c = _.get(u), c[1].type === "lineEnding" || c[1].type === "lineEndingBlank")
          c[0] === "enter" && (o && (_.get(o)[1].type = "lineEndingBlank"), c[1].type = "lineEnding", o = u);
        else if (c[1].type !== "linePrefix") break;
      o && (a[1].end = {
        ..._.get(o)[1].start
      }, d = _.slice(o, r), d.unshift(a), _.splice(o, r - o + 1, d));
    }
  }
  return splice(e, 0, Number.POSITIVE_INFINITY, _.slice(0)), !b;
}
function subcontent(e, t) {
  const r = e.get(t)[1], a = e.get(t)[2];
  let o = t - 1;
  const u = [], c = r._tokenizer || a.parser[r.contentType](r.start), d = c.events, g = [], b = {};
  let _, y, A = -1, E = r, v = 0, C = 0;
  const R = [C];
  for (; E; ) {
    for (; e.get(++o)[1] !== E; )
      ;
    u.push(o), E._tokenizer || (_ = a.sliceStream(E), E.next || _.push(null), y && c.defineSkip(E.start), E._isInFirstContentOfListItem && (c._gfmTasklistFirstContentOfListItem = !0), c.write(_), E._isInFirstContentOfListItem && (c._gfmTasklistFirstContentOfListItem = void 0)), y = E, E = E.next;
  }
  for (E = r; ++A < d.length; )
    // Find a void token that includes a break.
    d[A][0] === "exit" && d[A - 1][0] === "enter" && d[A][1].type === d[A - 1][1].type && d[A][1].start.line !== d[A][1].end.line && (C = A + 1, R.push(C), E._tokenizer = void 0, E.previous = void 0, E = E.next);
  for (c.events = [], E ? (E._tokenizer = void 0, E.previous = void 0) : R.pop(), A = R.length; A--; ) {
    const I = d.slice(R[A], R[A + 1]), w = u.pop();
    g.push([w, w + I.length - 1]), e.splice(w, 2, I);
  }
  for (g.reverse(), A = -1; ++A < g.length; )
    b[v + g[A][0]] = v + g[A][1], v += g[A][1] - g[A][0] - 1;
  return b;
}
const content = {
  resolve: resolveContent,
  tokenize: tokenizeContent
}, continuationConstruct = {
  partial: !0,
  tokenize: tokenizeContinuation
};
function resolveContent(e) {
  return subtokenize(e), e;
}
function tokenizeContent(e, t) {
  let r;
  return a;
  function a(d) {
    return e.enter("content"), r = e.enter("chunkContent", {
      contentType: "content"
    }), o(d);
  }
  function o(d) {
    return d === null ? u(d) : markdownLineEnding(d) ? e.check(continuationConstruct, c, u)(d) : (e.consume(d), o);
  }
  function u(d) {
    return e.exit("chunkContent"), e.exit("content"), t(d);
  }
  function c(d) {
    return e.consume(d), e.exit("chunkContent"), r.next = e.enter("chunkContent", {
      contentType: "content",
      previous: r
    }), r = r.next, o;
  }
}
function tokenizeContinuation(e, t, r) {
  const a = this;
  return o;
  function o(c) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(c), e.exit("lineEnding"), factorySpace(e, u, "linePrefix");
  }
  function u(c) {
    if (c === null || markdownLineEnding(c))
      return r(c);
    const d = a.events[a.events.length - 1];
    return !a.parser.constructs.disable.null.includes("codeIndented") && d && d[1].type === "linePrefix" && d[2].sliceSerialize(d[1], !0).length >= 4 ? t(c) : e.interrupt(a.parser.constructs.flow, r, t)(c);
  }
}
function factoryDestination(e, t, r, a, o, u, c, d, g) {
  const b = g || Number.POSITIVE_INFINITY;
  let _ = 0;
  return y;
  function y(I) {
    return I === 60 ? (e.enter(a), e.enter(o), e.enter(u), e.consume(I), e.exit(u), A) : I === null || I === 32 || I === 41 || asciiControl(I) ? r(I) : (e.enter(a), e.enter(c), e.enter(d), e.enter("chunkString", {
      contentType: "string"
    }), C(I));
  }
  function A(I) {
    return I === 62 ? (e.enter(u), e.consume(I), e.exit(u), e.exit(o), e.exit(a), t) : (e.enter(d), e.enter("chunkString", {
      contentType: "string"
    }), E(I));
  }
  function E(I) {
    return I === 62 ? (e.exit("chunkString"), e.exit(d), A(I)) : I === null || I === 60 || markdownLineEnding(I) ? r(I) : (e.consume(I), I === 92 ? v : E);
  }
  function v(I) {
    return I === 60 || I === 62 || I === 92 ? (e.consume(I), E) : E(I);
  }
  function C(I) {
    return !_ && (I === null || I === 41 || markdownLineEndingOrSpace(I)) ? (e.exit("chunkString"), e.exit(d), e.exit(c), e.exit(a), t(I)) : _ < b && I === 40 ? (e.consume(I), _++, C) : I === 41 ? (e.consume(I), _--, C) : I === null || I === 32 || I === 40 || asciiControl(I) ? r(I) : (e.consume(I), I === 92 ? R : C);
  }
  function R(I) {
    return I === 40 || I === 41 || I === 92 ? (e.consume(I), C) : C(I);
  }
}
function factoryLabel$1(e, t, r, a, o, u) {
  const c = this;
  let d = 0, g;
  return b;
  function b(E) {
    return e.enter(a), e.enter(o), e.consume(E), e.exit(o), e.enter(u), _;
  }
  function _(E) {
    return d > 999 || E === null || E === 91 || E === 93 && !g || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    E === 94 && !d && "_hiddenFootnoteSupport" in c.parser.constructs ? r(E) : E === 93 ? (e.exit(u), e.enter(o), e.consume(E), e.exit(o), e.exit(a), t) : markdownLineEnding(E) ? (e.enter("lineEnding"), e.consume(E), e.exit("lineEnding"), _) : (e.enter("chunkString", {
      contentType: "string"
    }), y(E));
  }
  function y(E) {
    return E === null || E === 91 || E === 93 || markdownLineEnding(E) || d++ > 999 ? (e.exit("chunkString"), _(E)) : (e.consume(E), g || (g = !markdownSpace(E)), E === 92 ? A : y);
  }
  function A(E) {
    return E === 91 || E === 92 || E === 93 ? (e.consume(E), d++, y) : y(E);
  }
}
function factoryTitle(e, t, r, a, o, u) {
  let c;
  return d;
  function d(A) {
    return A === 34 || A === 39 || A === 40 ? (e.enter(a), e.enter(o), e.consume(A), e.exit(o), c = A === 40 ? 41 : A, g) : r(A);
  }
  function g(A) {
    return A === c ? (e.enter(o), e.consume(A), e.exit(o), e.exit(a), t) : (e.enter(u), b(A));
  }
  function b(A) {
    return A === c ? (e.exit(u), g(c)) : A === null ? r(A) : markdownLineEnding(A) ? (e.enter("lineEnding"), e.consume(A), e.exit("lineEnding"), factorySpace(e, b, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), _(A));
  }
  function _(A) {
    return A === c || A === null || markdownLineEnding(A) ? (e.exit("chunkString"), b(A)) : (e.consume(A), A === 92 ? y : _);
  }
  function y(A) {
    return A === c || A === 92 ? (e.consume(A), _) : _(A);
  }
}
function factoryWhitespace(e, t) {
  let r;
  return a;
  function a(o) {
    return markdownLineEnding(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), r = !0, a) : markdownSpace(o) ? factorySpace(e, a, r ? "linePrefix" : "lineSuffix")(o) : t(o);
  }
}
const definition$1 = {
  name: "definition",
  tokenize: tokenizeDefinition
}, titleBefore = {
  partial: !0,
  tokenize: tokenizeTitleBefore
};
function tokenizeDefinition(e, t, r) {
  const a = this;
  let o;
  return u;
  function u(E) {
    return e.enter("definition"), c(E);
  }
  function c(E) {
    return factoryLabel$1.call(
      a,
      e,
      d,
      // Note: we dont need to reset the way `markdown-rs` does.
      r,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(E);
  }
  function d(E) {
    return o = normalizeIdentifier(a.sliceSerialize(a.events[a.events.length - 1][1]).slice(1, -1)), E === 58 ? (e.enter("definitionMarker"), e.consume(E), e.exit("definitionMarker"), g) : r(E);
  }
  function g(E) {
    return markdownLineEndingOrSpace(E) ? factoryWhitespace(e, b)(E) : b(E);
  }
  function b(E) {
    return factoryDestination(
      e,
      _,
      // Note: we dont need to reset the way `markdown-rs` does.
      r,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(E);
  }
  function _(E) {
    return e.attempt(titleBefore, y, y)(E);
  }
  function y(E) {
    return markdownSpace(E) ? factorySpace(e, A, "whitespace")(E) : A(E);
  }
  function A(E) {
    return E === null || markdownLineEnding(E) ? (e.exit("definition"), a.parser.defined.push(o), t(E)) : r(E);
  }
}
function tokenizeTitleBefore(e, t, r) {
  return a;
  function a(d) {
    return markdownLineEndingOrSpace(d) ? factoryWhitespace(e, o)(d) : r(d);
  }
  function o(d) {
    return factoryTitle(e, u, r, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(d);
  }
  function u(d) {
    return markdownSpace(d) ? factorySpace(e, c, "whitespace")(d) : c(d);
  }
  function c(d) {
    return d === null || markdownLineEnding(d) ? t(d) : r(d);
  }
}
const hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(e, t, r) {
  return a;
  function a(u) {
    return e.enter("hardBreakEscape"), e.consume(u), o;
  }
  function o(u) {
    return markdownLineEnding(u) ? (e.exit("hardBreakEscape"), t(u)) : r(u);
  }
}
const headingAtx = {
  name: "headingAtx",
  resolve: resolveHeadingAtx,
  tokenize: tokenizeHeadingAtx
};
function resolveHeadingAtx(e, t) {
  let r = e.length - 2, a = 3, o, u;
  return e[a][1].type === "whitespace" && (a += 2), r - 2 > a && e[r][1].type === "whitespace" && (r -= 2), e[r][1].type === "atxHeadingSequence" && (a === r - 1 || r - 4 > a && e[r - 2][1].type === "whitespace") && (r -= a + 1 === r ? 2 : 4), r > a && (o = {
    type: "atxHeadingText",
    start: e[a][1].start,
    end: e[r][1].end
  }, u = {
    type: "chunkText",
    start: e[a][1].start,
    end: e[r][1].end,
    contentType: "text"
  }, splice(e, a, r - a + 1, [["enter", o, t], ["enter", u, t], ["exit", u, t], ["exit", o, t]])), e;
}
function tokenizeHeadingAtx(e, t, r) {
  let a = 0;
  return o;
  function o(_) {
    return e.enter("atxHeading"), u(_);
  }
  function u(_) {
    return e.enter("atxHeadingSequence"), c(_);
  }
  function c(_) {
    return _ === 35 && a++ < 6 ? (e.consume(_), c) : _ === null || markdownLineEndingOrSpace(_) ? (e.exit("atxHeadingSequence"), d(_)) : r(_);
  }
  function d(_) {
    return _ === 35 ? (e.enter("atxHeadingSequence"), g(_)) : _ === null || markdownLineEnding(_) ? (e.exit("atxHeading"), t(_)) : markdownSpace(_) ? factorySpace(e, d, "whitespace")(_) : (e.enter("atxHeadingText"), b(_));
  }
  function g(_) {
    return _ === 35 ? (e.consume(_), g) : (e.exit("atxHeadingSequence"), d(_));
  }
  function b(_) {
    return _ === null || _ === 35 || markdownLineEndingOrSpace(_) ? (e.exit("atxHeadingText"), d(_)) : (e.consume(_), b);
  }
}
const htmlBlockNames = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "search", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"], htmlRawNames = ["pre", "script", "style", "textarea"], htmlFlow = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: resolveToHtmlFlow,
  tokenize: tokenizeHtmlFlow
}, blankLineBefore = {
  partial: !0,
  tokenize: tokenizeBlankLineBefore
}, nonLazyContinuationStart = {
  partial: !0,
  tokenize: tokenizeNonLazyContinuationStart
};
function resolveToHtmlFlow(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function tokenizeHtmlFlow(e, t, r) {
  const a = this;
  let o, u, c, d, g;
  return b;
  function b(O) {
    return _(O);
  }
  function _(O) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(O), y;
  }
  function y(O) {
    return O === 33 ? (e.consume(O), A) : O === 47 ? (e.consume(O), u = !0, C) : O === 63 ? (e.consume(O), o = 3, a.interrupt ? t : j) : asciiAlpha(O) ? (e.consume(O), c = String.fromCharCode(O), R) : r(O);
  }
  function A(O) {
    return O === 45 ? (e.consume(O), o = 2, E) : O === 91 ? (e.consume(O), o = 5, d = 0, v) : asciiAlpha(O) ? (e.consume(O), o = 4, a.interrupt ? t : j) : r(O);
  }
  function E(O) {
    return O === 45 ? (e.consume(O), a.interrupt ? t : j) : r(O);
  }
  function v(O) {
    const z = "CDATA[";
    return O === z.charCodeAt(d++) ? (e.consume(O), d === z.length ? a.interrupt ? t : V : v) : r(O);
  }
  function C(O) {
    return asciiAlpha(O) ? (e.consume(O), c = String.fromCharCode(O), R) : r(O);
  }
  function R(O) {
    if (O === null || O === 47 || O === 62 || markdownLineEndingOrSpace(O)) {
      const z = O === 47, W = c.toLowerCase();
      return !z && !u && htmlRawNames.includes(W) ? (o = 1, a.interrupt ? t(O) : V(O)) : htmlBlockNames.includes(c.toLowerCase()) ? (o = 6, z ? (e.consume(O), I) : a.interrupt ? t(O) : V(O)) : (o = 7, a.interrupt && !a.parser.lazy[a.now().line] ? r(O) : u ? w(O) : N(O));
    }
    return O === 45 || asciiAlphanumeric(O) ? (e.consume(O), c += String.fromCharCode(O), R) : r(O);
  }
  function I(O) {
    return O === 62 ? (e.consume(O), a.interrupt ? t : V) : r(O);
  }
  function w(O) {
    return markdownSpace(O) ? (e.consume(O), w) : H(O);
  }
  function N(O) {
    return O === 47 ? (e.consume(O), H) : O === 58 || O === 95 || asciiAlpha(O) ? (e.consume(O), F) : markdownSpace(O) ? (e.consume(O), N) : H(O);
  }
  function F(O) {
    return O === 45 || O === 46 || O === 58 || O === 95 || asciiAlphanumeric(O) ? (e.consume(O), F) : M(O);
  }
  function M(O) {
    return O === 61 ? (e.consume(O), x) : markdownSpace(O) ? (e.consume(O), M) : N(O);
  }
  function x(O) {
    return O === null || O === 60 || O === 61 || O === 62 || O === 96 ? r(O) : O === 34 || O === 39 ? (e.consume(O), g = O, P) : markdownSpace(O) ? (e.consume(O), x) : U(O);
  }
  function P(O) {
    return O === g ? (e.consume(O), g = null, L) : O === null || markdownLineEnding(O) ? r(O) : (e.consume(O), P);
  }
  function U(O) {
    return O === null || O === 34 || O === 39 || O === 47 || O === 60 || O === 61 || O === 62 || O === 96 || markdownLineEndingOrSpace(O) ? M(O) : (e.consume(O), U);
  }
  function L(O) {
    return O === 47 || O === 62 || markdownSpace(O) ? N(O) : r(O);
  }
  function H(O) {
    return O === 62 ? (e.consume(O), B) : r(O);
  }
  function B(O) {
    return O === null || markdownLineEnding(O) ? V(O) : markdownSpace(O) ? (e.consume(O), B) : r(O);
  }
  function V(O) {
    return O === 45 && o === 2 ? (e.consume(O), se) : O === 60 && o === 1 ? (e.consume(O), ue) : O === 62 && o === 4 ? (e.consume(O), le) : O === 63 && o === 3 ? (e.consume(O), j) : O === 93 && o === 5 ? (e.consume(O), J) : markdownLineEnding(O) && (o === 6 || o === 7) ? (e.exit("htmlFlowData"), e.check(blankLineBefore, Z, X)(O)) : O === null || markdownLineEnding(O) ? (e.exit("htmlFlowData"), X(O)) : (e.consume(O), V);
  }
  function X(O) {
    return e.check(nonLazyContinuationStart, de, Z)(O);
  }
  function de(O) {
    return e.enter("lineEnding"), e.consume(O), e.exit("lineEnding"), Y;
  }
  function Y(O) {
    return O === null || markdownLineEnding(O) ? X(O) : (e.enter("htmlFlowData"), V(O));
  }
  function se(O) {
    return O === 45 ? (e.consume(O), j) : V(O);
  }
  function ue(O) {
    return O === 47 ? (e.consume(O), c = "", pe) : V(O);
  }
  function pe(O) {
    if (O === 62) {
      const z = c.toLowerCase();
      return htmlRawNames.includes(z) ? (e.consume(O), le) : V(O);
    }
    return asciiAlpha(O) && c.length < 8 ? (e.consume(O), c += String.fromCharCode(O), pe) : V(O);
  }
  function J(O) {
    return O === 93 ? (e.consume(O), j) : V(O);
  }
  function j(O) {
    return O === 62 ? (e.consume(O), le) : O === 45 && o === 2 ? (e.consume(O), j) : V(O);
  }
  function le(O) {
    return O === null || markdownLineEnding(O) ? (e.exit("htmlFlowData"), Z(O)) : (e.consume(O), le);
  }
  function Z(O) {
    return e.exit("htmlFlow"), t(O);
  }
}
function tokenizeNonLazyContinuationStart(e, t, r) {
  const a = this;
  return o;
  function o(c) {
    return markdownLineEnding(c) ? (e.enter("lineEnding"), e.consume(c), e.exit("lineEnding"), u) : r(c);
  }
  function u(c) {
    return a.parser.lazy[a.now().line] ? r(c) : t(c);
  }
}
function tokenizeBlankLineBefore(e, t, r) {
  return a;
  function a(o) {
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), e.attempt(blankLine, t, r);
  }
}
const htmlText = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(e, t, r) {
  const a = this;
  let o, u, c;
  return d;
  function d(j) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(j), g;
  }
  function g(j) {
    return j === 33 ? (e.consume(j), b) : j === 47 ? (e.consume(j), M) : j === 63 ? (e.consume(j), N) : asciiAlpha(j) ? (e.consume(j), U) : r(j);
  }
  function b(j) {
    return j === 45 ? (e.consume(j), _) : j === 91 ? (e.consume(j), u = 0, v) : asciiAlpha(j) ? (e.consume(j), w) : r(j);
  }
  function _(j) {
    return j === 45 ? (e.consume(j), E) : r(j);
  }
  function y(j) {
    return j === null ? r(j) : j === 45 ? (e.consume(j), A) : markdownLineEnding(j) ? (c = y, ue(j)) : (e.consume(j), y);
  }
  function A(j) {
    return j === 45 ? (e.consume(j), E) : y(j);
  }
  function E(j) {
    return j === 62 ? se(j) : j === 45 ? A(j) : y(j);
  }
  function v(j) {
    const le = "CDATA[";
    return j === le.charCodeAt(u++) ? (e.consume(j), u === le.length ? C : v) : r(j);
  }
  function C(j) {
    return j === null ? r(j) : j === 93 ? (e.consume(j), R) : markdownLineEnding(j) ? (c = C, ue(j)) : (e.consume(j), C);
  }
  function R(j) {
    return j === 93 ? (e.consume(j), I) : C(j);
  }
  function I(j) {
    return j === 62 ? se(j) : j === 93 ? (e.consume(j), I) : C(j);
  }
  function w(j) {
    return j === null || j === 62 ? se(j) : markdownLineEnding(j) ? (c = w, ue(j)) : (e.consume(j), w);
  }
  function N(j) {
    return j === null ? r(j) : j === 63 ? (e.consume(j), F) : markdownLineEnding(j) ? (c = N, ue(j)) : (e.consume(j), N);
  }
  function F(j) {
    return j === 62 ? se(j) : N(j);
  }
  function M(j) {
    return asciiAlpha(j) ? (e.consume(j), x) : r(j);
  }
  function x(j) {
    return j === 45 || asciiAlphanumeric(j) ? (e.consume(j), x) : P(j);
  }
  function P(j) {
    return markdownLineEnding(j) ? (c = P, ue(j)) : markdownSpace(j) ? (e.consume(j), P) : se(j);
  }
  function U(j) {
    return j === 45 || asciiAlphanumeric(j) ? (e.consume(j), U) : j === 47 || j === 62 || markdownLineEndingOrSpace(j) ? L(j) : r(j);
  }
  function L(j) {
    return j === 47 ? (e.consume(j), se) : j === 58 || j === 95 || asciiAlpha(j) ? (e.consume(j), H) : markdownLineEnding(j) ? (c = L, ue(j)) : markdownSpace(j) ? (e.consume(j), L) : se(j);
  }
  function H(j) {
    return j === 45 || j === 46 || j === 58 || j === 95 || asciiAlphanumeric(j) ? (e.consume(j), H) : B(j);
  }
  function B(j) {
    return j === 61 ? (e.consume(j), V) : markdownLineEnding(j) ? (c = B, ue(j)) : markdownSpace(j) ? (e.consume(j), B) : L(j);
  }
  function V(j) {
    return j === null || j === 60 || j === 61 || j === 62 || j === 96 ? r(j) : j === 34 || j === 39 ? (e.consume(j), o = j, X) : markdownLineEnding(j) ? (c = V, ue(j)) : markdownSpace(j) ? (e.consume(j), V) : (e.consume(j), de);
  }
  function X(j) {
    return j === o ? (e.consume(j), o = void 0, Y) : j === null ? r(j) : markdownLineEnding(j) ? (c = X, ue(j)) : (e.consume(j), X);
  }
  function de(j) {
    return j === null || j === 34 || j === 39 || j === 60 || j === 61 || j === 96 ? r(j) : j === 47 || j === 62 || markdownLineEndingOrSpace(j) ? L(j) : (e.consume(j), de);
  }
  function Y(j) {
    return j === 47 || j === 62 || markdownLineEndingOrSpace(j) ? L(j) : r(j);
  }
  function se(j) {
    return j === 62 ? (e.consume(j), e.exit("htmlTextData"), e.exit("htmlText"), t) : r(j);
  }
  function ue(j) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(j), e.exit("lineEnding"), pe;
  }
  function pe(j) {
    return markdownSpace(j) ? factorySpace(e, J, "linePrefix", a.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(j) : J(j);
  }
  function J(j) {
    return e.enter("htmlTextData"), c(j);
  }
}
const labelEnd = {
  name: "labelEnd",
  resolveAll: resolveAllLabelEnd,
  resolveTo: resolveToLabelEnd,
  tokenize: tokenizeLabelEnd
}, resourceConstruct = {
  tokenize: tokenizeResource
}, referenceFullConstruct = {
  tokenize: tokenizeReferenceFull
}, referenceCollapsedConstruct = {
  tokenize: tokenizeReferenceCollapsed
};
function resolveAllLabelEnd(e) {
  let t = -1;
  const r = [];
  for (; ++t < e.length; ) {
    const a = e[t][1];
    if (r.push(e[t]), a.type === "labelImage" || a.type === "labelLink" || a.type === "labelEnd") {
      const o = a.type === "labelImage" ? 4 : 2;
      a.type = "data", t += o;
    }
  }
  return e.length !== r.length && splice(e, 0, e.length, r), e;
}
function resolveToLabelEnd(e, t) {
  let r = e.length, a = 0, o, u, c, d;
  for (; r--; )
    if (o = e[r][1], u) {
      if (o.type === "link" || o.type === "labelLink" && o._inactive)
        break;
      e[r][0] === "enter" && o.type === "labelLink" && (o._inactive = !0);
    } else if (c) {
      if (e[r][0] === "enter" && (o.type === "labelImage" || o.type === "labelLink") && !o._balanced && (u = r, o.type !== "labelLink")) {
        a = 2;
        break;
      }
    } else o.type === "labelEnd" && (c = r);
  const g = {
    type: e[u][1].type === "labelLink" ? "link" : "image",
    start: {
      ...e[u][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  }, b = {
    type: "label",
    start: {
      ...e[u][1].start
    },
    end: {
      ...e[c][1].end
    }
  }, _ = {
    type: "labelText",
    start: {
      ...e[u + a + 2][1].end
    },
    end: {
      ...e[c - 2][1].start
    }
  };
  return d = [["enter", g, t], ["enter", b, t]], d = push(d, e.slice(u + 1, u + a + 3)), d = push(d, [["enter", _, t]]), d = push(d, resolveAll(t.parser.constructs.insideSpan.null, e.slice(u + a + 4, c - 3), t)), d = push(d, [["exit", _, t], e[c - 2], e[c - 1], ["exit", b, t]]), d = push(d, e.slice(c + 1)), d = push(d, [["exit", g, t]]), splice(e, u, e.length, d), e;
}
function tokenizeLabelEnd(e, t, r) {
  const a = this;
  let o = a.events.length, u, c;
  for (; o--; )
    if ((a.events[o][1].type === "labelImage" || a.events[o][1].type === "labelLink") && !a.events[o][1]._balanced) {
      u = a.events[o][1];
      break;
    }
  return d;
  function d(A) {
    return u ? u._inactive ? y(A) : (c = a.parser.defined.includes(normalizeIdentifier(a.sliceSerialize({
      start: u.end,
      end: a.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(A), e.exit("labelMarker"), e.exit("labelEnd"), g) : r(A);
  }
  function g(A) {
    return A === 40 ? e.attempt(resourceConstruct, _, c ? _ : y)(A) : A === 91 ? e.attempt(referenceFullConstruct, _, c ? b : y)(A) : c ? _(A) : y(A);
  }
  function b(A) {
    return e.attempt(referenceCollapsedConstruct, _, y)(A);
  }
  function _(A) {
    return t(A);
  }
  function y(A) {
    return u._balanced = !0, r(A);
  }
}
function tokenizeResource(e, t, r) {
  return a;
  function a(y) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(y), e.exit("resourceMarker"), o;
  }
  function o(y) {
    return markdownLineEndingOrSpace(y) ? factoryWhitespace(e, u)(y) : u(y);
  }
  function u(y) {
    return y === 41 ? _(y) : factoryDestination(e, c, d, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(y);
  }
  function c(y) {
    return markdownLineEndingOrSpace(y) ? factoryWhitespace(e, g)(y) : _(y);
  }
  function d(y) {
    return r(y);
  }
  function g(y) {
    return y === 34 || y === 39 || y === 40 ? factoryTitle(e, b, r, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(y) : _(y);
  }
  function b(y) {
    return markdownLineEndingOrSpace(y) ? factoryWhitespace(e, _)(y) : _(y);
  }
  function _(y) {
    return y === 41 ? (e.enter("resourceMarker"), e.consume(y), e.exit("resourceMarker"), e.exit("resource"), t) : r(y);
  }
}
function tokenizeReferenceFull(e, t, r) {
  const a = this;
  return o;
  function o(d) {
    return factoryLabel$1.call(a, e, u, c, "reference", "referenceMarker", "referenceString")(d);
  }
  function u(d) {
    return a.parser.defined.includes(normalizeIdentifier(a.sliceSerialize(a.events[a.events.length - 1][1]).slice(1, -1))) ? t(d) : r(d);
  }
  function c(d) {
    return r(d);
  }
}
function tokenizeReferenceCollapsed(e, t, r) {
  return a;
  function a(u) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(u), e.exit("referenceMarker"), o;
  }
  function o(u) {
    return u === 93 ? (e.enter("referenceMarker"), e.consume(u), e.exit("referenceMarker"), e.exit("reference"), t) : r(u);
  }
}
const labelStartImage = {
  name: "labelStartImage",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartImage
};
function tokenizeLabelStartImage(e, t, r) {
  const a = this;
  return o;
  function o(d) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(d), e.exit("labelImageMarker"), u;
  }
  function u(d) {
    return d === 91 ? (e.enter("labelMarker"), e.consume(d), e.exit("labelMarker"), e.exit("labelImage"), c) : r(d);
  }
  function c(d) {
    return d === 94 && "_hiddenFootnoteSupport" in a.parser.constructs ? r(d) : t(d);
  }
}
const labelStartLink = {
  name: "labelStartLink",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartLink
};
function tokenizeLabelStartLink(e, t, r) {
  const a = this;
  return o;
  function o(c) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(c), e.exit("labelMarker"), e.exit("labelLink"), u;
  }
  function u(c) {
    return c === 94 && "_hiddenFootnoteSupport" in a.parser.constructs ? r(c) : t(c);
  }
}
const lineEnding = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(e, t) {
  return r;
  function r(a) {
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), factorySpace(e, t, "linePrefix");
  }
}
const thematicBreak$2 = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(e, t, r) {
  let a = 0, o;
  return u;
  function u(b) {
    return e.enter("thematicBreak"), c(b);
  }
  function c(b) {
    return o = b, d(b);
  }
  function d(b) {
    return b === o ? (e.enter("thematicBreakSequence"), g(b)) : a >= 3 && (b === null || markdownLineEnding(b)) ? (e.exit("thematicBreak"), t(b)) : r(b);
  }
  function g(b) {
    return b === o ? (e.consume(b), a++, g) : (e.exit("thematicBreakSequence"), markdownSpace(b) ? factorySpace(e, d, "whitespace")(b) : d(b));
  }
}
const list$2 = {
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd,
  name: "list",
  tokenize: tokenizeListStart
}, listItemPrefixWhitespaceConstruct = {
  partial: !0,
  tokenize: tokenizeListItemPrefixWhitespace
}, indentConstruct = {
  partial: !0,
  tokenize: tokenizeIndent$1
};
function tokenizeListStart(e, t, r) {
  const a = this, o = a.events[a.events.length - 1];
  let u = o && o[1].type === "linePrefix" ? o[2].sliceSerialize(o[1], !0).length : 0, c = 0;
  return d;
  function d(E) {
    const v = a.containerState.type || (E === 42 || E === 43 || E === 45 ? "listUnordered" : "listOrdered");
    if (v === "listUnordered" ? !a.containerState.marker || E === a.containerState.marker : asciiDigit(E)) {
      if (a.containerState.type || (a.containerState.type = v, e.enter(v, {
        _container: !0
      })), v === "listUnordered")
        return e.enter("listItemPrefix"), E === 42 || E === 45 ? e.check(thematicBreak$2, r, b)(E) : b(E);
      if (!a.interrupt || E === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), g(E);
    }
    return r(E);
  }
  function g(E) {
    return asciiDigit(E) && ++c < 10 ? (e.consume(E), g) : (!a.interrupt || c < 2) && (a.containerState.marker ? E === a.containerState.marker : E === 41 || E === 46) ? (e.exit("listItemValue"), b(E)) : r(E);
  }
  function b(E) {
    return e.enter("listItemMarker"), e.consume(E), e.exit("listItemMarker"), a.containerState.marker = a.containerState.marker || E, e.check(
      blankLine,
      // Cant be empty when interrupting.
      a.interrupt ? r : _,
      e.attempt(listItemPrefixWhitespaceConstruct, A, y)
    );
  }
  function _(E) {
    return a.containerState.initialBlankLine = !0, u++, A(E);
  }
  function y(E) {
    return markdownSpace(E) ? (e.enter("listItemPrefixWhitespace"), e.consume(E), e.exit("listItemPrefixWhitespace"), A) : r(E);
  }
  function A(E) {
    return a.containerState.size = u + a.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(E);
  }
}
function tokenizeListContinuation(e, t, r) {
  const a = this;
  return a.containerState._closeFlow = void 0, e.check(blankLine, o, u);
  function o(d) {
    return a.containerState.furtherBlankLines = a.containerState.furtherBlankLines || a.containerState.initialBlankLine, factorySpace(e, t, "listItemIndent", a.containerState.size + 1)(d);
  }
  function u(d) {
    return a.containerState.furtherBlankLines || !markdownSpace(d) ? (a.containerState.furtherBlankLines = void 0, a.containerState.initialBlankLine = void 0, c(d)) : (a.containerState.furtherBlankLines = void 0, a.containerState.initialBlankLine = void 0, e.attempt(indentConstruct, t, c)(d));
  }
  function c(d) {
    return a.containerState._closeFlow = !0, a.interrupt = void 0, factorySpace(e, e.attempt(list$2, t, r), "linePrefix", a.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(d);
  }
}
function tokenizeIndent$1(e, t, r) {
  const a = this;
  return factorySpace(e, o, "listItemIndent", a.containerState.size + 1);
  function o(u) {
    const c = a.events[a.events.length - 1];
    return c && c[1].type === "listItemIndent" && c[2].sliceSerialize(c[1], !0).length === a.containerState.size ? t(u) : r(u);
  }
}
function tokenizeListEnd(e) {
  e.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(e, t, r) {
  const a = this;
  return factorySpace(e, o, "listItemPrefixWhitespace", a.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function o(u) {
    const c = a.events[a.events.length - 1];
    return !markdownSpace(u) && c && c[1].type === "listItemPrefixWhitespace" ? t(u) : r(u);
  }
}
const setextUnderline = {
  name: "setextUnderline",
  resolveTo: resolveToSetextUnderline,
  tokenize: tokenizeSetextUnderline
};
function resolveToSetextUnderline(e, t) {
  let r = e.length, a, o, u;
  for (; r--; )
    if (e[r][0] === "enter") {
      if (e[r][1].type === "content") {
        a = r;
        break;
      }
      e[r][1].type === "paragraph" && (o = r);
    } else
      e[r][1].type === "content" && e.splice(r, 1), !u && e[r][1].type === "definition" && (u = r);
  const c = {
    type: "setextHeading",
    start: {
      ...e[o][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  };
  return e[o][1].type = "setextHeadingText", u ? (e.splice(o, 0, ["enter", c, t]), e.splice(u + 1, 0, ["exit", e[a][1], t]), e[a][1].end = {
    ...e[u][1].end
  }) : e[a][1] = c, e.push(["exit", c, t]), e;
}
function tokenizeSetextUnderline(e, t, r) {
  const a = this;
  let o;
  return u;
  function u(b) {
    let _ = a.events.length, y;
    for (; _--; )
      if (a.events[_][1].type !== "lineEnding" && a.events[_][1].type !== "linePrefix" && a.events[_][1].type !== "content") {
        y = a.events[_][1].type === "paragraph";
        break;
      }
    return !a.parser.lazy[a.now().line] && (a.interrupt || y) ? (e.enter("setextHeadingLine"), o = b, c(b)) : r(b);
  }
  function c(b) {
    return e.enter("setextHeadingLineSequence"), d(b);
  }
  function d(b) {
    return b === o ? (e.consume(b), d) : (e.exit("setextHeadingLineSequence"), markdownSpace(b) ? factorySpace(e, g, "lineSuffix")(b) : g(b));
  }
  function g(b) {
    return b === null || markdownLineEnding(b) ? (e.exit("setextHeadingLine"), t(b)) : r(b);
  }
}
const flow$1 = {
  tokenize: initializeFlow
};
function initializeFlow(e) {
  const t = this, r = e.attempt(
    // Try to parse a blank line.
    blankLine,
    a,
    // Try to parse initial flow (essentially, only code).
    e.attempt(this.parser.constructs.flowInitial, o, factorySpace(e, e.attempt(this.parser.constructs.flow, o, e.attempt(content, o)), "linePrefix"))
  );
  return r;
  function a(u) {
    if (u === null) {
      e.consume(u);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(u), e.exit("lineEndingBlank"), t.currentConstruct = void 0, r;
  }
  function o(u) {
    if (u === null) {
      e.consume(u);
      return;
    }
    return e.enter("lineEnding"), e.consume(u), e.exit("lineEnding"), t.currentConstruct = void 0, r;
  }
}
const resolver = {
  resolveAll: createResolver()
}, string$1 = initializeFactory("string"), text$a = initializeFactory("text");
function initializeFactory(e) {
  return {
    tokenize: t,
    resolveAll: createResolver(e === "text" ? resolveAllLineSuffixes : void 0)
  };
  function t(r) {
    const a = this, o = this.parser.constructs[e], u = r.attempt(o, c, d);
    return c;
    function c(_) {
      return b(_) ? u(_) : d(_);
    }
    function d(_) {
      if (_ === null) {
        r.consume(_);
        return;
      }
      return r.enter("data"), r.consume(_), g;
    }
    function g(_) {
      return b(_) ? (r.exit("data"), u(_)) : (r.consume(_), g);
    }
    function b(_) {
      if (_ === null)
        return !0;
      const y = o[_];
      let A = -1;
      if (y)
        for (; ++A < y.length; ) {
          const E = y[A];
          if (!E.previous || E.previous.call(a, a.previous))
            return !0;
        }
      return !1;
    }
  }
}
function createResolver(e) {
  return t;
  function t(r, a) {
    let o = -1, u;
    for (; ++o <= r.length; )
      u === void 0 ? r[o] && r[o][1].type === "data" && (u = o, o++) : (!r[o] || r[o][1].type !== "data") && (o !== u + 2 && (r[u][1].end = r[o - 1][1].end, r.splice(u + 2, o - u - 2), o = u + 2), u = void 0);
    return e ? e(r, a) : r;
  }
}
function resolveAllLineSuffixes(e, t) {
  let r = 0;
  for (; ++r <= e.length; )
    if ((r === e.length || e[r][1].type === "lineEnding") && e[r - 1][1].type === "data") {
      const a = e[r - 1][1], o = t.sliceStream(a);
      let u = o.length, c = -1, d = 0, g;
      for (; u--; ) {
        const b = o[u];
        if (typeof b == "string") {
          for (c = b.length; b.charCodeAt(c - 1) === 32; )
            d++, c--;
          if (c) break;
          c = -1;
        } else if (b === -2)
          g = !0, d++;
        else if (b !== -1) {
          u++;
          break;
        }
      }
      if (d) {
        const b = {
          type: r === e.length || g || d < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: a.end.line,
            column: a.end.column - d,
            offset: a.end.offset - d,
            _index: a.start._index + u,
            _bufferIndex: u ? c : a.start._bufferIndex + c
          },
          end: Object.assign({}, a.end)
        };
        a.end = Object.assign({}, b.start), a.start.offset === a.end.offset ? Object.assign(a, b) : (e.splice(r, 0, ["enter", b, t], ["exit", b, t]), r += 2);
      }
      r++;
    }
  return e;
}
function createTokenizer(e, t, r) {
  let a = Object.assign(r ? Object.assign({}, r) : {
    line: 1,
    column: 1,
    offset: 0
  }, {
    _index: 0,
    _bufferIndex: -1
  });
  const o = {}, u = [];
  let c = [], d = [];
  const g = {
    consume: w,
    enter: N,
    exit: F,
    attempt: P(M),
    check: P(x),
    interrupt: P(x, {
      interrupt: !0
    })
  }, b = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: e,
    sliceStream: E,
    sliceSerialize: A,
    now: v,
    defineSkip: C,
    write: y
  };
  let _ = t.tokenize.call(b, g);
  return t.resolveAll && u.push(t), b;
  function y(B) {
    return c = push(c, B), R(), c[c.length - 1] !== null ? [] : (U(t, 0), b.events = resolveAll(u, b.events, b), b.events);
  }
  function A(B, V) {
    return serializeChunks(E(B), V);
  }
  function E(B) {
    return sliceChunks(c, B);
  }
  function v() {
    const {
      line: B,
      column: V,
      offset: X,
      _index: de,
      _bufferIndex: Y
    } = a;
    return {
      line: B,
      column: V,
      offset: X,
      _index: de,
      _bufferIndex: Y
    };
  }
  function C(B) {
    o[B.line] = B.column, H();
  }
  function R() {
    let B;
    for (; a._index < c.length; ) {
      const V = c[a._index];
      if (typeof V == "string")
        for (B = a._index, a._bufferIndex < 0 && (a._bufferIndex = 0); a._index === B && a._bufferIndex < V.length; )
          I(V.charCodeAt(a._bufferIndex));
      else
        I(V);
    }
  }
  function I(B) {
    _ = _(B);
  }
  function w(B) {
    markdownLineEnding(B) ? (a.line++, a.column = 1, a.offset += B === -3 ? 2 : 1, H()) : B !== -1 && (a.column++, a.offset++), a._bufferIndex < 0 ? a._index++ : (a._bufferIndex++, a._bufferIndex === c[a._index].length && (a._bufferIndex = -1, a._index++)), b.previous = B;
  }
  function N(B, V) {
    const X = V || {};
    return X.type = B, X.start = v(), b.events.push(["enter", X, b]), d.push(X), X;
  }
  function F(B) {
    const V = d.pop();
    return V.end = v(), b.events.push(["exit", V, b]), V;
  }
  function M(B, V) {
    U(B, V.from);
  }
  function x(B, V) {
    V.restore();
  }
  function P(B, V) {
    return X;
    function X(de, Y, se) {
      let ue, pe, J, j;
      return Array.isArray(de) ? Z(de) : "tokenize" in de ? (
        // @ts-expect-error Looks like a construct.
        Z([de])
      ) : le(de);
      function le(ee) {
        return ae;
        function ae(ie) {
          const me = ie !== null && ee[ie], ye = ie !== null && ee.null, Re = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(me) ? me : me ? [me] : [],
            ...Array.isArray(ye) ? ye : ye ? [ye] : []
          ];
          return Z(Re)(ie);
        }
      }
      function Z(ee) {
        return ue = ee, pe = 0, ee.length === 0 ? se : O(ee[pe]);
      }
      function O(ee) {
        return ae;
        function ae(ie) {
          return j = L(), J = ee, ee.partial || (b.currentConstruct = ee), ee.name && b.parser.constructs.disable.null.includes(ee.name) ? W() : ee.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            V ? Object.assign(Object.create(b), V) : b,
            g,
            z,
            W
          )(ie);
        }
      }
      function z(ee) {
        return B(J, j), Y;
      }
      function W(ee) {
        return j.restore(), ++pe < ue.length ? O(ue[pe]) : se;
      }
    }
  }
  function U(B, V) {
    B.resolveAll && !u.includes(B) && u.push(B), B.resolve && splice(b.events, V, b.events.length - V, B.resolve(b.events.slice(V), b)), B.resolveTo && (b.events = B.resolveTo(b.events, b));
  }
  function L() {
    const B = v(), V = b.previous, X = b.currentConstruct, de = b.events.length, Y = Array.from(d);
    return {
      restore: se,
      from: de
    };
    function se() {
      a = B, b.previous = V, b.currentConstruct = X, b.events.length = de, d = Y, H();
    }
  }
  function H() {
    a.line in o && a.column < 2 && (a.column = o[a.line], a.offset += o[a.line] - 1);
  }
}
function sliceChunks(e, t) {
  const r = t.start._index, a = t.start._bufferIndex, o = t.end._index, u = t.end._bufferIndex;
  let c;
  if (r === o)
    c = [e[r].slice(a, u)];
  else {
    if (c = e.slice(r, o), a > -1) {
      const d = c[0];
      typeof d == "string" ? c[0] = d.slice(a) : c.shift();
    }
    u > 0 && c.push(e[o].slice(0, u));
  }
  return c;
}
function serializeChunks(e, t) {
  let r = -1;
  const a = [];
  let o;
  for (; ++r < e.length; ) {
    const u = e[r];
    let c;
    if (typeof u == "string")
      c = u;
    else switch (u) {
      case -5: {
        c = "\r";
        break;
      }
      case -4: {
        c = `
`;
        break;
      }
      case -3: {
        c = `\r
`;
        break;
      }
      case -2: {
        c = t ? " " : "	";
        break;
      }
      case -1: {
        if (!t && o) continue;
        c = " ";
        break;
      }
      default:
        c = String.fromCharCode(u);
    }
    o = u === -2, a.push(c);
  }
  return a.join("");
}
const document$1 = {
  42: list$2,
  43: list$2,
  45: list$2,
  48: list$2,
  49: list$2,
  50: list$2,
  51: list$2,
  52: list$2,
  53: list$2,
  54: list$2,
  55: list$2,
  56: list$2,
  57: list$2,
  62: blockQuote
}, contentInitial = {
  91: definition$1
}, flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  32: codeIndented
}, flow = {
  35: headingAtx,
  42: thematicBreak$2,
  45: [setextUnderline, thematicBreak$2],
  60: htmlFlow,
  61: setextUnderline,
  95: thematicBreak$2,
  96: codeFenced,
  126: codeFenced
}, string = {
  38: characterReference,
  92: characterEscape
}, text$9 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  33: labelStartImage,
  38: characterReference,
  42: attention,
  60: [autolink, htmlText],
  91: labelStartLink,
  92: [hardBreakEscape, characterEscape],
  93: labelEnd,
  95: attention,
  96: codeText
}, insideSpan = {
  null: [attention, resolver]
}, attentionMarkers = {
  null: [42, 95]
}, disable = {
  null: []
}, defaultConstructs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers,
  contentInitial,
  disable,
  document: document$1,
  flow,
  flowInitial,
  insideSpan,
  string,
  text: text$9
}, Symbol.toStringTag, {
  value: "Module"
}));
function parse$5(e) {
  const r = (
    /** @type {FullNormalizedExtension} */
    combineExtensions([defaultConstructs, ...(e || {}).extensions || []])
  ), a = {
    defined: [],
    lazy: {},
    constructs: r,
    content: o(content$1),
    document: o(document$2),
    flow: o(flow$1),
    string: o(string$1),
    text: o(text$a)
  };
  return a;
  function o(u) {
    return c;
    function c(d) {
      return createTokenizer(a, u, d);
    }
  }
}
function postprocess(e) {
  for (; !subtokenize(e); )
    ;
  return e;
}
const search$3 = /[\0\t\n\r]/g;
function preprocess() {
  let e = 1, t = "", r = !0, a;
  return o;
  function o(u, c, d) {
    const g = [];
    let b, _, y, A, E;
    for (u = t + (typeof u == "string" ? u.toString() : new TextDecoder(c || void 0).decode(u)), y = 0, t = "", r && (u.charCodeAt(0) === 65279 && y++, r = void 0); y < u.length; ) {
      if (search$3.lastIndex = y, b = search$3.exec(u), A = b && b.index !== void 0 ? b.index : u.length, E = u.charCodeAt(A), !b) {
        t = u.slice(y);
        break;
      }
      if (E === 10 && y === A && a)
        g.push(-3), a = void 0;
      else
        switch (a && (g.push(-5), a = void 0), y < A && (g.push(u.slice(y, A)), e += A - y), E) {
          case 0: {
            g.push(65533), e++;
            break;
          }
          case 9: {
            for (_ = Math.ceil(e / 4) * 4, g.push(-2); e++ < _; ) g.push(-1);
            break;
          }
          case 10: {
            g.push(-4), e = 1;
            break;
          }
          default:
            a = !0, e = 1;
        }
      y = A + 1;
    }
    return d && (a && g.push(-5), t && g.push(t), g.push(null)), g;
  }
}
const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(e) {
  return e.replace(characterEscapeOrReference, decode$1);
}
function decode$1(e, t, r) {
  if (t)
    return t;
  if (r.charCodeAt(0) === 35) {
    const o = r.charCodeAt(1), u = o === 120 || o === 88;
    return decodeNumericCharacterReference(r.slice(u ? 2 : 1), u ? 16 : 10);
  }
  return decodeNamedCharacterReference(r) || e;
}
const own$e = {}.hasOwnProperty;
function fromMarkdown(e, t, r) {
  return typeof t != "string" && (r = t, t = void 0), compiler(r)(postprocess(parse$5(r).document().write(preprocess()(e, t, !0))));
}
function compiler(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: u(Q),
      autolinkProtocol: L,
      autolinkEmail: L,
      atxHeading: u(he),
      blockQuote: u(me),
      characterEscape: L,
      characterReference: L,
      codeFenced: u(ye),
      codeFencedFenceInfo: c,
      codeFencedFenceMeta: c,
      codeIndented: u(ye, c),
      codeText: u(Re, c),
      codeTextData: L,
      data: L,
      codeFlowValue: L,
      definition: u(De),
      definitionDestinationString: c,
      definitionLabelString: c,
      definitionTitleString: c,
      emphasis: u(Pe),
      hardBreakEscape: u(Le),
      hardBreakTrailing: u(Le),
      htmlFlow: u(Ee, c),
      htmlFlowData: L,
      htmlText: u(Ee, c),
      htmlTextData: L,
      image: u(Se),
      label: c,
      link: u(Q),
      listItem: u(fe),
      listItemValue: A,
      listOrdered: u(K, y),
      listUnordered: u(K),
      paragraph: u(be),
      reference: O,
      referenceString: c,
      resourceDestinationString: c,
      resourceTitleString: c,
      setextHeading: u(he),
      strong: u(ke),
      thematicBreak: u(Be)
    },
    exit: {
      atxHeading: g(),
      atxHeadingSequence: M,
      autolink: g(),
      autolinkEmail: ie,
      autolinkProtocol: ae,
      blockQuote: g(),
      characterEscapeValue: H,
      characterReferenceMarkerHexadecimal: W,
      characterReferenceMarkerNumeric: W,
      characterReferenceValue: ee,
      codeFenced: g(R),
      codeFencedFence: C,
      codeFencedFenceInfo: E,
      codeFencedFenceMeta: v,
      codeFlowValue: H,
      codeIndented: g(I),
      codeText: g(Y),
      codeTextData: H,
      data: H,
      definition: g(),
      definitionDestinationString: F,
      definitionLabelString: w,
      definitionTitleString: N,
      emphasis: g(),
      hardBreakEscape: g(V),
      hardBreakTrailing: g(V),
      htmlFlow: g(X),
      htmlFlowData: H,
      htmlText: g(de),
      htmlTextData: H,
      image: g(ue),
      label: J,
      labelText: pe,
      lineEnding: B,
      link: g(se),
      listItem: g(),
      listOrdered: g(),
      listUnordered: g(),
      paragraph: g(),
      referenceString: z,
      resourceDestinationString: j,
      resourceTitleString: le,
      resource: Z,
      setextHeading: g(U),
      setextHeadingLineSequence: P,
      setextHeadingText: x,
      strong: g(),
      thematicBreak: g()
    }
  };
  configure(t, (e || {}).mdastExtensions || []);
  const r = {};
  return a;
  function a(te) {
    let Ce = {
      type: "root",
      children: []
    };
    const Me = {
      stack: [Ce],
      tokenStack: [],
      config: t,
      enter: d,
      exit: b,
      buffer: c,
      resume: _,
      data: r
    }, Ve = [];
    let je = -1;
    for (; ++je < te.length; )
      if (te[je][1].type === "listOrdered" || te[je][1].type === "listUnordered")
        if (te[je][0] === "enter")
          Ve.push(je);
        else {
          const ot = Ve.pop();
          je = o(te, ot, je);
        }
    for (je = -1; ++je < te.length; ) {
      const ot = t[te[je][0]];
      own$e.call(ot, te[je][1].type) && ot[te[je][1].type].call(Object.assign({
        sliceSerialize: te[je][2].sliceSerialize
      }, Me), te[je][1]);
    }
    if (Me.tokenStack.length > 0) {
      const ot = Me.tokenStack[Me.tokenStack.length - 1];
      (ot[1] || defaultOnError).call(Me, void 0, ot[0]);
    }
    for (Ce.position = {
      start: point$1(te.length > 0 ? te[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: point$1(te.length > 0 ? te[te.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, je = -1; ++je < t.transforms.length; )
      Ce = t.transforms[je](Ce) || Ce;
    return Ce;
  }
  function o(te, Ce, Me) {
    let Ve = Ce - 1, je = -1, ot = !1, We, Xe, ut, ct;
    for (; ++Ve <= Me; ) {
      const $e = te[Ve];
      switch ($e[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          $e[0] === "enter" ? je++ : je--, ct = void 0;
          break;
        }
        case "lineEndingBlank": {
          $e[0] === "enter" && (We && !ct && !je && !ut && (ut = Ve), ct = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          ct = void 0;
      }
      if (!je && $e[0] === "enter" && $e[1].type === "listItemPrefix" || je === -1 && $e[0] === "exit" && ($e[1].type === "listUnordered" || $e[1].type === "listOrdered")) {
        if (We) {
          let Ae = Ve;
          for (Xe = void 0; Ae--; ) {
            const ve = te[Ae];
            if (ve[1].type === "lineEnding" || ve[1].type === "lineEndingBlank") {
              if (ve[0] === "exit") continue;
              Xe && (te[Xe][1].type = "lineEndingBlank", ot = !0), ve[1].type = "lineEnding", Xe = Ae;
            } else if (!(ve[1].type === "linePrefix" || ve[1].type === "blockQuotePrefix" || ve[1].type === "blockQuotePrefixWhitespace" || ve[1].type === "blockQuoteMarker" || ve[1].type === "listItemIndent")) break;
          }
          ut && (!Xe || ut < Xe) && (We._spread = !0), We.end = Object.assign({}, Xe ? te[Xe][1].start : $e[1].end), te.splice(Xe || Ve, 0, ["exit", We, $e[2]]), Ve++, Me++;
        }
        if ($e[1].type === "listItemPrefix") {
          const Ae = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, $e[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          We = Ae, te.splice(Ve, 0, ["enter", Ae, $e[2]]), Ve++, Me++, ut = void 0, ct = !0;
        }
      }
    }
    return te[Ce][1]._spread = ot, Me;
  }
  function u(te, Ce) {
    return Me;
    function Me(Ve) {
      d.call(this, te(Ve), Ve), Ce && Ce.call(this, Ve);
    }
  }
  function c() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function d(te, Ce, Me) {
    this.stack[this.stack.length - 1].children.push(te), this.stack.push(te), this.tokenStack.push([Ce, Me]), te.position = {
      start: point$1(Ce.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function g(te) {
    return Ce;
    function Ce(Me) {
      te && te.call(this, Me), b.call(this, Me);
    }
  }
  function b(te, Ce) {
    const Me = this.stack.pop(), Ve = this.tokenStack.pop();
    if (Ve)
      Ve[0].type !== te.type && (Ce ? Ce.call(this, te, Ve[0]) : (Ve[1] || defaultOnError).call(this, te, Ve[0]));
    else throw new Error("Cannot close `" + te.type + "` (" + stringifyPosition({
      start: te.start,
      end: te.end
    }) + "): its not open");
    Me.position.end = point$1(te.end);
  }
  function _() {
    return toString$1(this.stack.pop());
  }
  function y() {
    this.data.expectingFirstListItemValue = !0;
  }
  function A(te) {
    if (this.data.expectingFirstListItemValue) {
      const Ce = this.stack[this.stack.length - 2];
      Ce.start = Number.parseInt(this.sliceSerialize(te), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function E() {
    const te = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.lang = te;
  }
  function v() {
    const te = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.meta = te;
  }
  function C() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function R() {
    const te = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.value = te.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function I() {
    const te = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.value = te.replace(/(\r?\n|\r)$/g, "");
  }
  function w(te) {
    const Ce = this.resume(), Me = this.stack[this.stack.length - 1];
    Me.label = Ce, Me.identifier = normalizeIdentifier(this.sliceSerialize(te)).toLowerCase();
  }
  function N() {
    const te = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.title = te;
  }
  function F() {
    const te = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.url = te;
  }
  function M(te) {
    const Ce = this.stack[this.stack.length - 1];
    if (!Ce.depth) {
      const Me = this.sliceSerialize(te).length;
      Ce.depth = Me;
    }
  }
  function x() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function P(te) {
    const Ce = this.stack[this.stack.length - 1];
    Ce.depth = this.sliceSerialize(te).codePointAt(0) === 61 ? 1 : 2;
  }
  function U() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function L(te) {
    const Me = this.stack[this.stack.length - 1].children;
    let Ve = Me[Me.length - 1];
    (!Ve || Ve.type !== "text") && (Ve = Fe(), Ve.position = {
      start: point$1(te.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, Me.push(Ve)), this.stack.push(Ve);
  }
  function H(te) {
    const Ce = this.stack.pop();
    Ce.value += this.sliceSerialize(te), Ce.position.end = point$1(te.end);
  }
  function B(te) {
    const Ce = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const Me = Ce.children[Ce.children.length - 1];
      Me.position.end = point$1(te.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(Ce.type) && (L.call(this, te), H.call(this, te));
  }
  function V() {
    this.data.atHardBreak = !0;
  }
  function X() {
    const te = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.value = te;
  }
  function de() {
    const te = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.value = te;
  }
  function Y() {
    const te = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.value = te;
  }
  function se() {
    const te = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const Ce = this.data.referenceType || "shortcut";
      te.type += "Reference", te.referenceType = Ce, delete te.url, delete te.title;
    } else
      delete te.identifier, delete te.label;
    this.data.referenceType = void 0;
  }
  function ue() {
    const te = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const Ce = this.data.referenceType || "shortcut";
      te.type += "Reference", te.referenceType = Ce, delete te.url, delete te.title;
    } else
      delete te.identifier, delete te.label;
    this.data.referenceType = void 0;
  }
  function pe(te) {
    const Ce = this.sliceSerialize(te), Me = this.stack[this.stack.length - 2];
    Me.label = decodeString(Ce), Me.identifier = normalizeIdentifier(Ce).toLowerCase();
  }
  function J() {
    const te = this.stack[this.stack.length - 1], Ce = this.resume(), Me = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, Me.type === "link") {
      const Ve = te.children;
      Me.children = Ve;
    } else
      Me.alt = Ce;
  }
  function j() {
    const te = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.url = te;
  }
  function le() {
    const te = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.title = te;
  }
  function Z() {
    this.data.inReference = void 0;
  }
  function O() {
    this.data.referenceType = "collapsed";
  }
  function z(te) {
    const Ce = this.resume(), Me = this.stack[this.stack.length - 1];
    Me.label = Ce, Me.identifier = normalizeIdentifier(this.sliceSerialize(te)).toLowerCase(), this.data.referenceType = "full";
  }
  function W(te) {
    this.data.characterReferenceType = te.type;
  }
  function ee(te) {
    const Ce = this.sliceSerialize(te), Me = this.data.characterReferenceType;
    let Ve;
    Me ? (Ve = decodeNumericCharacterReference(Ce, Me === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Ve = decodeNamedCharacterReference(Ce);
    const je = this.stack.pop();
    je.value += Ve, je.position.end = point$1(te.end);
  }
  function ae(te) {
    H.call(this, te);
    const Ce = this.stack[this.stack.length - 1];
    Ce.url = this.sliceSerialize(te);
  }
  function ie(te) {
    H.call(this, te);
    const Ce = this.stack[this.stack.length - 1];
    Ce.url = "mailto:" + this.sliceSerialize(te);
  }
  function me() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function ye() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function Re() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function De() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function Pe() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function he() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function Le() {
    return {
      type: "break"
    };
  }
  function Ee() {
    return {
      type: "html",
      value: ""
    };
  }
  function Se() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function Q() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function K(te) {
    return {
      type: "list",
      ordered: te.type === "listOrdered",
      start: null,
      spread: te._spread,
      children: []
    };
  }
  function fe(te) {
    return {
      type: "listItem",
      spread: te._spread,
      checked: null,
      children: []
    };
  }
  function be() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function ke() {
    return {
      type: "strong",
      children: []
    };
  }
  function Fe() {
    return {
      type: "text",
      value: ""
    };
  }
  function Be() {
    return {
      type: "thematicBreak"
    };
  }
}
function point$1(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function configure(e, t) {
  let r = -1;
  for (; ++r < t.length; ) {
    const a = t[r];
    Array.isArray(a) ? configure(e, a) : extension(e, a);
  }
}
function extension(e, t) {
  let r;
  for (r in t)
    if (own$e.call(t, r))
      switch (r) {
        case "canContainEols": {
          const a = t[r];
          a && e[r].push(...a);
          break;
        }
        case "transforms": {
          const a = t[r];
          a && e[r].push(...a);
          break;
        }
        case "enter":
        case "exit": {
          const a = t[r];
          a && Object.assign(e[r], a);
          break;
        }
      }
}
function defaultOnError(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + stringifyPosition({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + stringifyPosition({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + stringifyPosition({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function remarkParse(e) {
  const t = this;
  t.parser = r;
  function r(a) {
    return fromMarkdown(a, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function blockquote$1(e, t) {
  const r = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function hardBreak$1(e, t) {
  const r = {
    type: "element",
    tagName: "br",
    properties: {},
    children: []
  };
  return e.patch(t, r), [e.applyData(t, r), {
    type: "text",
    value: `
`
  }];
}
function code$2(e, t) {
  const r = t.value ? t.value + `
` : "", a = {};
  t.lang && (a.className = ["language-" + t.lang]);
  let o = {
    type: "element",
    tagName: "code",
    properties: a,
    children: [{
      type: "text",
      value: r
    }]
  };
  return t.meta && (o.data = {
    meta: t.meta
  }), e.patch(t, o), o = e.applyData(t, o), o = {
    type: "element",
    tagName: "pre",
    properties: {},
    children: [o]
  }, e.patch(t, o), o;
}
function strikethrough(e, t) {
  const r = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function emphasis$1(e, t) {
  const r = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function footnoteReference$1(e, t) {
  const r = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", a = String(t.identifier).toUpperCase(), o = normalizeUri(a.toLowerCase()), u = e.footnoteOrder.indexOf(a);
  let c, d = e.footnoteCounts.get(a);
  d === void 0 ? (d = 0, e.footnoteOrder.push(a), c = e.footnoteOrder.length) : c = u + 1, d += 1, e.footnoteCounts.set(a, d);
  const g = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + r + "fn-" + o,
      id: r + "fnref-" + o + (d > 1 ? "-" + d : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{
      type: "text",
      value: String(c)
    }]
  };
  e.patch(t, g);
  const b = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [g]
  };
  return e.patch(t, b), e.applyData(t, b);
}
function heading$1(e, t) {
  const r = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function html$6(e, t) {
  if (e.options.allowDangerousHtml) {
    const r = {
      type: "raw",
      value: t.value
    };
    return e.patch(t, r), e.applyData(t, r);
  }
}
function revert(e, t) {
  const r = t.referenceType;
  let a = "]";
  if (r === "collapsed" ? a += "[]" : r === "full" && (a += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{
      type: "text",
      value: "![" + t.alt + a
    }];
  const o = e.all(t), u = o[0];
  u && u.type === "text" ? u.value = "[" + u.value : o.unshift({
    type: "text",
    value: "["
  });
  const c = o[o.length - 1];
  return c && c.type === "text" ? c.value += a : o.push({
    type: "text",
    value: a
  }), o;
}
function imageReference$1(e, t) {
  const r = String(t.identifier).toUpperCase(), a = e.definitionById.get(r);
  if (!a)
    return revert(e, t);
  const o = {
    src: normalizeUri(a.url || ""),
    alt: t.alt
  };
  a.title !== null && a.title !== void 0 && (o.title = a.title);
  const u = {
    type: "element",
    tagName: "img",
    properties: o,
    children: []
  };
  return e.patch(t, u), e.applyData(t, u);
}
function image$1(e, t) {
  const r = {
    src: normalizeUri(t.url)
  };
  t.alt !== null && t.alt !== void 0 && (r.alt = t.alt), t.title !== null && t.title !== void 0 && (r.title = t.title);
  const a = {
    type: "element",
    tagName: "img",
    properties: r,
    children: []
  };
  return e.patch(t, a), e.applyData(t, a);
}
function inlineCode$1(e, t) {
  const r = {
    type: "text",
    value: t.value.replace(/\r?\n|\r/g, " ")
  };
  e.patch(t, r);
  const a = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [r]
  };
  return e.patch(t, a), e.applyData(t, a);
}
function linkReference$1(e, t) {
  const r = String(t.identifier).toUpperCase(), a = e.definitionById.get(r);
  if (!a)
    return revert(e, t);
  const o = {
    href: normalizeUri(a.url || "")
  };
  a.title !== null && a.title !== void 0 && (o.title = a.title);
  const u = {
    type: "element",
    tagName: "a",
    properties: o,
    children: e.all(t)
  };
  return e.patch(t, u), e.applyData(t, u);
}
function link$1(e, t) {
  const r = {
    href: normalizeUri(t.url)
  };
  t.title !== null && t.title !== void 0 && (r.title = t.title);
  const a = {
    type: "element",
    tagName: "a",
    properties: r,
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function listItem$1(e, t, r) {
  const a = e.all(t), o = r ? listLoose(r) : listItemLoose(t), u = {}, c = [];
  if (typeof t.checked == "boolean") {
    const _ = a[0];
    let y;
    _ && _.type === "element" && _.tagName === "p" ? y = _ : (y = {
      type: "element",
      tagName: "p",
      properties: {},
      children: []
    }, a.unshift(y)), y.children.length > 0 && y.children.unshift({
      type: "text",
      value: " "
    }), y.children.unshift({
      type: "element",
      tagName: "input",
      properties: {
        type: "checkbox",
        checked: t.checked,
        disabled: !0
      },
      children: []
    }), u.className = ["task-list-item"];
  }
  let d = -1;
  for (; ++d < a.length; ) {
    const _ = a[d];
    (o || d !== 0 || _.type !== "element" || _.tagName !== "p") && c.push({
      type: "text",
      value: `
`
    }), _.type === "element" && _.tagName === "p" && !o ? c.push(..._.children) : c.push(_);
  }
  const g = a[a.length - 1];
  g && (o || g.type !== "element" || g.tagName !== "p") && c.push({
    type: "text",
    value: `
`
  });
  const b = {
    type: "element",
    tagName: "li",
    properties: u,
    children: c
  };
  return e.patch(t, b), e.applyData(t, b);
}
function listLoose(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const r = e.children;
    let a = -1;
    for (; !t && ++a < r.length; )
      t = listItemLoose(r[a]);
  }
  return t;
}
function listItemLoose(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function list$1(e, t) {
  const r = {}, a = e.all(t);
  let o = -1;
  for (typeof t.start == "number" && t.start !== 1 && (r.start = t.start); ++o < a.length; ) {
    const c = a[o];
    if (c.type === "element" && c.tagName === "li" && c.properties && Array.isArray(c.properties.className) && c.properties.className.includes("task-list-item")) {
      r.className = ["contains-task-list"];
      break;
    }
  }
  const u = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: r,
    children: e.wrap(a, !0)
  };
  return e.patch(t, u), e.applyData(t, u);
}
function paragraph$1(e, t) {
  const r = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function root$5(e, t) {
  const r = {
    type: "root",
    children: e.wrap(e.all(t))
  };
  return e.patch(t, r), e.applyData(t, r);
}
function strong$1(e, t) {
  const r = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function table(e, t) {
  const r = e.all(t), a = r.shift(), o = [];
  if (a) {
    const c = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([a], !0)
    };
    e.patch(t.children[0], c), o.push(c);
  }
  if (r.length > 0) {
    const c = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(r, !0)
    }, d = pointStart(t.children[1]), g = pointEnd(t.children[t.children.length - 1]);
    d && g && (c.position = {
      start: d,
      end: g
    }), o.push(c);
  }
  const u = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(o, !0)
  };
  return e.patch(t, u), e.applyData(t, u);
}
function tableRow(e, t, r) {
  const a = r ? r.children : void 0, u = (a ? a.indexOf(t) : 1) === 0 ? "th" : "td", c = r && r.type === "table" ? r.align : void 0, d = c ? c.length : t.children.length;
  let g = -1;
  const b = [];
  for (; ++g < d; ) {
    const y = t.children[g], A = {}, E = c ? c[g] : void 0;
    E && (A.align = E);
    let v = {
      type: "element",
      tagName: u,
      properties: A,
      children: []
    };
    y && (v.children = e.all(y), e.patch(y, v), v = e.applyData(y, v)), b.push(v);
  }
  const _ = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(b, !0)
  };
  return e.patch(t, _), e.applyData(t, _);
}
function tableCell(e, t) {
  const r = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
const tab$1 = 9, space$6 = 32;
function trimLines(e) {
  const t = String(e), r = /\r?\n|\r/g;
  let a = r.exec(t), o = 0;
  const u = [];
  for (; a; )
    u.push(trimLine(t.slice(o, a.index), o > 0, !0), a[0]), o = a.index + a[0].length, a = r.exec(t);
  return u.push(trimLine(t.slice(o), o > 0, !1)), u.join("");
}
function trimLine(e, t, r) {
  let a = 0, o = e.length;
  if (t) {
    let u = e.codePointAt(a);
    for (; u === tab$1 || u === space$6; )
      a++, u = e.codePointAt(a);
  }
  if (r) {
    let u = e.codePointAt(o - 1);
    for (; u === tab$1 || u === space$6; )
      o--, u = e.codePointAt(o - 1);
  }
  return o > a ? e.slice(a, o) : "";
}
function text$8(e, t) {
  const r = {
    type: "text",
    value: trimLines(String(t.value))
  };
  return e.patch(t, r), e.applyData(t, r);
}
function thematicBreak$1(e, t) {
  const r = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, r), e.applyData(t, r);
}
const handlers = {
  blockquote: blockquote$1,
  break: hardBreak$1,
  code: code$2,
  delete: strikethrough,
  emphasis: emphasis$1,
  footnoteReference: footnoteReference$1,
  heading: heading$1,
  html: html$6,
  imageReference: imageReference$1,
  image: image$1,
  inlineCode: inlineCode$1,
  linkReference: linkReference$1,
  link: link$1,
  listItem: listItem$1,
  list: list$1,
  paragraph: paragraph$1,
  // @ts-expect-error: root is different, but hard to type.
  root: root$5,
  strong: strong$1,
  table,
  tableCell,
  tableRow,
  text: text$8,
  thematicBreak: thematicBreak$1,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};
function ignore() {
}
const VOID = -1, PRIMITIVE = 0, ARRAY = 1, OBJECT = 2, DATE = 3, REGEXP = 4, MAP = 5, SET = 6, ERROR = 7, BIGINT = 8, env = typeof self == "object" ? self : globalThis, deserializer = (e, t) => {
  const r = (o, u) => (e.set(u, o), o), a = (o) => {
    if (e.has(o)) return e.get(o);
    const [u, c] = t[o];
    switch (u) {
      case PRIMITIVE:
      case VOID:
        return r(c, o);
      case ARRAY: {
        const d = r([], o);
        for (const g of c) d.push(a(g));
        return d;
      }
      case OBJECT: {
        const d = r({}, o);
        for (const [g, b] of c) d[a(g)] = a(b);
        return d;
      }
      case DATE:
        return r(new Date(c), o);
      case REGEXP: {
        const {
          source: d,
          flags: g
        } = c;
        return r(new RegExp(d, g), o);
      }
      case MAP: {
        const d = r(/* @__PURE__ */ new Map(), o);
        for (const [g, b] of c) d.set(a(g), a(b));
        return d;
      }
      case SET: {
        const d = r(/* @__PURE__ */ new Set(), o);
        for (const g of c) d.add(a(g));
        return d;
      }
      case ERROR: {
        const {
          name: d,
          message: g
        } = c;
        return r(new env[d](g), o);
      }
      case BIGINT:
        return r(BigInt(c), o);
      case "BigInt":
        return r(Object(BigInt(c)), o);
      case "ArrayBuffer":
        return r(new Uint8Array(c).buffer, c);
      case "DataView": {
        const {
          buffer: d
        } = new Uint8Array(c);
        return r(new DataView(d), c);
      }
    }
    return r(new env[u](c), o);
  };
  return a;
}, deserialize = (e) => deserializer(/* @__PURE__ */ new Map(), e)(0), EMPTY = "", {
  toString
} = {}, {
  keys
} = Object, typeOf = (e) => {
  const t = typeof e;
  if (t !== "object" || !e) return [PRIMITIVE, t];
  const r = toString.call(e).slice(8, -1);
  switch (r) {
    case "Array":
      return [ARRAY, EMPTY];
    case "Object":
      return [OBJECT, EMPTY];
    case "Date":
      return [DATE, EMPTY];
    case "RegExp":
      return [REGEXP, EMPTY];
    case "Map":
      return [MAP, EMPTY];
    case "Set":
      return [SET, EMPTY];
    case "DataView":
      return [ARRAY, r];
  }
  return r.includes("Array") ? [ARRAY, r] : r.includes("Error") ? [ERROR, r] : [OBJECT, r];
}, shouldSkip = ([e, t]) => e === PRIMITIVE && (t === "function" || t === "symbol"), serializer = (e, t, r, a) => {
  const o = (c, d) => {
    const g = a.push(c) - 1;
    return r.set(d, g), g;
  }, u = (c) => {
    if (r.has(c)) return r.get(c);
    let [d, g] = typeOf(c);
    switch (d) {
      case PRIMITIVE: {
        let _ = c;
        switch (g) {
          case "bigint":
            d = BIGINT, _ = c.toString();
            break;
          case "function":
          case "symbol":
            if (e) throw new TypeError("unable to serialize " + g);
            _ = null;
            break;
          case "undefined":
            return o([VOID], c);
        }
        return o([d, _], c);
      }
      case ARRAY: {
        if (g) {
          let A = c;
          return g === "DataView" ? A = new Uint8Array(c.buffer) : g === "ArrayBuffer" && (A = new Uint8Array(c)), o([g, [...A]], c);
        }
        const _ = [], y = o([d, _], c);
        for (const A of c) _.push(u(A));
        return y;
      }
      case OBJECT: {
        if (g)
          switch (g) {
            case "BigInt":
              return o([g, c.toString()], c);
            case "Boolean":
            case "Number":
            case "String":
              return o([g, c.valueOf()], c);
          }
        if (t && "toJSON" in c) return u(c.toJSON());
        const _ = [], y = o([d, _], c);
        for (const A of keys(c))
          (e || !shouldSkip(typeOf(c[A]))) && _.push([u(A), u(c[A])]);
        return y;
      }
      case DATE:
        return o([d, c.toISOString()], c);
      case REGEXP: {
        const {
          source: _,
          flags: y
        } = c;
        return o([d, {
          source: _,
          flags: y
        }], c);
      }
      case MAP: {
        const _ = [], y = o([d, _], c);
        for (const [A, E] of c)
          (e || !(shouldSkip(typeOf(A)) || shouldSkip(typeOf(E)))) && _.push([u(A), u(E)]);
        return y;
      }
      case SET: {
        const _ = [], y = o([d, _], c);
        for (const A of c)
          (e || !shouldSkip(typeOf(A))) && _.push(u(A));
        return y;
      }
    }
    const {
      message: b
    } = c;
    return o([d, {
      name: g,
      message: b
    }], c);
  };
  return u;
}, serialize$1 = (e, {
  json: t,
  lossy: r
} = {}) => {
  const a = [];
  return serializer(!(t || r), !!t, /* @__PURE__ */ new Map(), a)(e), a;
}, structuredClone$1 = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? deserialize(serialize$1(e, t)) : structuredClone(e)
) : (e, t) => deserialize(serialize$1(e, t));
function defaultFootnoteBackContent(e, t) {
  const r = [{
    type: "text",
    value: ""
  }];
  return t > 1 && r.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{
      type: "text",
      value: String(t)
    }]
  }), r;
}
function defaultFootnoteBackLabel(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function footer(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = e.options.footnoteBackContent || defaultFootnoteBackContent, a = e.options.footnoteBackLabel || defaultFootnoteBackLabel, o = e.options.footnoteLabel || "Footnotes", u = e.options.footnoteLabelTagName || "h2", c = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, d = [];
  let g = -1;
  for (; ++g < e.footnoteOrder.length; ) {
    const b = e.footnoteById.get(e.footnoteOrder[g]);
    if (!b)
      continue;
    const _ = e.all(b), y = String(b.identifier).toUpperCase(), A = normalizeUri(y.toLowerCase());
    let E = 0;
    const v = [], C = e.footnoteCounts.get(y);
    for (; C !== void 0 && ++E <= C; ) {
      v.length > 0 && v.push({
        type: "text",
        value: " "
      });
      let w = typeof r == "string" ? r : r(g, E);
      typeof w == "string" && (w = {
        type: "text",
        value: w
      }), v.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + A + (E > 1 ? "-" + E : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof a == "string" ? a : a(g, E),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(w) ? w : [w]
      });
    }
    const R = _[_.length - 1];
    if (R && R.type === "element" && R.tagName === "p") {
      const w = R.children[R.children.length - 1];
      w && w.type === "text" ? w.value += " " : R.children.push({
        type: "text",
        value: " "
      }), R.children.push(...v);
    } else
      _.push(...v);
    const I = {
      type: "element",
      tagName: "li",
      properties: {
        id: t + "fn-" + A
      },
      children: e.wrap(_, !0)
    };
    e.patch(b, I), d.push(I);
  }
  if (d.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: {
        dataFootnotes: !0,
        className: ["footnotes"]
      },
      children: [{
        type: "element",
        tagName: u,
        properties: {
          ...structuredClone$1(c),
          id: "footnote-label"
        },
        children: [{
          type: "text",
          value: o
        }]
      }, {
        type: "text",
        value: `
`
      }, {
        type: "element",
        tagName: "ol",
        properties: {},
        children: e.wrap(d, !0)
      }, {
        type: "text",
        value: `
`
      }]
    };
}
const convert = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return ok;
    if (typeof e == "function")
      return castFactory$1(e);
    if (typeof e == "object")
      return Array.isArray(e) ? anyFactory$1(e) : propsFactory(e);
    if (typeof e == "string")
      return typeFactory(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory$1(e) {
  const t = [];
  let r = -1;
  for (; ++r < e.length; )
    t[r] = convert(e[r]);
  return castFactory$1(a);
  function a(...o) {
    let u = -1;
    for (; ++u < t.length; )
      if (t[u].apply(this, o)) return !0;
    return !1;
  }
}
function propsFactory(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return castFactory$1(r);
  function r(a) {
    const o = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      a
    );
    let u;
    for (u in e)
      if (o[u] !== t[u]) return !1;
    return !0;
  }
}
function typeFactory(e) {
  return castFactory$1(t);
  function t(r) {
    return r && r.type === e;
  }
}
function castFactory$1(e) {
  return t;
  function t(r, a, o) {
    return !!(looksLikeANode(r) && e.call(this, r, typeof a == "number" ? a : void 0, o || void 0));
  }
}
function ok() {
  return !0;
}
function looksLikeANode(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
function color(e) {
  return e;
}
const empty$3 = [], CONTINUE = !0, EXIT = !1, SKIP = "skip";
function visitParents(e, t, r, a) {
  let o;
  typeof t == "function" && typeof r != "function" ? (a = r, r = t) : o = t;
  const u = convert(o), c = a ? -1 : 1;
  d(e, void 0, [])();
  function d(g, b, _) {
    const y = (
      /** @type {Record<string, unknown>} */
      g && typeof g == "object" ? g : {}
    );
    if (typeof y.type == "string") {
      const E = (
        // `hast`
        typeof y.tagName == "string" ? y.tagName : (
          // `xast`
          typeof y.name == "string" ? y.name : void 0
        )
      );
      Object.defineProperty(A, "name", {
        value: "node (" + (g.type + (E ? "<" + E + ">" : "")) + ")"
      });
    }
    return A;
    function A() {
      let E = empty$3, v, C, R;
      if ((!t || u(g, b, _[_.length - 1] || void 0)) && (E = toResult(r(g, _)), E[0] === EXIT))
        return E;
      if ("children" in g && g.children) {
        const I = (
          /** @type {UnistParent} */
          g
        );
        if (I.children && E[0] !== SKIP)
          for (C = (a ? I.children.length : -1) + c, R = _.concat(I); C > -1 && C < I.children.length; ) {
            const w = I.children[C];
            if (v = d(w, C, R)(), v[0] === EXIT)
              return v;
            C = typeof v[1] == "number" ? v[1] : C + c;
          }
      }
      return E;
    }
  }
}
function toResult(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [CONTINUE, e] : e == null ? empty$3 : [e];
}
function visit(e, t, r, a) {
  let o, u, c;
  typeof t == "function" && typeof r != "function" ? (u = void 0, c = t, o = r) : (u = t, c = r, o = a), visitParents(e, u, d, o);
  function d(g, b) {
    const _ = b[b.length - 1], y = _ ? _.children.indexOf(g) : void 0;
    return c(g, y, _);
  }
}
const own$d = {}.hasOwnProperty, emptyOptions$5 = {};
function createState(e, t) {
  const r = t || emptyOptions$5, a = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map(), c = {
    ...handlers,
    ...r.handlers
  }, d = {
    all: b,
    applyData,
    definitionById: a,
    footnoteById: o,
    footnoteCounts: u,
    footnoteOrder: [],
    handlers: c,
    one: g,
    options: r,
    patch: patch$3,
    wrap: wrap$1
  };
  return visit(e, function(_) {
    if (_.type === "definition" || _.type === "footnoteDefinition") {
      const y = _.type === "definition" ? a : o, A = String(_.identifier).toUpperCase();
      y.has(A) || y.set(A, _);
    }
  }), d;
  function g(_, y) {
    const A = _.type, E = d.handlers[A];
    if (own$d.call(d.handlers, A) && E)
      return E(d, _, y);
    if (d.options.passThrough && d.options.passThrough.includes(A)) {
      if ("children" in _) {
        const {
          children: C,
          ...R
        } = _, I = structuredClone$1(R);
        return I.children = d.all(_), I;
      }
      return structuredClone$1(_);
    }
    return (d.options.unknownHandler || defaultUnknownHandler)(d, _, y);
  }
  function b(_) {
    const y = [];
    if ("children" in _) {
      const A = _.children;
      let E = -1;
      for (; ++E < A.length; ) {
        const v = d.one(A[E], _);
        if (v) {
          if (E && A[E - 1].type === "break" && (!Array.isArray(v) && v.type === "text" && (v.value = trimMarkdownSpaceStart(v.value)), !Array.isArray(v) && v.type === "element")) {
            const C = v.children[0];
            C && C.type === "text" && (C.value = trimMarkdownSpaceStart(C.value));
          }
          Array.isArray(v) ? y.push(...v) : y.push(v);
        }
      }
    }
    return y;
  }
}
function patch$3(e, t) {
  e.position && (t.position = position$2(e));
}
function applyData(e, t) {
  let r = t;
  if (e && e.data) {
    const a = e.data.hName, o = e.data.hChildren, u = e.data.hProperties;
    if (typeof a == "string")
      if (r.type === "element")
        r.tagName = a;
      else {
        const c = "children" in r ? r.children : [r];
        r = {
          type: "element",
          tagName: a,
          properties: {},
          children: c
        };
      }
    r.type === "element" && u && Object.assign(r.properties, structuredClone$1(u)), "children" in r && r.children && o !== null && o !== void 0 && (r.children = o);
  }
  return r;
}
function defaultUnknownHandler(e, t) {
  const r = t.data || {}, a = "value" in t && !(own$d.call(r, "hProperties") || own$d.call(r, "hChildren")) ? {
    type: "text",
    value: t.value
  } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function wrap$1(e, t) {
  const r = [];
  let a = -1;
  for (t && r.push({
    type: "text",
    value: `
`
  }); ++a < e.length; )
    a && r.push({
      type: "text",
      value: `
`
    }), r.push(e[a]);
  return t && e.length > 0 && r.push({
    type: "text",
    value: `
`
  }), r;
}
function trimMarkdownSpaceStart(e) {
  let t = 0, r = e.charCodeAt(t);
  for (; r === 9 || r === 32; )
    t++, r = e.charCodeAt(t);
  return e.slice(t);
}
function toHast(e, t) {
  const r = createState(e, t), a = r.one(e, void 0), o = footer(r), u = Array.isArray(a) ? {
    type: "root",
    children: a
  } : a || {
    type: "root",
    children: []
  };
  return o && u.children.push({
    type: "text",
    value: `
`
  }, o), u;
}
function remarkRehype(e, t) {
  return e && "run" in e ? async function(r, a) {
    const o = (
      /** @type {HastRoot} */
      toHast(r, {
        file: a,
        ...t
      })
    );
    await e.run(o, a);
  } : function(r, a) {
    return (
      /** @type {HastRoot} */
      toHast(r, {
        file: a,
        ...e || t
      })
    );
  };
}
function bail(e) {
  if (e)
    throw e;
}
var hasOwn = Object.prototype.hasOwnProperty, toStr = Object.prototype.toString, defineProperty$1 = Object.defineProperty, gOPD = Object.getOwnPropertyDescriptor, isArray = function e(t) {
  return typeof Array.isArray == "function" ? Array.isArray(t) : toStr.call(t) === "[object Array]";
}, isPlainObject$1 = function e(t) {
  if (!t || toStr.call(t) !== "[object Object]")
    return !1;
  var r = hasOwn.call(t, "constructor"), a = t.constructor && t.constructor.prototype && hasOwn.call(t.constructor.prototype, "isPrototypeOf");
  if (t.constructor && !r && !a)
    return !1;
  var o;
  for (o in t)
    ;
  return typeof o > "u" || hasOwn.call(t, o);
}, setProperty = function e(t, r) {
  defineProperty$1 && r.name === "__proto__" ? defineProperty$1(t, r.name, {
    enumerable: !0,
    configurable: !0,
    value: r.newValue,
    writable: !0
  }) : t[r.name] = r.newValue;
}, getProperty = function e(t, r) {
  if (r === "__proto__")
    if (hasOwn.call(t, r)) {
      if (gOPD)
        return gOPD(t, r).value;
    } else return;
  return t[r];
}, extend$1 = function e() {
  var t, r, a, o, u, c, d = arguments[0], g = 1, b = arguments.length, _ = !1;
  for (typeof d == "boolean" && (_ = d, d = arguments[1] || {}, g = 2), (d == null || typeof d != "object" && typeof d != "function") && (d = {}); g < b; ++g)
    if (t = arguments[g], t != null)
      for (r in t)
        a = getProperty(d, r), o = getProperty(t, r), d !== o && (_ && o && (isPlainObject$1(o) || (u = isArray(o))) ? (u ? (u = !1, c = a && isArray(a) ? a : []) : c = a && isPlainObject$1(a) ? a : {}, setProperty(d, {
          name: r,
          newValue: e(_, c, o)
        })) : typeof o < "u" && setProperty(d, {
          name: r,
          newValue: o
        }));
  return d;
};
const extend$2 = /* @__PURE__ */ getDefaultExportFromCjs(extend$1);
function isPlainObject(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function trough() {
  const e = [], t = {
    run: r,
    use: a
  };
  return t;
  function r(...o) {
    let u = -1;
    const c = o.pop();
    if (typeof c != "function")
      throw new TypeError("Expected function as last argument, not " + c);
    d(null, ...o);
    function d(g, ...b) {
      const _ = e[++u];
      let y = -1;
      if (g) {
        c(g);
        return;
      }
      for (; ++y < o.length; )
        (b[y] === null || b[y] === void 0) && (b[y] = o[y]);
      o = b, _ ? wrap(_, d)(...b) : c(null, ...b);
    }
  }
  function a(o) {
    if (typeof o != "function")
      throw new TypeError("Expected `middelware` to be a function, not " + o);
    return e.push(o), t;
  }
}
function wrap(e, t) {
  let r;
  return a;
  function a(...c) {
    const d = e.length > c.length;
    let g;
    d && c.push(o);
    try {
      g = e.apply(this, c);
    } catch (b) {
      const _ = (
        /** @type {Error} */
        b
      );
      if (d && r)
        throw _;
      return o(_);
    }
    d || (g && g.then && typeof g.then == "function" ? g.then(u, o) : g instanceof Error ? o(g) : u(g));
  }
  function o(c, ...d) {
    r || (r = !0, t(c, ...d));
  }
  function u(c) {
    o(null, c);
  }
}
const minpath = {
  basename,
  dirname,
  extname,
  join,
  sep: "/"
};
function basename(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  assertPath$1(e);
  let r = 0, a = -1, o = e.length, u;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; o--; )
      if (e.codePointAt(o) === 47) {
        if (u) {
          r = o + 1;
          break;
        }
      } else a < 0 && (u = !0, a = o + 1);
    return a < 0 ? "" : e.slice(r, a);
  }
  if (t === e)
    return "";
  let c = -1, d = t.length - 1;
  for (; o--; )
    if (e.codePointAt(o) === 47) {
      if (u) {
        r = o + 1;
        break;
      }
    } else
      c < 0 && (u = !0, c = o + 1), d > -1 && (e.codePointAt(o) === t.codePointAt(d--) ? d < 0 && (a = o) : (d = -1, a = c));
  return r === a ? a = c : a < 0 && (a = e.length), e.slice(r, a);
}
function dirname(e) {
  if (assertPath$1(e), e.length === 0)
    return ".";
  let t = -1, r = e.length, a;
  for (; --r; )
    if (e.codePointAt(r) === 47) {
      if (a) {
        t = r;
        break;
      }
    } else a || (a = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function extname(e) {
  assertPath$1(e);
  let t = e.length, r = -1, a = 0, o = -1, u = 0, c;
  for (; t--; ) {
    const d = e.codePointAt(t);
    if (d === 47) {
      if (c) {
        a = t + 1;
        break;
      }
      continue;
    }
    r < 0 && (c = !0, r = t + 1), d === 46 ? o < 0 ? o = t : u !== 1 && (u = 1) : o > -1 && (u = -1);
  }
  return o < 0 || r < 0 || // We saw a non-dot character immediately before the dot.
  u === 0 || // The (right-most) trimmed path component is exactly `..`.
  u === 1 && o === r - 1 && o === a + 1 ? "" : e.slice(o, r);
}
function join(...e) {
  let t = -1, r;
  for (; ++t < e.length; )
    assertPath$1(e[t]), e[t] && (r = r === void 0 ? e[t] : r + "/" + e[t]);
  return r === void 0 ? "." : normalize$5(r);
}
function normalize$5(e) {
  assertPath$1(e);
  const t = e.codePointAt(0) === 47;
  let r = normalizeString(e, !t);
  return r.length === 0 && !t && (r = "."), r.length > 0 && e.codePointAt(e.length - 1) === 47 && (r += "/"), t ? "/" + r : r;
}
function normalizeString(e, t) {
  let r = "", a = 0, o = -1, u = 0, c = -1, d, g;
  for (; ++c <= e.length; ) {
    if (c < e.length)
      d = e.codePointAt(c);
    else {
      if (d === 47)
        break;
      d = 47;
    }
    if (d === 47) {
      if (!(o === c - 1 || u === 1)) if (o !== c - 1 && u === 2) {
        if (r.length < 2 || a !== 2 || r.codePointAt(r.length - 1) !== 46 || r.codePointAt(r.length - 2) !== 46) {
          if (r.length > 2) {
            if (g = r.lastIndexOf("/"), g !== r.length - 1) {
              g < 0 ? (r = "", a = 0) : (r = r.slice(0, g), a = r.length - 1 - r.lastIndexOf("/")), o = c, u = 0;
              continue;
            }
          } else if (r.length > 0) {
            r = "", a = 0, o = c, u = 0;
            continue;
          }
        }
        t && (r = r.length > 0 ? r + "/.." : "..", a = 2);
      } else
        r.length > 0 ? r += "/" + e.slice(o + 1, c) : r = e.slice(o + 1, c), a = c - o - 1;
      o = c, u = 0;
    } else d === 46 && u > -1 ? u++ : u = -1;
  }
  return r;
}
function assertPath$1(e) {
  if (typeof e != "string")
    throw new TypeError("Path must be a string. Received " + JSON.stringify(e));
}
const minproc = {
  cwd
};
function cwd() {
  return "/";
}
function isUrl(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function urlToPath(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!isUrl(e)) {
    const t = new TypeError('The "path" argument must be of type string or an instance of URL. Received `' + e + "`");
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return getPathFromURLPosix(e);
}
function getPathFromURLPosix(e) {
  if (e.hostname !== "") {
    const a = new TypeError('File URL host must be "localhost" or empty on darwin');
    throw a.code = "ERR_INVALID_FILE_URL_HOST", a;
  }
  const t = e.pathname;
  let r = -1;
  for (; ++r < t.length; )
    if (t.codePointAt(r) === 37 && t.codePointAt(r + 1) === 50) {
      const a = t.codePointAt(r + 2);
      if (a === 70 || a === 102) {
        const o = new TypeError("File URL path must not include encoded / characters");
        throw o.code = "ERR_INVALID_FILE_URL_PATH", o;
      }
    }
  return decodeURIComponent(t);
}
const order = (
  /** @type {const} */
  ["history", "path", "basename", "stem", "extname", "dirname"]
);
class VFile {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let r;
    t ? isUrl(t) ? r = {
      path: t
    } : typeof t == "string" || isUint8Array$1(t) ? r = {
      value: t
    } : r = t : r = {}, this.cwd = "cwd" in r ? "" : minproc.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let a = -1;
    for (; ++a < order.length; ) {
      const u = order[a];
      u in r && r[u] !== void 0 && r[u] !== null && (this[u] = u === "history" ? [...r[u]] : r[u]);
    }
    let o;
    for (o in r)
      order.includes(o) || (this[o] = r[o]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? minpath.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    assertNonEmpty(t, "basename"), assertPart(t, "basename"), this.path = minpath.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? minpath.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    assertPath(this.basename, "dirname"), this.path = minpath.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? minpath.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (assertPart(t, "extname"), assertPath(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = minpath.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    isUrl(t) && (t = urlToPath(t)), assertNonEmpty(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? minpath.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    assertNonEmpty(t, "stem"), assertPart(t, "stem"), this.path = minpath.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, r, a) {
    const o = this.message(t, r, a);
    throw o.fatal = !0, o;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, r, a) {
    const o = this.message(t, r, a);
    return o.fatal = void 0, o;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, r, a) {
    const o = new VFileMessage(
      // @ts-expect-error: the overloads are fine.
      t,
      r,
      a
    );
    return this.path && (o.name = this.path + ":" + o.name, o.file = this.path), o.fatal = !1, this.messages.push(o), o;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function assertPart(e, t) {
  if (e && e.includes(minpath.sep))
    throw new Error("`" + t + "` cannot be a path: did not expect `" + minpath.sep + "`");
}
function assertNonEmpty(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function assertPath(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function isUint8Array$1(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const CallableInstance = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const a = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), o = a[e], u = function() {
      return o.apply(u, arguments);
    };
    return Object.setPrototypeOf(u, a), u;
  }
), own$c = {}.hasOwnProperty;
class Processor extends CallableInstance {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = trough();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Processor()
    );
    let r = -1;
    for (; ++r < this.attachers.length; ) {
      const a = this.attachers[r];
      t.use(...a);
    }
    return t.data(extend$2(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, r) {
    return typeof t == "string" ? arguments.length === 2 ? (assertUnfrozen("data", this.frozen), this.namespace[t] = r, this) : own$c.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (assertUnfrozen("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [r, ...a] = this.attachers[this.freezeIndex];
      if (a[0] === !1)
        continue;
      a[0] === !0 && (a[0] = void 0);
      const o = r.call(t, ...a);
      typeof o == "function" && this.transformers.use(o);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const r = vfile(t), a = this.parser || this.Parser;
    return assertParser("parse", a), a(String(r), r);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, r) {
    const a = this;
    return this.freeze(), assertParser("process", this.parser || this.Parser), assertCompiler("process", this.compiler || this.Compiler), r ? o(void 0, r) : new Promise(o);
    function o(u, c) {
      const d = vfile(t), g = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        a.parse(d)
      );
      a.run(g, d, function(_, y, A) {
        if (_ || !y || !A)
          return b(_);
        const E = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          y
        ), v = a.stringify(E, A);
        looksLikeAValue(v) ? A.value = v : A.result = v, b(
          _,
          /** @type {VFileWithOutput<CompileResult>} */
          A
        );
      });
      function b(_, y) {
        _ || !y ? c(_) : u ? u(y) : r(void 0, y);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let r = !1, a;
    return this.freeze(), assertParser("processSync", this.parser || this.Parser), assertCompiler("processSync", this.compiler || this.Compiler), this.process(t, o), assertDone("processSync", "process", r), a;
    function o(u, c) {
      r = !0, bail(u), a = c;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, r, a) {
    assertNode(t), this.freeze();
    const o = this.transformers;
    return !a && typeof r == "function" && (a = r, r = void 0), a ? u(void 0, a) : new Promise(u);
    function u(c, d) {
      const g = vfile(r);
      o.run(t, g, b);
      function b(_, y, A) {
        const E = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          y || t
        );
        _ ? d(_) : c ? c(E) : a(void 0, E, A);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, r) {
    let a = !1, o;
    return this.run(t, r, u), assertDone("runSync", "run", a), o;
    function u(c, d) {
      bail(c), o = d, a = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, r) {
    this.freeze();
    const a = vfile(r), o = this.compiler || this.Compiler;
    return assertCompiler("stringify", o), assertNode(t), o(t, a);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...r) {
    const a = this.attachers, o = this.namespace;
    if (assertUnfrozen("use", this.frozen), t != null) if (typeof t == "function")
      g(t, r);
    else if (typeof t == "object")
      Array.isArray(t) ? d(t) : c(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function u(b) {
      if (typeof b == "function")
        g(b, []);
      else if (typeof b == "object")
        if (Array.isArray(b)) {
          const [_, ...y] = (
            /** @type {PluginTuple<Array<unknown>>} */
            b
          );
          g(_, y);
        } else
          c(b);
      else
        throw new TypeError("Expected usable value, not `" + b + "`");
    }
    function c(b) {
      if (!("plugins" in b) && !("settings" in b))
        throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither");
      d(b.plugins), b.settings && (o.settings = extend$2(!0, o.settings, b.settings));
    }
    function d(b) {
      let _ = -1;
      if (b != null) if (Array.isArray(b))
        for (; ++_ < b.length; ) {
          const y = b[_];
          u(y);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + b + "`");
    }
    function g(b, _) {
      let y = -1, A = -1;
      for (; ++y < a.length; )
        if (a[y][0] === b) {
          A = y;
          break;
        }
      if (A === -1)
        a.push([b, ..._]);
      else if (_.length > 0) {
        let [E, ...v] = _;
        const C = a[A][1];
        isPlainObject(C) && isPlainObject(E) && (E = extend$2(!0, C, E)), a[A] = [b, E, ...v];
      }
    }
  }
}
const unified = new Processor().freeze();
function assertParser(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function assertCompiler(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function assertUnfrozen(e, t) {
  if (t)
    throw new Error("Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.");
}
function assertNode(e) {
  if (!isPlainObject(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function assertDone(e, t, r) {
  if (!r)
    throw new Error("`" + e + "` finished async. Use `" + t + "` instead");
}
function vfile(e) {
  return looksLikeAVFile(e) ? e : new VFile(e);
}
function looksLikeAVFile(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function looksLikeAValue(e) {
  return typeof e == "string" || isUint8Array(e);
}
function isUint8Array(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", emptyPlugins = [], emptyRemarkRehypeOptions = {
  allowDangerousHtml: !0
}, safeProtocol$1 = /^(https?|ircs?|mailto|xmpp)$/i, deprecations = [{
  from: "astPlugins",
  id: "remove-buggy-html-in-markdown-parser"
}, {
  from: "allowDangerousHtml",
  id: "remove-buggy-html-in-markdown-parser"
}, {
  from: "allowNode",
  id: "replace-allownode-allowedtypes-and-disallowedtypes",
  to: "allowElement"
}, {
  from: "allowedTypes",
  id: "replace-allownode-allowedtypes-and-disallowedtypes",
  to: "allowedElements"
}, {
  from: "disallowedTypes",
  id: "replace-allownode-allowedtypes-and-disallowedtypes",
  to: "disallowedElements"
}, {
  from: "escapeHtml",
  id: "remove-buggy-html-in-markdown-parser"
}, {
  from: "includeElementIndex",
  id: "#remove-includeelementindex"
}, {
  from: "includeNodeIndex",
  id: "change-includenodeindex-to-includeelementindex"
}, {
  from: "linkTarget",
  id: "remove-linktarget"
}, {
  from: "plugins",
  id: "change-plugins-to-remarkplugins",
  to: "remarkPlugins"
}, {
  from: "rawSourcePos",
  id: "#remove-rawsourcepos"
}, {
  from: "renderers",
  id: "change-renderers-to-components",
  to: "components"
}, {
  from: "source",
  id: "change-source-to-children",
  to: "children"
}, {
  from: "sourcePos",
  id: "#remove-sourcepos"
}, {
  from: "transformImageUri",
  id: "#add-urltransform",
  to: "urlTransform"
}, {
  from: "transformLinkUri",
  id: "#add-urltransform",
  to: "urlTransform"
}];
function Markdown$1(e) {
  const t = e.allowedElements, r = e.allowElement, a = e.children || "", o = e.className, u = e.components, c = e.disallowedElements, d = e.rehypePlugins || emptyPlugins, g = e.remarkPlugins || emptyPlugins, b = e.remarkRehypeOptions ? {
    ...e.remarkRehypeOptions,
    ...emptyRemarkRehypeOptions
  } : emptyRemarkRehypeOptions, _ = e.skipHtml, y = e.unwrapDisallowed, A = e.urlTransform || defaultUrlTransform, E = unified().use(remarkParse).use(g).use(remarkRehype, b).use(d), v = new VFile();
  typeof a == "string" && (v.value = a);
  for (const w of deprecations)
    Object.hasOwn(e, w.from) && ("" + w.from + (w.to ? "use `" + w.to + "` instead" : "remove it") + changelog + w.id, void 0);
  const C = E.parse(v);
  let R = E.runSync(C, v);
  return o && (R = {
    type: "element",
    tagName: "div",
    properties: {
      className: o
    },
    // Assume no doctypes.
    children: (
      /** @type {Array<ElementContent>} */
      R.type === "root" ? R.children : [R]
    )
  }), visit(R, I), toJsxRuntime(R, {
    Fragment: jsxRuntimeExports.Fragment,
    // @ts-expect-error
    // React components are allowed to return numbers,
    // but not according to the types in hast-util-to-jsx-runtime
    components: u,
    ignoreInvalidStyle: !0,
    jsx: jsxRuntimeExports.jsx,
    jsxs: jsxRuntimeExports.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function I(w, N, F) {
    if (w.type === "raw" && F && typeof N == "number")
      return _ ? F.children.splice(N, 1) : F.children[N] = {
        type: "text",
        value: w.value
      }, N;
    if (w.type === "element") {
      let M;
      for (M in urlAttributes)
        if (Object.hasOwn(urlAttributes, M) && Object.hasOwn(w.properties, M)) {
          const x = w.properties[M], P = urlAttributes[M];
          (P === null || P.includes(w.tagName)) && (w.properties[M] = A(String(x || ""), M, w));
        }
    }
    if (w.type === "element") {
      let M = t ? !t.includes(w.tagName) : c ? c.includes(w.tagName) : !1;
      if (!M && r && typeof N == "number" && (M = !r(w, N, F)), M && F && typeof N == "number")
        return y && w.children ? F.children.splice(N, 1, ...w.children) : F.children.splice(N, 1), N;
    }
  }
}
function defaultUrlTransform(e) {
  const t = e.indexOf(":"), r = e.indexOf("?"), a = e.indexOf("#"), o = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t === -1 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    o !== -1 && t > o || r !== -1 && t > r || a !== -1 && t > a || // It is a protocol, it should be allowed.
    safeProtocol$1.test(e.slice(0, t)) ? e : ""
  );
}
var isMergeableObject = function e(t) {
  return isNonNullObject(t) && !isSpecial(t);
};
function isNonNullObject(e) {
  return !!e && typeof e == "object";
}
function isSpecial(e) {
  var t = Object.prototype.toString.call(e);
  return t === "[object RegExp]" || t === "[object Date]" || isReactElement(e);
}
var canUseSymbol = typeof Symbol == "function" && Symbol.for, REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(e) {
  return e.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(e) {
  return Array.isArray(e) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(e, t) {
  return t.clone !== !1 && t.isMergeableObject(e) ? deepmerge(emptyTarget(e), e, t) : e;
}
function defaultArrayMerge(e, t, r) {
  return e.concat(t).map(function(a) {
    return cloneUnlessOtherwiseSpecified(a, r);
  });
}
function getMergeFunction(e, t) {
  if (!t.customMerge)
    return deepmerge;
  var r = t.customMerge(e);
  return typeof r == "function" ? r : deepmerge;
}
function getEnumerableOwnPropertySymbols(e) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e).filter(function(t) {
    return Object.propertyIsEnumerable.call(e, t);
  }) : [];
}
function getKeys(e) {
  return Object.keys(e).concat(getEnumerableOwnPropertySymbols(e));
}
function propertyIsOnObject(e, t) {
  try {
    return t in e;
  } catch {
    return !1;
  }
}
function propertyIsUnsafe(e, t) {
  return propertyIsOnObject(e, t) && !(Object.hasOwnProperty.call(e, t) && Object.propertyIsEnumerable.call(e, t));
}
function mergeObject(e, t, r) {
  var a = {};
  return r.isMergeableObject(e) && getKeys(e).forEach(function(o) {
    a[o] = cloneUnlessOtherwiseSpecified(e[o], r);
  }), getKeys(t).forEach(function(o) {
    propertyIsUnsafe(e, o) || (propertyIsOnObject(e, o) && r.isMergeableObject(t[o]) ? a[o] = getMergeFunction(o, r)(e[o], t[o], r) : a[o] = cloneUnlessOtherwiseSpecified(t[o], r));
  }), a;
}
function deepmerge(e, t, r) {
  r = r || {}, r.arrayMerge = r.arrayMerge || defaultArrayMerge, r.isMergeableObject = r.isMergeableObject || isMergeableObject, r.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
  var a = Array.isArray(t), o = Array.isArray(e), u = a === o;
  return u ? a ? r.arrayMerge(e, t, r) : mergeObject(e, t, r) : cloneUnlessOtherwiseSpecified(t, r);
}
deepmerge.all = function e(t, r) {
  if (!Array.isArray(t))
    throw new Error("first argument should be an array");
  return t.reduce(function(a, o) {
    return deepmerge(a, o, r);
  }, {});
};
var deepmerge_1 = deepmerge, cjs = deepmerge_1;
const deepmerge$1 = /* @__PURE__ */ getDefaultExportFromCjs(cjs), dark = `.markdown-body{color-scheme:dark;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;margin:0;color:#f0f6fc;background-color:#0d1117;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Noto Sans,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";font-size:16px;line-height:1.5;word-wrap:break-word}.markdown-body .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}.markdown-body h1:hover .anchor .octicon-link:before,.markdown-body h2:hover .anchor .octicon-link:before,.markdown-body h3:hover .anchor .octicon-link:before,.markdown-body h4:hover .anchor .octicon-link:before,.markdown-body h5:hover .anchor .octicon-link:before,.markdown-body h6:hover .anchor .octicon-link:before{width:16px;height:16px;content:" ";display:inline-block;background-color:currentColor;-webkit-mask-image:url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");mask-image:url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>")}.markdown-body details,.markdown-body figcaption,.markdown-body figure{display:block}.markdown-body summary{display:list-item}.markdown-body [hidden]{display:none!important}.markdown-body a{background-color:transparent;color:#4493f8;text-decoration:none}.markdown-body abbr[title]{border-bottom:none;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}.markdown-body b,.markdown-body strong{font-weight:600}.markdown-body dfn{font-style:italic}.markdown-body h1{margin:.67em 0;font-weight:600;padding-bottom:.3em;font-size:2em;border-bottom:1px solid #3d444db3}.markdown-body mark{background-color:#bb800926;color:#f0f6fc}.markdown-body small{font-size:90%}.markdown-body sub,.markdown-body sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}.markdown-body sub{bottom:-.25em}.markdown-body sup{top:-.5em}.markdown-body img{border-style:none;max-width:100%;box-sizing:content-box}.markdown-body code,.markdown-body kbd,.markdown-body pre,.markdown-body samp{font-family:monospace;font-size:1em}.markdown-body figure{margin:1em 2.5rem}.markdown-body hr{box-sizing:content-box;overflow:hidden;background:transparent;border-bottom:1px solid #3d444db3;height:.25em;padding:0;margin:1.5rem 0;background-color:#3d444d;border:0}.markdown-body input{font:inherit;margin:0;overflow:visible;font-family:inherit;font-size:inherit;line-height:inherit}.markdown-body [type=button],.markdown-body [type=reset],.markdown-body [type=submit]{-webkit-appearance:button;-moz-appearance:button;appearance:button}.markdown-body [type=checkbox],.markdown-body [type=radio]{box-sizing:border-box;padding:0}.markdown-body [type=number]::-webkit-inner-spin-button,.markdown-body [type=number]::-webkit-outer-spin-button{height:auto}.markdown-body [type=search]::-webkit-search-cancel-button,.markdown-body [type=search]::-webkit-search-decoration{-webkit-appearance:none;-moz-appearance:none;appearance:none}.markdown-body ::-webkit-input-placeholder{color:inherit;opacity:.54}.markdown-body ::-webkit-file-upload-button{-webkit-appearance:button;-moz-appearance:button;appearance:button;font:inherit}.markdown-body a:hover{text-decoration:underline}.markdown-body ::placeholder{color:#9198a1;opacity:1}.markdown-body hr:before{display:table;content:""}.markdown-body hr:after{display:table;clear:both;content:""}.markdown-body table{border-spacing:0;border-collapse:collapse;display:block;width:max-content;max-width:100%;overflow:auto;font-variant:tabular-nums}.markdown-body td,.markdown-body th{padding:0}.markdown-body details summary{cursor:pointer}.markdown-body a:focus,.markdown-body [role=button]:focus,.markdown-body input[type=radio]:focus,.markdown-body input[type=checkbox]:focus{outline:2px solid #1f6feb;outline-offset:-2px;box-shadow:none}.markdown-body a:focus:not(:focus-visible),.markdown-body [role=button]:focus:not(:focus-visible),.markdown-body input[type=radio]:focus:not(:focus-visible),.markdown-body input[type=checkbox]:focus:not(:focus-visible){outline:solid 1px transparent}.markdown-body a:focus-visible,.markdown-body [role=button]:focus-visible,.markdown-body input[type=radio]:focus-visible,.markdown-body input[type=checkbox]:focus-visible{outline:2px solid #1f6feb;outline-offset:-2px;box-shadow:none}.markdown-body a:not([class]):focus,.markdown-body a:not([class]):focus-visible,.markdown-body input[type=radio]:focus,.markdown-body input[type=radio]:focus-visible,.markdown-body input[type=checkbox]:focus,.markdown-body input[type=checkbox]:focus-visible{outline-offset:0}.markdown-body kbd{display:inline-block;padding:.25rem;font:11px ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;line-height:10px;color:#f0f6fc;vertical-align:middle;background-color:#151b23;border:solid 1px #3d444db3;border-bottom-color:#3d444db3;border-radius:6px;box-shadow:inset 0 -1px #3d444db3}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin-top:1.5rem;margin-bottom:1rem;font-weight:600;line-height:1.25}.markdown-body h2{font-weight:600;padding-bottom:.3em;font-size:1.5em;border-bottom:1px solid #3d444db3}.markdown-body h3{font-weight:600;font-size:1.25em}.markdown-body h4{font-weight:600;font-size:1em}.markdown-body h5{font-weight:600;font-size:.875em}.markdown-body h6{font-weight:600;font-size:.85em;color:#9198a1}.markdown-body p{margin-top:0;margin-bottom:10px}.markdown-body blockquote{margin:0;padding:0 1em;color:#9198a1;border-left:.25em solid #3d444d}.markdown-body ul,.markdown-body ol{margin-top:0;margin-bottom:0;padding-left:2em}.markdown-body ol ol,.markdown-body ul ol{list-style-type:lower-roman}.markdown-body ul ul ol,.markdown-body ul ol ol,.markdown-body ol ul ol,.markdown-body ol ol ol{list-style-type:lower-alpha}.markdown-body dd{margin-left:0}.markdown-body tt,.markdown-body code,.markdown-body samp{font-family:ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;font-size:12px}.markdown-body pre{margin-top:0;margin-bottom:0;font-family:ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;font-size:12px;word-wrap:normal}.markdown-body .octicon{display:inline-block;overflow:visible!important;vertical-align:text-bottom;fill:currentColor}.markdown-body input::-webkit-outer-spin-button,.markdown-body input::-webkit-inner-spin-button{margin:0;-webkit-appearance:none;-moz-appearance:none;appearance:none}.markdown-body .mr-2{margin-right:.5rem!important}.markdown-body:before{display:table;content:""}.markdown-body:after{display:table;clear:both;content:""}.markdown-body>*:first-child{margin-top:0!important}.markdown-body>*:last-child{margin-bottom:0!important}.markdown-body a:not([href]){color:inherit;text-decoration:none}.markdown-body .absent{color:#f85149}.markdown-body .anchor{float:left;padding-right:.25rem;margin-left:-20px;line-height:1}.markdown-body .anchor:focus{outline:none}.markdown-body p,.markdown-body blockquote,.markdown-body ul,.markdown-body ol,.markdown-body dl,.markdown-body table,.markdown-body pre,.markdown-body details{margin-top:0;margin-bottom:1rem}.markdown-body blockquote>:first-child{margin-top:0}.markdown-body blockquote>:last-child{margin-bottom:0}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{color:#f0f6fc;vertical-align:middle;visibility:hidden}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{text-decoration:none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{visibility:visible}.markdown-body h1 tt,.markdown-body h1 code,.markdown-body h2 tt,.markdown-body h2 code,.markdown-body h3 tt,.markdown-body h3 code,.markdown-body h4 tt,.markdown-body h4 code,.markdown-body h5 tt,.markdown-body h5 code,.markdown-body h6 tt,.markdown-body h6 code{padding:0 .2em;font-size:inherit}.markdown-body summary h1,.markdown-body summary h2,.markdown-body summary h3,.markdown-body summary h4,.markdown-body summary h5,.markdown-body summary h6{display:inline-block}.markdown-body summary h1 .anchor,.markdown-body summary h2 .anchor,.markdown-body summary h3 .anchor,.markdown-body summary h4 .anchor,.markdown-body summary h5 .anchor,.markdown-body summary h6 .anchor{margin-left:-40px}.markdown-body summary h1,.markdown-body summary h2{padding-bottom:0;border-bottom:0}.markdown-body ul.no-list,.markdown-body ol.no-list{padding:0;list-style-type:none}.markdown-body ol[type="a s"]{list-style-type:lower-alpha}.markdown-body ol[type="A s"]{list-style-type:upper-alpha}.markdown-body ol[type="i s"]{list-style-type:lower-roman}.markdown-body ol[type="I s"]{list-style-type:upper-roman}.markdown-body ol[type="1"]{list-style-type:decimal}.markdown-body div>ol:not([type]){list-style-type:decimal}.markdown-body ul ul,.markdown-body ul ol,.markdown-body ol ol,.markdown-body ol ul{margin-top:0;margin-bottom:0}.markdown-body li>p{margin-top:1rem}.markdown-body li+li{margin-top:.25em}.markdown-body dl{padding:0}.markdown-body dl dt{padding:0;margin-top:1rem;font-size:1em;font-style:italic;font-weight:600}.markdown-body dl dd{padding:0 1rem;margin-bottom:1rem}.markdown-body table th{font-weight:600}.markdown-body table th,.markdown-body table td{padding:6px 13px;border:1px solid #3d444d}.markdown-body table td>:last-child{margin-bottom:0}.markdown-body table tr{background-color:#0d1117;border-top:1px solid #3d444db3}.markdown-body table tr:nth-child(2n){background-color:#151b23}.markdown-body table img{background-color:transparent}.markdown-body img[align=right]{padding-left:20px}.markdown-body img[align=left]{padding-right:20px}.markdown-body .emoji{max-width:none;vertical-align:text-top;background-color:transparent}.markdown-body span.frame{display:block;overflow:hidden}.markdown-body span.frame>span{display:block;float:left;width:auto;padding:7px;margin:13px 0 0;overflow:hidden;border:1px solid #3d444d}.markdown-body span.frame span img{display:block;float:left}.markdown-body span.frame span span{display:block;padding:5px 0 0;clear:both;color:#f0f6fc}.markdown-body span.align-center{display:block;overflow:hidden;clear:both}.markdown-body span.align-center>span{display:block;margin:13px auto 0;overflow:hidden;text-align:center}.markdown-body span.align-center span img{margin:0 auto;text-align:center}.markdown-body span.align-right{display:block;overflow:hidden;clear:both}.markdown-body span.align-right>span{display:block;margin:13px 0 0;overflow:hidden;text-align:right}.markdown-body span.align-right span img{margin:0;text-align:right}.markdown-body span.float-left{display:block;float:left;margin-right:13px;overflow:hidden}.markdown-body span.float-left span{margin:13px 0 0}.markdown-body span.float-right{display:block;float:right;margin-left:13px;overflow:hidden}.markdown-body span.float-right>span{display:block;margin:13px auto 0;overflow:hidden;text-align:right}.markdown-body code,.markdown-body tt{padding:.2em .4em;margin:0;font-size:85%;white-space:break-spaces;background-color:#656c7633;border-radius:6px}.markdown-body code br,.markdown-body tt br{display:none}.markdown-body del code{text-decoration:inherit}.markdown-body samp{font-size:85%}.markdown-body pre code{font-size:100%}.markdown-body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:transparent;border:0}.markdown-body .highlight{margin-bottom:1rem}.markdown-body .highlight pre{margin-bottom:0;word-break:normal}.markdown-body .highlight pre,.markdown-body pre{padding:1rem;overflow:auto;font-size:85%;line-height:1.45;color:#f0f6fc;background-color:#151b23;border-radius:6px}.markdown-body pre code,.markdown-body pre tt{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}.markdown-body .csv-data td,.markdown-body .csv-data th{padding:5px;overflow:hidden;font-size:12px;line-height:1;text-align:left;white-space:nowrap}.markdown-body .csv-data .blob-num{padding:10px .5rem 9px;text-align:right;background:#0d1117;border:0}.markdown-body .csv-data tr{border-top:0}.markdown-body .csv-data th{font-weight:600;background:#151b23;border-top:0}.markdown-body [data-footnote-ref]:before{content:"["}.markdown-body [data-footnote-ref]:after{content:"]"}.markdown-body .footnotes{font-size:12px;color:#9198a1;border-top:1px solid #3d444d}.markdown-body .footnotes ol{padding-left:1rem}.markdown-body .footnotes ol ul{display:inline-block;padding-left:1rem;margin-top:1rem}.markdown-body .footnotes li{position:relative}.markdown-body .footnotes li:target:before{position:absolute;top:-.5rem;right:-.5rem;bottom:-.5rem;left:-1.5rem;pointer-events:none;content:"";border:2px solid #1f6feb;border-radius:6px}.markdown-body .footnotes li:target{color:#f0f6fc}.markdown-body .footnotes .data-footnote-backref g-emoji{font-family:monospace}.markdown-body body:has(:modal){padding-right:var(--dialog-scrollgutter)!important}.markdown-body .pl-c{color:#9198a1}.markdown-body .pl-c1,.markdown-body .pl-s .pl-v{color:#79c0ff}.markdown-body .pl-e,.markdown-body .pl-en{color:#d2a8ff}.markdown-body .pl-smi,.markdown-body .pl-s .pl-s1{color:#f0f6fc}.markdown-body .pl-ent{color:#7ee787}.markdown-body .pl-k{color:#ff7b72}.markdown-body .pl-s,.markdown-body .pl-pds,.markdown-body .pl-s .pl-pse .pl-s1,.markdown-body .pl-sr,.markdown-body .pl-sr .pl-cce,.markdown-body .pl-sr .pl-sre,.markdown-body .pl-sr .pl-sra{color:#a5d6ff}.markdown-body .pl-v,.markdown-body .pl-smw{color:#ffa657}.markdown-body .pl-bu{color:#f85149}.markdown-body .pl-ii{color:#f0f6fc;background-color:#8e1519}.markdown-body .pl-c2{color:#f0f6fc;background-color:#b62324}.markdown-body .pl-sr .pl-cce{font-weight:700;color:#7ee787}.markdown-body .pl-ml{color:#f2cc60}.markdown-body .pl-mh,.markdown-body .pl-mh .pl-en,.markdown-body .pl-ms{font-weight:700;color:#1f6feb}.markdown-body .pl-mi{font-style:italic;color:#f0f6fc}.markdown-body .pl-mb{font-weight:700;color:#f0f6fc}.markdown-body .pl-md{color:#ffdcd7;background-color:#67060c}.markdown-body .pl-mi1{color:#aff5b4;background-color:#033a16}.markdown-body .pl-mc{color:#ffdfb6;background-color:#5a1e02}.markdown-body .pl-mi2{color:#f0f6fc;background-color:#1158c7}.markdown-body .pl-mdr{font-weight:700;color:#d2a8ff}.markdown-body .pl-ba{color:#9198a1}.markdown-body .pl-sg{color:#3d444d}.markdown-body .pl-corl{text-decoration:underline;color:#a5d6ff}.markdown-body [role=button]:focus:not(:focus-visible),.markdown-body [role=tabpanel][tabindex="0"]:focus:not(:focus-visible),.markdown-body button:focus:not(:focus-visible),.markdown-body summary:focus:not(:focus-visible),.markdown-body a:focus:not(:focus-visible){outline:none;box-shadow:none}.markdown-body [tabindex="0"]:focus:not(:focus-visible),.markdown-body details-dialog:focus:not(:focus-visible){outline:none}.markdown-body g-emoji{display:inline-block;min-width:1ch;font-family:"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol;font-size:1em;font-style:normal!important;font-weight:400;line-height:1;vertical-align:-.075em}.markdown-body g-emoji img{width:1em;height:1em}.markdown-body .task-list-item{list-style-type:none}.markdown-body .task-list-item label{font-weight:400}.markdown-body .task-list-item.enabled label{cursor:pointer}.markdown-body .task-list-item+.task-list-item{margin-top:.25rem}.markdown-body .task-list-item .handle{display:none}.markdown-body .task-list-item-checkbox{margin:0 .2em .25em -1.4em;vertical-align:middle}.markdown-body ul:dir(rtl) .task-list-item-checkbox{margin:0 -1.6em .25em .2em}.markdown-body ol:dir(rtl) .task-list-item-checkbox{margin:0 -1.6em .25em .2em}.markdown-body .contains-task-list:hover .task-list-item-convert-container,.markdown-body .contains-task-list:focus-within .task-list-item-convert-container{display:block;width:auto;height:24px;overflow:visible;clip:auto}.markdown-body ::-webkit-calendar-picker-indicator{filter:invert(50%)}.markdown-body .markdown-alert{padding:.5rem 1rem;margin-bottom:1rem;color:inherit;border-left:.25em solid #3d444d}.markdown-body .markdown-alert>:first-child{margin-top:0}.markdown-body .markdown-alert>:last-child{margin-bottom:0}.markdown-body .markdown-alert .markdown-alert-title{display:flex;font-weight:500;align-items:center;line-height:1}.markdown-body .markdown-alert.markdown-alert-note{border-left-color:#1f6feb}.markdown-body .markdown-alert.markdown-alert-note .markdown-alert-title{color:#4493f8}.markdown-body .markdown-alert.markdown-alert-important{border-left-color:#8957e5}.markdown-body .markdown-alert.markdown-alert-important .markdown-alert-title{color:#ab7df8}.markdown-body .markdown-alert.markdown-alert-warning{border-left-color:#9e6a03}.markdown-body .markdown-alert.markdown-alert-warning .markdown-alert-title{color:#d29922}.markdown-body .markdown-alert.markdown-alert-tip{border-left-color:#238636}.markdown-body .markdown-alert.markdown-alert-tip .markdown-alert-title{color:#3fb950}.markdown-body .markdown-alert.markdown-alert-caution{border-left-color:#da3633}.markdown-body .markdown-alert.markdown-alert-caution .markdown-alert-title{color:#f85149}.markdown-body>*:first-child>.heading-element:first-child{margin-top:0!important}.markdown-body .highlight pre:has(+.zeroclipboard-container){min-height:52px}`, light = `.markdown-body{color-scheme:light;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;margin:0;color:#1f2328;background-color:#fff;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Noto Sans,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";font-size:16px;line-height:1.5;word-wrap:break-word}.markdown-body .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}.markdown-body h1:hover .anchor .octicon-link:before,.markdown-body h2:hover .anchor .octicon-link:before,.markdown-body h3:hover .anchor .octicon-link:before,.markdown-body h4:hover .anchor .octicon-link:before,.markdown-body h5:hover .anchor .octicon-link:before,.markdown-body h6:hover .anchor .octicon-link:before{width:16px;height:16px;content:" ";display:inline-block;background-color:currentColor;-webkit-mask-image:url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");mask-image:url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>")}.markdown-body details,.markdown-body figcaption,.markdown-body figure{display:block}.markdown-body summary{display:list-item}.markdown-body [hidden]{display:none!important}.markdown-body a{background-color:transparent;color:#0969da;text-decoration:none}.markdown-body abbr[title]{border-bottom:none;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}.markdown-body b,.markdown-body strong{font-weight:600}.markdown-body dfn{font-style:italic}.markdown-body h1{margin:.67em 0;font-weight:600;padding-bottom:.3em;font-size:2em;border-bottom:1px solid #d1d9e0b3}.markdown-body mark{background-color:#fff8c5;color:#1f2328}.markdown-body small{font-size:90%}.markdown-body sub,.markdown-body sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}.markdown-body sub{bottom:-.25em}.markdown-body sup{top:-.5em}.markdown-body img{border-style:none;max-width:100%;box-sizing:content-box}.markdown-body code,.markdown-body kbd,.markdown-body pre,.markdown-body samp{font-family:monospace;font-size:1em}.markdown-body figure{margin:1em 2.5rem}.markdown-body hr{box-sizing:content-box;overflow:hidden;background:transparent;border-bottom:1px solid #d1d9e0b3;height:.25em;padding:0;margin:1.5rem 0;background-color:#d1d9e0;border:0}.markdown-body input{font:inherit;margin:0;overflow:visible;font-family:inherit;font-size:inherit;line-height:inherit}.markdown-body [type=button],.markdown-body [type=reset],.markdown-body [type=submit]{-webkit-appearance:button;-moz-appearance:button;appearance:button}.markdown-body [type=checkbox],.markdown-body [type=radio]{box-sizing:border-box;padding:0}.markdown-body [type=number]::-webkit-inner-spin-button,.markdown-body [type=number]::-webkit-outer-spin-button{height:auto}.markdown-body [type=search]::-webkit-search-cancel-button,.markdown-body [type=search]::-webkit-search-decoration{-webkit-appearance:none;-moz-appearance:none;appearance:none}.markdown-body ::-webkit-input-placeholder{color:inherit;opacity:.54}.markdown-body ::-webkit-file-upload-button{-webkit-appearance:button;-moz-appearance:button;appearance:button;font:inherit}.markdown-body a:hover{text-decoration:underline}.markdown-body ::placeholder{color:#59636e;opacity:1}.markdown-body hr:before{display:table;content:""}.markdown-body hr:after{display:table;clear:both;content:""}.markdown-body table{border-spacing:0;border-collapse:collapse;display:block;width:max-content;max-width:100%;overflow:auto;font-variant:tabular-nums}.markdown-body td,.markdown-body th{padding:0}.markdown-body details summary{cursor:pointer}.markdown-body a:focus,.markdown-body [role=button]:focus,.markdown-body input[type=radio]:focus,.markdown-body input[type=checkbox]:focus{outline:2px solid #0969da;outline-offset:-2px;box-shadow:none}.markdown-body a:focus:not(:focus-visible),.markdown-body [role=button]:focus:not(:focus-visible),.markdown-body input[type=radio]:focus:not(:focus-visible),.markdown-body input[type=checkbox]:focus:not(:focus-visible){outline:solid 1px transparent}.markdown-body a:focus-visible,.markdown-body [role=button]:focus-visible,.markdown-body input[type=radio]:focus-visible,.markdown-body input[type=checkbox]:focus-visible{outline:2px solid #0969da;outline-offset:-2px;box-shadow:none}.markdown-body a:not([class]):focus,.markdown-body a:not([class]):focus-visible,.markdown-body input[type=radio]:focus,.markdown-body input[type=radio]:focus-visible,.markdown-body input[type=checkbox]:focus,.markdown-body input[type=checkbox]:focus-visible{outline-offset:0}.markdown-body kbd{display:inline-block;padding:.25rem;font:11px ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;line-height:10px;color:#1f2328;vertical-align:middle;background-color:#f6f8fa;border:solid 1px #d1d9e0b3;border-bottom-color:#d1d9e0b3;border-radius:6px;box-shadow:inset 0 -1px #d1d9e0b3}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin-top:1.5rem;margin-bottom:1rem;font-weight:600;line-height:1.25}.markdown-body h2{font-weight:600;padding-bottom:.3em;font-size:1.5em;border-bottom:1px solid #d1d9e0b3}.markdown-body h3{font-weight:600;font-size:1.25em}.markdown-body h4{font-weight:600;font-size:1em}.markdown-body h5{font-weight:600;font-size:.875em}.markdown-body h6{font-weight:600;font-size:.85em;color:#59636e}.markdown-body p{margin-top:0;margin-bottom:10px}.markdown-body blockquote{margin:0;padding:0 1em;color:#59636e;border-left:.25em solid #d1d9e0}.markdown-body ul,.markdown-body ol{margin-top:0;margin-bottom:0;padding-left:2em}.markdown-body ol ol,.markdown-body ul ol{list-style-type:lower-roman}.markdown-body ul ul ol,.markdown-body ul ol ol,.markdown-body ol ul ol,.markdown-body ol ol ol{list-style-type:lower-alpha}.markdown-body dd{margin-left:0}.markdown-body tt,.markdown-body code,.markdown-body samp{font-family:ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;font-size:12px}.markdown-body pre{margin-top:0;margin-bottom:0;font-family:ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;font-size:12px;word-wrap:normal}.markdown-body .octicon{display:inline-block;overflow:visible!important;vertical-align:text-bottom;fill:currentColor}.markdown-body input::-webkit-outer-spin-button,.markdown-body input::-webkit-inner-spin-button{margin:0;-webkit-appearance:none;-moz-appearance:none;appearance:none}.markdown-body .mr-2{margin-right:.5rem!important}.markdown-body:before{display:table;content:""}.markdown-body:after{display:table;clear:both;content:""}.markdown-body>*:first-child{margin-top:0!important}.markdown-body>*:last-child{margin-bottom:0!important}.markdown-body a:not([href]){color:inherit;text-decoration:none}.markdown-body .absent{color:#d1242f}.markdown-body .anchor{float:left;padding-right:.25rem;margin-left:-20px;line-height:1}.markdown-body .anchor:focus{outline:none}.markdown-body p,.markdown-body blockquote,.markdown-body ul,.markdown-body ol,.markdown-body dl,.markdown-body table,.markdown-body pre,.markdown-body details{margin-top:0;margin-bottom:1rem}.markdown-body blockquote>:first-child{margin-top:0}.markdown-body blockquote>:last-child{margin-bottom:0}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{color:#1f2328;vertical-align:middle;visibility:hidden}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{text-decoration:none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{visibility:visible}.markdown-body h1 tt,.markdown-body h1 code,.markdown-body h2 tt,.markdown-body h2 code,.markdown-body h3 tt,.markdown-body h3 code,.markdown-body h4 tt,.markdown-body h4 code,.markdown-body h5 tt,.markdown-body h5 code,.markdown-body h6 tt,.markdown-body h6 code{padding:0 .2em;font-size:inherit}.markdown-body summary h1,.markdown-body summary h2,.markdown-body summary h3,.markdown-body summary h4,.markdown-body summary h5,.markdown-body summary h6{display:inline-block}.markdown-body summary h1 .anchor,.markdown-body summary h2 .anchor,.markdown-body summary h3 .anchor,.markdown-body summary h4 .anchor,.markdown-body summary h5 .anchor,.markdown-body summary h6 .anchor{margin-left:-40px}.markdown-body summary h1,.markdown-body summary h2{padding-bottom:0;border-bottom:0}.markdown-body ul.no-list,.markdown-body ol.no-list{padding:0;list-style-type:none}.markdown-body ol[type="a s"]{list-style-type:lower-alpha}.markdown-body ol[type="A s"]{list-style-type:upper-alpha}.markdown-body ol[type="i s"]{list-style-type:lower-roman}.markdown-body ol[type="I s"]{list-style-type:upper-roman}.markdown-body ol[type="1"]{list-style-type:decimal}.markdown-body div>ol:not([type]){list-style-type:decimal}.markdown-body ul ul,.markdown-body ul ol,.markdown-body ol ol,.markdown-body ol ul{margin-top:0;margin-bottom:0}.markdown-body li>p{margin-top:1rem}.markdown-body li+li{margin-top:.25em}.markdown-body dl{padding:0}.markdown-body dl dt{padding:0;margin-top:1rem;font-size:1em;font-style:italic;font-weight:600}.markdown-body dl dd{padding:0 1rem;margin-bottom:1rem}.markdown-body table th{font-weight:600}.markdown-body table th,.markdown-body table td{padding:6px 13px;border:1px solid #d1d9e0}.markdown-body table td>:last-child{margin-bottom:0}.markdown-body table tr{background-color:#fff;border-top:1px solid #d1d9e0b3}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}.markdown-body table img{background-color:transparent}.markdown-body img[align=right]{padding-left:20px}.markdown-body img[align=left]{padding-right:20px}.markdown-body .emoji{max-width:none;vertical-align:text-top;background-color:transparent}.markdown-body span.frame{display:block;overflow:hidden}.markdown-body span.frame>span{display:block;float:left;width:auto;padding:7px;margin:13px 0 0;overflow:hidden;border:1px solid #d1d9e0}.markdown-body span.frame span img{display:block;float:left}.markdown-body span.frame span span{display:block;padding:5px 0 0;clear:both;color:#1f2328}.markdown-body span.align-center{display:block;overflow:hidden;clear:both}.markdown-body span.align-center>span{display:block;margin:13px auto 0;overflow:hidden;text-align:center}.markdown-body span.align-center span img{margin:0 auto;text-align:center}.markdown-body span.align-right{display:block;overflow:hidden;clear:both}.markdown-body span.align-right>span{display:block;margin:13px 0 0;overflow:hidden;text-align:right}.markdown-body span.align-right span img{margin:0;text-align:right}.markdown-body span.float-left{display:block;float:left;margin-right:13px;overflow:hidden}.markdown-body span.float-left span{margin:13px 0 0}.markdown-body span.float-right{display:block;float:right;margin-left:13px;overflow:hidden}.markdown-body span.float-right>span{display:block;margin:13px auto 0;overflow:hidden;text-align:right}.markdown-body code,.markdown-body tt{padding:.2em .4em;margin:0;font-size:85%;white-space:break-spaces;background-color:#818b981f;border-radius:6px}.markdown-body code br,.markdown-body tt br{display:none}.markdown-body del code{text-decoration:inherit}.markdown-body samp{font-size:85%}.markdown-body pre code{font-size:100%}.markdown-body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:transparent;border:0}.markdown-body .highlight{margin-bottom:1rem}.markdown-body .highlight pre{margin-bottom:0;word-break:normal}.markdown-body .highlight pre,.markdown-body pre{padding:1rem;overflow:auto;font-size:85%;line-height:1.45;color:#1f2328;background-color:#f6f8fa;border-radius:6px}.markdown-body pre code,.markdown-body pre tt{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}.markdown-body .csv-data td,.markdown-body .csv-data th{padding:5px;overflow:hidden;font-size:12px;line-height:1;text-align:left;white-space:nowrap}.markdown-body .csv-data .blob-num{padding:10px .5rem 9px;text-align:right;background:#fff;border:0}.markdown-body .csv-data tr{border-top:0}.markdown-body .csv-data th{font-weight:600;background:#f6f8fa;border-top:0}.markdown-body [data-footnote-ref]:before{content:"["}.markdown-body [data-footnote-ref]:after{content:"]"}.markdown-body .footnotes{font-size:12px;color:#59636e;border-top:1px solid #d1d9e0}.markdown-body .footnotes ol{padding-left:1rem}.markdown-body .footnotes ol ul{display:inline-block;padding-left:1rem;margin-top:1rem}.markdown-body .footnotes li{position:relative}.markdown-body .footnotes li:target:before{position:absolute;top:-.5rem;right:-.5rem;bottom:-.5rem;left:-1.5rem;pointer-events:none;content:"";border:2px solid #0969da;border-radius:6px}.markdown-body .footnotes li:target{color:#1f2328}.markdown-body .footnotes .data-footnote-backref g-emoji{font-family:monospace}.markdown-body body:has(:modal){padding-right:var(--dialog-scrollgutter)!important}.markdown-body .pl-c{color:#59636e}.markdown-body .pl-c1,.markdown-body .pl-s .pl-v{color:#0550ae}.markdown-body .pl-e,.markdown-body .pl-en{color:#6639ba}.markdown-body .pl-smi,.markdown-body .pl-s .pl-s1{color:#1f2328}.markdown-body .pl-ent{color:#0550ae}.markdown-body .pl-k{color:#cf222e}.markdown-body .pl-s,.markdown-body .pl-pds,.markdown-body .pl-s .pl-pse .pl-s1,.markdown-body .pl-sr,.markdown-body .pl-sr .pl-cce,.markdown-body .pl-sr .pl-sre,.markdown-body .pl-sr .pl-sra{color:#0a3069}.markdown-body .pl-v,.markdown-body .pl-smw{color:#953800}.markdown-body .pl-bu{color:#82071e}.markdown-body .pl-ii{color:#f6f8fa;background-color:#82071e}.markdown-body .pl-c2{color:#f6f8fa;background-color:#cf222e}.markdown-body .pl-sr .pl-cce{font-weight:700;color:#116329}.markdown-body .pl-ml{color:#3b2300}.markdown-body .pl-mh,.markdown-body .pl-mh .pl-en,.markdown-body .pl-ms{font-weight:700;color:#0550ae}.markdown-body .pl-mi{font-style:italic;color:#1f2328}.markdown-body .pl-mb{font-weight:700;color:#1f2328}.markdown-body .pl-md{color:#82071e;background-color:#ffebe9}.markdown-body .pl-mi1{color:#116329;background-color:#dafbe1}.markdown-body .pl-mc{color:#953800;background-color:#ffd8b5}.markdown-body .pl-mi2{color:#d1d9e0;background-color:#0550ae}.markdown-body .pl-mdr{font-weight:700;color:#8250df}.markdown-body .pl-ba{color:#59636e}.markdown-body .pl-sg{color:#818b98}.markdown-body .pl-corl{text-decoration:underline;color:#0a3069}.markdown-body [role=button]:focus:not(:focus-visible),.markdown-body [role=tabpanel][tabindex="0"]:focus:not(:focus-visible),.markdown-body button:focus:not(:focus-visible),.markdown-body summary:focus:not(:focus-visible),.markdown-body a:focus:not(:focus-visible){outline:none;box-shadow:none}.markdown-body [tabindex="0"]:focus:not(:focus-visible),.markdown-body details-dialog:focus:not(:focus-visible){outline:none}.markdown-body g-emoji{display:inline-block;min-width:1ch;font-family:"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol;font-size:1em;font-style:normal!important;font-weight:400;line-height:1;vertical-align:-.075em}.markdown-body g-emoji img{width:1em;height:1em}.markdown-body .task-list-item{list-style-type:none}.markdown-body .task-list-item label{font-weight:400}.markdown-body .task-list-item.enabled label{cursor:pointer}.markdown-body .task-list-item+.task-list-item{margin-top:.25rem}.markdown-body .task-list-item .handle{display:none}.markdown-body .task-list-item-checkbox{margin:0 .2em .25em -1.4em;vertical-align:middle}.markdown-body ul:dir(rtl) .task-list-item-checkbox{margin:0 -1.6em .25em .2em}.markdown-body ol:dir(rtl) .task-list-item-checkbox{margin:0 -1.6em .25em .2em}.markdown-body .contains-task-list:hover .task-list-item-convert-container,.markdown-body .contains-task-list:focus-within .task-list-item-convert-container{display:block;width:auto;height:24px;overflow:visible;clip:auto}.markdown-body ::-webkit-calendar-picker-indicator{filter:invert(50%)}.markdown-body .markdown-alert{padding:.5rem 1rem;margin-bottom:1rem;color:inherit;border-left:.25em solid #d1d9e0}.markdown-body .markdown-alert>:first-child{margin-top:0}.markdown-body .markdown-alert>:last-child{margin-bottom:0}.markdown-body .markdown-alert .markdown-alert-title{display:flex;font-weight:500;align-items:center;line-height:1}.markdown-body .markdown-alert.markdown-alert-note{border-left-color:#0969da}.markdown-body .markdown-alert.markdown-alert-note .markdown-alert-title{color:#0969da}.markdown-body .markdown-alert.markdown-alert-important{border-left-color:#8250df}.markdown-body .markdown-alert.markdown-alert-important .markdown-alert-title{color:#8250df}.markdown-body .markdown-alert.markdown-alert-warning{border-left-color:#9a6700}.markdown-body .markdown-alert.markdown-alert-warning .markdown-alert-title{color:#9a6700}.markdown-body .markdown-alert.markdown-alert-tip{border-left-color:#1a7f37}.markdown-body .markdown-alert.markdown-alert-tip .markdown-alert-title{color:#1a7f37}.markdown-body .markdown-alert.markdown-alert-caution{border-left-color:#cf222e}.markdown-body .markdown-alert.markdown-alert-caution .markdown-alert-title{color:#d1242f}.markdown-body>*:first-child>.heading-element:first-child{margin-top:0!important}.markdown-body .highlight pre:has(+.zeroclipboard-container){min-height:52px}`;
let Schema$3 = class {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, r, a) {
    this.property = t, this.normal = r, a && (this.space = a);
  }
};
Schema$3.prototype.property = {};
Schema$3.prototype.normal = {};
Schema$3.prototype.space = null;
function merge$2(e, t) {
  const r = {}, a = {};
  let o = -1;
  for (; ++o < e.length; )
    Object.assign(r, e[o].property), Object.assign(a, e[o].normal);
  return new Schema$3(r, a, t);
}
function normalize$4(e) {
  return e.toLowerCase();
}
let Info$3 = class {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, r) {
    this.property = t, this.attribute = r;
  }
};
Info$3.prototype.space = null;
Info$3.prototype.boolean = !1;
Info$3.prototype.booleanish = !1;
Info$3.prototype.overloadedBoolean = !1;
Info$3.prototype.number = !1;
Info$3.prototype.commaSeparated = !1;
Info$3.prototype.spaceSeparated = !1;
Info$3.prototype.commaOrSpaceSeparated = !1;
Info$3.prototype.mustUseProperty = !1;
Info$3.prototype.defined = !1;
let powers$1 = 0;
const boolean$1 = increment$1(), booleanish$2 = increment$1(), overloadedBoolean$1 = increment$1(), number$2 = increment$1(), spaceSeparated$2 = increment$1(), commaSeparated$1 = increment$1(), commaOrSpaceSeparated = increment$1();
function increment$1() {
  return 2 ** ++powers$1;
}
const types$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: boolean$1,
  booleanish: booleanish$2,
  commaOrSpaceSeparated,
  commaSeparated: commaSeparated$1,
  number: number$2,
  overloadedBoolean: overloadedBoolean$1,
  spaceSeparated: spaceSeparated$2
}, Symbol.toStringTag, {
  value: "Module"
})), checks$1 = Object.keys(types$4);
let DefinedInfo$3 = class extends Info$3 {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, r, a, o) {
    let u = -1;
    if (super(t, r), mark$1(this, "space", o), typeof a == "number")
      for (; ++u < checks$1.length; ) {
        const c = checks$1[u];
        mark$1(this, checks$1[u], (a & types$4[c]) === types$4[c]);
      }
  }
};
DefinedInfo$3.prototype.defined = !0;
function mark$1(e, t, r) {
  r && (e[t] = r);
}
const own$b = {}.hasOwnProperty;
function create$6(e) {
  const t = {}, r = {};
  let a;
  for (a in e.properties)
    if (own$b.call(e.properties, a)) {
      const o = e.properties[a], u = new DefinedInfo$3(a, e.transform(e.attributes || {}, a), o, e.space);
      e.mustUseProperty && e.mustUseProperty.includes(a) && (u.mustUseProperty = !0), t[a] = u, r[normalize$4(a)] = a, r[normalize$4(u.attribute)] = a;
    }
  return new Schema$3(t, r, e.space);
}
const xlink$2 = create$6({
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), xml$2 = create$6({
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: {
    xmlLang: null,
    xmlBase: null,
    xmlSpace: null
  }
});
function caseSensitiveTransform$2(e, t) {
  return t in e ? e[t] : t;
}
function caseInsensitiveTransform$3(e, t) {
  return caseSensitiveTransform$2(e, t.toLowerCase());
}
const xmlns$2 = create$6({
  space: "xmlns",
  attributes: {
    xmlnsxlink: "xmlns:xlink"
  },
  transform: caseInsensitiveTransform$3,
  properties: {
    xmlns: null,
    xmlnsXLink: null
  }
}), aria$3 = create$6({
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish$2,
    ariaAutoComplete: null,
    ariaBusy: booleanish$2,
    ariaChecked: booleanish$2,
    ariaColCount: number$2,
    ariaColIndex: number$2,
    ariaColSpan: number$2,
    ariaControls: spaceSeparated$2,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated$2,
    ariaDetails: null,
    ariaDisabled: booleanish$2,
    ariaDropEffect: spaceSeparated$2,
    ariaErrorMessage: null,
    ariaExpanded: booleanish$2,
    ariaFlowTo: spaceSeparated$2,
    ariaGrabbed: booleanish$2,
    ariaHasPopup: null,
    ariaHidden: booleanish$2,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated$2,
    ariaLevel: number$2,
    ariaLive: null,
    ariaModal: booleanish$2,
    ariaMultiLine: booleanish$2,
    ariaMultiSelectable: booleanish$2,
    ariaOrientation: null,
    ariaOwns: spaceSeparated$2,
    ariaPlaceholder: null,
    ariaPosInSet: number$2,
    ariaPressed: booleanish$2,
    ariaReadOnly: booleanish$2,
    ariaRelevant: null,
    ariaRequired: booleanish$2,
    ariaRoleDescription: spaceSeparated$2,
    ariaRowCount: number$2,
    ariaRowIndex: number$2,
    ariaRowSpan: number$2,
    ariaSelected: booleanish$2,
    ariaSetSize: number$2,
    ariaSort: null,
    ariaValueMax: number$2,
    ariaValueMin: number$2,
    ariaValueNow: number$2,
    ariaValueText: null,
    role: null
  }
}), html$5 = create$6({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform$3,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated$1,
    acceptCharset: spaceSeparated$2,
    accessKey: spaceSeparated$2,
    action: null,
    allow: null,
    allowFullScreen: boolean$1,
    allowPaymentRequest: boolean$1,
    allowUserMedia: boolean$1,
    alt: null,
    as: null,
    async: boolean$1,
    autoCapitalize: null,
    autoComplete: spaceSeparated$2,
    autoFocus: boolean$1,
    autoPlay: boolean$1,
    blocking: spaceSeparated$2,
    capture: boolean$1,
    charSet: null,
    checked: boolean$1,
    cite: null,
    className: spaceSeparated$2,
    cols: number$2,
    colSpan: null,
    content: null,
    contentEditable: booleanish$2,
    controls: boolean$1,
    controlsList: spaceSeparated$2,
    coords: number$2 | commaSeparated$1,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean$1,
    defer: boolean$1,
    dir: null,
    dirName: null,
    disabled: boolean$1,
    download: overloadedBoolean$1,
    draggable: booleanish$2,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean$1,
    formTarget: null,
    headers: spaceSeparated$2,
    height: number$2,
    hidden: boolean$1,
    high: number$2,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated$2,
    httpEquiv: spaceSeparated$2,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean$1,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean$1,
    itemId: null,
    itemProp: spaceSeparated$2,
    itemRef: spaceSeparated$2,
    itemScope: boolean$1,
    itemType: spaceSeparated$2,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean$1,
    low: number$2,
    manifest: null,
    max: null,
    maxLength: number$2,
    media: null,
    method: null,
    min: null,
    minLength: number$2,
    multiple: boolean$1,
    muted: boolean$1,
    name: null,
    nonce: null,
    noModule: boolean$1,
    noValidate: boolean$1,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean$1,
    optimum: number$2,
    pattern: null,
    ping: spaceSeparated$2,
    placeholder: null,
    playsInline: boolean$1,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean$1,
    referrerPolicy: null,
    rel: spaceSeparated$2,
    required: boolean$1,
    reversed: boolean$1,
    rows: number$2,
    rowSpan: number$2,
    sandbox: spaceSeparated$2,
    scope: null,
    scoped: boolean$1,
    seamless: boolean$1,
    selected: boolean$1,
    shadowRootDelegatesFocus: boolean$1,
    shadowRootMode: null,
    shape: null,
    size: number$2,
    sizes: null,
    slot: null,
    span: number$2,
    spellCheck: booleanish$2,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number$2,
    step: null,
    style: null,
    tabIndex: number$2,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean$1,
    useMap: null,
    value: booleanish$2,
    width: number$2,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated$2,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number$2,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number$2,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean$1,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean$1,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number$2,
    // `<img>` and `<object>`
    leftMargin: number$2,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number$2,
    // `<body>`
    marginWidth: number$2,
    // `<body>`
    noResize: boolean$1,
    // `<frame>`
    noHref: boolean$1,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean$1,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean$1,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number$2,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish$2,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number$2,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number$2,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean$1,
    disableRemotePlayback: boolean$1,
    prefix: null,
    property: null,
    results: number$2,
    security: null,
    unselectable: null
  }
}), svg$1 = create$6({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: caseSensitiveTransform$2,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number$2,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number$2,
    amplitude: number$2,
    arabicForm: null,
    ascent: number$2,
    attributeName: null,
    attributeType: null,
    azimuth: number$2,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number$2,
    by: null,
    calcMode: null,
    capHeight: number$2,
    className: spaceSeparated$2,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number$2,
    diffuseConstant: number$2,
    direction: null,
    display: null,
    dur: null,
    divisor: number$2,
    dominantBaseline: null,
    download: boolean$1,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number$2,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number$2,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number$2,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated$1,
    g2: commaSeparated$1,
    glyphName: commaSeparated$1,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number$2,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number$2,
    horizOriginX: number$2,
    horizOriginY: number$2,
    id: null,
    ideographic: number$2,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number$2,
    k: number$2,
    k1: number$2,
    k2: number$2,
    k3: number$2,
    k4: number$2,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number$2,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number$2,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number$2,
    overlineThickness: number$2,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number$2,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated$2,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number$2,
    pointsAtY: number$2,
    pointsAtZ: number$2,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number$2,
    specularExponent: number$2,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number$2,
    strikethroughThickness: number$2,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number$2,
    strokeOpacity: number$2,
    strokeWidth: null,
    style: null,
    surfaceScale: number$2,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number$2,
    tableValues: null,
    target: null,
    targetX: number$2,
    targetY: number$2,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number$2,
    underlineThickness: number$2,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number$2,
    values: null,
    vAlphabetic: number$2,
    vMathematical: number$2,
    vectorEffect: null,
    vHanging: number$2,
    vIdeographic: number$2,
    version: null,
    vertAdvY: number$2,
    vertOriginX: number$2,
    vertOriginY: number$2,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number$2,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), valid$1 = /^data[-\w.:]+$/i, dash$1 = /-[a-z]/g, cap$1 = /[A-Z]/g;
function find$2(e, t) {
  const r = normalize$4(t);
  let a = t, o = Info$3;
  if (r in e.normal)
    return e.property[e.normal[r]];
  if (r.length > 4 && r.slice(0, 4) === "data" && valid$1.test(t)) {
    if (t.charAt(4) === "-") {
      const u = t.slice(5).replace(dash$1, camelcase$1);
      a = "data" + u.charAt(0).toUpperCase() + u.slice(1);
    } else {
      const u = t.slice(4);
      if (!dash$1.test(u)) {
        let c = u.replace(cap$1, kebab$1);
        c.charAt(0) !== "-" && (c = "-" + c), t = "data" + c;
      }
    }
    o = DefinedInfo$3;
  }
  return new o(a, t);
}
function kebab$1(e) {
  return "-" + e.toLowerCase();
}
function camelcase$1(e) {
  return e.charAt(1).toUpperCase();
}
const html$4 = merge$2([xml$2, xlink$2, xmlns$2, aria$3, html$5], "html"), svg = merge$2([xml$2, xlink$2, xmlns$2, aria$3, svg$1], "svg"), search$2 = /[#.]/g;
function parseSelector$1(e, t) {
  const r = e || "", a = {};
  let o = 0, u, c;
  for (; o < r.length; ) {
    search$2.lastIndex = o;
    const d = search$2.exec(r), g = r.slice(o, d ? d.index : r.length);
    g && (u ? u === "#" ? a.id = g : Array.isArray(a.className) ? a.className.push(g) : a.className = [g] : c = g, o += g.length), d && (u = d[0], o++);
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: c || t || "div",
    properties: a,
    children: []
  };
}
const buttonTypes = /* @__PURE__ */ new Set(["button", "menu", "reset", "submit"]), own$a = {}.hasOwnProperty;
function createH$1(e, t, r) {
  const a = r && createAdjustMap$2(r);
  function o(u, c, ...d) {
    let g = -1, b;
    if (u == null) {
      b = {
        type: "root",
        children: []
      };
      const _ = (
        /** @type {Child} */
        c
      );
      d.unshift(_);
    } else if (b = parseSelector$1(u, t), b.tagName = b.tagName.toLowerCase(), a && own$a.call(a, b.tagName) && (b.tagName = a[b.tagName]), isProperties(c, b.tagName)) {
      let _;
      for (_ in c)
        own$a.call(c, _) && addProperty$1(e, b.properties, _, c[_]);
    } else
      d.unshift(c);
    for (; ++g < d.length; )
      addChild$2(b.children, d[g]);
    return b.type === "element" && b.tagName === "template" && (b.content = {
      type: "root",
      children: b.children
    }, b.children = []), b;
  }
  return o;
}
function isProperties(e, t) {
  return e == null || typeof e != "object" || Array.isArray(e) ? !1 : t === "input" || !e.type || typeof e.type != "string" ? !0 : "children" in e && Array.isArray(e.children) ? !1 : t === "button" ? buttonTypes.has(e.type.toLowerCase()) : !("value" in e);
}
function addProperty$1(e, t, r, a) {
  const o = find$2(e, r);
  let u = -1, c;
  if (a != null) {
    if (typeof a == "number") {
      if (Number.isNaN(a)) return;
      c = a;
    } else typeof a == "boolean" ? c = a : typeof a == "string" ? o.spaceSeparated ? c = parse$6(a) : o.commaSeparated ? c = parse$7(a) : o.commaOrSpaceSeparated ? c = parse$6(parse$7(a).join(" ")) : c = parsePrimitive$2(o, o.property, a) : Array.isArray(a) ? c = a.concat() : c = o.property === "style" ? style$2(a) : String(a);
    if (Array.isArray(c)) {
      const d = [];
      for (; ++u < c.length; ) {
        const g = (
          /** @type {number | string} */
          parsePrimitive$2(o, o.property, c[u])
        );
        d[u] = g;
      }
      c = d;
    }
    if (o.property === "className" && Array.isArray(t.className)) {
      const d = (
        /** @type {number | string} */
        c
      );
      c = t.className.concat(d);
    }
    t[o.property] = c;
  }
}
function addChild$2(e, t) {
  let r = -1;
  if (t != null) if (typeof t == "string" || typeof t == "number")
    e.push({
      type: "text",
      value: String(t)
    });
  else if (Array.isArray(t))
    for (; ++r < t.length; )
      addChild$2(e, t[r]);
  else if (typeof t == "object" && "type" in t)
    t.type === "root" ? addChild$2(e, t.children) : e.push(t);
  else
    throw new Error("Expected node, nodes, or string, got `" + t + "`");
}
function parsePrimitive$2(e, t, r) {
  if (typeof r == "string") {
    if (e.number && r && !Number.isNaN(Number(r)))
      return Number(r);
    if ((e.boolean || e.overloadedBoolean) && (r === "" || normalize$4(r) === normalize$4(t)))
      return !0;
  }
  return r;
}
function style$2(e) {
  const t = [];
  let r;
  for (r in e)
    own$a.call(e, r) && t.push([r, e[r]].join(": "));
  return t.join("; ");
}
function createAdjustMap$2(e) {
  const t = {};
  let r = -1;
  for (; ++r < e.length; )
    t[e[r].toLowerCase()] = e[r];
  return t;
}
const svgCaseSensitiveTagNames$1 = ["altGlyph", "altGlyphDef", "altGlyphItem", "animateColor", "animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "glyphRef", "linearGradient", "radialGradient", "solidColor", "textArea", "textPath"], h$2 = createH$1(html$4, "div"), s = createH$1(svg, "g", svgCaseSensitiveTagNames$1), webNamespaces = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function fromDom(e, t) {
  return transform$1(e, {}) || {
    type: "root",
    children: []
  };
}
function transform$1(e, t) {
  const r = one$2(e, t);
  return r && t.afterTransform && t.afterTransform(e, r), r;
}
function one$2(e, t) {
  switch (e.nodeType) {
    case 1:
      return element$b(
        /** @type {Element} */
        e,
        t
      );
    case 3:
      return text$7(
        /** @type {Text} */
        e
      );
    case 8:
      return comment$3(
        /** @type {Comment} */
        e
      );
    case 9:
      return root$4(
        /** @type {Document} */
        e,
        t
      );
    case 10:
      return doctype$3();
    case 11:
      return root$4(
        /** @type {DocumentFragment} */
        e,
        t
      );
    default:
      return;
  }
}
function root$4(e, t) {
  return {
    type: "root",
    children: all$3(e, t)
  };
}
function doctype$3() {
  return {
    type: "doctype"
  };
}
function text$7(e) {
  return {
    type: "text",
    value: e.nodeValue || ""
  };
}
function comment$3(e) {
  return {
    type: "comment",
    value: e.nodeValue || ""
  };
}
function element$b(e, t) {
  const r = e.namespaceURI, a = r === webNamespaces.svg ? s : h$2, o = r === webNamespaces.html ? e.tagName.toLowerCase() : e.tagName, u = (
    // @ts-expect-error: DOM types are wrong, content can exist.
    r === webNamespaces.html && o === "template" ? e.content : e
  ), c = e.getAttributeNames(), d = {};
  let g = -1;
  for (; ++g < c.length; )
    d[c[g]] = e.getAttribute(c[g]) || "";
  return a(o, d, all$3(u, t));
}
function all$3(e, t) {
  const r = e.childNodes, a = [];
  let o = -1;
  for (; ++o < r.length; ) {
    const u = transform$1(r[o], t);
    u !== void 0 && a.push(u);
  }
  return a;
}
new DOMParser();
function fromHtmlIsomorphic(e, t) {
  const r = parseFragment(e);
  return (
    /** @type {Root} */
    fromDom(r)
  );
}
function parseFragment(e) {
  const t = document.createElement("template");
  return t.innerHTML = e, t.content;
}
const findAfter = (
  // Note: overloads like this are needed to support optional generics.
  /**
   * @type {(
   *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &
   *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)
   * )}
   */
  /**
   * @param {UnistParent} parent
   * @param {UnistNode | number} index
   * @param {Test} [test]
   * @returns {UnistNode | undefined}
   */
  function(e, t, r) {
    const a = convert(r);
    if (!e || !e.type || !e.children)
      throw new Error("Expected parent node");
    if (typeof t == "number") {
      if (t < 0 || t === Number.POSITIVE_INFINITY)
        throw new Error("Expected positive finite number as index");
    } else if (t = e.children.indexOf(t), t < 0)
      throw new Error("Expected child node or index");
    for (; ++t < e.children.length; )
      if (a(e.children[t], t, e))
        return e.children[t];
  }
), convertElement = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
   *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
   *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test | null | undefined} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return element$a;
    if (typeof e == "string")
      return tagNameFactory(e);
    if (typeof e == "object")
      return anyFactory(e);
    if (typeof e == "function")
      return castFactory(e);
    throw new Error("Expected function, string, or array as `test`");
  }
);
function anyFactory(e) {
  const t = [];
  let r = -1;
  for (; ++r < e.length; )
    t[r] = convertElement(e[r]);
  return castFactory(a);
  function a(...o) {
    let u = -1;
    for (; ++u < t.length; )
      if (t[u].apply(this, o)) return !0;
    return !1;
  }
}
function tagNameFactory(e) {
  return castFactory(t);
  function t(r) {
    return r.tagName === e;
  }
}
function castFactory(e) {
  return t;
  function t(r, a, o) {
    return !!(looksLikeAnElement(r) && e.call(this, r, typeof a == "number" ? a : void 0, o || void 0));
  }
}
function element$a(e) {
  return !!(e && typeof e == "object" && "type" in e && e.type === "element" && "tagName" in e && typeof e.tagName == "string");
}
function looksLikeAnElement(e) {
  return e !== null && typeof e == "object" && "type" in e && "tagName" in e;
}
const searchLineFeeds = /\n/g, searchTabOrSpaces = /[\t ]+/g, br = convertElement("br"), cell = convertElement(isCell), p = convertElement("p"), row = convertElement("tr"), notRendered = convertElement([
  // List from: <https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements>
  "datalist",
  "head",
  "noembed",
  "noframes",
  "noscript",
  // Act as if we support scripting.
  "rp",
  "script",
  "style",
  "template",
  "title",
  // Hidden attribute.
  hidden,
  // From: <https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3>
  closedDialog
]), blockOrCaption = convertElement([
  "address",
  // Flow content
  "article",
  // Sections and headings
  "aside",
  // Sections and headings
  "blockquote",
  // Flow content
  "body",
  // Page
  "caption",
  // `table-caption`
  "center",
  // Flow content (legacy)
  "dd",
  // Lists
  "dialog",
  // Flow content
  "dir",
  // Lists (legacy)
  "dl",
  // Lists
  "dt",
  // Lists
  "div",
  // Flow content
  "figure",
  // Flow content
  "figcaption",
  // Flow content
  "footer",
  // Flow content
  "form,",
  // Flow content
  "h1",
  // Sections and headings
  "h2",
  // Sections and headings
  "h3",
  // Sections and headings
  "h4",
  // Sections and headings
  "h5",
  // Sections and headings
  "h6",
  // Sections and headings
  "header",
  // Flow content
  "hgroup",
  // Sections and headings
  "hr",
  // Flow content
  "html",
  // Page
  "legend",
  // Flow content
  "li",
  // Lists (as `display: list-item`)
  "listing",
  // Flow content (legacy)
  "main",
  // Flow content
  "menu",
  // Lists
  "nav",
  // Sections and headings
  "ol",
  // Lists
  "p",
  // Flow content
  "plaintext",
  // Flow content (legacy)
  "pre",
  // Flow content
  "section",
  // Sections and headings
  "ul",
  // Lists
  "xmp"
  // Flow content (legacy)
]);
function toText(e, t) {
  const r = t || {}, a = "children" in e ? e.children : [], o = blockOrCaption(e), u = inferWhitespace(e, {
    whitespace: r.whitespace || "normal"
  }), c = [];
  (e.type === "text" || e.type === "comment") && c.push(...collectText(e, {
    breakBefore: !0,
    breakAfter: !0
  }));
  let d = -1;
  for (; ++d < a.length; )
    c.push(...renderedTextCollection(
      a[d],
      // @ts-expect-error: `tree` is a parent if were here.
      e,
      {
        whitespace: u,
        breakBefore: d ? void 0 : o,
        breakAfter: d < a.length - 1 ? br(a[d + 1]) : o
      }
    ));
  const g = [];
  let b;
  for (d = -1; ++d < c.length; ) {
    const _ = c[d];
    typeof _ == "number" ? b !== void 0 && _ > b && (b = _) : _ && (b !== void 0 && b > -1 && g.push(`
`.repeat(b) || " "), b = -1, g.push(_));
  }
  return g.join("");
}
function renderedTextCollection(e, t, r) {
  return e.type === "element" ? collectElement(e, t, r) : e.type === "text" ? r.whitespace === "normal" ? collectText(e, r) : collectPreText(e) : [];
}
function collectElement(e, t, r) {
  const a = inferWhitespace(e, r), o = e.children || [];
  let u = -1, c = [];
  if (notRendered(e))
    return c;
  let d, g;
  for (br(e) || row(e) && // @ts-expect-error: something up with types of parents.
  findAfter(t, e, row) ? g = `
` : p(e) ? (d = 2, g = 2) : blockOrCaption(e) && (d = 1, g = 1); ++u < o.length; )
    c = c.concat(renderedTextCollection(o[u], e, {
      whitespace: a,
      breakBefore: u ? void 0 : d,
      breakAfter: u < o.length - 1 ? br(o[u + 1]) : g
    }));
  return cell(e) && // @ts-expect-error: something up with types of parents.
  findAfter(t, e, cell) && c.push("	"), d && c.unshift(d), g && c.push(g), c;
}
function collectText(e, t) {
  const r = String(e.value), a = [], o = [];
  let u = 0;
  for (; u <= r.length; ) {
    searchLineFeeds.lastIndex = u;
    const g = searchLineFeeds.exec(r), b = g && "index" in g ? g.index : r.length;
    a.push(
      // Any sequence of collapsible spaces and tabs immediately preceding or
      // following a segment break is removed.
      trimAndCollapseSpacesAndTabs(
        // [] ignoring bidi formatting characters (characters with the
        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if
        // they were not there.
        r.slice(u, b).replace(/[\u061C\u200E\u200F\u202A-\u202E\u2066-\u2069]/g, ""),
        u === 0 ? t.breakBefore : !0,
        b === r.length ? t.breakAfter : !0
      )
    ), u = b + 1;
  }
  let c = -1, d;
  for (; ++c < a.length; )
    a[c].charCodeAt(a[c].length - 1) === 8203 || c < a.length - 1 && a[c + 1].charCodeAt(0) === 8203 ? (o.push(a[c]), d = void 0) : a[c] ? (typeof d == "number" && o.push(d), o.push(a[c]), d = 0) : (c === 0 || c === a.length - 1) && o.push(0);
  return o;
}
function collectPreText(e) {
  return [String(e.value)];
}
function trimAndCollapseSpacesAndTabs(e, t, r) {
  const a = [];
  let o = 0, u;
  for (; o < e.length; ) {
    searchTabOrSpaces.lastIndex = o;
    const c = searchTabOrSpaces.exec(e);
    u = c ? c.index : e.length, !o && !u && c && !t && a.push(""), o !== u && a.push(e.slice(o, u)), o = c ? u + c[0].length : u;
  }
  return o !== u && !r && a.push(""), a.join(" ");
}
function inferWhitespace(e, t) {
  if (e.type === "element") {
    const r = e.properties || {};
    switch (e.tagName) {
      case "listing":
      case "plaintext":
      case "xmp":
        return "pre";
      case "nobr":
        return "nowrap";
      case "pre":
        return r.wrap ? "pre-wrap" : "pre";
      case "td":
      case "th":
        return r.noWrap ? "nowrap" : t.whitespace;
      case "textarea":
        return "pre-wrap";
    }
  }
  return t.whitespace;
}
function hidden(e) {
  return !!(e.properties || {}).hidden;
}
function isCell(e) {
  return e.tagName === "td" || e.tagName === "th";
}
function closedDialog(e) {
  return e.tagName === "dialog" && !(e.properties || {}).open;
}
class SourceLocation {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  constructor(t, r, a) {
    this.lexer = void 0, this.start = void 0, this.end = void 0, this.lexer = t, this.start = r, this.end = a;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(t, r) {
    return r ? !t || !t.loc || !r.loc || t.loc.lexer !== r.loc.lexer ? null : new SourceLocation(t.loc.lexer, t.loc.start, r.loc.end) : t && t.loc;
  }
}
class Token {
  // don't expand the token
  // used in \noexpand
  constructor(t, r) {
    this.text = void 0, this.loc = void 0, this.noexpand = void 0, this.treatAsRelax = void 0, this.text = t, this.loc = r;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(t, r) {
    return new Token(r, SourceLocation.range(this, t));
  }
}
class ParseError {
  // Error start position based on passed-in Token or ParseNode.
  // Length of affected text based on passed-in Token or ParseNode.
  // The underlying error message without any context added.
  constructor(t, r) {
    this.name = void 0, this.position = void 0, this.length = void 0, this.rawMessage = void 0;
    var a = "KaTeX parse error: " + t, o, u, c = r && r.loc;
    if (c && c.start <= c.end) {
      var d = c.lexer.input;
      o = c.start, u = c.end, o === d.length ? a += " at end of input: " : a += " at position " + (o + 1) + ": ";
      var g = d.slice(o, u).replace(/[^]/g, "$&"), b;
      o > 15 ? b = "" + d.slice(o - 15, o) : b = d.slice(0, o);
      var _;
      u + 15 < d.length ? _ = d.slice(u, u + 15) + "" : _ = d.slice(u), a += b + g + _;
    }
    var y = new Error(a);
    return y.name = "ParseError", y.__proto__ = ParseError.prototype, y.position = o, o != null && u != null && (y.length = u - o), y.rawMessage = t, y;
  }
}
ParseError.prototype.__proto__ = Error.prototype;
var contains = function e(t, r) {
  return t.indexOf(r) !== -1;
}, deflt = function e(t, r) {
  return t === void 0 ? r : t;
}, uppercase = /([A-Z])/g, hyphenate = function e(t) {
  return t.replace(uppercase, "-$1").toLowerCase();
}, ESCAPE_LOOKUP = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
}, ESCAPE_REGEX = /[&><"']/g;
function escape$1(e) {
  return String(e).replace(ESCAPE_REGEX, (t) => ESCAPE_LOOKUP[t]);
}
var getBaseElem = function e(t) {
  return t.type === "ordgroup" || t.type === "color" ? t.body.length === 1 ? e(t.body[0]) : t : t.type === "font" ? e(t.body) : t;
}, isCharacterBox = function e(t) {
  var r = getBaseElem(t);
  return r.type === "mathord" || r.type === "textord" || r.type === "atom";
}, assert = function e(t) {
  if (!t)
    throw new Error("Expected non-null, but got " + String(t));
  return t;
}, protocolFromUrl = function e(t) {
  var r = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(t);
  return r ? r[2] !== ":" || !/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(r[1]) ? null : r[1].toLowerCase() : "_relative";
}, utils = {
  contains,
  deflt,
  escape: escape$1,
  hyphenate,
  getBaseElem,
  isCharacterBox,
  protocolFromUrl
}, SETTINGS_SCHEMA = {
  displayMode: {
    type: "boolean",
    description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
    cli: "-d, --display-mode"
  },
  output: {
    type: {
      enum: ["htmlAndMathml", "html", "mathml"]
    },
    description: "Determines the markup language of the output.",
    cli: "-F, --format <type>"
  },
  leqno: {
    type: "boolean",
    description: "Render display math in leqno style (left-justified tags)."
  },
  fleqn: {
    type: "boolean",
    description: "Render display math flush left."
  },
  throwOnError: {
    type: "boolean",
    default: !0,
    cli: "-t, --no-throw-on-error",
    cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
  },
  errorColor: {
    type: "string",
    default: "#cc0000",
    cli: "-c, --error-color <color>",
    cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
    cliProcessor: (e) => "#" + e
  },
  macros: {
    type: "object",
    cli: "-m, --macro <def>",
    cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
    cliDefault: [],
    cliProcessor: (e, t) => (t.push(e), t)
  },
  minRuleThickness: {
    type: "number",
    description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
    processor: (e) => Math.max(0, e),
    cli: "--min-rule-thickness <size>",
    cliProcessor: parseFloat
  },
  colorIsTextColor: {
    type: "boolean",
    description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
    cli: "-b, --color-is-text-color"
  },
  strict: {
    type: [{
      enum: ["warn", "ignore", "error"]
    }, "boolean", "function"],
    description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
    cli: "-S, --strict",
    cliDefault: !1
  },
  trust: {
    type: ["boolean", "function"],
    description: "Trust the input, enabling all HTML features such as \\url.",
    cli: "-T, --trust"
  },
  maxSize: {
    type: "number",
    default: 1 / 0,
    description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
    processor: (e) => Math.max(0, e),
    cli: "-s, --max-size <n>",
    cliProcessor: parseInt
  },
  maxExpand: {
    type: "number",
    default: 1e3,
    description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
    processor: (e) => Math.max(0, e),
    cli: "-e, --max-expand <n>",
    cliProcessor: (e) => e === "Infinity" ? 1 / 0 : parseInt(e)
  },
  globalGroup: {
    type: "boolean",
    cli: !1
  }
};
function getDefaultValue(e) {
  if (e.default)
    return e.default;
  var t = e.type, r = Array.isArray(t) ? t[0] : t;
  if (typeof r != "string")
    return r.enum[0];
  switch (r) {
    case "boolean":
      return !1;
    case "string":
      return "";
    case "number":
      return 0;
    case "object":
      return {};
  }
}
class Settings {
  constructor(t) {
    this.displayMode = void 0, this.output = void 0, this.leqno = void 0, this.fleqn = void 0, this.throwOnError = void 0, this.errorColor = void 0, this.macros = void 0, this.minRuleThickness = void 0, this.colorIsTextColor = void 0, this.strict = void 0, this.trust = void 0, this.maxSize = void 0, this.maxExpand = void 0, this.globalGroup = void 0, t = t || {};
    for (var r in SETTINGS_SCHEMA)
      if (SETTINGS_SCHEMA.hasOwnProperty(r)) {
        var a = SETTINGS_SCHEMA[r];
        this[r] = t[r] !== void 0 ? a.processor ? a.processor(t[r]) : t[r] : getDefaultValue(a);
      }
  }
  /**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */
  reportNonstrict(t, r, a) {
    var o = this.strict;
    if (typeof o == "function" && (o = o(t, r, a)), !(!o || o === "ignore")) {
      if (o === !0 || o === "error")
        throw new ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (r + " [" + t + "]"), a);
      o === "warn" ? typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (r + " [" + t + "]")) : typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + o + "': " + r + " [" + t + "]"));
    }
  }
  /**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */
  useStrictBehavior(t, r, a) {
    var o = this.strict;
    if (typeof o == "function")
      try {
        o = o(t, r, a);
      } catch {
        o = "error";
      }
    return !o || o === "ignore" ? !1 : o === !0 || o === "error" ? !0 : o === "warn" ? (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (r + " [" + t + "]")), !1) : (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + o + "': " + r + " [" + t + "]")), !1);
  }
  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(t) {
    if (t.url && !t.protocol) {
      var r = utils.protocolFromUrl(t.url);
      if (r == null)
        return !1;
      t.protocol = r;
    }
    var a = typeof this.trust == "function" ? this.trust(t) : this.trust;
    return !!a;
  }
}
class Style {
  constructor(t, r, a) {
    this.id = void 0, this.size = void 0, this.cramped = void 0, this.id = t, this.size = r, this.cramped = a;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */
  sup() {
    return styles[sup[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */
  sub() {
    return styles[sub[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */
  fracNum() {
    return styles[fracNum[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */
  fracDen() {
    return styles[fracDen[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */
  cramp() {
    return styles[cramp[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */
  text() {
    return styles[text$1$1[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */
  isTight() {
    return this.size >= 2;
  }
}
var D = 0, Dc = 1, T = 2, Tc = 3, S = 4, Sc = 5, SS = 6, SSc = 7, styles = [new Style(D, 0, !1), new Style(Dc, 0, !0), new Style(T, 1, !1), new Style(Tc, 1, !0), new Style(S, 2, !1), new Style(Sc, 2, !0), new Style(SS, 3, !1), new Style(SSc, 3, !0)], sup = [S, Sc, S, Sc, SS, SSc, SS, SSc], sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc], fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc], fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc], cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc], text$1$1 = [D, Dc, T, Tc, T, Tc, T, Tc], Style$1 = {
  DISPLAY: styles[D],
  TEXT: styles[T],
  SCRIPT: styles[S],
  SCRIPTSCRIPT: styles[SS]
}, scriptData = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: "latin",
  blocks: [
    [256, 591],
    // Latin Extended-A and Latin Extended-B
    [768, 879]
    // Combining Diacritical marks
  ]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: "cyrillic",
  blocks: [[1024, 1279]]
}, {
  // Armenian
  name: "armenian",
  blocks: [[1328, 1423]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900097F)
  // Bengali (098009FF)
  // Gurmukhi (0A000A7F)
  // Gujarati (0A800AFF)
  // Oriya (0B000B7F)
  // Tamil (0B800BFF)
  // Telugu (0C000C7F)
  // Kannada (0C800CFF)
  // Malayalam (0D000D7F)
  // Sinhala (0D800DFF)
  // Thai (0E000E7F)
  // Lao (0E800EFF)
  // Tibetan (0F000FFF)
  // Myanmar (1000109F)
  name: "brahmic",
  blocks: [[2304, 4255]]
}, {
  name: "georgian",
  blocks: [[4256, 4351]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [
    [12288, 12543],
    // CJK symbols and punctuation, Hiragana, Katakana
    [19968, 40879],
    // CJK ideograms
    [65280, 65376]
    // Fullwidth punctuation
    // TODO: add halfwidth Katakana and Romanji glyphs
  ]
}, {
  // Korean
  name: "hangul",
  blocks: [[44032, 55215]]
}];
function scriptFromCodepoint(e) {
  for (var t = 0; t < scriptData.length; t++)
    for (var r = scriptData[t], a = 0; a < r.blocks.length; a++) {
      var o = r.blocks[a];
      if (e >= o[0] && e <= o[1])
        return r.name;
    }
  return null;
}
var allBlocks = [];
scriptData.forEach((e) => e.blocks.forEach((t) => allBlocks.push(...t)));
function supportedCodepoint(e) {
  for (var t = 0; t < allBlocks.length; t += 2)
    if (e >= allBlocks[t] && e <= allBlocks[t + 1])
      return !0;
  return !1;
}
var hLinePad = 80, sqrtMain = function e(t, r) {
  return "M95," + (622 + t + r) + `
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l` + t / 2.075 + " -" + t + `
c5.3,-9.3,12,-14,20,-14
H400000v` + (40 + t) + `H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M` + (834 + t) + " " + r + "h400000v" + (40 + t) + "h-400000z";
}, sqrtSize1 = function e(t, r) {
  return "M263," + (601 + t + r) + `c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l` + t / 2.084 + " -" + t + `
c4.7,-7.3,11,-11,19,-11
H40000v` + (40 + t) + `H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M` + (1001 + t) + " " + r + "h400000v" + (40 + t) + "h-400000z";
}, sqrtSize2 = function e(t, r) {
  return "M983 " + (10 + t + r) + `
l` + t / 3.13 + " -" + t + `
c4,-6.7,10,-10,18,-10 H400000v` + (40 + t) + `
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M` + (1001 + t) + " " + r + "h400000v" + (40 + t) + "h-400000z";
}, sqrtSize3 = function e(t, r) {
  return "M424," + (2398 + t + r) + `
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l` + t / 4.223 + " -" + t + `c4,-6.7,10,-10,18,-10 H400000
v` + (40 + t) + `H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M` + (1001 + t) + " " + r + `
h400000v` + (40 + t) + "h-400000z";
}, sqrtSize4 = function e(t, r) {
  return "M473," + (2713 + t + r) + `
c339.3,-1799.3,509.3,-2700,510,-2702 l` + t / 5.298 + " -" + t + `
c3.3,-7.3,9.3,-11,18,-11 H400000v` + (40 + t) + `H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM` + (1001 + t) + " " + r + "h400000v" + (40 + t) + "H1017.7z";
}, phasePath = function e(t) {
  var r = t / 2;
  return "M400000 " + t + " H0 L" + r + " 0 l65 45 L145 " + (t - 80) + " H400000z";
}, sqrtTall = function e(t, r, a) {
  var o = a - 54 - r - t;
  return "M702 " + (t + r) + "H400000" + (40 + t) + `
H742v` + o + `l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ` + r + "H400000v" + (40 + t) + "H742z";
}, sqrtPath = function e(t, r, a) {
  r = 1e3 * r;
  var o = "";
  switch (t) {
    case "sqrtMain":
      o = sqrtMain(r, hLinePad);
      break;
    case "sqrtSize1":
      o = sqrtSize1(r, hLinePad);
      break;
    case "sqrtSize2":
      o = sqrtSize2(r, hLinePad);
      break;
    case "sqrtSize3":
      o = sqrtSize3(r, hLinePad);
      break;
    case "sqrtSize4":
      o = sqrtSize4(r, hLinePad);
      break;
    case "sqrtTall":
      o = sqrtTall(r, hLinePad, a);
  }
  return o;
}, innerPath = function e(t, r) {
  switch (t) {
    case "":
      return "M291 0 H417 V" + r + " H291z M291 0 H417 V" + r + " H291z";
    case "":
      return "M145 0 H188 V" + r + " H145z M145 0 H188 V" + r + " H145z";
    case "":
      return "M145 0 H188 V" + r + " H145z M145 0 H188 V" + r + " H145z" + ("M367 0 H410 V" + r + " H367z M367 0 H410 V" + r + " H367z");
    case "":
      return "M457 0 H583 V" + r + " H457z M457 0 H583 V" + r + " H457z";
    case "":
      return "M319 0 H403 V" + r + " H319z M319 0 H403 V" + r + " H319z";
    case "":
      return "M263 0 H347 V" + r + " H263z M263 0 H347 V" + r + " H263z";
    case "":
      return "M384 0 H504 V" + r + " H384z M384 0 H504 V" + r + " H384z";
    case "":
      return "M312 0 H355 V" + r + " H312z M312 0 H355 V" + r + " H312z";
    case "":
      return "M257 0 H300 V" + r + " H257z M257 0 H300 V" + r + " H257z" + ("M478 0 H521 V" + r + " H478z M478 0 H521 V" + r + " H478z");
    default:
      return "";
  }
}, path$1 = {
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
  leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
  leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
  leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
  leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
  leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
  leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
  leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
  longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
  midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
  midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
  oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
  oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
  oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
  oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
  rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
  rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
  rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
  rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
  rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
  rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
  rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
  rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
  rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
  righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
  rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
  rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
  twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
  // ditto tilde2, tilde3, & tilde4
  tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
  tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
  tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
  // ditto widehat2, widehat3, & widehat4
  widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  // widecheck paths are all inverted versions of widehat
  widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
  widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
  rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
  shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
  shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
}, tallDelim = function e(t, r) {
  switch (t) {
    case "lbrack":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + r + ` v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v` + r + " v1759 h84z";
    case "rbrack":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + r + ` v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v` + r + " v1759 h84z";
    case "vert":
      return "M145 15 v585 v" + r + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -r + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + r + " v585 h43z";
    case "doublevert":
      return "M145 15 v585 v" + r + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -r + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + r + ` v585 h43z
M367 15 v585 v` + r + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -r + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v` + r + " v585 h43z";
    case "lfloor":
      return "M319 602 V0 H403 V602 v" + r + ` v1715 h263 v84 H319z
MM319 602 V0 H403 V602 v` + r + " v1715 H319z";
    case "rfloor":
      return "M319 602 V0 H403 V602 v" + r + ` v1799 H0 v-84 H319z
MM319 602 V0 H403 V602 v` + r + " v1715 H319z";
    case "lceil":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + r + ` v602 h84z
M403 1759 V0 H319 V1759 v` + r + " v602 h84z";
    case "rceil":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + r + ` v602 h84z
M347 1759 V0 h-84 V1759 v` + r + " v602 h84z";
    case "lparen":
      return `M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
-36,557 l0,` + (r + 84) + `c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
l0,-` + (r + 92) + `c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z`;
    case "rparen":
      return `M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,` + (r + 9) + `
c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
l0,-` + (r + 144) + `c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z`;
    default:
      throw new Error("Unknown stretchy delimiter.");
  }
};
class DocumentFragment {
  // HtmlDomNode
  // Never used; needed for satisfying interface.
  constructor(t) {
    this.children = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.children = t, this.classes = [], this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = {};
  }
  hasClass(t) {
    return utils.contains(this.classes, t);
  }
  /** Convert the fragment into a node. */
  toNode() {
    for (var t = document.createDocumentFragment(), r = 0; r < this.children.length; r++)
      t.appendChild(this.children[r].toNode());
    return t;
  }
  /** Convert the fragment into HTML markup. */
  toMarkup() {
    for (var t = "", r = 0; r < this.children.length; r++)
      t += this.children[r].toMarkup();
    return t;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    var t = (r) => r.toText();
    return this.children.map(t).join("");
  }
}
var fontMetricsData = {
  "AMS-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68889, 0, 0, 0.72222],
    66: [0, 0.68889, 0, 0, 0.66667],
    67: [0, 0.68889, 0, 0, 0.72222],
    68: [0, 0.68889, 0, 0, 0.72222],
    69: [0, 0.68889, 0, 0, 0.66667],
    70: [0, 0.68889, 0, 0, 0.61111],
    71: [0, 0.68889, 0, 0, 0.77778],
    72: [0, 0.68889, 0, 0, 0.77778],
    73: [0, 0.68889, 0, 0, 0.38889],
    74: [0.16667, 0.68889, 0, 0, 0.5],
    75: [0, 0.68889, 0, 0, 0.77778],
    76: [0, 0.68889, 0, 0, 0.66667],
    77: [0, 0.68889, 0, 0, 0.94445],
    78: [0, 0.68889, 0, 0, 0.72222],
    79: [0.16667, 0.68889, 0, 0, 0.77778],
    80: [0, 0.68889, 0, 0, 0.61111],
    81: [0.16667, 0.68889, 0, 0, 0.77778],
    82: [0, 0.68889, 0, 0, 0.72222],
    83: [0, 0.68889, 0, 0, 0.55556],
    84: [0, 0.68889, 0, 0, 0.66667],
    85: [0, 0.68889, 0, 0, 0.72222],
    86: [0, 0.68889, 0, 0, 0.72222],
    87: [0, 0.68889, 0, 0, 1],
    88: [0, 0.68889, 0, 0, 0.72222],
    89: [0, 0.68889, 0, 0, 0.72222],
    90: [0, 0.68889, 0, 0, 0.66667],
    107: [0, 0.68889, 0, 0, 0.55556],
    160: [0, 0, 0, 0, 0.25],
    165: [0, 0.675, 0.025, 0, 0.75],
    174: [0.15559, 0.69224, 0, 0, 0.94666],
    240: [0, 0.68889, 0, 0, 0.55556],
    295: [0, 0.68889, 0, 0, 0.54028],
    710: [0, 0.825, 0, 0, 2.33334],
    732: [0, 0.9, 0, 0, 2.33334],
    770: [0, 0.825, 0, 0, 2.33334],
    771: [0, 0.9, 0, 0, 2.33334],
    989: [0.08167, 0.58167, 0, 0, 0.77778],
    1008: [0, 0.43056, 0.04028, 0, 0.66667],
    8245: [0, 0.54986, 0, 0, 0.275],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8487: [0, 0.68889, 0, 0, 0.72222],
    8498: [0, 0.68889, 0, 0, 0.55556],
    8502: [0, 0.68889, 0, 0, 0.66667],
    8503: [0, 0.68889, 0, 0, 0.44445],
    8504: [0, 0.68889, 0, 0, 0.66667],
    8513: [0, 0.68889, 0, 0, 0.63889],
    8592: [-0.03598, 0.46402, 0, 0, 0.5],
    8594: [-0.03598, 0.46402, 0, 0, 0.5],
    8602: [-0.13313, 0.36687, 0, 0, 1],
    8603: [-0.13313, 0.36687, 0, 0, 1],
    8606: [0.01354, 0.52239, 0, 0, 1],
    8608: [0.01354, 0.52239, 0, 0, 1],
    8610: [0.01354, 0.52239, 0, 0, 1.11111],
    8611: [0.01354, 0.52239, 0, 0, 1.11111],
    8619: [0, 0.54986, 0, 0, 1],
    8620: [0, 0.54986, 0, 0, 1],
    8621: [-0.13313, 0.37788, 0, 0, 1.38889],
    8622: [-0.13313, 0.36687, 0, 0, 1],
    8624: [0, 0.69224, 0, 0, 0.5],
    8625: [0, 0.69224, 0, 0, 0.5],
    8630: [0, 0.43056, 0, 0, 1],
    8631: [0, 0.43056, 0, 0, 1],
    8634: [0.08198, 0.58198, 0, 0, 0.77778],
    8635: [0.08198, 0.58198, 0, 0, 0.77778],
    8638: [0.19444, 0.69224, 0, 0, 0.41667],
    8639: [0.19444, 0.69224, 0, 0, 0.41667],
    8642: [0.19444, 0.69224, 0, 0, 0.41667],
    8643: [0.19444, 0.69224, 0, 0, 0.41667],
    8644: [0.1808, 0.675, 0, 0, 1],
    8646: [0.1808, 0.675, 0, 0, 1],
    8647: [0.1808, 0.675, 0, 0, 1],
    8648: [0.19444, 0.69224, 0, 0, 0.83334],
    8649: [0.1808, 0.675, 0, 0, 1],
    8650: [0.19444, 0.69224, 0, 0, 0.83334],
    8651: [0.01354, 0.52239, 0, 0, 1],
    8652: [0.01354, 0.52239, 0, 0, 1],
    8653: [-0.13313, 0.36687, 0, 0, 1],
    8654: [-0.13313, 0.36687, 0, 0, 1],
    8655: [-0.13313, 0.36687, 0, 0, 1],
    8666: [0.13667, 0.63667, 0, 0, 1],
    8667: [0.13667, 0.63667, 0, 0, 1],
    8669: [-0.13313, 0.37788, 0, 0, 1],
    8672: [-0.064, 0.437, 0, 0, 1.334],
    8674: [-0.064, 0.437, 0, 0, 1.334],
    8705: [0, 0.825, 0, 0, 0.5],
    8708: [0, 0.68889, 0, 0, 0.55556],
    8709: [0.08167, 0.58167, 0, 0, 0.77778],
    8717: [0, 0.43056, 0, 0, 0.42917],
    8722: [-0.03598, 0.46402, 0, 0, 0.5],
    8724: [0.08198, 0.69224, 0, 0, 0.77778],
    8726: [0.08167, 0.58167, 0, 0, 0.77778],
    8733: [0, 0.69224, 0, 0, 0.77778],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8737: [0, 0.69224, 0, 0, 0.72222],
    8738: [0.03517, 0.52239, 0, 0, 0.72222],
    8739: [0.08167, 0.58167, 0, 0, 0.22222],
    8740: [0.25142, 0.74111, 0, 0, 0.27778],
    8741: [0.08167, 0.58167, 0, 0, 0.38889],
    8742: [0.25142, 0.74111, 0, 0, 0.5],
    8756: [0, 0.69224, 0, 0, 0.66667],
    8757: [0, 0.69224, 0, 0, 0.66667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8765: [-0.13313, 0.37788, 0, 0, 0.77778],
    8769: [-0.13313, 0.36687, 0, 0, 0.77778],
    8770: [-0.03625, 0.46375, 0, 0, 0.77778],
    8774: [0.30274, 0.79383, 0, 0, 0.77778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8778: [0.08167, 0.58167, 0, 0, 0.77778],
    8782: [0.06062, 0.54986, 0, 0, 0.77778],
    8783: [0.06062, 0.54986, 0, 0, 0.77778],
    8785: [0.08198, 0.58198, 0, 0, 0.77778],
    8786: [0.08198, 0.58198, 0, 0, 0.77778],
    8787: [0.08198, 0.58198, 0, 0, 0.77778],
    8790: [0, 0.69224, 0, 0, 0.77778],
    8791: [0.22958, 0.72958, 0, 0, 0.77778],
    8796: [0.08198, 0.91667, 0, 0, 0.77778],
    8806: [0.25583, 0.75583, 0, 0, 0.77778],
    8807: [0.25583, 0.75583, 0, 0, 0.77778],
    8808: [0.25142, 0.75726, 0, 0, 0.77778],
    8809: [0.25142, 0.75726, 0, 0, 0.77778],
    8812: [0.25583, 0.75583, 0, 0, 0.5],
    8814: [0.20576, 0.70576, 0, 0, 0.77778],
    8815: [0.20576, 0.70576, 0, 0, 0.77778],
    8816: [0.30274, 0.79383, 0, 0, 0.77778],
    8817: [0.30274, 0.79383, 0, 0, 0.77778],
    8818: [0.22958, 0.72958, 0, 0, 0.77778],
    8819: [0.22958, 0.72958, 0, 0, 0.77778],
    8822: [0.1808, 0.675, 0, 0, 0.77778],
    8823: [0.1808, 0.675, 0, 0, 0.77778],
    8828: [0.13667, 0.63667, 0, 0, 0.77778],
    8829: [0.13667, 0.63667, 0, 0, 0.77778],
    8830: [0.22958, 0.72958, 0, 0, 0.77778],
    8831: [0.22958, 0.72958, 0, 0, 0.77778],
    8832: [0.20576, 0.70576, 0, 0, 0.77778],
    8833: [0.20576, 0.70576, 0, 0, 0.77778],
    8840: [0.30274, 0.79383, 0, 0, 0.77778],
    8841: [0.30274, 0.79383, 0, 0, 0.77778],
    8842: [0.13597, 0.63597, 0, 0, 0.77778],
    8843: [0.13597, 0.63597, 0, 0, 0.77778],
    8847: [0.03517, 0.54986, 0, 0, 0.77778],
    8848: [0.03517, 0.54986, 0, 0, 0.77778],
    8858: [0.08198, 0.58198, 0, 0, 0.77778],
    8859: [0.08198, 0.58198, 0, 0, 0.77778],
    8861: [0.08198, 0.58198, 0, 0, 0.77778],
    8862: [0, 0.675, 0, 0, 0.77778],
    8863: [0, 0.675, 0, 0, 0.77778],
    8864: [0, 0.675, 0, 0, 0.77778],
    8865: [0, 0.675, 0, 0, 0.77778],
    8872: [0, 0.69224, 0, 0, 0.61111],
    8873: [0, 0.69224, 0, 0, 0.72222],
    8874: [0, 0.69224, 0, 0, 0.88889],
    8876: [0, 0.68889, 0, 0, 0.61111],
    8877: [0, 0.68889, 0, 0, 0.61111],
    8878: [0, 0.68889, 0, 0, 0.72222],
    8879: [0, 0.68889, 0, 0, 0.72222],
    8882: [0.03517, 0.54986, 0, 0, 0.77778],
    8883: [0.03517, 0.54986, 0, 0, 0.77778],
    8884: [0.13667, 0.63667, 0, 0, 0.77778],
    8885: [0.13667, 0.63667, 0, 0, 0.77778],
    8888: [0, 0.54986, 0, 0, 1.11111],
    8890: [0.19444, 0.43056, 0, 0, 0.55556],
    8891: [0.19444, 0.69224, 0, 0, 0.61111],
    8892: [0.19444, 0.69224, 0, 0, 0.61111],
    8901: [0, 0.54986, 0, 0, 0.27778],
    8903: [0.08167, 0.58167, 0, 0, 0.77778],
    8905: [0.08167, 0.58167, 0, 0, 0.77778],
    8906: [0.08167, 0.58167, 0, 0, 0.77778],
    8907: [0, 0.69224, 0, 0, 0.77778],
    8908: [0, 0.69224, 0, 0, 0.77778],
    8909: [-0.03598, 0.46402, 0, 0, 0.77778],
    8910: [0, 0.54986, 0, 0, 0.76042],
    8911: [0, 0.54986, 0, 0, 0.76042],
    8912: [0.03517, 0.54986, 0, 0, 0.77778],
    8913: [0.03517, 0.54986, 0, 0, 0.77778],
    8914: [0, 0.54986, 0, 0, 0.66667],
    8915: [0, 0.54986, 0, 0, 0.66667],
    8916: [0, 0.69224, 0, 0, 0.66667],
    8918: [0.0391, 0.5391, 0, 0, 0.77778],
    8919: [0.0391, 0.5391, 0, 0, 0.77778],
    8920: [0.03517, 0.54986, 0, 0, 1.33334],
    8921: [0.03517, 0.54986, 0, 0, 1.33334],
    8922: [0.38569, 0.88569, 0, 0, 0.77778],
    8923: [0.38569, 0.88569, 0, 0, 0.77778],
    8926: [0.13667, 0.63667, 0, 0, 0.77778],
    8927: [0.13667, 0.63667, 0, 0, 0.77778],
    8928: [0.30274, 0.79383, 0, 0, 0.77778],
    8929: [0.30274, 0.79383, 0, 0, 0.77778],
    8934: [0.23222, 0.74111, 0, 0, 0.77778],
    8935: [0.23222, 0.74111, 0, 0, 0.77778],
    8936: [0.23222, 0.74111, 0, 0, 0.77778],
    8937: [0.23222, 0.74111, 0, 0, 0.77778],
    8938: [0.20576, 0.70576, 0, 0, 0.77778],
    8939: [0.20576, 0.70576, 0, 0, 0.77778],
    8940: [0.30274, 0.79383, 0, 0, 0.77778],
    8941: [0.30274, 0.79383, 0, 0, 0.77778],
    8994: [0.19444, 0.69224, 0, 0, 0.77778],
    8995: [0.19444, 0.69224, 0, 0, 0.77778],
    9416: [0.15559, 0.69224, 0, 0, 0.90222],
    9484: [0, 0.69224, 0, 0, 0.5],
    9488: [0, 0.69224, 0, 0, 0.5],
    9492: [0, 0.37788, 0, 0, 0.5],
    9496: [0, 0.37788, 0, 0, 0.5],
    9585: [0.19444, 0.68889, 0, 0, 0.88889],
    9586: [0.19444, 0.74111, 0, 0, 0.88889],
    9632: [0, 0.675, 0, 0, 0.77778],
    9633: [0, 0.675, 0, 0, 0.77778],
    9650: [0, 0.54986, 0, 0, 0.72222],
    9651: [0, 0.54986, 0, 0, 0.72222],
    9654: [0.03517, 0.54986, 0, 0, 0.77778],
    9660: [0, 0.54986, 0, 0, 0.72222],
    9661: [0, 0.54986, 0, 0, 0.72222],
    9664: [0.03517, 0.54986, 0, 0, 0.77778],
    9674: [0.11111, 0.69224, 0, 0, 0.66667],
    9733: [0.19444, 0.69224, 0, 0, 0.94445],
    10003: [0, 0.69224, 0, 0, 0.83334],
    10016: [0, 0.69224, 0, 0, 0.83334],
    10731: [0.11111, 0.69224, 0, 0, 0.66667],
    10846: [0.19444, 0.75583, 0, 0, 0.61111],
    10877: [0.13667, 0.63667, 0, 0, 0.77778],
    10878: [0.13667, 0.63667, 0, 0, 0.77778],
    10885: [0.25583, 0.75583, 0, 0, 0.77778],
    10886: [0.25583, 0.75583, 0, 0, 0.77778],
    10887: [0.13597, 0.63597, 0, 0, 0.77778],
    10888: [0.13597, 0.63597, 0, 0, 0.77778],
    10889: [0.26167, 0.75726, 0, 0, 0.77778],
    10890: [0.26167, 0.75726, 0, 0, 0.77778],
    10891: [0.48256, 0.98256, 0, 0, 0.77778],
    10892: [0.48256, 0.98256, 0, 0, 0.77778],
    10901: [0.13667, 0.63667, 0, 0, 0.77778],
    10902: [0.13667, 0.63667, 0, 0, 0.77778],
    10933: [0.25142, 0.75726, 0, 0, 0.77778],
    10934: [0.25142, 0.75726, 0, 0, 0.77778],
    10935: [0.26167, 0.75726, 0, 0, 0.77778],
    10936: [0.26167, 0.75726, 0, 0, 0.77778],
    10937: [0.26167, 0.75726, 0, 0, 0.77778],
    10938: [0.26167, 0.75726, 0, 0, 0.77778],
    10949: [0.25583, 0.75583, 0, 0, 0.77778],
    10950: [0.25583, 0.75583, 0, 0, 0.77778],
    10955: [0.28481, 0.79383, 0, 0, 0.77778],
    10956: [0.28481, 0.79383, 0, 0, 0.77778],
    57350: [0.08167, 0.58167, 0, 0, 0.22222],
    57351: [0.08167, 0.58167, 0, 0, 0.38889],
    57352: [0.08167, 0.58167, 0, 0, 0.77778],
    57353: [0, 0.43056, 0.04028, 0, 0.66667],
    57356: [0.25142, 0.75726, 0, 0, 0.77778],
    57357: [0.25142, 0.75726, 0, 0, 0.77778],
    57358: [0.41951, 0.91951, 0, 0, 0.77778],
    57359: [0.30274, 0.79383, 0, 0, 0.77778],
    57360: [0.30274, 0.79383, 0, 0, 0.77778],
    57361: [0.41951, 0.91951, 0, 0, 0.77778],
    57366: [0.25142, 0.75726, 0, 0, 0.77778],
    57367: [0.25142, 0.75726, 0, 0, 0.77778],
    57368: [0.25142, 0.75726, 0, 0, 0.77778],
    57369: [0.25142, 0.75726, 0, 0, 0.77778],
    57370: [0.13597, 0.63597, 0, 0, 0.77778],
    57371: [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68333, 0, 0.19445, 0.79847],
    66: [0, 0.68333, 0.03041, 0.13889, 0.65681],
    67: [0, 0.68333, 0.05834, 0.13889, 0.52653],
    68: [0, 0.68333, 0.02778, 0.08334, 0.77139],
    69: [0, 0.68333, 0.08944, 0.11111, 0.52778],
    70: [0, 0.68333, 0.09931, 0.11111, 0.71875],
    71: [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    72: [0, 0.68333, 965e-5, 0.11111, 0.84452],
    73: [0, 0.68333, 0.07382, 0, 0.54452],
    74: [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    75: [0, 0.68333, 0.01445, 0.05556, 0.76195],
    76: [0, 0.68333, 0, 0.13889, 0.68972],
    77: [0, 0.68333, 0, 0.13889, 1.2009],
    78: [0, 0.68333, 0.14736, 0.08334, 0.82049],
    79: [0, 0.68333, 0.02778, 0.11111, 0.79611],
    80: [0, 0.68333, 0.08222, 0.08334, 0.69556],
    81: [0.09722, 0.68333, 0, 0.11111, 0.81667],
    82: [0, 0.68333, 0, 0.08334, 0.8475],
    83: [0, 0.68333, 0.075, 0.13889, 0.60556],
    84: [0, 0.68333, 0.25417, 0, 0.54464],
    85: [0, 0.68333, 0.09931, 0.08334, 0.62583],
    86: [0, 0.68333, 0.08222, 0, 0.61278],
    87: [0, 0.68333, 0.08222, 0.08334, 0.98778],
    88: [0, 0.68333, 0.14643, 0.13889, 0.7133],
    89: [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    90: [0, 0.68333, 0.07944, 0.13889, 0.72473],
    160: [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69141, 0, 0, 0.29574],
    34: [0, 0.69141, 0, 0, 0.21471],
    38: [0, 0.69141, 0, 0, 0.73786],
    39: [0, 0.69141, 0, 0, 0.21201],
    40: [0.24982, 0.74947, 0, 0, 0.38865],
    41: [0.24982, 0.74947, 0, 0, 0.38865],
    42: [0, 0.62119, 0, 0, 0.27764],
    43: [0.08319, 0.58283, 0, 0, 0.75623],
    44: [0, 0.10803, 0, 0, 0.27764],
    45: [0.08319, 0.58283, 0, 0, 0.75623],
    46: [0, 0.10803, 0, 0, 0.27764],
    47: [0.24982, 0.74947, 0, 0, 0.50181],
    48: [0, 0.47534, 0, 0, 0.50181],
    49: [0, 0.47534, 0, 0, 0.50181],
    50: [0, 0.47534, 0, 0, 0.50181],
    51: [0.18906, 0.47534, 0, 0, 0.50181],
    52: [0.18906, 0.47534, 0, 0, 0.50181],
    53: [0.18906, 0.47534, 0, 0, 0.50181],
    54: [0, 0.69141, 0, 0, 0.50181],
    55: [0.18906, 0.47534, 0, 0, 0.50181],
    56: [0, 0.69141, 0, 0, 0.50181],
    57: [0.18906, 0.47534, 0, 0, 0.50181],
    58: [0, 0.47534, 0, 0, 0.21606],
    59: [0.12604, 0.47534, 0, 0, 0.21606],
    61: [-0.13099, 0.36866, 0, 0, 0.75623],
    63: [0, 0.69141, 0, 0, 0.36245],
    65: [0, 0.69141, 0, 0, 0.7176],
    66: [0, 0.69141, 0, 0, 0.88397],
    67: [0, 0.69141, 0, 0, 0.61254],
    68: [0, 0.69141, 0, 0, 0.83158],
    69: [0, 0.69141, 0, 0, 0.66278],
    70: [0.12604, 0.69141, 0, 0, 0.61119],
    71: [0, 0.69141, 0, 0, 0.78539],
    72: [0.06302, 0.69141, 0, 0, 0.7203],
    73: [0, 0.69141, 0, 0, 0.55448],
    74: [0.12604, 0.69141, 0, 0, 0.55231],
    75: [0, 0.69141, 0, 0, 0.66845],
    76: [0, 0.69141, 0, 0, 0.66602],
    77: [0, 0.69141, 0, 0, 1.04953],
    78: [0, 0.69141, 0, 0, 0.83212],
    79: [0, 0.69141, 0, 0, 0.82699],
    80: [0.18906, 0.69141, 0, 0, 0.82753],
    81: [0.03781, 0.69141, 0, 0, 0.82699],
    82: [0, 0.69141, 0, 0, 0.82807],
    83: [0, 0.69141, 0, 0, 0.82861],
    84: [0, 0.69141, 0, 0, 0.66899],
    85: [0, 0.69141, 0, 0, 0.64576],
    86: [0, 0.69141, 0, 0, 0.83131],
    87: [0, 0.69141, 0, 0, 1.04602],
    88: [0, 0.69141, 0, 0, 0.71922],
    89: [0.18906, 0.69141, 0, 0, 0.83293],
    90: [0.12604, 0.69141, 0, 0, 0.60201],
    91: [0.24982, 0.74947, 0, 0, 0.27764],
    93: [0.24982, 0.74947, 0, 0, 0.27764],
    94: [0, 0.69141, 0, 0, 0.49965],
    97: [0, 0.47534, 0, 0, 0.50046],
    98: [0, 0.69141, 0, 0, 0.51315],
    99: [0, 0.47534, 0, 0, 0.38946],
    100: [0, 0.62119, 0, 0, 0.49857],
    101: [0, 0.47534, 0, 0, 0.40053],
    102: [0.18906, 0.69141, 0, 0, 0.32626],
    103: [0.18906, 0.47534, 0, 0, 0.5037],
    104: [0.18906, 0.69141, 0, 0, 0.52126],
    105: [0, 0.69141, 0, 0, 0.27899],
    106: [0, 0.69141, 0, 0, 0.28088],
    107: [0, 0.69141, 0, 0, 0.38946],
    108: [0, 0.69141, 0, 0, 0.27953],
    109: [0, 0.47534, 0, 0, 0.76676],
    110: [0, 0.47534, 0, 0, 0.52666],
    111: [0, 0.47534, 0, 0, 0.48885],
    112: [0.18906, 0.52396, 0, 0, 0.50046],
    113: [0.18906, 0.47534, 0, 0, 0.48912],
    114: [0, 0.47534, 0, 0, 0.38919],
    115: [0, 0.47534, 0, 0, 0.44266],
    116: [0, 0.62119, 0, 0, 0.33301],
    117: [0, 0.47534, 0, 0, 0.5172],
    118: [0, 0.52396, 0, 0, 0.5118],
    119: [0, 0.52396, 0, 0, 0.77351],
    120: [0.18906, 0.47534, 0, 0, 0.38865],
    121: [0.18906, 0.47534, 0, 0, 0.49884],
    122: [0.18906, 0.47534, 0, 0, 0.39054],
    160: [0, 0, 0, 0, 0.25],
    8216: [0, 0.69141, 0, 0, 0.21471],
    8217: [0, 0.69141, 0, 0, 0.21471],
    58112: [0, 0.62119, 0, 0, 0.49749],
    58113: [0, 0.62119, 0, 0, 0.4983],
    58114: [0.18906, 0.69141, 0, 0, 0.33328],
    58115: [0.18906, 0.69141, 0, 0, 0.32923],
    58116: [0.18906, 0.47534, 0, 0, 0.50343],
    58117: [0, 0.69141, 0, 0, 0.33301],
    58118: [0, 0.62119, 0, 0, 0.33409],
    58119: [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.35],
    34: [0, 0.69444, 0, 0, 0.60278],
    35: [0.19444, 0.69444, 0, 0, 0.95833],
    36: [0.05556, 0.75, 0, 0, 0.575],
    37: [0.05556, 0.75, 0, 0, 0.95833],
    38: [0, 0.69444, 0, 0, 0.89444],
    39: [0, 0.69444, 0, 0, 0.31944],
    40: [0.25, 0.75, 0, 0, 0.44722],
    41: [0.25, 0.75, 0, 0, 0.44722],
    42: [0, 0.75, 0, 0, 0.575],
    43: [0.13333, 0.63333, 0, 0, 0.89444],
    44: [0.19444, 0.15556, 0, 0, 0.31944],
    45: [0, 0.44444, 0, 0, 0.38333],
    46: [0, 0.15556, 0, 0, 0.31944],
    47: [0.25, 0.75, 0, 0, 0.575],
    48: [0, 0.64444, 0, 0, 0.575],
    49: [0, 0.64444, 0, 0, 0.575],
    50: [0, 0.64444, 0, 0, 0.575],
    51: [0, 0.64444, 0, 0, 0.575],
    52: [0, 0.64444, 0, 0, 0.575],
    53: [0, 0.64444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0, 0.64444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0, 0.64444, 0, 0, 0.575],
    58: [0, 0.44444, 0, 0, 0.31944],
    59: [0.19444, 0.44444, 0, 0, 0.31944],
    60: [0.08556, 0.58556, 0, 0, 0.89444],
    61: [-0.10889, 0.39111, 0, 0, 0.89444],
    62: [0.08556, 0.58556, 0, 0, 0.89444],
    63: [0, 0.69444, 0, 0, 0.54305],
    64: [0, 0.69444, 0, 0, 0.89444],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0, 0, 0.81805],
    67: [0, 0.68611, 0, 0, 0.83055],
    68: [0, 0.68611, 0, 0, 0.88194],
    69: [0, 0.68611, 0, 0, 0.75555],
    70: [0, 0.68611, 0, 0, 0.72361],
    71: [0, 0.68611, 0, 0, 0.90416],
    72: [0, 0.68611, 0, 0, 0.9],
    73: [0, 0.68611, 0, 0, 0.43611],
    74: [0, 0.68611, 0, 0, 0.59444],
    75: [0, 0.68611, 0, 0, 0.90138],
    76: [0, 0.68611, 0, 0, 0.69166],
    77: [0, 0.68611, 0, 0, 1.09166],
    78: [0, 0.68611, 0, 0, 0.9],
    79: [0, 0.68611, 0, 0, 0.86388],
    80: [0, 0.68611, 0, 0, 0.78611],
    81: [0.19444, 0.68611, 0, 0, 0.86388],
    82: [0, 0.68611, 0, 0, 0.8625],
    83: [0, 0.68611, 0, 0, 0.63889],
    84: [0, 0.68611, 0, 0, 0.8],
    85: [0, 0.68611, 0, 0, 0.88472],
    86: [0, 0.68611, 0.01597, 0, 0.86944],
    87: [0, 0.68611, 0.01597, 0, 1.18888],
    88: [0, 0.68611, 0, 0, 0.86944],
    89: [0, 0.68611, 0.02875, 0, 0.86944],
    90: [0, 0.68611, 0, 0, 0.70277],
    91: [0.25, 0.75, 0, 0, 0.31944],
    92: [0.25, 0.75, 0, 0, 0.575],
    93: [0.25, 0.75, 0, 0, 0.31944],
    94: [0, 0.69444, 0, 0, 0.575],
    95: [0.31, 0.13444, 0.03194, 0, 0.575],
    97: [0, 0.44444, 0, 0, 0.55902],
    98: [0, 0.69444, 0, 0, 0.63889],
    99: [0, 0.44444, 0, 0, 0.51111],
    100: [0, 0.69444, 0, 0, 0.63889],
    101: [0, 0.44444, 0, 0, 0.52708],
    102: [0, 0.69444, 0.10903, 0, 0.35139],
    103: [0.19444, 0.44444, 0.01597, 0, 0.575],
    104: [0, 0.69444, 0, 0, 0.63889],
    105: [0, 0.69444, 0, 0, 0.31944],
    106: [0.19444, 0.69444, 0, 0, 0.35139],
    107: [0, 0.69444, 0, 0, 0.60694],
    108: [0, 0.69444, 0, 0, 0.31944],
    109: [0, 0.44444, 0, 0, 0.95833],
    110: [0, 0.44444, 0, 0, 0.63889],
    111: [0, 0.44444, 0, 0, 0.575],
    112: [0.19444, 0.44444, 0, 0, 0.63889],
    113: [0.19444, 0.44444, 0, 0, 0.60694],
    114: [0, 0.44444, 0, 0, 0.47361],
    115: [0, 0.44444, 0, 0, 0.45361],
    116: [0, 0.63492, 0, 0, 0.44722],
    117: [0, 0.44444, 0, 0, 0.63889],
    118: [0, 0.44444, 0.01597, 0, 0.60694],
    119: [0, 0.44444, 0.01597, 0, 0.83055],
    120: [0, 0.44444, 0, 0, 0.60694],
    121: [0.19444, 0.44444, 0.01597, 0, 0.60694],
    122: [0, 0.44444, 0, 0, 0.51111],
    123: [0.25, 0.75, 0, 0, 0.575],
    124: [0.25, 0.75, 0, 0, 0.31944],
    125: [0.25, 0.75, 0, 0, 0.575],
    126: [0.35, 0.34444, 0, 0, 0.575],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.86853],
    168: [0, 0.69444, 0, 0, 0.575],
    172: [0, 0.44444, 0, 0, 0.76666],
    176: [0, 0.69444, 0, 0, 0.86944],
    177: [0.13333, 0.63333, 0, 0, 0.89444],
    184: [0.17014, 0, 0, 0, 0.51111],
    198: [0, 0.68611, 0, 0, 1.04166],
    215: [0.13333, 0.63333, 0, 0, 0.89444],
    216: [0.04861, 0.73472, 0, 0, 0.89444],
    223: [0, 0.69444, 0, 0, 0.59722],
    230: [0, 0.44444, 0, 0, 0.83055],
    247: [0.13333, 0.63333, 0, 0, 0.89444],
    248: [0.09722, 0.54167, 0, 0, 0.575],
    305: [0, 0.44444, 0, 0, 0.31944],
    338: [0, 0.68611, 0, 0, 1.16944],
    339: [0, 0.44444, 0, 0, 0.89444],
    567: [0.19444, 0.44444, 0, 0, 0.35139],
    710: [0, 0.69444, 0, 0, 0.575],
    711: [0, 0.63194, 0, 0, 0.575],
    713: [0, 0.59611, 0, 0, 0.575],
    714: [0, 0.69444, 0, 0, 0.575],
    715: [0, 0.69444, 0, 0, 0.575],
    728: [0, 0.69444, 0, 0, 0.575],
    729: [0, 0.69444, 0, 0, 0.31944],
    730: [0, 0.69444, 0, 0, 0.86944],
    732: [0, 0.69444, 0, 0, 0.575],
    733: [0, 0.69444, 0, 0, 0.575],
    915: [0, 0.68611, 0, 0, 0.69166],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0, 0, 0.89444],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0, 0, 0.76666],
    928: [0, 0.68611, 0, 0, 0.9],
    931: [0, 0.68611, 0, 0, 0.83055],
    933: [0, 0.68611, 0, 0, 0.89444],
    934: [0, 0.68611, 0, 0, 0.83055],
    936: [0, 0.68611, 0, 0, 0.89444],
    937: [0, 0.68611, 0, 0, 0.83055],
    8211: [0, 0.44444, 0.03194, 0, 0.575],
    8212: [0, 0.44444, 0.03194, 0, 1.14999],
    8216: [0, 0.69444, 0, 0, 0.31944],
    8217: [0, 0.69444, 0, 0, 0.31944],
    8220: [0, 0.69444, 0, 0, 0.60278],
    8221: [0, 0.69444, 0, 0, 0.60278],
    8224: [0.19444, 0.69444, 0, 0, 0.51111],
    8225: [0.19444, 0.69444, 0, 0, 0.51111],
    8242: [0, 0.55556, 0, 0, 0.34444],
    8407: [0, 0.72444, 0.15486, 0, 0.575],
    8463: [0, 0.69444, 0, 0, 0.66759],
    8465: [0, 0.69444, 0, 0, 0.83055],
    8467: [0, 0.69444, 0, 0, 0.47361],
    8472: [0.19444, 0.44444, 0, 0, 0.74027],
    8476: [0, 0.69444, 0, 0, 0.83055],
    8501: [0, 0.69444, 0, 0, 0.70277],
    8592: [-0.10889, 0.39111, 0, 0, 1.14999],
    8593: [0.19444, 0.69444, 0, 0, 0.575],
    8594: [-0.10889, 0.39111, 0, 0, 1.14999],
    8595: [0.19444, 0.69444, 0, 0, 0.575],
    8596: [-0.10889, 0.39111, 0, 0, 1.14999],
    8597: [0.25, 0.75, 0, 0, 0.575],
    8598: [0.19444, 0.69444, 0, 0, 1.14999],
    8599: [0.19444, 0.69444, 0, 0, 1.14999],
    8600: [0.19444, 0.69444, 0, 0, 1.14999],
    8601: [0.19444, 0.69444, 0, 0, 1.14999],
    8636: [-0.10889, 0.39111, 0, 0, 1.14999],
    8637: [-0.10889, 0.39111, 0, 0, 1.14999],
    8640: [-0.10889, 0.39111, 0, 0, 1.14999],
    8641: [-0.10889, 0.39111, 0, 0, 1.14999],
    8656: [-0.10889, 0.39111, 0, 0, 1.14999],
    8657: [0.19444, 0.69444, 0, 0, 0.70277],
    8658: [-0.10889, 0.39111, 0, 0, 1.14999],
    8659: [0.19444, 0.69444, 0, 0, 0.70277],
    8660: [-0.10889, 0.39111, 0, 0, 1.14999],
    8661: [0.25, 0.75, 0, 0, 0.70277],
    8704: [0, 0.69444, 0, 0, 0.63889],
    8706: [0, 0.69444, 0.06389, 0, 0.62847],
    8707: [0, 0.69444, 0, 0, 0.63889],
    8709: [0.05556, 0.75, 0, 0, 0.575],
    8711: [0, 0.68611, 0, 0, 0.95833],
    8712: [0.08556, 0.58556, 0, 0, 0.76666],
    8715: [0.08556, 0.58556, 0, 0, 0.76666],
    8722: [0.13333, 0.63333, 0, 0, 0.89444],
    8723: [0.13333, 0.63333, 0, 0, 0.89444],
    8725: [0.25, 0.75, 0, 0, 0.575],
    8726: [0.25, 0.75, 0, 0, 0.575],
    8727: [-0.02778, 0.47222, 0, 0, 0.575],
    8728: [-0.02639, 0.47361, 0, 0, 0.575],
    8729: [-0.02639, 0.47361, 0, 0, 0.575],
    8730: [0.18, 0.82, 0, 0, 0.95833],
    8733: [0, 0.44444, 0, 0, 0.89444],
    8734: [0, 0.44444, 0, 0, 1.14999],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.31944],
    8741: [0.25, 0.75, 0, 0, 0.575],
    8743: [0, 0.55556, 0, 0, 0.76666],
    8744: [0, 0.55556, 0, 0, 0.76666],
    8745: [0, 0.55556, 0, 0, 0.76666],
    8746: [0, 0.55556, 0, 0, 0.76666],
    8747: [0.19444, 0.69444, 0.12778, 0, 0.56875],
    8764: [-0.10889, 0.39111, 0, 0, 0.89444],
    8768: [0.19444, 0.69444, 0, 0, 0.31944],
    8771: [222e-5, 0.50222, 0, 0, 0.89444],
    8773: [0.027, 0.638, 0, 0, 0.894],
    8776: [0.02444, 0.52444, 0, 0, 0.89444],
    8781: [222e-5, 0.50222, 0, 0, 0.89444],
    8801: [222e-5, 0.50222, 0, 0, 0.89444],
    8804: [0.19667, 0.69667, 0, 0, 0.89444],
    8805: [0.19667, 0.69667, 0, 0, 0.89444],
    8810: [0.08556, 0.58556, 0, 0, 1.14999],
    8811: [0.08556, 0.58556, 0, 0, 1.14999],
    8826: [0.08556, 0.58556, 0, 0, 0.89444],
    8827: [0.08556, 0.58556, 0, 0, 0.89444],
    8834: [0.08556, 0.58556, 0, 0, 0.89444],
    8835: [0.08556, 0.58556, 0, 0, 0.89444],
    8838: [0.19667, 0.69667, 0, 0, 0.89444],
    8839: [0.19667, 0.69667, 0, 0, 0.89444],
    8846: [0, 0.55556, 0, 0, 0.76666],
    8849: [0.19667, 0.69667, 0, 0, 0.89444],
    8850: [0.19667, 0.69667, 0, 0, 0.89444],
    8851: [0, 0.55556, 0, 0, 0.76666],
    8852: [0, 0.55556, 0, 0, 0.76666],
    8853: [0.13333, 0.63333, 0, 0, 0.89444],
    8854: [0.13333, 0.63333, 0, 0, 0.89444],
    8855: [0.13333, 0.63333, 0, 0, 0.89444],
    8856: [0.13333, 0.63333, 0, 0, 0.89444],
    8857: [0.13333, 0.63333, 0, 0, 0.89444],
    8866: [0, 0.69444, 0, 0, 0.70277],
    8867: [0, 0.69444, 0, 0, 0.70277],
    8868: [0, 0.69444, 0, 0, 0.89444],
    8869: [0, 0.69444, 0, 0, 0.89444],
    8900: [-0.02639, 0.47361, 0, 0, 0.575],
    8901: [-0.02639, 0.47361, 0, 0, 0.31944],
    8902: [-0.02778, 0.47222, 0, 0, 0.575],
    8968: [0.25, 0.75, 0, 0, 0.51111],
    8969: [0.25, 0.75, 0, 0, 0.51111],
    8970: [0.25, 0.75, 0, 0, 0.51111],
    8971: [0.25, 0.75, 0, 0, 0.51111],
    8994: [-0.13889, 0.36111, 0, 0, 1.14999],
    8995: [-0.13889, 0.36111, 0, 0, 1.14999],
    9651: [0.19444, 0.69444, 0, 0, 1.02222],
    9657: [-0.02778, 0.47222, 0, 0, 0.575],
    9661: [0.19444, 0.69444, 0, 0, 1.02222],
    9667: [-0.02778, 0.47222, 0, 0, 0.575],
    9711: [0.19444, 0.69444, 0, 0, 1.14999],
    9824: [0.12963, 0.69444, 0, 0, 0.89444],
    9825: [0.12963, 0.69444, 0, 0, 0.89444],
    9826: [0.12963, 0.69444, 0, 0, 0.89444],
    9827: [0.12963, 0.69444, 0, 0, 0.89444],
    9837: [0, 0.75, 0, 0, 0.44722],
    9838: [0.19444, 0.69444, 0, 0, 0.44722],
    9839: [0.19444, 0.69444, 0, 0, 0.44722],
    10216: [0.25, 0.75, 0, 0, 0.44722],
    10217: [0.25, 0.75, 0, 0, 0.44722],
    10815: [0, 0.68611, 0, 0, 0.9],
    10927: [0.19667, 0.69667, 0, 0, 0.89444],
    10928: [0.19667, 0.69667, 0, 0, 0.89444],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.11417, 0, 0.38611],
    34: [0, 0.69444, 0.07939, 0, 0.62055],
    35: [0.19444, 0.69444, 0.06833, 0, 0.94444],
    37: [0.05556, 0.75, 0.12861, 0, 0.94444],
    38: [0, 0.69444, 0.08528, 0, 0.88555],
    39: [0, 0.69444, 0.12945, 0, 0.35555],
    40: [0.25, 0.75, 0.15806, 0, 0.47333],
    41: [0.25, 0.75, 0.03306, 0, 0.47333],
    42: [0, 0.75, 0.14333, 0, 0.59111],
    43: [0.10333, 0.60333, 0.03306, 0, 0.88555],
    44: [0.19444, 0.14722, 0, 0, 0.35555],
    45: [0, 0.44444, 0.02611, 0, 0.41444],
    46: [0, 0.14722, 0, 0, 0.35555],
    47: [0.25, 0.75, 0.15806, 0, 0.59111],
    48: [0, 0.64444, 0.13167, 0, 0.59111],
    49: [0, 0.64444, 0.13167, 0, 0.59111],
    50: [0, 0.64444, 0.13167, 0, 0.59111],
    51: [0, 0.64444, 0.13167, 0, 0.59111],
    52: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    53: [0, 0.64444, 0.13167, 0, 0.59111],
    54: [0, 0.64444, 0.13167, 0, 0.59111],
    55: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    56: [0, 0.64444, 0.13167, 0, 0.59111],
    57: [0, 0.64444, 0.13167, 0, 0.59111],
    58: [0, 0.44444, 0.06695, 0, 0.35555],
    59: [0.19444, 0.44444, 0.06695, 0, 0.35555],
    61: [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    63: [0, 0.69444, 0.11472, 0, 0.59111],
    64: [0, 0.69444, 0.09208, 0, 0.88555],
    65: [0, 0.68611, 0, 0, 0.86555],
    66: [0, 0.68611, 0.0992, 0, 0.81666],
    67: [0, 0.68611, 0.14208, 0, 0.82666],
    68: [0, 0.68611, 0.09062, 0, 0.87555],
    69: [0, 0.68611, 0.11431, 0, 0.75666],
    70: [0, 0.68611, 0.12903, 0, 0.72722],
    71: [0, 0.68611, 0.07347, 0, 0.89527],
    72: [0, 0.68611, 0.17208, 0, 0.8961],
    73: [0, 0.68611, 0.15681, 0, 0.47166],
    74: [0, 0.68611, 0.145, 0, 0.61055],
    75: [0, 0.68611, 0.14208, 0, 0.89499],
    76: [0, 0.68611, 0, 0, 0.69777],
    77: [0, 0.68611, 0.17208, 0, 1.07277],
    78: [0, 0.68611, 0.17208, 0, 0.8961],
    79: [0, 0.68611, 0.09062, 0, 0.85499],
    80: [0, 0.68611, 0.0992, 0, 0.78721],
    81: [0.19444, 0.68611, 0.09062, 0, 0.85499],
    82: [0, 0.68611, 0.02559, 0, 0.85944],
    83: [0, 0.68611, 0.11264, 0, 0.64999],
    84: [0, 0.68611, 0.12903, 0, 0.7961],
    85: [0, 0.68611, 0.17208, 0, 0.88083],
    86: [0, 0.68611, 0.18625, 0, 0.86555],
    87: [0, 0.68611, 0.18625, 0, 1.15999],
    88: [0, 0.68611, 0.15681, 0, 0.86555],
    89: [0, 0.68611, 0.19803, 0, 0.86555],
    90: [0, 0.68611, 0.14208, 0, 0.70888],
    91: [0.25, 0.75, 0.1875, 0, 0.35611],
    93: [0.25, 0.75, 0.09972, 0, 0.35611],
    94: [0, 0.69444, 0.06709, 0, 0.59111],
    95: [0.31, 0.13444, 0.09811, 0, 0.59111],
    97: [0, 0.44444, 0.09426, 0, 0.59111],
    98: [0, 0.69444, 0.07861, 0, 0.53222],
    99: [0, 0.44444, 0.05222, 0, 0.53222],
    100: [0, 0.69444, 0.10861, 0, 0.59111],
    101: [0, 0.44444, 0.085, 0, 0.53222],
    102: [0.19444, 0.69444, 0.21778, 0, 0.4],
    103: [0.19444, 0.44444, 0.105, 0, 0.53222],
    104: [0, 0.69444, 0.09426, 0, 0.59111],
    105: [0, 0.69326, 0.11387, 0, 0.35555],
    106: [0.19444, 0.69326, 0.1672, 0, 0.35555],
    107: [0, 0.69444, 0.11111, 0, 0.53222],
    108: [0, 0.69444, 0.10861, 0, 0.29666],
    109: [0, 0.44444, 0.09426, 0, 0.94444],
    110: [0, 0.44444, 0.09426, 0, 0.64999],
    111: [0, 0.44444, 0.07861, 0, 0.59111],
    112: [0.19444, 0.44444, 0.07861, 0, 0.59111],
    113: [0.19444, 0.44444, 0.105, 0, 0.53222],
    114: [0, 0.44444, 0.11111, 0, 0.50167],
    115: [0, 0.44444, 0.08167, 0, 0.48694],
    116: [0, 0.63492, 0.09639, 0, 0.385],
    117: [0, 0.44444, 0.09426, 0, 0.62055],
    118: [0, 0.44444, 0.11111, 0, 0.53222],
    119: [0, 0.44444, 0.11111, 0, 0.76777],
    120: [0, 0.44444, 0.12583, 0, 0.56055],
    121: [0.19444, 0.44444, 0.105, 0, 0.56166],
    122: [0, 0.44444, 0.13889, 0, 0.49055],
    126: [0.35, 0.34444, 0.11472, 0, 0.59111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0.11473, 0, 0.59111],
    176: [0, 0.69444, 0, 0, 0.94888],
    184: [0.17014, 0, 0, 0, 0.53222],
    198: [0, 0.68611, 0.11431, 0, 1.02277],
    216: [0.04861, 0.73472, 0.09062, 0, 0.88555],
    223: [0.19444, 0.69444, 0.09736, 0, 0.665],
    230: [0, 0.44444, 0.085, 0, 0.82666],
    248: [0.09722, 0.54167, 0.09458, 0, 0.59111],
    305: [0, 0.44444, 0.09426, 0, 0.35555],
    338: [0, 0.68611, 0.11431, 0, 1.14054],
    339: [0, 0.44444, 0.085, 0, 0.82666],
    567: [0.19444, 0.44444, 0.04611, 0, 0.385],
    710: [0, 0.69444, 0.06709, 0, 0.59111],
    711: [0, 0.63194, 0.08271, 0, 0.59111],
    713: [0, 0.59444, 0.10444, 0, 0.59111],
    714: [0, 0.69444, 0.08528, 0, 0.59111],
    715: [0, 0.69444, 0, 0, 0.59111],
    728: [0, 0.69444, 0.10333, 0, 0.59111],
    729: [0, 0.69444, 0.12945, 0, 0.35555],
    730: [0, 0.69444, 0, 0, 0.94888],
    732: [0, 0.69444, 0.11472, 0, 0.59111],
    733: [0, 0.69444, 0.11472, 0, 0.59111],
    915: [0, 0.68611, 0.12903, 0, 0.69777],
    916: [0, 0.68611, 0, 0, 0.94444],
    920: [0, 0.68611, 0.09062, 0, 0.88555],
    923: [0, 0.68611, 0, 0, 0.80666],
    926: [0, 0.68611, 0.15092, 0, 0.76777],
    928: [0, 0.68611, 0.17208, 0, 0.8961],
    931: [0, 0.68611, 0.11431, 0, 0.82666],
    933: [0, 0.68611, 0.10778, 0, 0.88555],
    934: [0, 0.68611, 0.05632, 0, 0.82666],
    936: [0, 0.68611, 0.10778, 0, 0.88555],
    937: [0, 0.68611, 0.0992, 0, 0.82666],
    8211: [0, 0.44444, 0.09811, 0, 0.59111],
    8212: [0, 0.44444, 0.09811, 0, 1.18221],
    8216: [0, 0.69444, 0.12945, 0, 0.35555],
    8217: [0, 0.69444, 0.12945, 0, 0.35555],
    8220: [0, 0.69444, 0.16772, 0, 0.62055],
    8221: [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.12417, 0, 0.30667],
    34: [0, 0.69444, 0.06961, 0, 0.51444],
    35: [0.19444, 0.69444, 0.06616, 0, 0.81777],
    37: [0.05556, 0.75, 0.13639, 0, 0.81777],
    38: [0, 0.69444, 0.09694, 0, 0.76666],
    39: [0, 0.69444, 0.12417, 0, 0.30667],
    40: [0.25, 0.75, 0.16194, 0, 0.40889],
    41: [0.25, 0.75, 0.03694, 0, 0.40889],
    42: [0, 0.75, 0.14917, 0, 0.51111],
    43: [0.05667, 0.56167, 0.03694, 0, 0.76666],
    44: [0.19444, 0.10556, 0, 0, 0.30667],
    45: [0, 0.43056, 0.02826, 0, 0.35778],
    46: [0, 0.10556, 0, 0, 0.30667],
    47: [0.25, 0.75, 0.16194, 0, 0.51111],
    48: [0, 0.64444, 0.13556, 0, 0.51111],
    49: [0, 0.64444, 0.13556, 0, 0.51111],
    50: [0, 0.64444, 0.13556, 0, 0.51111],
    51: [0, 0.64444, 0.13556, 0, 0.51111],
    52: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    53: [0, 0.64444, 0.13556, 0, 0.51111],
    54: [0, 0.64444, 0.13556, 0, 0.51111],
    55: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    56: [0, 0.64444, 0.13556, 0, 0.51111],
    57: [0, 0.64444, 0.13556, 0, 0.51111],
    58: [0, 0.43056, 0.0582, 0, 0.30667],
    59: [0.19444, 0.43056, 0.0582, 0, 0.30667],
    61: [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    63: [0, 0.69444, 0.1225, 0, 0.51111],
    64: [0, 0.69444, 0.09597, 0, 0.76666],
    65: [0, 0.68333, 0, 0, 0.74333],
    66: [0, 0.68333, 0.10257, 0, 0.70389],
    67: [0, 0.68333, 0.14528, 0, 0.71555],
    68: [0, 0.68333, 0.09403, 0, 0.755],
    69: [0, 0.68333, 0.12028, 0, 0.67833],
    70: [0, 0.68333, 0.13305, 0, 0.65277],
    71: [0, 0.68333, 0.08722, 0, 0.77361],
    72: [0, 0.68333, 0.16389, 0, 0.74333],
    73: [0, 0.68333, 0.15806, 0, 0.38555],
    74: [0, 0.68333, 0.14028, 0, 0.525],
    75: [0, 0.68333, 0.14528, 0, 0.76888],
    76: [0, 0.68333, 0, 0, 0.62722],
    77: [0, 0.68333, 0.16389, 0, 0.89666],
    78: [0, 0.68333, 0.16389, 0, 0.74333],
    79: [0, 0.68333, 0.09403, 0, 0.76666],
    80: [0, 0.68333, 0.10257, 0, 0.67833],
    81: [0.19444, 0.68333, 0.09403, 0, 0.76666],
    82: [0, 0.68333, 0.03868, 0, 0.72944],
    83: [0, 0.68333, 0.11972, 0, 0.56222],
    84: [0, 0.68333, 0.13305, 0, 0.71555],
    85: [0, 0.68333, 0.16389, 0, 0.74333],
    86: [0, 0.68333, 0.18361, 0, 0.74333],
    87: [0, 0.68333, 0.18361, 0, 0.99888],
    88: [0, 0.68333, 0.15806, 0, 0.74333],
    89: [0, 0.68333, 0.19383, 0, 0.74333],
    90: [0, 0.68333, 0.14528, 0, 0.61333],
    91: [0.25, 0.75, 0.1875, 0, 0.30667],
    93: [0.25, 0.75, 0.10528, 0, 0.30667],
    94: [0, 0.69444, 0.06646, 0, 0.51111],
    95: [0.31, 0.12056, 0.09208, 0, 0.51111],
    97: [0, 0.43056, 0.07671, 0, 0.51111],
    98: [0, 0.69444, 0.06312, 0, 0.46],
    99: [0, 0.43056, 0.05653, 0, 0.46],
    100: [0, 0.69444, 0.10333, 0, 0.51111],
    101: [0, 0.43056, 0.07514, 0, 0.46],
    102: [0.19444, 0.69444, 0.21194, 0, 0.30667],
    103: [0.19444, 0.43056, 0.08847, 0, 0.46],
    104: [0, 0.69444, 0.07671, 0, 0.51111],
    105: [0, 0.65536, 0.1019, 0, 0.30667],
    106: [0.19444, 0.65536, 0.14467, 0, 0.30667],
    107: [0, 0.69444, 0.10764, 0, 0.46],
    108: [0, 0.69444, 0.10333, 0, 0.25555],
    109: [0, 0.43056, 0.07671, 0, 0.81777],
    110: [0, 0.43056, 0.07671, 0, 0.56222],
    111: [0, 0.43056, 0.06312, 0, 0.51111],
    112: [0.19444, 0.43056, 0.06312, 0, 0.51111],
    113: [0.19444, 0.43056, 0.08847, 0, 0.46],
    114: [0, 0.43056, 0.10764, 0, 0.42166],
    115: [0, 0.43056, 0.08208, 0, 0.40889],
    116: [0, 0.61508, 0.09486, 0, 0.33222],
    117: [0, 0.43056, 0.07671, 0, 0.53666],
    118: [0, 0.43056, 0.10764, 0, 0.46],
    119: [0, 0.43056, 0.10764, 0, 0.66444],
    120: [0, 0.43056, 0.12042, 0, 0.46389],
    121: [0.19444, 0.43056, 0.08847, 0, 0.48555],
    122: [0, 0.43056, 0.12292, 0, 0.40889],
    126: [0.35, 0.31786, 0.11585, 0, 0.51111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.66786, 0.10474, 0, 0.51111],
    176: [0, 0.69444, 0, 0, 0.83129],
    184: [0.17014, 0, 0, 0, 0.46],
    198: [0, 0.68333, 0.12028, 0, 0.88277],
    216: [0.04861, 0.73194, 0.09403, 0, 0.76666],
    223: [0.19444, 0.69444, 0.10514, 0, 0.53666],
    230: [0, 0.43056, 0.07514, 0, 0.71555],
    248: [0.09722, 0.52778, 0.09194, 0, 0.51111],
    338: [0, 0.68333, 0.12028, 0, 0.98499],
    339: [0, 0.43056, 0.07514, 0, 0.71555],
    710: [0, 0.69444, 0.06646, 0, 0.51111],
    711: [0, 0.62847, 0.08295, 0, 0.51111],
    713: [0, 0.56167, 0.10333, 0, 0.51111],
    714: [0, 0.69444, 0.09694, 0, 0.51111],
    715: [0, 0.69444, 0, 0, 0.51111],
    728: [0, 0.69444, 0.10806, 0, 0.51111],
    729: [0, 0.66786, 0.11752, 0, 0.30667],
    730: [0, 0.69444, 0, 0, 0.83129],
    732: [0, 0.66786, 0.11585, 0, 0.51111],
    733: [0, 0.69444, 0.1225, 0, 0.51111],
    915: [0, 0.68333, 0.13305, 0, 0.62722],
    916: [0, 0.68333, 0, 0, 0.81777],
    920: [0, 0.68333, 0.09403, 0, 0.76666],
    923: [0, 0.68333, 0, 0, 0.69222],
    926: [0, 0.68333, 0.15294, 0, 0.66444],
    928: [0, 0.68333, 0.16389, 0, 0.74333],
    931: [0, 0.68333, 0.12028, 0, 0.71555],
    933: [0, 0.68333, 0.11111, 0, 0.76666],
    934: [0, 0.68333, 0.05986, 0, 0.71555],
    936: [0, 0.68333, 0.11111, 0, 0.76666],
    937: [0, 0.68333, 0.10257, 0, 0.71555],
    8211: [0, 0.43056, 0.09208, 0, 0.51111],
    8212: [0, 0.43056, 0.09208, 0, 1.02222],
    8216: [0, 0.69444, 0.12417, 0, 0.30667],
    8217: [0, 0.69444, 0.12417, 0, 0.30667],
    8220: [0, 0.69444, 0.1685, 0, 0.51444],
    8221: [0, 0.69444, 0.06961, 0, 0.51444],
    8463: [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.27778],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.77778],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.19444, 0.10556, 0, 0, 0.27778],
    45: [0, 0.43056, 0, 0, 0.33333],
    46: [0, 0.10556, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.64444, 0, 0, 0.5],
    49: [0, 0.64444, 0, 0, 0.5],
    50: [0, 0.64444, 0, 0, 0.5],
    51: [0, 0.64444, 0, 0, 0.5],
    52: [0, 0.64444, 0, 0, 0.5],
    53: [0, 0.64444, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0, 0.64444, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0, 0.64444, 0, 0, 0.5],
    58: [0, 0.43056, 0, 0, 0.27778],
    59: [0.19444, 0.43056, 0, 0, 0.27778],
    60: [0.0391, 0.5391, 0, 0, 0.77778],
    61: [-0.13313, 0.36687, 0, 0, 0.77778],
    62: [0.0391, 0.5391, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.77778],
    65: [0, 0.68333, 0, 0, 0.75],
    66: [0, 0.68333, 0, 0, 0.70834],
    67: [0, 0.68333, 0, 0, 0.72222],
    68: [0, 0.68333, 0, 0, 0.76389],
    69: [0, 0.68333, 0, 0, 0.68056],
    70: [0, 0.68333, 0, 0, 0.65278],
    71: [0, 0.68333, 0, 0, 0.78472],
    72: [0, 0.68333, 0, 0, 0.75],
    73: [0, 0.68333, 0, 0, 0.36111],
    74: [0, 0.68333, 0, 0, 0.51389],
    75: [0, 0.68333, 0, 0, 0.77778],
    76: [0, 0.68333, 0, 0, 0.625],
    77: [0, 0.68333, 0, 0, 0.91667],
    78: [0, 0.68333, 0, 0, 0.75],
    79: [0, 0.68333, 0, 0, 0.77778],
    80: [0, 0.68333, 0, 0, 0.68056],
    81: [0.19444, 0.68333, 0, 0, 0.77778],
    82: [0, 0.68333, 0, 0, 0.73611],
    83: [0, 0.68333, 0, 0, 0.55556],
    84: [0, 0.68333, 0, 0, 0.72222],
    85: [0, 0.68333, 0, 0, 0.75],
    86: [0, 0.68333, 0.01389, 0, 0.75],
    87: [0, 0.68333, 0.01389, 0, 1.02778],
    88: [0, 0.68333, 0, 0, 0.75],
    89: [0, 0.68333, 0.025, 0, 0.75],
    90: [0, 0.68333, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.27778],
    92: [0.25, 0.75, 0, 0, 0.5],
    93: [0.25, 0.75, 0, 0, 0.27778],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.31, 0.12056, 0.02778, 0, 0.5],
    97: [0, 0.43056, 0, 0, 0.5],
    98: [0, 0.69444, 0, 0, 0.55556],
    99: [0, 0.43056, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.55556],
    101: [0, 0.43056, 0, 0, 0.44445],
    102: [0, 0.69444, 0.07778, 0, 0.30556],
    103: [0.19444, 0.43056, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.55556],
    105: [0, 0.66786, 0, 0, 0.27778],
    106: [0.19444, 0.66786, 0, 0, 0.30556],
    107: [0, 0.69444, 0, 0, 0.52778],
    108: [0, 0.69444, 0, 0, 0.27778],
    109: [0, 0.43056, 0, 0, 0.83334],
    110: [0, 0.43056, 0, 0, 0.55556],
    111: [0, 0.43056, 0, 0, 0.5],
    112: [0.19444, 0.43056, 0, 0, 0.55556],
    113: [0.19444, 0.43056, 0, 0, 0.52778],
    114: [0, 0.43056, 0, 0, 0.39167],
    115: [0, 0.43056, 0, 0, 0.39445],
    116: [0, 0.61508, 0, 0, 0.38889],
    117: [0, 0.43056, 0, 0, 0.55556],
    118: [0, 0.43056, 0.01389, 0, 0.52778],
    119: [0, 0.43056, 0.01389, 0, 0.72222],
    120: [0, 0.43056, 0, 0, 0.52778],
    121: [0.19444, 0.43056, 0.01389, 0, 0.52778],
    122: [0, 0.43056, 0, 0, 0.44445],
    123: [0.25, 0.75, 0, 0, 0.5],
    124: [0.25, 0.75, 0, 0, 0.27778],
    125: [0.25, 0.75, 0, 0, 0.5],
    126: [0.35, 0.31786, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.76909],
    167: [0.19444, 0.69444, 0, 0, 0.44445],
    168: [0, 0.66786, 0, 0, 0.5],
    172: [0, 0.43056, 0, 0, 0.66667],
    176: [0, 0.69444, 0, 0, 0.75],
    177: [0.08333, 0.58333, 0, 0, 0.77778],
    182: [0.19444, 0.69444, 0, 0, 0.61111],
    184: [0.17014, 0, 0, 0, 0.44445],
    198: [0, 0.68333, 0, 0, 0.90278],
    215: [0.08333, 0.58333, 0, 0, 0.77778],
    216: [0.04861, 0.73194, 0, 0, 0.77778],
    223: [0, 0.69444, 0, 0, 0.5],
    230: [0, 0.43056, 0, 0, 0.72222],
    247: [0.08333, 0.58333, 0, 0, 0.77778],
    248: [0.09722, 0.52778, 0, 0, 0.5],
    305: [0, 0.43056, 0, 0, 0.27778],
    338: [0, 0.68333, 0, 0, 1.01389],
    339: [0, 0.43056, 0, 0, 0.77778],
    567: [0.19444, 0.43056, 0, 0, 0.30556],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.62847, 0, 0, 0.5],
    713: [0, 0.56778, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.66786, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.75],
    732: [0, 0.66786, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.68333, 0, 0, 0.625],
    916: [0, 0.68333, 0, 0, 0.83334],
    920: [0, 0.68333, 0, 0, 0.77778],
    923: [0, 0.68333, 0, 0, 0.69445],
    926: [0, 0.68333, 0, 0, 0.66667],
    928: [0, 0.68333, 0, 0, 0.75],
    931: [0, 0.68333, 0, 0, 0.72222],
    933: [0, 0.68333, 0, 0, 0.77778],
    934: [0, 0.68333, 0, 0, 0.72222],
    936: [0, 0.68333, 0, 0, 0.77778],
    937: [0, 0.68333, 0, 0, 0.72222],
    8211: [0, 0.43056, 0.02778, 0, 0.5],
    8212: [0, 0.43056, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5],
    8224: [0.19444, 0.69444, 0, 0, 0.44445],
    8225: [0.19444, 0.69444, 0, 0, 0.44445],
    8230: [0, 0.123, 0, 0, 1.172],
    8242: [0, 0.55556, 0, 0, 0.275],
    8407: [0, 0.71444, 0.15382, 0, 0.5],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8465: [0, 0.69444, 0, 0, 0.72222],
    8467: [0, 0.69444, 0, 0.11111, 0.41667],
    8472: [0.19444, 0.43056, 0, 0.11111, 0.63646],
    8476: [0, 0.69444, 0, 0, 0.72222],
    8501: [0, 0.69444, 0, 0, 0.61111],
    8592: [-0.13313, 0.36687, 0, 0, 1],
    8593: [0.19444, 0.69444, 0, 0, 0.5],
    8594: [-0.13313, 0.36687, 0, 0, 1],
    8595: [0.19444, 0.69444, 0, 0, 0.5],
    8596: [-0.13313, 0.36687, 0, 0, 1],
    8597: [0.25, 0.75, 0, 0, 0.5],
    8598: [0.19444, 0.69444, 0, 0, 1],
    8599: [0.19444, 0.69444, 0, 0, 1],
    8600: [0.19444, 0.69444, 0, 0, 1],
    8601: [0.19444, 0.69444, 0, 0, 1],
    8614: [0.011, 0.511, 0, 0, 1],
    8617: [0.011, 0.511, 0, 0, 1.126],
    8618: [0.011, 0.511, 0, 0, 1.126],
    8636: [-0.13313, 0.36687, 0, 0, 1],
    8637: [-0.13313, 0.36687, 0, 0, 1],
    8640: [-0.13313, 0.36687, 0, 0, 1],
    8641: [-0.13313, 0.36687, 0, 0, 1],
    8652: [0.011, 0.671, 0, 0, 1],
    8656: [-0.13313, 0.36687, 0, 0, 1],
    8657: [0.19444, 0.69444, 0, 0, 0.61111],
    8658: [-0.13313, 0.36687, 0, 0, 1],
    8659: [0.19444, 0.69444, 0, 0, 0.61111],
    8660: [-0.13313, 0.36687, 0, 0, 1],
    8661: [0.25, 0.75, 0, 0, 0.61111],
    8704: [0, 0.69444, 0, 0, 0.55556],
    8706: [0, 0.69444, 0.05556, 0.08334, 0.5309],
    8707: [0, 0.69444, 0, 0, 0.55556],
    8709: [0.05556, 0.75, 0, 0, 0.5],
    8711: [0, 0.68333, 0, 0, 0.83334],
    8712: [0.0391, 0.5391, 0, 0, 0.66667],
    8715: [0.0391, 0.5391, 0, 0, 0.66667],
    8722: [0.08333, 0.58333, 0, 0, 0.77778],
    8723: [0.08333, 0.58333, 0, 0, 0.77778],
    8725: [0.25, 0.75, 0, 0, 0.5],
    8726: [0.25, 0.75, 0, 0, 0.5],
    8727: [-0.03472, 0.46528, 0, 0, 0.5],
    8728: [-0.05555, 0.44445, 0, 0, 0.5],
    8729: [-0.05555, 0.44445, 0, 0, 0.5],
    8730: [0.2, 0.8, 0, 0, 0.83334],
    8733: [0, 0.43056, 0, 0, 0.77778],
    8734: [0, 0.43056, 0, 0, 1],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.27778],
    8741: [0.25, 0.75, 0, 0, 0.5],
    8743: [0, 0.55556, 0, 0, 0.66667],
    8744: [0, 0.55556, 0, 0, 0.66667],
    8745: [0, 0.55556, 0, 0, 0.66667],
    8746: [0, 0.55556, 0, 0, 0.66667],
    8747: [0.19444, 0.69444, 0.11111, 0, 0.41667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8768: [0.19444, 0.69444, 0, 0, 0.27778],
    8771: [-0.03625, 0.46375, 0, 0, 0.77778],
    8773: [-0.022, 0.589, 0, 0, 0.778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8781: [-0.03625, 0.46375, 0, 0, 0.77778],
    8784: [-0.133, 0.673, 0, 0, 0.778],
    8801: [-0.03625, 0.46375, 0, 0, 0.77778],
    8804: [0.13597, 0.63597, 0, 0, 0.77778],
    8805: [0.13597, 0.63597, 0, 0, 0.77778],
    8810: [0.0391, 0.5391, 0, 0, 1],
    8811: [0.0391, 0.5391, 0, 0, 1],
    8826: [0.0391, 0.5391, 0, 0, 0.77778],
    8827: [0.0391, 0.5391, 0, 0, 0.77778],
    8834: [0.0391, 0.5391, 0, 0, 0.77778],
    8835: [0.0391, 0.5391, 0, 0, 0.77778],
    8838: [0.13597, 0.63597, 0, 0, 0.77778],
    8839: [0.13597, 0.63597, 0, 0, 0.77778],
    8846: [0, 0.55556, 0, 0, 0.66667],
    8849: [0.13597, 0.63597, 0, 0, 0.77778],
    8850: [0.13597, 0.63597, 0, 0, 0.77778],
    8851: [0, 0.55556, 0, 0, 0.66667],
    8852: [0, 0.55556, 0, 0, 0.66667],
    8853: [0.08333, 0.58333, 0, 0, 0.77778],
    8854: [0.08333, 0.58333, 0, 0, 0.77778],
    8855: [0.08333, 0.58333, 0, 0, 0.77778],
    8856: [0.08333, 0.58333, 0, 0, 0.77778],
    8857: [0.08333, 0.58333, 0, 0, 0.77778],
    8866: [0, 0.69444, 0, 0, 0.61111],
    8867: [0, 0.69444, 0, 0, 0.61111],
    8868: [0, 0.69444, 0, 0, 0.77778],
    8869: [0, 0.69444, 0, 0, 0.77778],
    8872: [0.249, 0.75, 0, 0, 0.867],
    8900: [-0.05555, 0.44445, 0, 0, 0.5],
    8901: [-0.05555, 0.44445, 0, 0, 0.27778],
    8902: [-0.03472, 0.46528, 0, 0, 0.5],
    8904: [5e-3, 0.505, 0, 0, 0.9],
    8942: [0.03, 0.903, 0, 0, 0.278],
    8943: [-0.19, 0.313, 0, 0, 1.172],
    8945: [-0.1, 0.823, 0, 0, 1.282],
    8968: [0.25, 0.75, 0, 0, 0.44445],
    8969: [0.25, 0.75, 0, 0, 0.44445],
    8970: [0.25, 0.75, 0, 0, 0.44445],
    8971: [0.25, 0.75, 0, 0, 0.44445],
    8994: [-0.14236, 0.35764, 0, 0, 1],
    8995: [-0.14236, 0.35764, 0, 0, 1],
    9136: [0.244, 0.744, 0, 0, 0.412],
    9137: [0.244, 0.745, 0, 0, 0.412],
    9651: [0.19444, 0.69444, 0, 0, 0.88889],
    9657: [-0.03472, 0.46528, 0, 0, 0.5],
    9661: [0.19444, 0.69444, 0, 0, 0.88889],
    9667: [-0.03472, 0.46528, 0, 0, 0.5],
    9711: [0.19444, 0.69444, 0, 0, 1],
    9824: [0.12963, 0.69444, 0, 0, 0.77778],
    9825: [0.12963, 0.69444, 0, 0, 0.77778],
    9826: [0.12963, 0.69444, 0, 0, 0.77778],
    9827: [0.12963, 0.69444, 0, 0, 0.77778],
    9837: [0, 0.75, 0, 0, 0.38889],
    9838: [0.19444, 0.69444, 0, 0, 0.38889],
    9839: [0.19444, 0.69444, 0, 0, 0.38889],
    10216: [0.25, 0.75, 0, 0, 0.38889],
    10217: [0.25, 0.75, 0, 0, 0.38889],
    10222: [0.244, 0.744, 0, 0, 0.412],
    10223: [0.244, 0.745, 0, 0, 0.412],
    10229: [0.011, 0.511, 0, 0, 1.609],
    10230: [0.011, 0.511, 0, 0, 1.638],
    10231: [0.011, 0.511, 0, 0, 1.859],
    10232: [0.024, 0.525, 0, 0, 1.609],
    10233: [0.024, 0.525, 0, 0, 1.638],
    10234: [0.024, 0.525, 0, 0, 1.858],
    10236: [0.011, 0.511, 0, 0, 1.638],
    10815: [0, 0.68333, 0, 0, 0.75],
    10927: [0.13597, 0.63597, 0, 0, 0.77778],
    10928: [0.13597, 0.63597, 0, 0, 0.77778],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.44444, 0, 0, 0.575],
    49: [0, 0.44444, 0, 0, 0.575],
    50: [0, 0.44444, 0, 0, 0.575],
    51: [0.19444, 0.44444, 0, 0, 0.575],
    52: [0.19444, 0.44444, 0, 0, 0.575],
    53: [0.19444, 0.44444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0.19444, 0.44444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0.19444, 0.44444, 0, 0, 0.575],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0.04835, 0, 0.8664],
    67: [0, 0.68611, 0.06979, 0, 0.81694],
    68: [0, 0.68611, 0.03194, 0, 0.93812],
    69: [0, 0.68611, 0.05451, 0, 0.81007],
    70: [0, 0.68611, 0.15972, 0, 0.68889],
    71: [0, 0.68611, 0, 0, 0.88673],
    72: [0, 0.68611, 0.08229, 0, 0.98229],
    73: [0, 0.68611, 0.07778, 0, 0.51111],
    74: [0, 0.68611, 0.10069, 0, 0.63125],
    75: [0, 0.68611, 0.06979, 0, 0.97118],
    76: [0, 0.68611, 0, 0, 0.75555],
    77: [0, 0.68611, 0.11424, 0, 1.14201],
    78: [0, 0.68611, 0.11424, 0, 0.95034],
    79: [0, 0.68611, 0.03194, 0, 0.83666],
    80: [0, 0.68611, 0.15972, 0, 0.72309],
    81: [0.19444, 0.68611, 0, 0, 0.86861],
    82: [0, 0.68611, 421e-5, 0, 0.87235],
    83: [0, 0.68611, 0.05382, 0, 0.69271],
    84: [0, 0.68611, 0.15972, 0, 0.63663],
    85: [0, 0.68611, 0.11424, 0, 0.80027],
    86: [0, 0.68611, 0.25555, 0, 0.67778],
    87: [0, 0.68611, 0.15972, 0, 1.09305],
    88: [0, 0.68611, 0.07778, 0, 0.94722],
    89: [0, 0.68611, 0.25555, 0, 0.67458],
    90: [0, 0.68611, 0.06979, 0, 0.77257],
    97: [0, 0.44444, 0, 0, 0.63287],
    98: [0, 0.69444, 0, 0, 0.52083],
    99: [0, 0.44444, 0, 0, 0.51342],
    100: [0, 0.69444, 0, 0, 0.60972],
    101: [0, 0.44444, 0, 0, 0.55361],
    102: [0.19444, 0.69444, 0.11042, 0, 0.56806],
    103: [0.19444, 0.44444, 0.03704, 0, 0.5449],
    104: [0, 0.69444, 0, 0, 0.66759],
    105: [0, 0.69326, 0, 0, 0.4048],
    106: [0.19444, 0.69326, 0.0622, 0, 0.47083],
    107: [0, 0.69444, 0.01852, 0, 0.6037],
    108: [0, 0.69444, 88e-4, 0, 0.34815],
    109: [0, 0.44444, 0, 0, 1.0324],
    110: [0, 0.44444, 0, 0, 0.71296],
    111: [0, 0.44444, 0, 0, 0.58472],
    112: [0.19444, 0.44444, 0, 0, 0.60092],
    113: [0.19444, 0.44444, 0.03704, 0, 0.54213],
    114: [0, 0.44444, 0.03194, 0, 0.5287],
    115: [0, 0.44444, 0, 0, 0.53125],
    116: [0, 0.63492, 0, 0, 0.41528],
    117: [0, 0.44444, 0, 0, 0.68102],
    118: [0, 0.44444, 0.03704, 0, 0.56666],
    119: [0, 0.44444, 0.02778, 0, 0.83148],
    120: [0, 0.44444, 0, 0, 0.65903],
    121: [0.19444, 0.44444, 0.03704, 0, 0.59028],
    122: [0, 0.44444, 0.04213, 0, 0.55509],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68611, 0.15972, 0, 0.65694],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0.03194, 0, 0.86722],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0.07458, 0, 0.84125],
    928: [0, 0.68611, 0.08229, 0, 0.98229],
    931: [0, 0.68611, 0.05451, 0, 0.88507],
    933: [0, 0.68611, 0.15972, 0, 0.67083],
    934: [0, 0.68611, 0, 0, 0.76666],
    936: [0, 0.68611, 0.11653, 0, 0.71402],
    937: [0, 0.68611, 0.04835, 0, 0.8789],
    945: [0, 0.44444, 0, 0, 0.76064],
    946: [0.19444, 0.69444, 0.03403, 0, 0.65972],
    947: [0.19444, 0.44444, 0.06389, 0, 0.59003],
    948: [0, 0.69444, 0.03819, 0, 0.52222],
    949: [0, 0.44444, 0, 0, 0.52882],
    950: [0.19444, 0.69444, 0.06215, 0, 0.50833],
    951: [0.19444, 0.44444, 0.03704, 0, 0.6],
    952: [0, 0.69444, 0.03194, 0, 0.5618],
    953: [0, 0.44444, 0, 0, 0.41204],
    954: [0, 0.44444, 0, 0, 0.66759],
    955: [0, 0.69444, 0, 0, 0.67083],
    956: [0.19444, 0.44444, 0, 0, 0.70787],
    957: [0, 0.44444, 0.06898, 0, 0.57685],
    958: [0.19444, 0.69444, 0.03021, 0, 0.50833],
    959: [0, 0.44444, 0, 0, 0.58472],
    960: [0, 0.44444, 0.03704, 0, 0.68241],
    961: [0.19444, 0.44444, 0, 0, 0.6118],
    962: [0.09722, 0.44444, 0.07917, 0, 0.42361],
    963: [0, 0.44444, 0.03704, 0, 0.68588],
    964: [0, 0.44444, 0.13472, 0, 0.52083],
    965: [0, 0.44444, 0.03704, 0, 0.63055],
    966: [0.19444, 0.44444, 0, 0, 0.74722],
    967: [0.19444, 0.44444, 0, 0, 0.71805],
    968: [0.19444, 0.69444, 0.03704, 0, 0.75833],
    969: [0, 0.44444, 0.03704, 0, 0.71782],
    977: [0, 0.69444, 0, 0, 0.69155],
    981: [0.19444, 0.69444, 0, 0, 0.7125],
    982: [0, 0.44444, 0.03194, 0, 0.975],
    1009: [0.19444, 0.44444, 0, 0, 0.6118],
    1013: [0, 0.44444, 0, 0, 0.48333],
    57649: [0, 0.44444, 0, 0, 0.39352],
    57911: [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.43056, 0, 0, 0.5],
    49: [0, 0.43056, 0, 0, 0.5],
    50: [0, 0.43056, 0, 0, 0.5],
    51: [0.19444, 0.43056, 0, 0, 0.5],
    52: [0.19444, 0.43056, 0, 0, 0.5],
    53: [0.19444, 0.43056, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0.19444, 0.43056, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0.19444, 0.43056, 0, 0, 0.5],
    65: [0, 0.68333, 0, 0.13889, 0.75],
    66: [0, 0.68333, 0.05017, 0.08334, 0.75851],
    67: [0, 0.68333, 0.07153, 0.08334, 0.71472],
    68: [0, 0.68333, 0.02778, 0.05556, 0.82792],
    69: [0, 0.68333, 0.05764, 0.08334, 0.7382],
    70: [0, 0.68333, 0.13889, 0.08334, 0.64306],
    71: [0, 0.68333, 0, 0.08334, 0.78625],
    72: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    73: [0, 0.68333, 0.07847, 0.11111, 0.43958],
    74: [0, 0.68333, 0.09618, 0.16667, 0.55451],
    75: [0, 0.68333, 0.07153, 0.05556, 0.84931],
    76: [0, 0.68333, 0, 0.02778, 0.68056],
    77: [0, 0.68333, 0.10903, 0.08334, 0.97014],
    78: [0, 0.68333, 0.10903, 0.08334, 0.80347],
    79: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    80: [0, 0.68333, 0.13889, 0.08334, 0.64201],
    81: [0.19444, 0.68333, 0, 0.08334, 0.79056],
    82: [0, 0.68333, 773e-5, 0.08334, 0.75929],
    83: [0, 0.68333, 0.05764, 0.08334, 0.6132],
    84: [0, 0.68333, 0.13889, 0.08334, 0.58438],
    85: [0, 0.68333, 0.10903, 0.02778, 0.68278],
    86: [0, 0.68333, 0.22222, 0, 0.58333],
    87: [0, 0.68333, 0.13889, 0, 0.94445],
    88: [0, 0.68333, 0.07847, 0.08334, 0.82847],
    89: [0, 0.68333, 0.22222, 0, 0.58056],
    90: [0, 0.68333, 0.07153, 0.08334, 0.68264],
    97: [0, 0.43056, 0, 0, 0.52859],
    98: [0, 0.69444, 0, 0, 0.42917],
    99: [0, 0.43056, 0, 0.05556, 0.43276],
    100: [0, 0.69444, 0, 0.16667, 0.52049],
    101: [0, 0.43056, 0, 0.05556, 0.46563],
    102: [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    103: [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    104: [0, 0.69444, 0, 0, 0.57616],
    105: [0, 0.65952, 0, 0, 0.34451],
    106: [0.19444, 0.65952, 0.05724, 0, 0.41181],
    107: [0, 0.69444, 0.03148, 0, 0.5206],
    108: [0, 0.69444, 0.01968, 0.08334, 0.29838],
    109: [0, 0.43056, 0, 0, 0.87801],
    110: [0, 0.43056, 0, 0, 0.60023],
    111: [0, 0.43056, 0, 0.05556, 0.48472],
    112: [0.19444, 0.43056, 0, 0.08334, 0.50313],
    113: [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    114: [0, 0.43056, 0.02778, 0.05556, 0.45116],
    115: [0, 0.43056, 0, 0.05556, 0.46875],
    116: [0, 0.61508, 0, 0.08334, 0.36111],
    117: [0, 0.43056, 0, 0.02778, 0.57246],
    118: [0, 0.43056, 0.03588, 0.02778, 0.48472],
    119: [0, 0.43056, 0.02691, 0.08334, 0.71592],
    120: [0, 0.43056, 0, 0.02778, 0.57153],
    121: [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    122: [0, 0.43056, 0.04398, 0.05556, 0.46505],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68333, 0.13889, 0.08334, 0.61528],
    916: [0, 0.68333, 0, 0.16667, 0.83334],
    920: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    923: [0, 0.68333, 0, 0.16667, 0.69445],
    926: [0, 0.68333, 0.07569, 0.08334, 0.74236],
    928: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    931: [0, 0.68333, 0.05764, 0.08334, 0.77986],
    933: [0, 0.68333, 0.13889, 0.05556, 0.58333],
    934: [0, 0.68333, 0, 0.08334, 0.66667],
    936: [0, 0.68333, 0.11, 0.05556, 0.61222],
    937: [0, 0.68333, 0.05017, 0.08334, 0.7724],
    945: [0, 0.43056, 37e-4, 0.02778, 0.6397],
    946: [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    947: [0.19444, 0.43056, 0.05556, 0, 0.51773],
    948: [0, 0.69444, 0.03785, 0.05556, 0.44444],
    949: [0, 0.43056, 0, 0.08334, 0.46632],
    950: [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    951: [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    952: [0, 0.69444, 0.02778, 0.08334, 0.46944],
    953: [0, 0.43056, 0, 0.05556, 0.35394],
    954: [0, 0.43056, 0, 0, 0.57616],
    955: [0, 0.69444, 0, 0, 0.58334],
    956: [0.19444, 0.43056, 0, 0.02778, 0.60255],
    957: [0, 0.43056, 0.06366, 0.02778, 0.49398],
    958: [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    959: [0, 0.43056, 0, 0.05556, 0.48472],
    960: [0, 0.43056, 0.03588, 0, 0.57003],
    961: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    962: [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    963: [0, 0.43056, 0.03588, 0, 0.57141],
    964: [0, 0.43056, 0.1132, 0.02778, 0.43715],
    965: [0, 0.43056, 0.03588, 0.02778, 0.54028],
    966: [0.19444, 0.43056, 0, 0.08334, 0.65417],
    967: [0.19444, 0.43056, 0, 0.05556, 0.62569],
    968: [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    969: [0, 0.43056, 0.03588, 0, 0.62245],
    977: [0, 0.69444, 0, 0.08334, 0.59144],
    981: [0.19444, 0.69444, 0, 0.08334, 0.59583],
    982: [0, 0.43056, 0.02778, 0, 0.82813],
    1009: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    1013: [0, 0.43056, 0, 0.05556, 0.4059],
    57649: [0, 0.43056, 0, 0.02778, 0.32246],
    57911: [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.36667],
    34: [0, 0.69444, 0, 0, 0.55834],
    35: [0.19444, 0.69444, 0, 0, 0.91667],
    36: [0.05556, 0.75, 0, 0, 0.55],
    37: [0.05556, 0.75, 0, 0, 1.02912],
    38: [0, 0.69444, 0, 0, 0.83056],
    39: [0, 0.69444, 0, 0, 0.30556],
    40: [0.25, 0.75, 0, 0, 0.42778],
    41: [0.25, 0.75, 0, 0, 0.42778],
    42: [0, 0.75, 0, 0, 0.55],
    43: [0.11667, 0.61667, 0, 0, 0.85556],
    44: [0.10556, 0.13056, 0, 0, 0.30556],
    45: [0, 0.45833, 0, 0, 0.36667],
    46: [0, 0.13056, 0, 0, 0.30556],
    47: [0.25, 0.75, 0, 0, 0.55],
    48: [0, 0.69444, 0, 0, 0.55],
    49: [0, 0.69444, 0, 0, 0.55],
    50: [0, 0.69444, 0, 0, 0.55],
    51: [0, 0.69444, 0, 0, 0.55],
    52: [0, 0.69444, 0, 0, 0.55],
    53: [0, 0.69444, 0, 0, 0.55],
    54: [0, 0.69444, 0, 0, 0.55],
    55: [0, 0.69444, 0, 0, 0.55],
    56: [0, 0.69444, 0, 0, 0.55],
    57: [0, 0.69444, 0, 0, 0.55],
    58: [0, 0.45833, 0, 0, 0.30556],
    59: [0.10556, 0.45833, 0, 0, 0.30556],
    61: [-0.09375, 0.40625, 0, 0, 0.85556],
    63: [0, 0.69444, 0, 0, 0.51945],
    64: [0, 0.69444, 0, 0, 0.73334],
    65: [0, 0.69444, 0, 0, 0.73334],
    66: [0, 0.69444, 0, 0, 0.73334],
    67: [0, 0.69444, 0, 0, 0.70278],
    68: [0, 0.69444, 0, 0, 0.79445],
    69: [0, 0.69444, 0, 0, 0.64167],
    70: [0, 0.69444, 0, 0, 0.61111],
    71: [0, 0.69444, 0, 0, 0.73334],
    72: [0, 0.69444, 0, 0, 0.79445],
    73: [0, 0.69444, 0, 0, 0.33056],
    74: [0, 0.69444, 0, 0, 0.51945],
    75: [0, 0.69444, 0, 0, 0.76389],
    76: [0, 0.69444, 0, 0, 0.58056],
    77: [0, 0.69444, 0, 0, 0.97778],
    78: [0, 0.69444, 0, 0, 0.79445],
    79: [0, 0.69444, 0, 0, 0.79445],
    80: [0, 0.69444, 0, 0, 0.70278],
    81: [0.10556, 0.69444, 0, 0, 0.79445],
    82: [0, 0.69444, 0, 0, 0.70278],
    83: [0, 0.69444, 0, 0, 0.61111],
    84: [0, 0.69444, 0, 0, 0.73334],
    85: [0, 0.69444, 0, 0, 0.76389],
    86: [0, 0.69444, 0.01528, 0, 0.73334],
    87: [0, 0.69444, 0.01528, 0, 1.03889],
    88: [0, 0.69444, 0, 0, 0.73334],
    89: [0, 0.69444, 0.0275, 0, 0.73334],
    90: [0, 0.69444, 0, 0, 0.67223],
    91: [0.25, 0.75, 0, 0, 0.34306],
    93: [0.25, 0.75, 0, 0, 0.34306],
    94: [0, 0.69444, 0, 0, 0.55],
    95: [0.35, 0.10833, 0.03056, 0, 0.55],
    97: [0, 0.45833, 0, 0, 0.525],
    98: [0, 0.69444, 0, 0, 0.56111],
    99: [0, 0.45833, 0, 0, 0.48889],
    100: [0, 0.69444, 0, 0, 0.56111],
    101: [0, 0.45833, 0, 0, 0.51111],
    102: [0, 0.69444, 0.07639, 0, 0.33611],
    103: [0.19444, 0.45833, 0.01528, 0, 0.55],
    104: [0, 0.69444, 0, 0, 0.56111],
    105: [0, 0.69444, 0, 0, 0.25556],
    106: [0.19444, 0.69444, 0, 0, 0.28611],
    107: [0, 0.69444, 0, 0, 0.53056],
    108: [0, 0.69444, 0, 0, 0.25556],
    109: [0, 0.45833, 0, 0, 0.86667],
    110: [0, 0.45833, 0, 0, 0.56111],
    111: [0, 0.45833, 0, 0, 0.55],
    112: [0.19444, 0.45833, 0, 0, 0.56111],
    113: [0.19444, 0.45833, 0, 0, 0.56111],
    114: [0, 0.45833, 0.01528, 0, 0.37222],
    115: [0, 0.45833, 0, 0, 0.42167],
    116: [0, 0.58929, 0, 0, 0.40417],
    117: [0, 0.45833, 0, 0, 0.56111],
    118: [0, 0.45833, 0.01528, 0, 0.5],
    119: [0, 0.45833, 0.01528, 0, 0.74445],
    120: [0, 0.45833, 0, 0, 0.5],
    121: [0.19444, 0.45833, 0.01528, 0, 0.5],
    122: [0, 0.45833, 0, 0, 0.47639],
    126: [0.35, 0.34444, 0, 0, 0.55],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0, 0, 0.55],
    176: [0, 0.69444, 0, 0, 0.73334],
    180: [0, 0.69444, 0, 0, 0.55],
    184: [0.17014, 0, 0, 0, 0.48889],
    305: [0, 0.45833, 0, 0, 0.25556],
    567: [0.19444, 0.45833, 0, 0, 0.28611],
    710: [0, 0.69444, 0, 0, 0.55],
    711: [0, 0.63542, 0, 0, 0.55],
    713: [0, 0.63778, 0, 0, 0.55],
    728: [0, 0.69444, 0, 0, 0.55],
    729: [0, 0.69444, 0, 0, 0.30556],
    730: [0, 0.69444, 0, 0, 0.73334],
    732: [0, 0.69444, 0, 0, 0.55],
    733: [0, 0.69444, 0, 0, 0.55],
    915: [0, 0.69444, 0, 0, 0.58056],
    916: [0, 0.69444, 0, 0, 0.91667],
    920: [0, 0.69444, 0, 0, 0.85556],
    923: [0, 0.69444, 0, 0, 0.67223],
    926: [0, 0.69444, 0, 0, 0.73334],
    928: [0, 0.69444, 0, 0, 0.79445],
    931: [0, 0.69444, 0, 0, 0.79445],
    933: [0, 0.69444, 0, 0, 0.85556],
    934: [0, 0.69444, 0, 0, 0.79445],
    936: [0, 0.69444, 0, 0, 0.85556],
    937: [0, 0.69444, 0, 0, 0.79445],
    8211: [0, 0.45833, 0.03056, 0, 0.55],
    8212: [0, 0.45833, 0.03056, 0, 1.10001],
    8216: [0, 0.69444, 0, 0, 0.30556],
    8217: [0, 0.69444, 0, 0, 0.30556],
    8220: [0, 0.69444, 0, 0, 0.55834],
    8221: [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.05733, 0, 0.31945],
    34: [0, 0.69444, 316e-5, 0, 0.5],
    35: [0.19444, 0.69444, 0.05087, 0, 0.83334],
    36: [0.05556, 0.75, 0.11156, 0, 0.5],
    37: [0.05556, 0.75, 0.03126, 0, 0.83334],
    38: [0, 0.69444, 0.03058, 0, 0.75834],
    39: [0, 0.69444, 0.07816, 0, 0.27778],
    40: [0.25, 0.75, 0.13164, 0, 0.38889],
    41: [0.25, 0.75, 0.02536, 0, 0.38889],
    42: [0, 0.75, 0.11775, 0, 0.5],
    43: [0.08333, 0.58333, 0.02536, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0.01946, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0.13164, 0, 0.5],
    48: [0, 0.65556, 0.11156, 0, 0.5],
    49: [0, 0.65556, 0.11156, 0, 0.5],
    50: [0, 0.65556, 0.11156, 0, 0.5],
    51: [0, 0.65556, 0.11156, 0, 0.5],
    52: [0, 0.65556, 0.11156, 0, 0.5],
    53: [0, 0.65556, 0.11156, 0, 0.5],
    54: [0, 0.65556, 0.11156, 0, 0.5],
    55: [0, 0.65556, 0.11156, 0, 0.5],
    56: [0, 0.65556, 0.11156, 0, 0.5],
    57: [0, 0.65556, 0.11156, 0, 0.5],
    58: [0, 0.44444, 0.02502, 0, 0.27778],
    59: [0.125, 0.44444, 0.02502, 0, 0.27778],
    61: [-0.13, 0.37, 0.05087, 0, 0.77778],
    63: [0, 0.69444, 0.11809, 0, 0.47222],
    64: [0, 0.69444, 0.07555, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0.08293, 0, 0.66667],
    67: [0, 0.69444, 0.11983, 0, 0.63889],
    68: [0, 0.69444, 0.07555, 0, 0.72223],
    69: [0, 0.69444, 0.11983, 0, 0.59722],
    70: [0, 0.69444, 0.13372, 0, 0.56945],
    71: [0, 0.69444, 0.11983, 0, 0.66667],
    72: [0, 0.69444, 0.08094, 0, 0.70834],
    73: [0, 0.69444, 0.13372, 0, 0.27778],
    74: [0, 0.69444, 0.08094, 0, 0.47222],
    75: [0, 0.69444, 0.11983, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0.08094, 0, 0.875],
    78: [0, 0.69444, 0.08094, 0, 0.70834],
    79: [0, 0.69444, 0.07555, 0, 0.73611],
    80: [0, 0.69444, 0.08293, 0, 0.63889],
    81: [0.125, 0.69444, 0.07555, 0, 0.73611],
    82: [0, 0.69444, 0.08293, 0, 0.64584],
    83: [0, 0.69444, 0.09205, 0, 0.55556],
    84: [0, 0.69444, 0.13372, 0, 0.68056],
    85: [0, 0.69444, 0.08094, 0, 0.6875],
    86: [0, 0.69444, 0.1615, 0, 0.66667],
    87: [0, 0.69444, 0.1615, 0, 0.94445],
    88: [0, 0.69444, 0.13372, 0, 0.66667],
    89: [0, 0.69444, 0.17261, 0, 0.66667],
    90: [0, 0.69444, 0.11983, 0, 0.61111],
    91: [0.25, 0.75, 0.15942, 0, 0.28889],
    93: [0.25, 0.75, 0.08719, 0, 0.28889],
    94: [0, 0.69444, 0.0799, 0, 0.5],
    95: [0.35, 0.09444, 0.08616, 0, 0.5],
    97: [0, 0.44444, 981e-5, 0, 0.48056],
    98: [0, 0.69444, 0.03057, 0, 0.51667],
    99: [0, 0.44444, 0.08336, 0, 0.44445],
    100: [0, 0.69444, 0.09483, 0, 0.51667],
    101: [0, 0.44444, 0.06778, 0, 0.44445],
    102: [0, 0.69444, 0.21705, 0, 0.30556],
    103: [0.19444, 0.44444, 0.10836, 0, 0.5],
    104: [0, 0.69444, 0.01778, 0, 0.51667],
    105: [0, 0.67937, 0.09718, 0, 0.23889],
    106: [0.19444, 0.67937, 0.09162, 0, 0.26667],
    107: [0, 0.69444, 0.08336, 0, 0.48889],
    108: [0, 0.69444, 0.09483, 0, 0.23889],
    109: [0, 0.44444, 0.01778, 0, 0.79445],
    110: [0, 0.44444, 0.01778, 0, 0.51667],
    111: [0, 0.44444, 0.06613, 0, 0.5],
    112: [0.19444, 0.44444, 0.0389, 0, 0.51667],
    113: [0.19444, 0.44444, 0.04169, 0, 0.51667],
    114: [0, 0.44444, 0.10836, 0, 0.34167],
    115: [0, 0.44444, 0.0778, 0, 0.38333],
    116: [0, 0.57143, 0.07225, 0, 0.36111],
    117: [0, 0.44444, 0.04169, 0, 0.51667],
    118: [0, 0.44444, 0.10836, 0, 0.46111],
    119: [0, 0.44444, 0.10836, 0, 0.68334],
    120: [0, 0.44444, 0.09169, 0, 0.46111],
    121: [0.19444, 0.44444, 0.10836, 0, 0.46111],
    122: [0, 0.44444, 0.08752, 0, 0.43472],
    126: [0.35, 0.32659, 0.08826, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0.06385, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.73752],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0.04169, 0, 0.23889],
    567: [0.19444, 0.44444, 0.04169, 0, 0.26667],
    710: [0, 0.69444, 0.0799, 0, 0.5],
    711: [0, 0.63194, 0.08432, 0, 0.5],
    713: [0, 0.60889, 0.08776, 0, 0.5],
    714: [0, 0.69444, 0.09205, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0.09483, 0, 0.5],
    729: [0, 0.67937, 0.07774, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.73752],
    732: [0, 0.67659, 0.08826, 0, 0.5],
    733: [0, 0.69444, 0.09205, 0, 0.5],
    915: [0, 0.69444, 0.13372, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0.07555, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0.12816, 0, 0.66667],
    928: [0, 0.69444, 0.08094, 0, 0.70834],
    931: [0, 0.69444, 0.11983, 0, 0.72222],
    933: [0, 0.69444, 0.09031, 0, 0.77778],
    934: [0, 0.69444, 0.04603, 0, 0.72222],
    936: [0, 0.69444, 0.09031, 0, 0.77778],
    937: [0, 0.69444, 0.08293, 0, 0.72222],
    8211: [0, 0.44444, 0.08616, 0, 0.5],
    8212: [0, 0.44444, 0.08616, 0, 1],
    8216: [0, 0.69444, 0.07816, 0, 0.27778],
    8217: [0, 0.69444, 0.07816, 0, 0.27778],
    8220: [0, 0.69444, 0.14205, 0, 0.5],
    8221: [0, 0.69444, 316e-5, 0, 0.5]
  },
  "SansSerif-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.31945],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.75834],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.65556, 0, 0, 0.5],
    49: [0, 0.65556, 0, 0, 0.5],
    50: [0, 0.65556, 0, 0, 0.5],
    51: [0, 0.65556, 0, 0, 0.5],
    52: [0, 0.65556, 0, 0, 0.5],
    53: [0, 0.65556, 0, 0, 0.5],
    54: [0, 0.65556, 0, 0, 0.5],
    55: [0, 0.65556, 0, 0, 0.5],
    56: [0, 0.65556, 0, 0, 0.5],
    57: [0, 0.65556, 0, 0, 0.5],
    58: [0, 0.44444, 0, 0, 0.27778],
    59: [0.125, 0.44444, 0, 0, 0.27778],
    61: [-0.13, 0.37, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0, 0, 0.66667],
    67: [0, 0.69444, 0, 0, 0.63889],
    68: [0, 0.69444, 0, 0, 0.72223],
    69: [0, 0.69444, 0, 0, 0.59722],
    70: [0, 0.69444, 0, 0, 0.56945],
    71: [0, 0.69444, 0, 0, 0.66667],
    72: [0, 0.69444, 0, 0, 0.70834],
    73: [0, 0.69444, 0, 0, 0.27778],
    74: [0, 0.69444, 0, 0, 0.47222],
    75: [0, 0.69444, 0, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0, 0, 0.875],
    78: [0, 0.69444, 0, 0, 0.70834],
    79: [0, 0.69444, 0, 0, 0.73611],
    80: [0, 0.69444, 0, 0, 0.63889],
    81: [0.125, 0.69444, 0, 0, 0.73611],
    82: [0, 0.69444, 0, 0, 0.64584],
    83: [0, 0.69444, 0, 0, 0.55556],
    84: [0, 0.69444, 0, 0, 0.68056],
    85: [0, 0.69444, 0, 0, 0.6875],
    86: [0, 0.69444, 0.01389, 0, 0.66667],
    87: [0, 0.69444, 0.01389, 0, 0.94445],
    88: [0, 0.69444, 0, 0, 0.66667],
    89: [0, 0.69444, 0.025, 0, 0.66667],
    90: [0, 0.69444, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.28889],
    93: [0.25, 0.75, 0, 0, 0.28889],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.35, 0.09444, 0.02778, 0, 0.5],
    97: [0, 0.44444, 0, 0, 0.48056],
    98: [0, 0.69444, 0, 0, 0.51667],
    99: [0, 0.44444, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.51667],
    101: [0, 0.44444, 0, 0, 0.44445],
    102: [0, 0.69444, 0.06944, 0, 0.30556],
    103: [0.19444, 0.44444, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.51667],
    105: [0, 0.67937, 0, 0, 0.23889],
    106: [0.19444, 0.67937, 0, 0, 0.26667],
    107: [0, 0.69444, 0, 0, 0.48889],
    108: [0, 0.69444, 0, 0, 0.23889],
    109: [0, 0.44444, 0, 0, 0.79445],
    110: [0, 0.44444, 0, 0, 0.51667],
    111: [0, 0.44444, 0, 0, 0.5],
    112: [0.19444, 0.44444, 0, 0, 0.51667],
    113: [0.19444, 0.44444, 0, 0, 0.51667],
    114: [0, 0.44444, 0.01389, 0, 0.34167],
    115: [0, 0.44444, 0, 0, 0.38333],
    116: [0, 0.57143, 0, 0, 0.36111],
    117: [0, 0.44444, 0, 0, 0.51667],
    118: [0, 0.44444, 0.01389, 0, 0.46111],
    119: [0, 0.44444, 0.01389, 0, 0.68334],
    120: [0, 0.44444, 0, 0, 0.46111],
    121: [0.19444, 0.44444, 0.01389, 0, 0.46111],
    122: [0, 0.44444, 0, 0, 0.43472],
    126: [0.35, 0.32659, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.66667],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0, 0, 0.23889],
    567: [0.19444, 0.44444, 0, 0, 0.26667],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.63194, 0, 0, 0.5],
    713: [0, 0.60889, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.67937, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.66667],
    732: [0, 0.67659, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.69444, 0, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0, 0, 0.66667],
    928: [0, 0.69444, 0, 0, 0.70834],
    931: [0, 0.69444, 0, 0, 0.72222],
    933: [0, 0.69444, 0, 0, 0.77778],
    934: [0, 0.69444, 0, 0, 0.72222],
    936: [0, 0.69444, 0, 0, 0.77778],
    937: [0, 0.69444, 0, 0, 0.72222],
    8211: [0, 0.44444, 0.02778, 0, 0.5],
    8212: [0, 0.44444, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.7, 0.22925, 0, 0.80253],
    66: [0, 0.7, 0.04087, 0, 0.90757],
    67: [0, 0.7, 0.1689, 0, 0.66619],
    68: [0, 0.7, 0.09371, 0, 0.77443],
    69: [0, 0.7, 0.18583, 0, 0.56162],
    70: [0, 0.7, 0.13634, 0, 0.89544],
    71: [0, 0.7, 0.17322, 0, 0.60961],
    72: [0, 0.7, 0.29694, 0, 0.96919],
    73: [0, 0.7, 0.19189, 0, 0.80907],
    74: [0.27778, 0.7, 0.19189, 0, 1.05159],
    75: [0, 0.7, 0.31259, 0, 0.91364],
    76: [0, 0.7, 0.19189, 0, 0.87373],
    77: [0, 0.7, 0.15981, 0, 1.08031],
    78: [0, 0.7, 0.3525, 0, 0.9015],
    79: [0, 0.7, 0.08078, 0, 0.73787],
    80: [0, 0.7, 0.08078, 0, 1.01262],
    81: [0, 0.7, 0.03305, 0, 0.88282],
    82: [0, 0.7, 0.06259, 0, 0.85],
    83: [0, 0.7, 0.19189, 0, 0.86767],
    84: [0, 0.7, 0.29087, 0, 0.74697],
    85: [0, 0.7, 0.25815, 0, 0.79996],
    86: [0, 0.7, 0.27523, 0, 0.62204],
    87: [0, 0.7, 0.27523, 0, 0.80532],
    88: [0, 0.7, 0.26006, 0, 0.94445],
    89: [0, 0.7, 0.2939, 0, 0.70961],
    90: [0, 0.7, 0.24037, 0, 0.8212],
    160: [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.35001, 0.85, 0, 0, 0.45834],
    41: [0.35001, 0.85, 0, 0, 0.45834],
    47: [0.35001, 0.85, 0, 0, 0.57778],
    91: [0.35001, 0.85, 0, 0, 0.41667],
    92: [0.35001, 0.85, 0, 0, 0.57778],
    93: [0.35001, 0.85, 0, 0, 0.41667],
    123: [0.35001, 0.85, 0, 0, 0.58334],
    125: [0.35001, 0.85, 0, 0, 0.58334],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.72222, 0, 0, 0.55556],
    732: [0, 0.72222, 0, 0, 0.55556],
    770: [0, 0.72222, 0, 0, 0.55556],
    771: [0, 0.72222, 0, 0, 0.55556],
    8214: [-99e-5, 0.601, 0, 0, 0.77778],
    8593: [1e-5, 0.6, 0, 0, 0.66667],
    8595: [1e-5, 0.6, 0, 0, 0.66667],
    8657: [1e-5, 0.6, 0, 0, 0.77778],
    8659: [1e-5, 0.6, 0, 0, 0.77778],
    8719: [0.25001, 0.75, 0, 0, 0.94445],
    8720: [0.25001, 0.75, 0, 0, 0.94445],
    8721: [0.25001, 0.75, 0, 0, 1.05556],
    8730: [0.35001, 0.85, 0, 0, 1],
    8739: [-599e-5, 0.606, 0, 0, 0.33333],
    8741: [-599e-5, 0.606, 0, 0, 0.55556],
    8747: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8748: [0.306, 0.805, 0.19445, 0, 0.47222],
    8749: [0.306, 0.805, 0.19445, 0, 0.47222],
    8750: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8896: [0.25001, 0.75, 0, 0, 0.83334],
    8897: [0.25001, 0.75, 0, 0, 0.83334],
    8898: [0.25001, 0.75, 0, 0, 0.83334],
    8899: [0.25001, 0.75, 0, 0, 0.83334],
    8968: [0.35001, 0.85, 0, 0, 0.47222],
    8969: [0.35001, 0.85, 0, 0, 0.47222],
    8970: [0.35001, 0.85, 0, 0, 0.47222],
    8971: [0.35001, 0.85, 0, 0, 0.47222],
    9168: [-99e-5, 0.601, 0, 0, 0.66667],
    10216: [0.35001, 0.85, 0, 0, 0.47222],
    10217: [0.35001, 0.85, 0, 0, 0.47222],
    10752: [0.25001, 0.75, 0, 0, 1.11111],
    10753: [0.25001, 0.75, 0, 0, 1.11111],
    10754: [0.25001, 0.75, 0, 0, 1.11111],
    10756: [0.25001, 0.75, 0, 0, 0.83334],
    10758: [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.65002, 1.15, 0, 0, 0.59722],
    41: [0.65002, 1.15, 0, 0, 0.59722],
    47: [0.65002, 1.15, 0, 0, 0.81111],
    91: [0.65002, 1.15, 0, 0, 0.47222],
    92: [0.65002, 1.15, 0, 0, 0.81111],
    93: [0.65002, 1.15, 0, 0, 0.47222],
    123: [0.65002, 1.15, 0, 0, 0.66667],
    125: [0.65002, 1.15, 0, 0, 0.66667],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1],
    732: [0, 0.75, 0, 0, 1],
    770: [0, 0.75, 0, 0, 1],
    771: [0, 0.75, 0, 0, 1],
    8719: [0.55001, 1.05, 0, 0, 1.27778],
    8720: [0.55001, 1.05, 0, 0, 1.27778],
    8721: [0.55001, 1.05, 0, 0, 1.44445],
    8730: [0.65002, 1.15, 0, 0, 1],
    8747: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8748: [0.862, 1.36, 0.44445, 0, 0.55556],
    8749: [0.862, 1.36, 0.44445, 0, 0.55556],
    8750: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8896: [0.55001, 1.05, 0, 0, 1.11111],
    8897: [0.55001, 1.05, 0, 0, 1.11111],
    8898: [0.55001, 1.05, 0, 0, 1.11111],
    8899: [0.55001, 1.05, 0, 0, 1.11111],
    8968: [0.65002, 1.15, 0, 0, 0.52778],
    8969: [0.65002, 1.15, 0, 0, 0.52778],
    8970: [0.65002, 1.15, 0, 0, 0.52778],
    8971: [0.65002, 1.15, 0, 0, 0.52778],
    10216: [0.65002, 1.15, 0, 0, 0.61111],
    10217: [0.65002, 1.15, 0, 0, 0.61111],
    10752: [0.55001, 1.05, 0, 0, 1.51112],
    10753: [0.55001, 1.05, 0, 0, 1.51112],
    10754: [0.55001, 1.05, 0, 0, 1.51112],
    10756: [0.55001, 1.05, 0, 0, 1.11111],
    10758: [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.95003, 1.45, 0, 0, 0.73611],
    41: [0.95003, 1.45, 0, 0, 0.73611],
    47: [0.95003, 1.45, 0, 0, 1.04445],
    91: [0.95003, 1.45, 0, 0, 0.52778],
    92: [0.95003, 1.45, 0, 0, 1.04445],
    93: [0.95003, 1.45, 0, 0, 0.52778],
    123: [0.95003, 1.45, 0, 0, 0.75],
    125: [0.95003, 1.45, 0, 0, 0.75],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1.44445],
    732: [0, 0.75, 0, 0, 1.44445],
    770: [0, 0.75, 0, 0, 1.44445],
    771: [0, 0.75, 0, 0, 1.44445],
    8730: [0.95003, 1.45, 0, 0, 1],
    8968: [0.95003, 1.45, 0, 0, 0.58334],
    8969: [0.95003, 1.45, 0, 0, 0.58334],
    8970: [0.95003, 1.45, 0, 0, 0.58334],
    8971: [0.95003, 1.45, 0, 0, 0.58334],
    10216: [0.95003, 1.45, 0, 0, 0.75],
    10217: [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [1.25003, 1.75, 0, 0, 0.79167],
    41: [1.25003, 1.75, 0, 0, 0.79167],
    47: [1.25003, 1.75, 0, 0, 1.27778],
    91: [1.25003, 1.75, 0, 0, 0.58334],
    92: [1.25003, 1.75, 0, 0, 1.27778],
    93: [1.25003, 1.75, 0, 0, 0.58334],
    123: [1.25003, 1.75, 0, 0, 0.80556],
    125: [1.25003, 1.75, 0, 0, 0.80556],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.825, 0, 0, 1.8889],
    732: [0, 0.825, 0, 0, 1.8889],
    770: [0, 0.825, 0, 0, 1.8889],
    771: [0, 0.825, 0, 0, 1.8889],
    8730: [1.25003, 1.75, 0, 0, 1],
    8968: [1.25003, 1.75, 0, 0, 0.63889],
    8969: [1.25003, 1.75, 0, 0, 0.63889],
    8970: [1.25003, 1.75, 0, 0, 0.63889],
    8971: [1.25003, 1.75, 0, 0, 0.63889],
    9115: [0.64502, 1.155, 0, 0, 0.875],
    9116: [1e-5, 0.6, 0, 0, 0.875],
    9117: [0.64502, 1.155, 0, 0, 0.875],
    9118: [0.64502, 1.155, 0, 0, 0.875],
    9119: [1e-5, 0.6, 0, 0, 0.875],
    9120: [0.64502, 1.155, 0, 0, 0.875],
    9121: [0.64502, 1.155, 0, 0, 0.66667],
    9122: [-99e-5, 0.601, 0, 0, 0.66667],
    9123: [0.64502, 1.155, 0, 0, 0.66667],
    9124: [0.64502, 1.155, 0, 0, 0.66667],
    9125: [-99e-5, 0.601, 0, 0, 0.66667],
    9126: [0.64502, 1.155, 0, 0, 0.66667],
    9127: [1e-5, 0.9, 0, 0, 0.88889],
    9128: [0.65002, 1.15, 0, 0, 0.88889],
    9129: [0.90001, 0, 0, 0, 0.88889],
    9130: [0, 0.3, 0, 0, 0.88889],
    9131: [1e-5, 0.9, 0, 0, 0.88889],
    9132: [0.65002, 1.15, 0, 0, 0.88889],
    9133: [0.90001, 0, 0, 0, 0.88889],
    9143: [0.88502, 0.915, 0, 0, 1.05556],
    10216: [1.25003, 1.75, 0, 0, 0.80556],
    10217: [1.25003, 1.75, 0, 0, 0.80556],
    57344: [-499e-5, 0.605, 0, 0, 1.05556],
    57345: [-499e-5, 0.605, 0, 0, 1.05556],
    57680: [0, 0.12, 0, 0, 0.45],
    57681: [0, 0.12, 0, 0, 0.45],
    57682: [0, 0.12, 0, 0, 0.45],
    57683: [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    32: [0, 0, 0, 0, 0.525],
    33: [0, 0.61111, 0, 0, 0.525],
    34: [0, 0.61111, 0, 0, 0.525],
    35: [0, 0.61111, 0, 0, 0.525],
    36: [0.08333, 0.69444, 0, 0, 0.525],
    37: [0.08333, 0.69444, 0, 0, 0.525],
    38: [0, 0.61111, 0, 0, 0.525],
    39: [0, 0.61111, 0, 0, 0.525],
    40: [0.08333, 0.69444, 0, 0, 0.525],
    41: [0.08333, 0.69444, 0, 0, 0.525],
    42: [0, 0.52083, 0, 0, 0.525],
    43: [-0.08056, 0.53055, 0, 0, 0.525],
    44: [0.13889, 0.125, 0, 0, 0.525],
    45: [-0.08056, 0.53055, 0, 0, 0.525],
    46: [0, 0.125, 0, 0, 0.525],
    47: [0.08333, 0.69444, 0, 0, 0.525],
    48: [0, 0.61111, 0, 0, 0.525],
    49: [0, 0.61111, 0, 0, 0.525],
    50: [0, 0.61111, 0, 0, 0.525],
    51: [0, 0.61111, 0, 0, 0.525],
    52: [0, 0.61111, 0, 0, 0.525],
    53: [0, 0.61111, 0, 0, 0.525],
    54: [0, 0.61111, 0, 0, 0.525],
    55: [0, 0.61111, 0, 0, 0.525],
    56: [0, 0.61111, 0, 0, 0.525],
    57: [0, 0.61111, 0, 0, 0.525],
    58: [0, 0.43056, 0, 0, 0.525],
    59: [0.13889, 0.43056, 0, 0, 0.525],
    60: [-0.05556, 0.55556, 0, 0, 0.525],
    61: [-0.19549, 0.41562, 0, 0, 0.525],
    62: [-0.05556, 0.55556, 0, 0, 0.525],
    63: [0, 0.61111, 0, 0, 0.525],
    64: [0, 0.61111, 0, 0, 0.525],
    65: [0, 0.61111, 0, 0, 0.525],
    66: [0, 0.61111, 0, 0, 0.525],
    67: [0, 0.61111, 0, 0, 0.525],
    68: [0, 0.61111, 0, 0, 0.525],
    69: [0, 0.61111, 0, 0, 0.525],
    70: [0, 0.61111, 0, 0, 0.525],
    71: [0, 0.61111, 0, 0, 0.525],
    72: [0, 0.61111, 0, 0, 0.525],
    73: [0, 0.61111, 0, 0, 0.525],
    74: [0, 0.61111, 0, 0, 0.525],
    75: [0, 0.61111, 0, 0, 0.525],
    76: [0, 0.61111, 0, 0, 0.525],
    77: [0, 0.61111, 0, 0, 0.525],
    78: [0, 0.61111, 0, 0, 0.525],
    79: [0, 0.61111, 0, 0, 0.525],
    80: [0, 0.61111, 0, 0, 0.525],
    81: [0.13889, 0.61111, 0, 0, 0.525],
    82: [0, 0.61111, 0, 0, 0.525],
    83: [0, 0.61111, 0, 0, 0.525],
    84: [0, 0.61111, 0, 0, 0.525],
    85: [0, 0.61111, 0, 0, 0.525],
    86: [0, 0.61111, 0, 0, 0.525],
    87: [0, 0.61111, 0, 0, 0.525],
    88: [0, 0.61111, 0, 0, 0.525],
    89: [0, 0.61111, 0, 0, 0.525],
    90: [0, 0.61111, 0, 0, 0.525],
    91: [0.08333, 0.69444, 0, 0, 0.525],
    92: [0.08333, 0.69444, 0, 0, 0.525],
    93: [0.08333, 0.69444, 0, 0, 0.525],
    94: [0, 0.61111, 0, 0, 0.525],
    95: [0.09514, 0, 0, 0, 0.525],
    96: [0, 0.61111, 0, 0, 0.525],
    97: [0, 0.43056, 0, 0, 0.525],
    98: [0, 0.61111, 0, 0, 0.525],
    99: [0, 0.43056, 0, 0, 0.525],
    100: [0, 0.61111, 0, 0, 0.525],
    101: [0, 0.43056, 0, 0, 0.525],
    102: [0, 0.61111, 0, 0, 0.525],
    103: [0.22222, 0.43056, 0, 0, 0.525],
    104: [0, 0.61111, 0, 0, 0.525],
    105: [0, 0.61111, 0, 0, 0.525],
    106: [0.22222, 0.61111, 0, 0, 0.525],
    107: [0, 0.61111, 0, 0, 0.525],
    108: [0, 0.61111, 0, 0, 0.525],
    109: [0, 0.43056, 0, 0, 0.525],
    110: [0, 0.43056, 0, 0, 0.525],
    111: [0, 0.43056, 0, 0, 0.525],
    112: [0.22222, 0.43056, 0, 0, 0.525],
    113: [0.22222, 0.43056, 0, 0, 0.525],
    114: [0, 0.43056, 0, 0, 0.525],
    115: [0, 0.43056, 0, 0, 0.525],
    116: [0, 0.55358, 0, 0, 0.525],
    117: [0, 0.43056, 0, 0, 0.525],
    118: [0, 0.43056, 0, 0, 0.525],
    119: [0, 0.43056, 0, 0, 0.525],
    120: [0, 0.43056, 0, 0, 0.525],
    121: [0.22222, 0.43056, 0, 0, 0.525],
    122: [0, 0.43056, 0, 0, 0.525],
    123: [0.08333, 0.69444, 0, 0, 0.525],
    124: [0.08333, 0.69444, 0, 0, 0.525],
    125: [0.08333, 0.69444, 0, 0, 0.525],
    126: [0, 0.61111, 0, 0, 0.525],
    127: [0, 0.61111, 0, 0, 0.525],
    160: [0, 0, 0, 0, 0.525],
    176: [0, 0.61111, 0, 0, 0.525],
    184: [0.19445, 0, 0, 0, 0.525],
    305: [0, 0.43056, 0, 0, 0.525],
    567: [0.22222, 0.43056, 0, 0, 0.525],
    711: [0, 0.56597, 0, 0, 0.525],
    713: [0, 0.56555, 0, 0, 0.525],
    714: [0, 0.61111, 0, 0, 0.525],
    715: [0, 0.61111, 0, 0, 0.525],
    728: [0, 0.61111, 0, 0, 0.525],
    730: [0, 0.61111, 0, 0, 0.525],
    770: [0, 0.61111, 0, 0, 0.525],
    771: [0, 0.61111, 0, 0, 0.525],
    776: [0, 0.61111, 0, 0, 0.525],
    915: [0, 0.61111, 0, 0, 0.525],
    916: [0, 0.61111, 0, 0, 0.525],
    920: [0, 0.61111, 0, 0, 0.525],
    923: [0, 0.61111, 0, 0, 0.525],
    926: [0, 0.61111, 0, 0, 0.525],
    928: [0, 0.61111, 0, 0, 0.525],
    931: [0, 0.61111, 0, 0, 0.525],
    933: [0, 0.61111, 0, 0, 0.525],
    934: [0, 0.61111, 0, 0, 0.525],
    936: [0, 0.61111, 0, 0, 0.525],
    937: [0, 0.61111, 0, 0, 0.525],
    8216: [0, 0.61111, 0, 0, 0.525],
    8217: [0, 0.61111, 0, 0, 0.525],
    8242: [0, 0.61111, 0, 0, 0.525],
    9251: [0.11111, 0.21944, 0, 0, 0.525]
  }
}, sigmasAndXis = {
  slant: [0.25, 0.25, 0.25],
  // sigma1
  space: [0, 0, 0],
  // sigma2
  stretch: [0, 0, 0],
  // sigma3
  shrink: [0, 0, 0],
  // sigma4
  xHeight: [0.431, 0.431, 0.431],
  // sigma5
  quad: [1, 1.171, 1.472],
  // sigma6
  extraSpace: [0, 0, 0],
  // sigma7
  num1: [0.677, 0.732, 0.925],
  // sigma8
  num2: [0.394, 0.384, 0.387],
  // sigma9
  num3: [0.444, 0.471, 0.504],
  // sigma10
  denom1: [0.686, 0.752, 1.025],
  // sigma11
  denom2: [0.345, 0.344, 0.532],
  // sigma12
  sup1: [0.413, 0.503, 0.504],
  // sigma13
  sup2: [0.363, 0.431, 0.404],
  // sigma14
  sup3: [0.289, 0.286, 0.294],
  // sigma15
  sub1: [0.15, 0.143, 0.2],
  // sigma16
  sub2: [0.247, 0.286, 0.4],
  // sigma17
  supDrop: [0.386, 0.353, 0.494],
  // sigma18
  subDrop: [0.05, 0.071, 0.1],
  // sigma19
  delim1: [2.39, 1.7, 1.98],
  // sigma20
  delim2: [1.01, 1.157, 1.42],
  // sigma21
  axisHeight: [0.25, 0.25, 0.25],
  // sigma22
  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
  // they correspond to the font parameters of the extension fonts (family 3).
  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
  // match cmex7, we'd use cmex7.tfm values for script and scriptscript
  // values.
  defaultRuleThickness: [0.04, 0.049, 0.049],
  // xi8; cmex7: 0.049
  bigOpSpacing1: [0.111, 0.111, 0.111],
  // xi9
  bigOpSpacing2: [0.166, 0.166, 0.166],
  // xi10
  bigOpSpacing3: [0.2, 0.2, 0.2],
  // xi11
  bigOpSpacing4: [0.6, 0.611, 0.611],
  // xi12; cmex7: 0.611
  bigOpSpacing5: [0.1, 0.143, 0.143],
  // xi13; cmex7: 0.143
  // The \sqrt rule width is taken from the height of the surd character.
  // Since we use the same font at all sizes, this thickness doesn't scale.
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  // This value determines how large a pt is, for metrics which are defined
  // in terms of pts.
  // This value is also used in katex.scss; if you change it make sure the
  // values match.
  ptPerEm: [10, 10, 10],
  // The space between adjacent `|` columns in an array definition. From
  // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
  doubleRuleSep: [0.2, 0.2, 0.2],
  // The width of separator lines in {array} environments. From
  // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
  arrayRuleWidth: [0.04, 0.04, 0.04],
  // Two values from LaTeX source2e:
  fboxsep: [0.3, 0.3, 0.3],
  //        3 pt / ptPerEm
  fboxrule: [0.04, 0.04, 0.04]
  // 0.4 pt / ptPerEm
}, extraCharacterMap = {
  // Latin-1
  : "A",
  : "D",
  : "o",
  : "a",
  : "d",
  : "o",
  // Cyrillic
  : "A",
  : "B",
  : "B",
  : "F",
  : "A",
  : "E",
  : "K",
  : "3",
  : "N",
  : "N",
  : "K",
  : "N",
  : "M",
  : "H",
  : "O",
  : "N",
  : "P",
  : "C",
  : "T",
  : "y",
  : "O",
  : "X",
  : "U",
  : "h",
  : "W",
  : "W",
  : "B",
  : "X",
  : "B",
  : "3",
  : "X",
  : "R",
  : "a",
  : "b",
  : "a",
  : "r",
  : "y",
  : "e",
  : "m",
  : "e",
  : "n",
  : "n",
  : "n",
  : "n",
  : "m",
  : "n",
  : "o",
  : "n",
  : "p",
  : "c",
  : "o",
  : "y",
  : "b",
  : "x",
  : "n",
  : "n",
  : "w",
  : "w",
  : "a",
  : "m",
  : "a",
  : "e",
  : "m",
  : "r"
};
function getCharacterMetrics(e, t, r) {
  if (!fontMetricsData[t])
    throw new Error("Font metrics not found for font: " + t + ".");
  var a = e.charCodeAt(0), o = fontMetricsData[t][a];
  if (!o && e[0] in extraCharacterMap && (a = extraCharacterMap[e[0]].charCodeAt(0), o = fontMetricsData[t][a]), !o && r === "text" && supportedCodepoint(a) && (o = fontMetricsData[t][77]), o)
    return {
      depth: o[0],
      height: o[1],
      italic: o[2],
      skew: o[3],
      width: o[4]
    };
}
var fontMetricsBySizeIndex = {};
function getGlobalMetrics(e) {
  var t;
  if (e >= 5 ? t = 0 : e >= 3 ? t = 1 : t = 2, !fontMetricsBySizeIndex[t]) {
    var r = fontMetricsBySizeIndex[t] = {
      cssEmPerMu: sigmasAndXis.quad[t] / 18
    };
    for (var a in sigmasAndXis)
      sigmasAndXis.hasOwnProperty(a) && (r[a] = sigmasAndXis[a][t]);
  }
  return fontMetricsBySizeIndex[t];
}
var sizeStyleMap = [
  // Each element contains [textsize, scriptsize, scriptscriptsize].
  // The size mappings are taken from TeX with \normalsize=10pt.
  [1, 1, 1],
  // size1: [5, 5, 5]              \tiny
  [2, 1, 1],
  // size2: [6, 5, 5]
  [3, 1, 1],
  // size3: [7, 5, 5]              \scriptsize
  [4, 2, 1],
  // size4: [8, 6, 5]              \footnotesize
  [5, 2, 1],
  // size5: [9, 6, 5]              \small
  [6, 3, 1],
  // size6: [10, 7, 5]             \normalsize
  [7, 4, 2],
  // size7: [12, 8, 6]             \large
  [8, 6, 3],
  // size8: [14.4, 10, 7]          \Large
  [9, 7, 6],
  // size9: [17.28, 12, 10]        \LARGE
  [10, 8, 7],
  // size10: [20.74, 14.4, 12]     \huge
  [11, 10, 9]
  // size11: [24.88, 20.74, 17.28] \HUGE
], sizeMultipliers = [
  // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
  // you change size indexes, change that function.
  0.5,
  0.6,
  0.7,
  0.8,
  0.9,
  1,
  1.2,
  1.44,
  1.728,
  2.074,
  2.488
], sizeAtStyle = function e(t, r) {
  return r.size < 2 ? t : sizeStyleMap[t - 1][r.size - 1];
};
class Options {
  // A font family applies to a group of fonts (i.e. SansSerif), while a font
  // represents a specific font (i.e. SansSerif Bold).
  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
  /**
   * The base size index.
   */
  constructor(t) {
    this.style = void 0, this.color = void 0, this.size = void 0, this.textSize = void 0, this.phantom = void 0, this.font = void 0, this.fontFamily = void 0, this.fontWeight = void 0, this.fontShape = void 0, this.sizeMultiplier = void 0, this.maxSize = void 0, this.minRuleThickness = void 0, this._fontMetrics = void 0, this.style = t.style, this.color = t.color, this.size = t.size || Options.BASESIZE, this.textSize = t.textSize || this.size, this.phantom = !!t.phantom, this.font = t.font || "", this.fontFamily = t.fontFamily || "", this.fontWeight = t.fontWeight || "", this.fontShape = t.fontShape || "", this.sizeMultiplier = sizeMultipliers[this.size - 1], this.maxSize = t.maxSize, this.minRuleThickness = t.minRuleThickness, this._fontMetrics = void 0;
  }
  /**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */
  extend(t) {
    var r = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize,
      minRuleThickness: this.minRuleThickness
    };
    for (var a in t)
      t.hasOwnProperty(a) && (r[a] = t[a]);
    return new Options(r);
  }
  /**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */
  havingStyle(t) {
    return this.style === t ? this : this.extend({
      style: t,
      size: sizeAtStyle(this.textSize, t)
    });
  }
  /**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */
  havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  /**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */
  havingSize(t) {
    return this.size === t && this.textSize === t ? this : this.extend({
      style: this.style.text(),
      size: t,
      textSize: t,
      sizeMultiplier: sizeMultipliers[t - 1]
    });
  }
  /**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */
  havingBaseStyle(t) {
    t = t || this.style.text();
    var r = sizeAtStyle(Options.BASESIZE, t);
    return this.size === r && this.textSize === Options.BASESIZE && this.style === t ? this : this.extend({
      style: t,
      size: r
    });
  }
  /**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */
  havingBaseSizing() {
    var t;
    switch (this.style.id) {
      case 4:
      case 5:
        t = 3;
        break;
      case 6:
      case 7:
        t = 1;
        break;
      default:
        t = 6;
    }
    return this.extend({
      style: this.style.text(),
      size: t
    });
  }
  /**
   * Create a new options object with the given color.
   */
  withColor(t) {
    return this.extend({
      color: t
    });
  }
  /**
   * Create a new options object with "phantom" set to true.
   */
  withPhantom() {
    return this.extend({
      phantom: !0
    });
  }
  /**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(t) {
    return this.extend({
      font: t
    });
  }
  /**
   * Create a new options objects with the given fontFamily.
   */
  withTextFontFamily(t) {
    return this.extend({
      fontFamily: t,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontWeight(t) {
    return this.extend({
      fontWeight: t,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontShape(t) {
    return this.extend({
      fontShape: t,
      font: ""
    });
  }
  /**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */
  sizingClasses(t) {
    return t.size !== this.size ? ["sizing", "reset-size" + t.size, "size" + this.size] : [];
  }
  /**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */
  baseSizingClasses() {
    return this.size !== Options.BASESIZE ? ["sizing", "reset-size" + this.size, "size" + Options.BASESIZE] : [];
  }
  /**
   * Return the font metrics for this size.
   */
  fontMetrics() {
    return this._fontMetrics || (this._fontMetrics = getGlobalMetrics(this.size)), this._fontMetrics;
  }
  /**
   * Gets the CSS color of the current options object
   */
  getColor() {
    return this.phantom ? "transparent" : this.color;
  }
}
Options.BASESIZE = 6;
var ptPerUnit = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  pt: 1,
  // TeX point
  mm: 7227 / 2540,
  // millimeter
  cm: 7227 / 254,
  // centimeter
  in: 72.27,
  // inch
  bp: 803 / 800,
  // big (PostScript) points
  pc: 12,
  // pica
  dd: 1238 / 1157,
  // didot
  cc: 14856 / 1157,
  // cicero (12 didot)
  nd: 685 / 642,
  // new didot
  nc: 1370 / 107,
  // new cicero (12 new didot)
  sp: 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  px: 803 / 800
  // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
}, relativeUnit = {
  ex: !0,
  em: !0,
  mu: !0
}, validUnit = function e(t) {
  return typeof t != "string" && (t = t.unit), t in ptPerUnit || t in relativeUnit || t === "ex";
}, calculateSize = function e(t, r) {
  var a;
  if (t.unit in ptPerUnit)
    a = ptPerUnit[t.unit] / r.fontMetrics().ptPerEm / r.sizeMultiplier;
  else if (t.unit === "mu")
    a = r.fontMetrics().cssEmPerMu;
  else {
    var o;
    if (r.style.isTight() ? o = r.havingStyle(r.style.text()) : o = r, t.unit === "ex")
      a = o.fontMetrics().xHeight;
    else if (t.unit === "em")
      a = o.fontMetrics().quad;
    else
      throw new ParseError("Invalid unit: '" + t.unit + "'");
    o !== r && (a *= o.sizeMultiplier / r.sizeMultiplier);
  }
  return Math.min(t.number * a, r.maxSize);
}, makeEm = function e(t) {
  return +t.toFixed(4) + "em";
}, createClass = function e(t) {
  return t.filter((r) => r).join(" ");
}, initNode = function e(t, r, a) {
  if (this.classes = t || [], this.attributes = {}, this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = a || {}, r) {
    r.style.isTight() && this.classes.push("mtight");
    var o = r.getColor();
    o && (this.style.color = o);
  }
}, toNode = function e(t) {
  var r = document.createElement(t);
  r.className = createClass(this.classes);
  for (var a in this.style)
    this.style.hasOwnProperty(a) && (r.style[a] = this.style[a]);
  for (var o in this.attributes)
    this.attributes.hasOwnProperty(o) && r.setAttribute(o, this.attributes[o]);
  for (var u = 0; u < this.children.length; u++)
    r.appendChild(this.children[u].toNode());
  return r;
}, invalidAttributeNameRegex = /[\s"'>/=\x00-\x1f]/, toMarkup = function e(t) {
  var r = "<" + t;
  this.classes.length && (r += ' class="' + utils.escape(createClass(this.classes)) + '"');
  var a = "";
  for (var o in this.style)
    this.style.hasOwnProperty(o) && (a += utils.hyphenate(o) + ":" + this.style[o] + ";");
  a && (r += ' style="' + utils.escape(a) + '"');
  for (var u in this.attributes)
    if (this.attributes.hasOwnProperty(u)) {
      if (invalidAttributeNameRegex.test(u))
        throw new ParseError("Invalid attribute name '" + u + "'");
      r += " " + u + '="' + utils.escape(this.attributes[u]) + '"';
    }
  r += ">";
  for (var c = 0; c < this.children.length; c++)
    r += this.children[c].toMarkup();
  return r += "</" + t + ">", r;
};
class Span {
  constructor(t, r, a, o) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.width = void 0, this.maxFontSize = void 0, this.style = void 0, initNode.call(this, t, a, o), this.children = r || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */
  setAttribute(t, r) {
    this.attributes[t] = r;
  }
  hasClass(t) {
    return utils.contains(this.classes, t);
  }
  toNode() {
    return toNode.call(this, "span");
  }
  toMarkup() {
    return toMarkup.call(this, "span");
  }
}
let Anchor$1 = class {
  constructor(t, r, a, o) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, initNode.call(this, r, o), this.children = a || [], this.setAttribute("href", t);
  }
  setAttribute(t, r) {
    this.attributes[t] = r;
  }
  hasClass(t) {
    return utils.contains(this.classes, t);
  }
  toNode() {
    return toNode.call(this, "a");
  }
  toMarkup() {
    return toMarkup.call(this, "a");
  }
};
class Img {
  constructor(t, r, a) {
    this.src = void 0, this.alt = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.alt = r, this.src = t, this.classes = ["mord"], this.style = a;
  }
  hasClass(t) {
    return utils.contains(this.classes, t);
  }
  toNode() {
    var t = document.createElement("img");
    t.src = this.src, t.alt = this.alt, t.className = "mord";
    for (var r in this.style)
      this.style.hasOwnProperty(r) && (t.style[r] = this.style[r]);
    return t;
  }
  toMarkup() {
    var t = '<img src="' + utils.escape(this.src) + '"' + (' alt="' + utils.escape(this.alt) + '"'), r = "";
    for (var a in this.style)
      this.style.hasOwnProperty(a) && (r += utils.hyphenate(a) + ":" + this.style[a] + ";");
    return r && (t += ' style="' + utils.escape(r) + '"'), t += "'/>", t;
  }
}
var iCombinations = {
  : "",
  : "",
  : "",
  // '': '\u0131\u0304', // enable when we add Extended Latin
  : ""
};
class SymbolNode {
  constructor(t, r, a, o, u, c, d, g) {
    this.text = void 0, this.height = void 0, this.depth = void 0, this.italic = void 0, this.skew = void 0, this.width = void 0, this.maxFontSize = void 0, this.classes = void 0, this.style = void 0, this.text = t, this.height = r || 0, this.depth = a || 0, this.italic = o || 0, this.skew = u || 0, this.width = c || 0, this.classes = d || [], this.style = g || {}, this.maxFontSize = 0;
    var b = scriptFromCodepoint(this.text.charCodeAt(0));
    b && this.classes.push(b + "_fallback"), /[]/.test(this.text) && (this.text = iCombinations[this.text]);
  }
  hasClass(t) {
    return utils.contains(this.classes, t);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */
  toNode() {
    var t = document.createTextNode(this.text), r = null;
    this.italic > 0 && (r = document.createElement("span"), r.style.marginRight = makeEm(this.italic)), this.classes.length > 0 && (r = r || document.createElement("span"), r.className = createClass(this.classes));
    for (var a in this.style)
      this.style.hasOwnProperty(a) && (r = r || document.createElement("span"), r.style[a] = this.style[a]);
    return r ? (r.appendChild(t), r) : t;
  }
  /**
   * Creates markup for a symbol node.
   */
  toMarkup() {
    var t = !1, r = "<span";
    this.classes.length && (t = !0, r += ' class="', r += utils.escape(createClass(this.classes)), r += '"');
    var a = "";
    this.italic > 0 && (a += "margin-right:" + this.italic + "em;");
    for (var o in this.style)
      this.style.hasOwnProperty(o) && (a += utils.hyphenate(o) + ":" + this.style[o] + ";");
    a && (t = !0, r += ' style="' + utils.escape(a) + '"');
    var u = utils.escape(this.text);
    return t ? (r += ">", r += u, r += "</span>", r) : u;
  }
}
class SvgNode {
  constructor(t, r) {
    this.children = void 0, this.attributes = void 0, this.children = t || [], this.attributes = r || {};
  }
  toNode() {
    var t = "http://www.w3.org/2000/svg", r = document.createElementNS(t, "svg");
    for (var a in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, a) && r.setAttribute(a, this.attributes[a]);
    for (var o = 0; o < this.children.length; o++)
      r.appendChild(this.children[o].toNode());
    return r;
  }
  toMarkup() {
    var t = '<svg xmlns="http://www.w3.org/2000/svg"';
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && (t += " " + r + '="' + utils.escape(this.attributes[r]) + '"');
    t += ">";
    for (var a = 0; a < this.children.length; a++)
      t += this.children[a].toMarkup();
    return t += "</svg>", t;
  }
}
class PathNode {
  constructor(t, r) {
    this.pathName = void 0, this.alternate = void 0, this.pathName = t, this.alternate = r;
  }
  toNode() {
    var t = "http://www.w3.org/2000/svg", r = document.createElementNS(t, "path");
    return this.alternate ? r.setAttribute("d", this.alternate) : r.setAttribute("d", path$1[this.pathName]), r;
  }
  toMarkup() {
    return this.alternate ? '<path d="' + utils.escape(this.alternate) + '"/>' : '<path d="' + utils.escape(path$1[this.pathName]) + '"/>';
  }
}
class LineNode {
  constructor(t) {
    this.attributes = void 0, this.attributes = t || {};
  }
  toNode() {
    var t = "http://www.w3.org/2000/svg", r = document.createElementNS(t, "line");
    for (var a in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, a) && r.setAttribute(a, this.attributes[a]);
    return r;
  }
  toMarkup() {
    var t = "<line";
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && (t += " " + r + '="' + utils.escape(this.attributes[r]) + '"');
    return t += "/>", t;
  }
}
function assertSymbolDomNode(e) {
  if (e instanceof SymbolNode)
    return e;
  throw new Error("Expected symbolNode but got " + String(e) + ".");
}
function assertSpan(e) {
  if (e instanceof Span)
    return e;
  throw new Error("Expected span<HtmlDomNode> but got " + String(e) + ".");
}
var ATOMS = {
  bin: 1,
  close: 1,
  inner: 1,
  open: 1,
  punct: 1,
  rel: 1
}, NON_ATOMS = {
  "accent-token": 1,
  mathord: 1,
  "op-token": 1,
  spacing: 1,
  textord: 1
}, symbols = {
  math: {},
  text: {}
};
function defineSymbol(e, t, r, a, o, u) {
  symbols[e][o] = {
    font: t,
    group: r,
    replace: a
  }, u && a && (symbols[e][a] = symbols[e][o]);
}
var math$1 = "math", text$6 = "text", main = "main", ams = "ams", accent = "accent-token", bin = "bin", close = "close", inner = "inner", mathord = "mathord", op = "op-token", open = "open", punct = "punct", rel = "rel", spacing = "spacing", textord = "textord";
defineSymbol(math$1, main, rel, "", "\\equiv", !0);
defineSymbol(math$1, main, rel, "", "\\prec", !0);
defineSymbol(math$1, main, rel, "", "\\succ", !0);
defineSymbol(math$1, main, rel, "", "\\sim", !0);
defineSymbol(math$1, main, rel, "", "\\perp");
defineSymbol(math$1, main, rel, "", "\\preceq", !0);
defineSymbol(math$1, main, rel, "", "\\succeq", !0);
defineSymbol(math$1, main, rel, "", "\\simeq", !0);
defineSymbol(math$1, main, rel, "", "\\mid", !0);
defineSymbol(math$1, main, rel, "", "\\ll", !0);
defineSymbol(math$1, main, rel, "", "\\gg", !0);
defineSymbol(math$1, main, rel, "", "\\asymp", !0);
defineSymbol(math$1, main, rel, "", "\\parallel");
defineSymbol(math$1, main, rel, "", "\\bowtie", !0);
defineSymbol(math$1, main, rel, "", "\\smile", !0);
defineSymbol(math$1, main, rel, "", "\\sqsubseteq", !0);
defineSymbol(math$1, main, rel, "", "\\sqsupseteq", !0);
defineSymbol(math$1, main, rel, "", "\\doteq", !0);
defineSymbol(math$1, main, rel, "", "\\frown", !0);
defineSymbol(math$1, main, rel, "", "\\ni", !0);
defineSymbol(math$1, main, rel, "", "\\propto", !0);
defineSymbol(math$1, main, rel, "", "\\vdash", !0);
defineSymbol(math$1, main, rel, "", "\\dashv", !0);
defineSymbol(math$1, main, rel, "", "\\owns");
defineSymbol(math$1, main, punct, ".", "\\ldotp");
defineSymbol(math$1, main, punct, "", "\\cdotp");
defineSymbol(math$1, main, textord, "#", "\\#");
defineSymbol(text$6, main, textord, "#", "\\#");
defineSymbol(math$1, main, textord, "&", "\\&");
defineSymbol(text$6, main, textord, "&", "\\&");
defineSymbol(math$1, main, textord, "", "\\aleph", !0);
defineSymbol(math$1, main, textord, "", "\\forall", !0);
defineSymbol(math$1, main, textord, "", "\\hbar", !0);
defineSymbol(math$1, main, textord, "", "\\exists", !0);
defineSymbol(math$1, main, textord, "", "\\nabla", !0);
defineSymbol(math$1, main, textord, "", "\\flat", !0);
defineSymbol(math$1, main, textord, "", "\\ell", !0);
defineSymbol(math$1, main, textord, "", "\\natural", !0);
defineSymbol(math$1, main, textord, "", "\\clubsuit", !0);
defineSymbol(math$1, main, textord, "", "\\wp", !0);
defineSymbol(math$1, main, textord, "", "\\sharp", !0);
defineSymbol(math$1, main, textord, "", "\\diamondsuit", !0);
defineSymbol(math$1, main, textord, "", "\\Re", !0);
defineSymbol(math$1, main, textord, "", "\\heartsuit", !0);
defineSymbol(math$1, main, textord, "", "\\Im", !0);
defineSymbol(math$1, main, textord, "", "\\spadesuit", !0);
defineSymbol(math$1, main, textord, "", "\\S", !0);
defineSymbol(text$6, main, textord, "", "\\S");
defineSymbol(math$1, main, textord, "", "\\P", !0);
defineSymbol(text$6, main, textord, "", "\\P");
defineSymbol(math$1, main, textord, "", "\\dag");
defineSymbol(text$6, main, textord, "", "\\dag");
defineSymbol(text$6, main, textord, "", "\\textdagger");
defineSymbol(math$1, main, textord, "", "\\ddag");
defineSymbol(text$6, main, textord, "", "\\ddag");
defineSymbol(text$6, main, textord, "", "\\textdaggerdbl");
defineSymbol(math$1, main, close, "", "\\rmoustache", !0);
defineSymbol(math$1, main, open, "", "\\lmoustache", !0);
defineSymbol(math$1, main, close, "", "\\rgroup", !0);
defineSymbol(math$1, main, open, "", "\\lgroup", !0);
defineSymbol(math$1, main, bin, "", "\\mp", !0);
defineSymbol(math$1, main, bin, "", "\\ominus", !0);
defineSymbol(math$1, main, bin, "", "\\uplus", !0);
defineSymbol(math$1, main, bin, "", "\\sqcap", !0);
defineSymbol(math$1, main, bin, "", "\\ast");
defineSymbol(math$1, main, bin, "", "\\sqcup", !0);
defineSymbol(math$1, main, bin, "", "\\bigcirc", !0);
defineSymbol(math$1, main, bin, "", "\\bullet", !0);
defineSymbol(math$1, main, bin, "", "\\ddagger");
defineSymbol(math$1, main, bin, "", "\\wr", !0);
defineSymbol(math$1, main, bin, "", "\\amalg");
defineSymbol(math$1, main, bin, "&", "\\And");
defineSymbol(math$1, main, rel, "", "\\longleftarrow", !0);
defineSymbol(math$1, main, rel, "", "\\Leftarrow", !0);
defineSymbol(math$1, main, rel, "", "\\Longleftarrow", !0);
defineSymbol(math$1, main, rel, "", "\\longrightarrow", !0);
defineSymbol(math$1, main, rel, "", "\\Rightarrow", !0);
defineSymbol(math$1, main, rel, "", "\\Longrightarrow", !0);
defineSymbol(math$1, main, rel, "", "\\leftrightarrow", !0);
defineSymbol(math$1, main, rel, "", "\\longleftrightarrow", !0);
defineSymbol(math$1, main, rel, "", "\\Leftrightarrow", !0);
defineSymbol(math$1, main, rel, "", "\\Longleftrightarrow", !0);
defineSymbol(math$1, main, rel, "", "\\mapsto", !0);
defineSymbol(math$1, main, rel, "", "\\longmapsto", !0);
defineSymbol(math$1, main, rel, "", "\\nearrow", !0);
defineSymbol(math$1, main, rel, "", "\\hookleftarrow", !0);
defineSymbol(math$1, main, rel, "", "\\hookrightarrow", !0);
defineSymbol(math$1, main, rel, "", "\\searrow", !0);
defineSymbol(math$1, main, rel, "", "\\leftharpoonup", !0);
defineSymbol(math$1, main, rel, "", "\\rightharpoonup", !0);
defineSymbol(math$1, main, rel, "", "\\swarrow", !0);
defineSymbol(math$1, main, rel, "", "\\leftharpoondown", !0);
defineSymbol(math$1, main, rel, "", "\\rightharpoondown", !0);
defineSymbol(math$1, main, rel, "", "\\nwarrow", !0);
defineSymbol(math$1, main, rel, "", "\\rightleftharpoons", !0);
defineSymbol(math$1, ams, rel, "", "\\nless", !0);
defineSymbol(math$1, ams, rel, "", "\\@nleqslant");
defineSymbol(math$1, ams, rel, "", "\\@nleqq");
defineSymbol(math$1, ams, rel, "", "\\lneq", !0);
defineSymbol(math$1, ams, rel, "", "\\lneqq", !0);
defineSymbol(math$1, ams, rel, "", "\\@lvertneqq");
defineSymbol(math$1, ams, rel, "", "\\lnsim", !0);
defineSymbol(math$1, ams, rel, "", "\\lnapprox", !0);
defineSymbol(math$1, ams, rel, "", "\\nprec", !0);
defineSymbol(math$1, ams, rel, "", "\\npreceq", !0);
defineSymbol(math$1, ams, rel, "", "\\precnsim", !0);
defineSymbol(math$1, ams, rel, "", "\\precnapprox", !0);
defineSymbol(math$1, ams, rel, "", "\\nsim", !0);
defineSymbol(math$1, ams, rel, "", "\\@nshortmid");
defineSymbol(math$1, ams, rel, "", "\\nmid", !0);
defineSymbol(math$1, ams, rel, "", "\\nvdash", !0);
defineSymbol(math$1, ams, rel, "", "\\nvDash", !0);
defineSymbol(math$1, ams, rel, "", "\\ntriangleleft");
defineSymbol(math$1, ams, rel, "", "\\ntrianglelefteq", !0);
defineSymbol(math$1, ams, rel, "", "\\subsetneq", !0);
defineSymbol(math$1, ams, rel, "", "\\@varsubsetneq");
defineSymbol(math$1, ams, rel, "", "\\subsetneqq", !0);
defineSymbol(math$1, ams, rel, "", "\\@varsubsetneqq");
defineSymbol(math$1, ams, rel, "", "\\ngtr", !0);
defineSymbol(math$1, ams, rel, "", "\\@ngeqslant");
defineSymbol(math$1, ams, rel, "", "\\@ngeqq");
defineSymbol(math$1, ams, rel, "", "\\gneq", !0);
defineSymbol(math$1, ams, rel, "", "\\gneqq", !0);
defineSymbol(math$1, ams, rel, "", "\\@gvertneqq");
defineSymbol(math$1, ams, rel, "", "\\gnsim", !0);
defineSymbol(math$1, ams, rel, "", "\\gnapprox", !0);
defineSymbol(math$1, ams, rel, "", "\\nsucc", !0);
defineSymbol(math$1, ams, rel, "", "\\nsucceq", !0);
defineSymbol(math$1, ams, rel, "", "\\succnsim", !0);
defineSymbol(math$1, ams, rel, "", "\\succnapprox", !0);
defineSymbol(math$1, ams, rel, "", "\\ncong", !0);
defineSymbol(math$1, ams, rel, "", "\\@nshortparallel");
defineSymbol(math$1, ams, rel, "", "\\nparallel", !0);
defineSymbol(math$1, ams, rel, "", "\\nVDash", !0);
defineSymbol(math$1, ams, rel, "", "\\ntriangleright");
defineSymbol(math$1, ams, rel, "", "\\ntrianglerighteq", !0);
defineSymbol(math$1, ams, rel, "", "\\@nsupseteqq");
defineSymbol(math$1, ams, rel, "", "\\supsetneq", !0);
defineSymbol(math$1, ams, rel, "", "\\@varsupsetneq");
defineSymbol(math$1, ams, rel, "", "\\supsetneqq", !0);
defineSymbol(math$1, ams, rel, "", "\\@varsupsetneqq");
defineSymbol(math$1, ams, rel, "", "\\nVdash", !0);
defineSymbol(math$1, ams, rel, "", "\\precneqq", !0);
defineSymbol(math$1, ams, rel, "", "\\succneqq", !0);
defineSymbol(math$1, ams, rel, "", "\\@nsubseteqq");
defineSymbol(math$1, ams, bin, "", "\\unlhd");
defineSymbol(math$1, ams, bin, "", "\\unrhd");
defineSymbol(math$1, ams, rel, "", "\\nleftarrow", !0);
defineSymbol(math$1, ams, rel, "", "\\nrightarrow", !0);
defineSymbol(math$1, ams, rel, "", "\\nLeftarrow", !0);
defineSymbol(math$1, ams, rel, "", "\\nRightarrow", !0);
defineSymbol(math$1, ams, rel, "", "\\nleftrightarrow", !0);
defineSymbol(math$1, ams, rel, "", "\\nLeftrightarrow", !0);
defineSymbol(math$1, ams, rel, "", "\\vartriangle");
defineSymbol(math$1, ams, textord, "", "\\hslash");
defineSymbol(math$1, ams, textord, "", "\\triangledown");
defineSymbol(math$1, ams, textord, "", "\\lozenge");
defineSymbol(math$1, ams, textord, "", "\\circledS");
defineSymbol(math$1, ams, textord, "", "\\circledR");
defineSymbol(text$6, ams, textord, "", "\\circledR");
defineSymbol(math$1, ams, textord, "", "\\measuredangle", !0);
defineSymbol(math$1, ams, textord, "", "\\nexists");
defineSymbol(math$1, ams, textord, "", "\\mho");
defineSymbol(math$1, ams, textord, "", "\\Finv", !0);
defineSymbol(math$1, ams, textord, "", "\\Game", !0);
defineSymbol(math$1, ams, textord, "", "\\backprime");
defineSymbol(math$1, ams, textord, "", "\\blacktriangle");
defineSymbol(math$1, ams, textord, "", "\\blacktriangledown");
defineSymbol(math$1, ams, textord, "", "\\blacksquare");
defineSymbol(math$1, ams, textord, "", "\\blacklozenge");
defineSymbol(math$1, ams, textord, "", "\\bigstar");
defineSymbol(math$1, ams, textord, "", "\\sphericalangle", !0);
defineSymbol(math$1, ams, textord, "", "\\complement", !0);
defineSymbol(math$1, ams, textord, "", "\\eth", !0);
defineSymbol(text$6, main, textord, "", "");
defineSymbol(math$1, ams, textord, "", "\\diagup");
defineSymbol(math$1, ams, textord, "", "\\diagdown");
defineSymbol(math$1, ams, textord, "", "\\square");
defineSymbol(math$1, ams, textord, "", "\\Box");
defineSymbol(math$1, ams, textord, "", "\\Diamond");
defineSymbol(math$1, ams, textord, "", "\\yen", !0);
defineSymbol(text$6, ams, textord, "", "\\yen", !0);
defineSymbol(math$1, ams, textord, "", "\\checkmark", !0);
defineSymbol(text$6, ams, textord, "", "\\checkmark");
defineSymbol(math$1, ams, textord, "", "\\beth", !0);
defineSymbol(math$1, ams, textord, "", "\\daleth", !0);
defineSymbol(math$1, ams, textord, "", "\\gimel", !0);
defineSymbol(math$1, ams, textord, "", "\\digamma", !0);
defineSymbol(math$1, ams, textord, "", "\\varkappa");
defineSymbol(math$1, ams, open, "", "\\@ulcorner", !0);
defineSymbol(math$1, ams, close, "", "\\@urcorner", !0);
defineSymbol(math$1, ams, open, "", "\\@llcorner", !0);
defineSymbol(math$1, ams, close, "", "\\@lrcorner", !0);
defineSymbol(math$1, ams, rel, "", "\\leqq", !0);
defineSymbol(math$1, ams, rel, "", "\\leqslant", !0);
defineSymbol(math$1, ams, rel, "", "\\eqslantless", !0);
defineSymbol(math$1, ams, rel, "", "\\lesssim", !0);
defineSymbol(math$1, ams, rel, "", "\\lessapprox", !0);
defineSymbol(math$1, ams, rel, "", "\\approxeq", !0);
defineSymbol(math$1, ams, bin, "", "\\lessdot");
defineSymbol(math$1, ams, rel, "", "\\lll", !0);
defineSymbol(math$1, ams, rel, "", "\\lessgtr", !0);
defineSymbol(math$1, ams, rel, "", "\\lesseqgtr", !0);
defineSymbol(math$1, ams, rel, "", "\\lesseqqgtr", !0);
defineSymbol(math$1, ams, rel, "", "\\doteqdot");
defineSymbol(math$1, ams, rel, "", "\\risingdotseq", !0);
defineSymbol(math$1, ams, rel, "", "\\fallingdotseq", !0);
defineSymbol(math$1, ams, rel, "", "\\backsim", !0);
defineSymbol(math$1, ams, rel, "", "\\backsimeq", !0);
defineSymbol(math$1, ams, rel, "", "\\subseteqq", !0);
defineSymbol(math$1, ams, rel, "", "\\Subset", !0);
defineSymbol(math$1, ams, rel, "", "\\sqsubset", !0);
defineSymbol(math$1, ams, rel, "", "\\preccurlyeq", !0);
defineSymbol(math$1, ams, rel, "", "\\curlyeqprec", !0);
defineSymbol(math$1, ams, rel, "", "\\precsim", !0);
defineSymbol(math$1, ams, rel, "", "\\precapprox", !0);
defineSymbol(math$1, ams, rel, "", "\\vartriangleleft");
defineSymbol(math$1, ams, rel, "", "\\trianglelefteq");
defineSymbol(math$1, ams, rel, "", "\\vDash", !0);
defineSymbol(math$1, ams, rel, "", "\\Vvdash", !0);
defineSymbol(math$1, ams, rel, "", "\\smallsmile");
defineSymbol(math$1, ams, rel, "", "\\smallfrown");
defineSymbol(math$1, ams, rel, "", "\\bumpeq", !0);
defineSymbol(math$1, ams, rel, "", "\\Bumpeq", !0);
defineSymbol(math$1, ams, rel, "", "\\geqq", !0);
defineSymbol(math$1, ams, rel, "", "\\geqslant", !0);
defineSymbol(math$1, ams, rel, "", "\\eqslantgtr", !0);
defineSymbol(math$1, ams, rel, "", "\\gtrsim", !0);
defineSymbol(math$1, ams, rel, "", "\\gtrapprox", !0);
defineSymbol(math$1, ams, bin, "", "\\gtrdot");
defineSymbol(math$1, ams, rel, "", "\\ggg", !0);
defineSymbol(math$1, ams, rel, "", "\\gtrless", !0);
defineSymbol(math$1, ams, rel, "", "\\gtreqless", !0);
defineSymbol(math$1, ams, rel, "", "\\gtreqqless", !0);
defineSymbol(math$1, ams, rel, "", "\\eqcirc", !0);
defineSymbol(math$1, ams, rel, "", "\\circeq", !0);
defineSymbol(math$1, ams, rel, "", "\\triangleq", !0);
defineSymbol(math$1, ams, rel, "", "\\thicksim");
defineSymbol(math$1, ams, rel, "", "\\thickapprox");
defineSymbol(math$1, ams, rel, "", "\\supseteqq", !0);
defineSymbol(math$1, ams, rel, "", "\\Supset", !0);
defineSymbol(math$1, ams, rel, "", "\\sqsupset", !0);
defineSymbol(math$1, ams, rel, "", "\\succcurlyeq", !0);
defineSymbol(math$1, ams, rel, "", "\\curlyeqsucc", !0);
defineSymbol(math$1, ams, rel, "", "\\succsim", !0);
defineSymbol(math$1, ams, rel, "", "\\succapprox", !0);
defineSymbol(math$1, ams, rel, "", "\\vartriangleright");
defineSymbol(math$1, ams, rel, "", "\\trianglerighteq");
defineSymbol(math$1, ams, rel, "", "\\Vdash", !0);
defineSymbol(math$1, ams, rel, "", "\\shortmid");
defineSymbol(math$1, ams, rel, "", "\\shortparallel");
defineSymbol(math$1, ams, rel, "", "\\between", !0);
defineSymbol(math$1, ams, rel, "", "\\pitchfork", !0);
defineSymbol(math$1, ams, rel, "", "\\varpropto");
defineSymbol(math$1, ams, rel, "", "\\blacktriangleleft");
defineSymbol(math$1, ams, rel, "", "\\therefore", !0);
defineSymbol(math$1, ams, rel, "", "\\backepsilon");
defineSymbol(math$1, ams, rel, "", "\\blacktriangleright");
defineSymbol(math$1, ams, rel, "", "\\because", !0);
defineSymbol(math$1, ams, rel, "", "\\llless");
defineSymbol(math$1, ams, rel, "", "\\gggtr");
defineSymbol(math$1, ams, bin, "", "\\lhd");
defineSymbol(math$1, ams, bin, "", "\\rhd");
defineSymbol(math$1, ams, rel, "", "\\eqsim", !0);
defineSymbol(math$1, main, rel, "", "\\Join");
defineSymbol(math$1, ams, rel, "", "\\Doteq", !0);
defineSymbol(math$1, ams, bin, "", "\\dotplus", !0);
defineSymbol(math$1, ams, bin, "", "\\smallsetminus");
defineSymbol(math$1, ams, bin, "", "\\Cap", !0);
defineSymbol(math$1, ams, bin, "", "\\Cup", !0);
defineSymbol(math$1, ams, bin, "", "\\doublebarwedge", !0);
defineSymbol(math$1, ams, bin, "", "\\boxminus", !0);
defineSymbol(math$1, ams, bin, "", "\\boxplus", !0);
defineSymbol(math$1, ams, bin, "", "\\divideontimes", !0);
defineSymbol(math$1, ams, bin, "", "\\ltimes", !0);
defineSymbol(math$1, ams, bin, "", "\\rtimes", !0);
defineSymbol(math$1, ams, bin, "", "\\leftthreetimes", !0);
defineSymbol(math$1, ams, bin, "", "\\rightthreetimes", !0);
defineSymbol(math$1, ams, bin, "", "\\curlywedge", !0);
defineSymbol(math$1, ams, bin, "", "\\curlyvee", !0);
defineSymbol(math$1, ams, bin, "", "\\circleddash", !0);
defineSymbol(math$1, ams, bin, "", "\\circledast", !0);
defineSymbol(math$1, ams, bin, "", "\\centerdot");
defineSymbol(math$1, ams, bin, "", "\\intercal", !0);
defineSymbol(math$1, ams, bin, "", "\\doublecap");
defineSymbol(math$1, ams, bin, "", "\\doublecup");
defineSymbol(math$1, ams, bin, "", "\\boxtimes", !0);
defineSymbol(math$1, ams, rel, "", "\\dashrightarrow", !0);
defineSymbol(math$1, ams, rel, "", "\\dashleftarrow", !0);
defineSymbol(math$1, ams, rel, "", "\\leftleftarrows", !0);
defineSymbol(math$1, ams, rel, "", "\\leftrightarrows", !0);
defineSymbol(math$1, ams, rel, "", "\\Lleftarrow", !0);
defineSymbol(math$1, ams, rel, "", "\\twoheadleftarrow", !0);
defineSymbol(math$1, ams, rel, "", "\\leftarrowtail", !0);
defineSymbol(math$1, ams, rel, "", "\\looparrowleft", !0);
defineSymbol(math$1, ams, rel, "", "\\leftrightharpoons", !0);
defineSymbol(math$1, ams, rel, "", "\\curvearrowleft", !0);
defineSymbol(math$1, ams, rel, "", "\\circlearrowleft", !0);
defineSymbol(math$1, ams, rel, "", "\\Lsh", !0);
defineSymbol(math$1, ams, rel, "", "\\upuparrows", !0);
defineSymbol(math$1, ams, rel, "", "\\upharpoonleft", !0);
defineSymbol(math$1, ams, rel, "", "\\downharpoonleft", !0);
defineSymbol(math$1, main, rel, "", "\\origof", !0);
defineSymbol(math$1, main, rel, "", "\\imageof", !0);
defineSymbol(math$1, ams, rel, "", "\\multimap", !0);
defineSymbol(math$1, ams, rel, "", "\\leftrightsquigarrow", !0);
defineSymbol(math$1, ams, rel, "", "\\rightrightarrows", !0);
defineSymbol(math$1, ams, rel, "", "\\rightleftarrows", !0);
defineSymbol(math$1, ams, rel, "", "\\twoheadrightarrow", !0);
defineSymbol(math$1, ams, rel, "", "\\rightarrowtail", !0);
defineSymbol(math$1, ams, rel, "", "\\looparrowright", !0);
defineSymbol(math$1, ams, rel, "", "\\curvearrowright", !0);
defineSymbol(math$1, ams, rel, "", "\\circlearrowright", !0);
defineSymbol(math$1, ams, rel, "", "\\Rsh", !0);
defineSymbol(math$1, ams, rel, "", "\\downdownarrows", !0);
defineSymbol(math$1, ams, rel, "", "\\upharpoonright", !0);
defineSymbol(math$1, ams, rel, "", "\\downharpoonright", !0);
defineSymbol(math$1, ams, rel, "", "\\rightsquigarrow", !0);
defineSymbol(math$1, ams, rel, "", "\\leadsto");
defineSymbol(math$1, ams, rel, "", "\\Rrightarrow", !0);
defineSymbol(math$1, ams, rel, "", "\\restriction");
defineSymbol(math$1, main, textord, "", "`");
defineSymbol(math$1, main, textord, "$", "\\$");
defineSymbol(text$6, main, textord, "$", "\\$");
defineSymbol(text$6, main, textord, "$", "\\textdollar");
defineSymbol(math$1, main, textord, "%", "\\%");
defineSymbol(text$6, main, textord, "%", "\\%");
defineSymbol(math$1, main, textord, "_", "\\_");
defineSymbol(text$6, main, textord, "_", "\\_");
defineSymbol(text$6, main, textord, "_", "\\textunderscore");
defineSymbol(math$1, main, textord, "", "\\angle", !0);
defineSymbol(math$1, main, textord, "", "\\infty", !0);
defineSymbol(math$1, main, textord, "", "\\prime");
defineSymbol(math$1, main, textord, "", "\\triangle");
defineSymbol(math$1, main, textord, "", "\\Gamma", !0);
defineSymbol(math$1, main, textord, "", "\\Delta", !0);
defineSymbol(math$1, main, textord, "", "\\Theta", !0);
defineSymbol(math$1, main, textord, "", "\\Lambda", !0);
defineSymbol(math$1, main, textord, "", "\\Xi", !0);
defineSymbol(math$1, main, textord, "", "\\Pi", !0);
defineSymbol(math$1, main, textord, "", "\\Sigma", !0);
defineSymbol(math$1, main, textord, "", "\\Upsilon", !0);
defineSymbol(math$1, main, textord, "", "\\Phi", !0);
defineSymbol(math$1, main, textord, "", "\\Psi", !0);
defineSymbol(math$1, main, textord, "", "\\Omega", !0);
defineSymbol(math$1, main, textord, "A", "");
defineSymbol(math$1, main, textord, "B", "");
defineSymbol(math$1, main, textord, "E", "");
defineSymbol(math$1, main, textord, "Z", "");
defineSymbol(math$1, main, textord, "H", "");
defineSymbol(math$1, main, textord, "I", "");
defineSymbol(math$1, main, textord, "K", "");
defineSymbol(math$1, main, textord, "M", "");
defineSymbol(math$1, main, textord, "N", "");
defineSymbol(math$1, main, textord, "O", "");
defineSymbol(math$1, main, textord, "P", "");
defineSymbol(math$1, main, textord, "T", "");
defineSymbol(math$1, main, textord, "X", "");
defineSymbol(math$1, main, textord, "", "\\neg", !0);
defineSymbol(math$1, main, textord, "", "\\lnot");
defineSymbol(math$1, main, textord, "", "\\top");
defineSymbol(math$1, main, textord, "", "\\bot");
defineSymbol(math$1, main, textord, "", "\\emptyset");
defineSymbol(math$1, ams, textord, "", "\\varnothing");
defineSymbol(math$1, main, mathord, "", "\\alpha", !0);
defineSymbol(math$1, main, mathord, "", "\\beta", !0);
defineSymbol(math$1, main, mathord, "", "\\gamma", !0);
defineSymbol(math$1, main, mathord, "", "\\delta", !0);
defineSymbol(math$1, main, mathord, "", "\\epsilon", !0);
defineSymbol(math$1, main, mathord, "", "\\zeta", !0);
defineSymbol(math$1, main, mathord, "", "\\eta", !0);
defineSymbol(math$1, main, mathord, "", "\\theta", !0);
defineSymbol(math$1, main, mathord, "", "\\iota", !0);
defineSymbol(math$1, main, mathord, "", "\\kappa", !0);
defineSymbol(math$1, main, mathord, "", "\\lambda", !0);
defineSymbol(math$1, main, mathord, "", "\\mu", !0);
defineSymbol(math$1, main, mathord, "", "\\nu", !0);
defineSymbol(math$1, main, mathord, "", "\\xi", !0);
defineSymbol(math$1, main, mathord, "", "\\omicron", !0);
defineSymbol(math$1, main, mathord, "", "\\pi", !0);
defineSymbol(math$1, main, mathord, "", "\\rho", !0);
defineSymbol(math$1, main, mathord, "", "\\sigma", !0);
defineSymbol(math$1, main, mathord, "", "\\tau", !0);
defineSymbol(math$1, main, mathord, "", "\\upsilon", !0);
defineSymbol(math$1, main, mathord, "", "\\phi", !0);
defineSymbol(math$1, main, mathord, "", "\\chi", !0);
defineSymbol(math$1, main, mathord, "", "\\psi", !0);
defineSymbol(math$1, main, mathord, "", "\\omega", !0);
defineSymbol(math$1, main, mathord, "", "\\varepsilon", !0);
defineSymbol(math$1, main, mathord, "", "\\vartheta", !0);
defineSymbol(math$1, main, mathord, "", "\\varpi", !0);
defineSymbol(math$1, main, mathord, "", "\\varrho", !0);
defineSymbol(math$1, main, mathord, "", "\\varsigma", !0);
defineSymbol(math$1, main, mathord, "", "\\varphi", !0);
defineSymbol(math$1, main, bin, "", "*", !0);
defineSymbol(math$1, main, bin, "+", "+");
defineSymbol(math$1, main, bin, "", "-", !0);
defineSymbol(math$1, main, bin, "", "\\cdot", !0);
defineSymbol(math$1, main, bin, "", "\\circ", !0);
defineSymbol(math$1, main, bin, "", "\\div", !0);
defineSymbol(math$1, main, bin, "", "\\pm", !0);
defineSymbol(math$1, main, bin, "", "\\times", !0);
defineSymbol(math$1, main, bin, "", "\\cap", !0);
defineSymbol(math$1, main, bin, "", "\\cup", !0);
defineSymbol(math$1, main, bin, "", "\\setminus", !0);
defineSymbol(math$1, main, bin, "", "\\land");
defineSymbol(math$1, main, bin, "", "\\lor");
defineSymbol(math$1, main, bin, "", "\\wedge", !0);
defineSymbol(math$1, main, bin, "", "\\vee", !0);
defineSymbol(math$1, main, textord, "", "\\surd");
defineSymbol(math$1, main, open, "", "\\langle", !0);
defineSymbol(math$1, main, open, "", "\\lvert");
defineSymbol(math$1, main, open, "", "\\lVert");
defineSymbol(math$1, main, close, "?", "?");
defineSymbol(math$1, main, close, "!", "!");
defineSymbol(math$1, main, close, "", "\\rangle", !0);
defineSymbol(math$1, main, close, "", "\\rvert");
defineSymbol(math$1, main, close, "", "\\rVert");
defineSymbol(math$1, main, rel, "=", "=");
defineSymbol(math$1, main, rel, ":", ":");
defineSymbol(math$1, main, rel, "", "\\approx", !0);
defineSymbol(math$1, main, rel, "", "\\cong", !0);
defineSymbol(math$1, main, rel, "", "\\ge");
defineSymbol(math$1, main, rel, "", "\\geq", !0);
defineSymbol(math$1, main, rel, "", "\\gets");
defineSymbol(math$1, main, rel, ">", "\\gt", !0);
defineSymbol(math$1, main, rel, "", "\\in", !0);
defineSymbol(math$1, main, rel, "", "\\@not");
defineSymbol(math$1, main, rel, "", "\\subset", !0);
defineSymbol(math$1, main, rel, "", "\\supset", !0);
defineSymbol(math$1, main, rel, "", "\\subseteq", !0);
defineSymbol(math$1, main, rel, "", "\\supseteq", !0);
defineSymbol(math$1, ams, rel, "", "\\nsubseteq", !0);
defineSymbol(math$1, ams, rel, "", "\\nsupseteq", !0);
defineSymbol(math$1, main, rel, "", "\\models");
defineSymbol(math$1, main, rel, "", "\\leftarrow", !0);
defineSymbol(math$1, main, rel, "", "\\le");
defineSymbol(math$1, main, rel, "", "\\leq", !0);
defineSymbol(math$1, main, rel, "<", "\\lt", !0);
defineSymbol(math$1, main, rel, "", "\\rightarrow", !0);
defineSymbol(math$1, main, rel, "", "\\to");
defineSymbol(math$1, ams, rel, "", "\\ngeq", !0);
defineSymbol(math$1, ams, rel, "", "\\nleq", !0);
defineSymbol(math$1, main, spacing, "", "\\ ");
defineSymbol(math$1, main, spacing, "", "\\space");
defineSymbol(math$1, main, spacing, "", "\\nobreakspace");
defineSymbol(text$6, main, spacing, "", "\\ ");
defineSymbol(text$6, main, spacing, "", " ");
defineSymbol(text$6, main, spacing, "", "\\space");
defineSymbol(text$6, main, spacing, "", "\\nobreakspace");
defineSymbol(math$1, main, spacing, null, "\\nobreak");
defineSymbol(math$1, main, spacing, null, "\\allowbreak");
defineSymbol(math$1, main, punct, ",", ",");
defineSymbol(math$1, main, punct, ";", ";");
defineSymbol(math$1, ams, bin, "", "\\barwedge", !0);
defineSymbol(math$1, ams, bin, "", "\\veebar", !0);
defineSymbol(math$1, main, bin, "", "\\odot", !0);
defineSymbol(math$1, main, bin, "", "\\oplus", !0);
defineSymbol(math$1, main, bin, "", "\\otimes", !0);
defineSymbol(math$1, main, textord, "", "\\partial", !0);
defineSymbol(math$1, main, bin, "", "\\oslash", !0);
defineSymbol(math$1, ams, bin, "", "\\circledcirc", !0);
defineSymbol(math$1, ams, bin, "", "\\boxdot", !0);
defineSymbol(math$1, main, bin, "", "\\bigtriangleup");
defineSymbol(math$1, main, bin, "", "\\bigtriangledown");
defineSymbol(math$1, main, bin, "", "\\dagger");
defineSymbol(math$1, main, bin, "", "\\diamond");
defineSymbol(math$1, main, bin, "", "\\star");
defineSymbol(math$1, main, bin, "", "\\triangleleft");
defineSymbol(math$1, main, bin, "", "\\triangleright");
defineSymbol(math$1, main, open, "{", "\\{");
defineSymbol(text$6, main, textord, "{", "\\{");
defineSymbol(text$6, main, textord, "{", "\\textbraceleft");
defineSymbol(math$1, main, close, "}", "\\}");
defineSymbol(text$6, main, textord, "}", "\\}");
defineSymbol(text$6, main, textord, "}", "\\textbraceright");
defineSymbol(math$1, main, open, "{", "\\lbrace");
defineSymbol(math$1, main, close, "}", "\\rbrace");
defineSymbol(math$1, main, open, "[", "\\lbrack", !0);
defineSymbol(text$6, main, textord, "[", "\\lbrack", !0);
defineSymbol(math$1, main, close, "]", "\\rbrack", !0);
defineSymbol(text$6, main, textord, "]", "\\rbrack", !0);
defineSymbol(math$1, main, open, "(", "\\lparen", !0);
defineSymbol(math$1, main, close, ")", "\\rparen", !0);
defineSymbol(text$6, main, textord, "<", "\\textless", !0);
defineSymbol(text$6, main, textord, ">", "\\textgreater", !0);
defineSymbol(math$1, main, open, "", "\\lfloor", !0);
defineSymbol(math$1, main, close, "", "\\rfloor", !0);
defineSymbol(math$1, main, open, "", "\\lceil", !0);
defineSymbol(math$1, main, close, "", "\\rceil", !0);
defineSymbol(math$1, main, textord, "\\", "\\backslash");
defineSymbol(math$1, main, textord, "", "|");
defineSymbol(math$1, main, textord, "", "\\vert");
defineSymbol(text$6, main, textord, "|", "\\textbar", !0);
defineSymbol(math$1, main, textord, "", "\\|");
defineSymbol(math$1, main, textord, "", "\\Vert");
defineSymbol(text$6, main, textord, "", "\\textbardbl");
defineSymbol(text$6, main, textord, "~", "\\textasciitilde");
defineSymbol(text$6, main, textord, "\\", "\\textbackslash");
defineSymbol(text$6, main, textord, "^", "\\textasciicircum");
defineSymbol(math$1, main, rel, "", "\\uparrow", !0);
defineSymbol(math$1, main, rel, "", "\\Uparrow", !0);
defineSymbol(math$1, main, rel, "", "\\downarrow", !0);
defineSymbol(math$1, main, rel, "", "\\Downarrow", !0);
defineSymbol(math$1, main, rel, "", "\\updownarrow", !0);
defineSymbol(math$1, main, rel, "", "\\Updownarrow", !0);
defineSymbol(math$1, main, op, "", "\\coprod");
defineSymbol(math$1, main, op, "", "\\bigvee");
defineSymbol(math$1, main, op, "", "\\bigwedge");
defineSymbol(math$1, main, op, "", "\\biguplus");
defineSymbol(math$1, main, op, "", "\\bigcap");
defineSymbol(math$1, main, op, "", "\\bigcup");
defineSymbol(math$1, main, op, "", "\\int");
defineSymbol(math$1, main, op, "", "\\intop");
defineSymbol(math$1, main, op, "", "\\iint");
defineSymbol(math$1, main, op, "", "\\iiint");
defineSymbol(math$1, main, op, "", "\\prod");
defineSymbol(math$1, main, op, "", "\\sum");
defineSymbol(math$1, main, op, "", "\\bigotimes");
defineSymbol(math$1, main, op, "", "\\bigoplus");
defineSymbol(math$1, main, op, "", "\\bigodot");
defineSymbol(math$1, main, op, "", "\\oint");
defineSymbol(math$1, main, op, "", "\\oiint");
defineSymbol(math$1, main, op, "", "\\oiiint");
defineSymbol(math$1, main, op, "", "\\bigsqcup");
defineSymbol(math$1, main, op, "", "\\smallint");
defineSymbol(text$6, main, inner, "", "\\textellipsis");
defineSymbol(math$1, main, inner, "", "\\mathellipsis");
defineSymbol(text$6, main, inner, "", "\\ldots", !0);
defineSymbol(math$1, main, inner, "", "\\ldots", !0);
defineSymbol(math$1, main, inner, "", "\\@cdots", !0);
defineSymbol(math$1, main, inner, "", "\\ddots", !0);
defineSymbol(math$1, main, textord, "", "\\varvdots");
defineSymbol(text$6, main, textord, "", "\\varvdots");
defineSymbol(math$1, main, accent, "", "\\acute");
defineSymbol(math$1, main, accent, "", "\\grave");
defineSymbol(math$1, main, accent, "", "\\ddot");
defineSymbol(math$1, main, accent, "~", "\\tilde");
defineSymbol(math$1, main, accent, "", "\\bar");
defineSymbol(math$1, main, accent, "", "\\breve");
defineSymbol(math$1, main, accent, "", "\\check");
defineSymbol(math$1, main, accent, "^", "\\hat");
defineSymbol(math$1, main, accent, "", "\\vec");
defineSymbol(math$1, main, accent, "", "\\dot");
defineSymbol(math$1, main, accent, "", "\\mathring");
defineSymbol(math$1, main, mathord, "", "\\@imath");
defineSymbol(math$1, main, mathord, "", "\\@jmath");
defineSymbol(math$1, main, textord, "", "");
defineSymbol(math$1, main, textord, "", "");
defineSymbol(text$6, main, textord, "", "\\i", !0);
defineSymbol(text$6, main, textord, "", "\\j", !0);
defineSymbol(text$6, main, textord, "", "\\ss", !0);
defineSymbol(text$6, main, textord, "", "\\ae", !0);
defineSymbol(text$6, main, textord, "", "\\oe", !0);
defineSymbol(text$6, main, textord, "", "\\o", !0);
defineSymbol(text$6, main, textord, "", "\\AE", !0);
defineSymbol(text$6, main, textord, "", "\\OE", !0);
defineSymbol(text$6, main, textord, "", "\\O", !0);
defineSymbol(text$6, main, accent, "", "\\'");
defineSymbol(text$6, main, accent, "", "\\`");
defineSymbol(text$6, main, accent, "", "\\^");
defineSymbol(text$6, main, accent, "", "\\~");
defineSymbol(text$6, main, accent, "", "\\=");
defineSymbol(text$6, main, accent, "", "\\u");
defineSymbol(text$6, main, accent, "", "\\.");
defineSymbol(text$6, main, accent, "", "\\c");
defineSymbol(text$6, main, accent, "", "\\r");
defineSymbol(text$6, main, accent, "", "\\v");
defineSymbol(text$6, main, accent, "", '\\"');
defineSymbol(text$6, main, accent, "", "\\H");
defineSymbol(text$6, main, accent, "", "\\textcircled");
var ligatures = {
  "--": !0,
  "---": !0,
  "``": !0,
  "''": !0
};
defineSymbol(text$6, main, textord, "", "--", !0);
defineSymbol(text$6, main, textord, "", "\\textendash");
defineSymbol(text$6, main, textord, "", "---", !0);
defineSymbol(text$6, main, textord, "", "\\textemdash");
defineSymbol(text$6, main, textord, "", "`", !0);
defineSymbol(text$6, main, textord, "", "\\textquoteleft");
defineSymbol(text$6, main, textord, "", "'", !0);
defineSymbol(text$6, main, textord, "", "\\textquoteright");
defineSymbol(text$6, main, textord, "", "``", !0);
defineSymbol(text$6, main, textord, "", "\\textquotedblleft");
defineSymbol(text$6, main, textord, "", "''", !0);
defineSymbol(text$6, main, textord, "", "\\textquotedblright");
defineSymbol(math$1, main, textord, "", "\\degree", !0);
defineSymbol(text$6, main, textord, "", "\\degree");
defineSymbol(text$6, main, textord, "", "\\textdegree", !0);
defineSymbol(math$1, main, textord, "", "\\pounds");
defineSymbol(math$1, main, textord, "", "\\mathsterling", !0);
defineSymbol(text$6, main, textord, "", "\\pounds");
defineSymbol(text$6, main, textord, "", "\\textsterling", !0);
defineSymbol(math$1, ams, textord, "", "\\maltese");
defineSymbol(text$6, ams, textord, "", "\\maltese");
var mathTextSymbols = '0123456789/@."';
for (var i = 0; i < mathTextSymbols.length; i++) {
  var ch = mathTextSymbols.charAt(i);
  defineSymbol(math$1, main, textord, ch, ch);
}
var textSymbols = '0123456789!@*()-=+";:?/.,';
for (var _i = 0; _i < textSymbols.length; _i++) {
  var _ch = textSymbols.charAt(_i);
  defineSymbol(text$6, main, textord, _ch, _ch);
}
var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (var _i2 = 0; _i2 < letters.length; _i2++) {
  var _ch2 = letters.charAt(_i2);
  defineSymbol(math$1, main, mathord, _ch2, _ch2), defineSymbol(text$6, main, textord, _ch2, _ch2);
}
defineSymbol(math$1, ams, textord, "C", "");
defineSymbol(text$6, ams, textord, "C", "");
defineSymbol(math$1, ams, textord, "H", "");
defineSymbol(text$6, ams, textord, "H", "");
defineSymbol(math$1, ams, textord, "N", "");
defineSymbol(text$6, ams, textord, "N", "");
defineSymbol(math$1, ams, textord, "P", "");
defineSymbol(text$6, ams, textord, "P", "");
defineSymbol(math$1, ams, textord, "Q", "");
defineSymbol(text$6, ams, textord, "Q", "");
defineSymbol(math$1, ams, textord, "R", "");
defineSymbol(text$6, ams, textord, "R", "");
defineSymbol(math$1, ams, textord, "Z", "");
defineSymbol(text$6, ams, textord, "Z", "");
defineSymbol(math$1, main, mathord, "h", "");
defineSymbol(text$6, main, mathord, "h", "");
var wideChar = "";
for (var _i3 = 0; _i3 < letters.length; _i3++) {
  var _ch3 = letters.charAt(_i3);
  wideChar = String.fromCharCode(55349, 56320 + _i3), defineSymbol(math$1, main, mathord, _ch3, wideChar), defineSymbol(text$6, main, textord, _ch3, wideChar), wideChar = String.fromCharCode(55349, 56372 + _i3), defineSymbol(math$1, main, mathord, _ch3, wideChar), defineSymbol(text$6, main, textord, _ch3, wideChar), wideChar = String.fromCharCode(55349, 56424 + _i3), defineSymbol(math$1, main, mathord, _ch3, wideChar), defineSymbol(text$6, main, textord, _ch3, wideChar), wideChar = String.fromCharCode(55349, 56580 + _i3), defineSymbol(math$1, main, mathord, _ch3, wideChar), defineSymbol(text$6, main, textord, _ch3, wideChar), wideChar = String.fromCharCode(55349, 56684 + _i3), defineSymbol(math$1, main, mathord, _ch3, wideChar), defineSymbol(text$6, main, textord, _ch3, wideChar), wideChar = String.fromCharCode(55349, 56736 + _i3), defineSymbol(math$1, main, mathord, _ch3, wideChar), defineSymbol(text$6, main, textord, _ch3, wideChar), wideChar = String.fromCharCode(55349, 56788 + _i3), defineSymbol(math$1, main, mathord, _ch3, wideChar), defineSymbol(text$6, main, textord, _ch3, wideChar), wideChar = String.fromCharCode(55349, 56840 + _i3), defineSymbol(math$1, main, mathord, _ch3, wideChar), defineSymbol(text$6, main, textord, _ch3, wideChar), wideChar = String.fromCharCode(55349, 56944 + _i3), defineSymbol(math$1, main, mathord, _ch3, wideChar), defineSymbol(text$6, main, textord, _ch3, wideChar), _i3 < 26 && (wideChar = String.fromCharCode(55349, 56632 + _i3), defineSymbol(math$1, main, mathord, _ch3, wideChar), defineSymbol(text$6, main, textord, _ch3, wideChar), wideChar = String.fromCharCode(55349, 56476 + _i3), defineSymbol(math$1, main, mathord, _ch3, wideChar), defineSymbol(text$6, main, textord, _ch3, wideChar));
}
wideChar = "";
defineSymbol(math$1, main, mathord, "k", wideChar);
defineSymbol(text$6, main, textord, "k", wideChar);
for (var _i4 = 0; _i4 < 10; _i4++) {
  var _ch4 = _i4.toString();
  wideChar = String.fromCharCode(55349, 57294 + _i4), defineSymbol(math$1, main, mathord, _ch4, wideChar), defineSymbol(text$6, main, textord, _ch4, wideChar), wideChar = String.fromCharCode(55349, 57314 + _i4), defineSymbol(math$1, main, mathord, _ch4, wideChar), defineSymbol(text$6, main, textord, _ch4, wideChar), wideChar = String.fromCharCode(55349, 57324 + _i4), defineSymbol(math$1, main, mathord, _ch4, wideChar), defineSymbol(text$6, main, textord, _ch4, wideChar), wideChar = String.fromCharCode(55349, 57334 + _i4), defineSymbol(math$1, main, mathord, _ch4, wideChar), defineSymbol(text$6, main, textord, _ch4, wideChar);
}
var extraLatin = "";
for (var _i5 = 0; _i5 < extraLatin.length; _i5++) {
  var _ch5 = extraLatin.charAt(_i5);
  defineSymbol(math$1, main, mathord, _ch5, _ch5), defineSymbol(text$6, main, textord, _ch5, _ch5);
}
var wideLatinLetterData = [
  ["mathbf", "textbf", "Main-Bold"],
  // A-Z bold upright
  ["mathbf", "textbf", "Main-Bold"],
  // a-z bold upright
  ["mathnormal", "textit", "Math-Italic"],
  // A-Z italic
  ["mathnormal", "textit", "Math-Italic"],
  // a-z italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // A-Z bold italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // a-z bold italic
  // Map fancy A-Z letters to script, not calligraphic.
  // This aligns with unicode-math and math fonts (except Cambria Math).
  ["mathscr", "textscr", "Script-Regular"],
  // A-Z script
  ["", "", ""],
  // a-z script.  No font
  ["", "", ""],
  // A-Z bold script. No font
  ["", "", ""],
  // a-z bold script. No font
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // A-Z Fraktur
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // a-z Fraktur
  ["mathbb", "textbb", "AMS-Regular"],
  // A-Z double-struck
  ["mathbb", "textbb", "AMS-Regular"],
  // k double-struck
  // Note that we are using a bold font, but font metrics for regular Fraktur.
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // A-Z bold Fraktur
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // a-z bold Fraktur
  ["mathsf", "textsf", "SansSerif-Regular"],
  // A-Z sans-serif
  ["mathsf", "textsf", "SansSerif-Regular"],
  // a-z sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // A-Z bold sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // a-z bold sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // A-Z italic sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // a-z italic sans-serif
  ["", "", ""],
  // A-Z bold italic sans. No font
  ["", "", ""],
  // a-z bold italic sans. No font
  ["mathtt", "texttt", "Typewriter-Regular"],
  // A-Z monospace
  ["mathtt", "texttt", "Typewriter-Regular"]
  // a-z monospace
], wideNumeralData = [
  ["mathbf", "textbf", "Main-Bold"],
  // 0-9 bold
  ["", "", ""],
  // 0-9 double-struck. No KaTeX font.
  ["mathsf", "textsf", "SansSerif-Regular"],
  // 0-9 sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // 0-9 bold sans-serif
  ["mathtt", "texttt", "Typewriter-Regular"]
  // 0-9 monospace
], wideCharacterFont = function e(t, r) {
  var a = t.charCodeAt(0), o = t.charCodeAt(1), u = (a - 55296) * 1024 + (o - 56320) + 65536, c = r === "math" ? 0 : 1;
  if (119808 <= u && u < 120484) {
    var d = Math.floor((u - 119808) / 26);
    return [wideLatinLetterData[d][2], wideLatinLetterData[d][c]];
  } else if (120782 <= u && u <= 120831) {
    var g = Math.floor((u - 120782) / 10);
    return [wideNumeralData[g][2], wideNumeralData[g][c]];
  } else {
    if (u === 120485 || u === 120486)
      return [wideLatinLetterData[0][2], wideLatinLetterData[0][c]];
    if (120486 < u && u < 120782)
      return ["", ""];
    throw new ParseError("Unsupported character: " + t);
  }
}, lookupSymbol = function e(t, r, a) {
  return symbols[a][t] && symbols[a][t].replace && (t = symbols[a][t].replace), {
    value: t,
    metrics: getCharacterMetrics(t, r, a)
  };
}, makeSymbol = function e(t, r, a, o, u) {
  var c = lookupSymbol(t, r, a), d = c.metrics;
  t = c.value;
  var g;
  if (d) {
    var b = d.italic;
    (a === "text" || o && o.font === "mathit") && (b = 0), g = new SymbolNode(t, d.height, d.depth, b, d.skew, d.width, u);
  } else
    typeof console < "u" && console.warn("No character metrics " + ("for '" + t + "' in style '" + r + "' and mode '" + a + "'")), g = new SymbolNode(t, 0, 0, 0, 0, 0, u);
  if (o) {
    g.maxFontSize = o.sizeMultiplier, o.style.isTight() && g.classes.push("mtight");
    var _ = o.getColor();
    _ && (g.style.color = _);
  }
  return g;
}, mathsym = function e(t, r, a, o) {
  return o === void 0 && (o = []), a.font === "boldsymbol" && lookupSymbol(t, "Main-Bold", r).metrics ? makeSymbol(t, "Main-Bold", r, a, o.concat(["mathbf"])) : t === "\\" || symbols[r][t].font === "main" ? makeSymbol(t, "Main-Regular", r, a, o) : makeSymbol(t, "AMS-Regular", r, a, o.concat(["amsrm"]));
}, boldsymbol = function e(t, r, a, o, u) {
  return u !== "textord" && lookupSymbol(t, "Math-BoldItalic", r).metrics ? {
    fontName: "Math-BoldItalic",
    fontClass: "boldsymbol"
  } : {
    fontName: "Main-Bold",
    fontClass: "mathbf"
  };
}, makeOrd = function e(t, r, a) {
  var o = t.mode, u = t.text, c = ["mord"], d = o === "math" || o === "text" && r.font, g = d ? r.font : r.fontFamily, b = "", _ = "";
  if (u.charCodeAt(0) === 55349 && ([b, _] = wideCharacterFont(u, o)), b.length > 0)
    return makeSymbol(u, b, o, r, c.concat(_));
  if (g) {
    var y, A;
    if (g === "boldsymbol") {
      var E = boldsymbol(u, o, r, c, a);
      y = E.fontName, A = [E.fontClass];
    } else d ? (y = fontMap[g].fontName, A = [g]) : (y = retrieveTextFontName(g, r.fontWeight, r.fontShape), A = [g, r.fontWeight, r.fontShape]);
    if (lookupSymbol(u, y, o).metrics)
      return makeSymbol(u, y, o, r, c.concat(A));
    if (ligatures.hasOwnProperty(u) && y.slice(0, 10) === "Typewriter") {
      for (var v = [], C = 0; C < u.length; C++)
        v.push(makeSymbol(u[C], y, o, r, c.concat(A)));
      return makeFragment(v);
    }
  }
  if (a === "mathord")
    return makeSymbol(u, "Math-Italic", o, r, c.concat(["mathnormal"]));
  if (a === "textord") {
    var R = symbols[o][u] && symbols[o][u].font;
    if (R === "ams") {
      var I = retrieveTextFontName("amsrm", r.fontWeight, r.fontShape);
      return makeSymbol(u, I, o, r, c.concat("amsrm", r.fontWeight, r.fontShape));
    } else if (R === "main" || !R) {
      var w = retrieveTextFontName("textrm", r.fontWeight, r.fontShape);
      return makeSymbol(u, w, o, r, c.concat(r.fontWeight, r.fontShape));
    } else {
      var N = retrieveTextFontName(R, r.fontWeight, r.fontShape);
      return makeSymbol(u, N, o, r, c.concat(N, r.fontWeight, r.fontShape));
    }
  } else
    throw new Error("unexpected type: " + a + " in makeOrd");
}, canCombine = (e, t) => {
  if (createClass(e.classes) !== createClass(t.classes) || e.skew !== t.skew || e.maxFontSize !== t.maxFontSize)
    return !1;
  if (e.classes.length === 1) {
    var r = e.classes[0];
    if (r === "mbin" || r === "mord")
      return !1;
  }
  for (var a in e.style)
    if (e.style.hasOwnProperty(a) && e.style[a] !== t.style[a])
      return !1;
  for (var o in t.style)
    if (t.style.hasOwnProperty(o) && e.style[o] !== t.style[o])
      return !1;
  return !0;
}, tryCombineChars = (e) => {
  for (var t = 0; t < e.length - 1; t++) {
    var r = e[t], a = e[t + 1];
    r instanceof SymbolNode && a instanceof SymbolNode && canCombine(r, a) && (r.text += a.text, r.height = Math.max(r.height, a.height), r.depth = Math.max(r.depth, a.depth), r.italic = a.italic, e.splice(t + 1, 1), t--);
  }
  return e;
}, sizeElementFromChildren = function e(t) {
  for (var r = 0, a = 0, o = 0, u = 0; u < t.children.length; u++) {
    var c = t.children[u];
    c.height > r && (r = c.height), c.depth > a && (a = c.depth), c.maxFontSize > o && (o = c.maxFontSize);
  }
  t.height = r, t.depth = a, t.maxFontSize = o;
}, makeSpan$2 = function e(t, r, a, o) {
  var u = new Span(t, r, a, o);
  return sizeElementFromChildren(u), u;
}, makeSvgSpan = (e, t, r, a) => new Span(e, t, r, a), makeLineSpan = function e(t, r, a) {
  var o = makeSpan$2([t], [], r);
  return o.height = Math.max(a || r.fontMetrics().defaultRuleThickness, r.minRuleThickness), o.style.borderBottomWidth = makeEm(o.height), o.maxFontSize = 1, o;
}, makeAnchor = function e(t, r, a, o) {
  var u = new Anchor$1(t, r, a, o);
  return sizeElementFromChildren(u), u;
}, makeFragment = function e(t) {
  var r = new DocumentFragment(t);
  return sizeElementFromChildren(r), r;
}, wrapFragment = function e(t, r) {
  return t instanceof DocumentFragment ? makeSpan$2([], [t], r) : t;
}, getVListChildrenAndDepth = function e(t) {
  if (t.positionType === "individualShift") {
    for (var r = t.children, a = [r[0]], o = -r[0].shift - r[0].elem.depth, u = o, c = 1; c < r.length; c++) {
      var d = -r[c].shift - u - r[c].elem.depth, g = d - (r[c - 1].elem.height + r[c - 1].elem.depth);
      u = u + d, a.push({
        type: "kern",
        size: g
      }), a.push(r[c]);
    }
    return {
      children: a,
      depth: o
    };
  }
  var b;
  if (t.positionType === "top") {
    for (var _ = t.positionData, y = 0; y < t.children.length; y++) {
      var A = t.children[y];
      _ -= A.type === "kern" ? A.size : A.elem.height + A.elem.depth;
    }
    b = _;
  } else if (t.positionType === "bottom")
    b = -t.positionData;
  else {
    var E = t.children[0];
    if (E.type !== "elem")
      throw new Error('First child must have type "elem".');
    if (t.positionType === "shift")
      b = -E.elem.depth - t.positionData;
    else if (t.positionType === "firstBaseline")
      b = -E.elem.depth;
    else
      throw new Error("Invalid positionType " + t.positionType + ".");
  }
  return {
    children: t.children,
    depth: b
  };
}, makeVList = function e(t, r) {
  for (var {
    children: a,
    depth: o
  } = getVListChildrenAndDepth(t), u = 0, c = 0; c < a.length; c++) {
    var d = a[c];
    if (d.type === "elem") {
      var g = d.elem;
      u = Math.max(u, g.maxFontSize, g.height);
    }
  }
  u += 2;
  var b = makeSpan$2(["pstrut"], []);
  b.style.height = makeEm(u);
  for (var _ = [], y = o, A = o, E = o, v = 0; v < a.length; v++) {
    var C = a[v];
    if (C.type === "kern")
      E += C.size;
    else {
      var R = C.elem, I = C.wrapperClasses || [], w = C.wrapperStyle || {}, N = makeSpan$2(I, [b, R], void 0, w);
      N.style.top = makeEm(-u - E - R.depth), C.marginLeft && (N.style.marginLeft = C.marginLeft), C.marginRight && (N.style.marginRight = C.marginRight), _.push(N), E += R.height + R.depth;
    }
    y = Math.min(y, E), A = Math.max(A, E);
  }
  var F = makeSpan$2(["vlist"], _);
  F.style.height = makeEm(A);
  var M;
  if (y < 0) {
    var x = makeSpan$2([], []), P = makeSpan$2(["vlist"], [x]);
    P.style.height = makeEm(-y);
    var U = makeSpan$2(["vlist-s"], [new SymbolNode("")]);
    M = [makeSpan$2(["vlist-r"], [F, U]), makeSpan$2(["vlist-r"], [P])];
  } else
    M = [makeSpan$2(["vlist-r"], [F])];
  var L = makeSpan$2(["vlist-t"], M);
  return M.length === 2 && L.classes.push("vlist-t2"), L.height = A, L.depth = -y, L;
}, makeGlue = (e, t) => {
  var r = makeSpan$2(["mspace"], [], t), a = calculateSize(e, t);
  return r.style.marginRight = makeEm(a), r;
}, retrieveTextFontName = function e(t, r, a) {
  var o = "";
  switch (t) {
    case "amsrm":
      o = "AMS";
      break;
    case "textrm":
      o = "Main";
      break;
    case "textsf":
      o = "SansSerif";
      break;
    case "texttt":
      o = "Typewriter";
      break;
    default:
      o = t;
  }
  var u;
  return r === "textbf" && a === "textit" ? u = "BoldItalic" : r === "textbf" ? u = "Bold" : r === "textit" ? u = "Italic" : u = "Regular", o + "-" + u;
}, fontMap = {
  // styles
  mathbf: {
    variant: "bold",
    fontName: "Main-Bold"
  },
  mathrm: {
    variant: "normal",
    fontName: "Main-Regular"
  },
  textit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathnormal: {
    variant: "italic",
    fontName: "Math-Italic"
  },
  mathsfit: {
    variant: "sans-serif-italic",
    fontName: "SansSerif-Italic"
  },
  // "boldsymbol" is missing because they require the use of multiple fonts:
  // Math-BoldItalic and Main-Bold.  This is handled by a special case in
  // makeOrd which ends up calling boldsymbol.
  // families
  mathbb: {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  mathcal: {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  mathfrak: {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  mathscr: {
    variant: "script",
    fontName: "Script-Regular"
  },
  mathsf: {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  mathtt: {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
}, svgData = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
}, staticSvg = function e(t, r) {
  var [a, o, u] = svgData[t], c = new PathNode(a), d = new SvgNode([c], {
    width: makeEm(o),
    height: makeEm(u),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + makeEm(o),
    viewBox: "0 0 " + 1e3 * o + " " + 1e3 * u,
    preserveAspectRatio: "xMinYMin"
  }), g = makeSvgSpan(["overlay"], [d], r);
  return g.height = u, g.style.height = makeEm(u), g.style.width = makeEm(o), g;
}, buildCommon = {
  fontMap,
  makeSymbol,
  mathsym,
  makeSpan: makeSpan$2,
  makeSvgSpan,
  makeLineSpan,
  makeAnchor,
  makeFragment,
  wrapFragment,
  makeVList,
  makeOrd,
  makeGlue,
  staticSvg,
  svgData,
  tryCombineChars
}, thinspace = {
  number: 3,
  unit: "mu"
}, mediumspace = {
  number: 4,
  unit: "mu"
}, thickspace = {
  number: 5,
  unit: "mu"
}, spacings = {
  mord: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    minner: thinspace
  },
  mbin: {
    mord: mediumspace,
    mop: mediumspace,
    mopen: mediumspace,
    minner: mediumspace
  },
  mrel: {
    mord: thickspace,
    mop: thickspace,
    mopen: thickspace,
    minner: thickspace
  },
  mopen: {},
  mclose: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mpunct: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    mopen: thinspace,
    mclose: thinspace,
    mpunct: thinspace,
    minner: thinspace
  },
  minner: {
    mord: thinspace,
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    mopen: thinspace,
    mpunct: thinspace,
    minner: thinspace
  }
}, tightSpacings = {
  mord: {
    mop: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: thinspace
  },
  mpunct: {},
  minner: {
    mop: thinspace
  }
}, _functions = {}, _htmlGroupBuilders = {}, _mathmlGroupBuilders = {};
function defineFunction(e) {
  for (var {
    type: t,
    names: r,
    props: a,
    handler: o,
    htmlBuilder: u,
    mathmlBuilder: c
  } = e, d = {
    type: t,
    numArgs: a.numArgs,
    argTypes: a.argTypes,
    allowedInArgument: !!a.allowedInArgument,
    allowedInText: !!a.allowedInText,
    allowedInMath: a.allowedInMath === void 0 ? !0 : a.allowedInMath,
    numOptionalArgs: a.numOptionalArgs || 0,
    infix: !!a.infix,
    primitive: !!a.primitive,
    handler: o
  }, g = 0; g < r.length; ++g)
    _functions[r[g]] = d;
  t && (u && (_htmlGroupBuilders[t] = u), c && (_mathmlGroupBuilders[t] = c));
}
function defineFunctionBuilders(e) {
  var {
    type: t,
    htmlBuilder: r,
    mathmlBuilder: a
  } = e;
  defineFunction({
    type: t,
    names: [],
    props: {
      numArgs: 0
    },
    handler() {
      throw new Error("Should never be called.");
    },
    htmlBuilder: r,
    mathmlBuilder: a
  });
}
var normalizeArgument = function e(t) {
  return t.type === "ordgroup" && t.body.length === 1 ? t.body[0] : t;
}, ordargument = function e(t) {
  return t.type === "ordgroup" ? t.body : [t];
}, makeSpan$1 = buildCommon.makeSpan, binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"], binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"], styleMap$1 = {
  display: Style$1.DISPLAY,
  text: Style$1.TEXT,
  script: Style$1.SCRIPT,
  scriptscript: Style$1.SCRIPTSCRIPT
}, DomEnum = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
}, buildExpression$1 = function e(t, r, a, o) {
  o === void 0 && (o = [null, null]);
  for (var u = [], c = 0; c < t.length; c++) {
    var d = buildGroup$1(t[c], r);
    if (d instanceof DocumentFragment) {
      var g = d.children;
      u.push(...g);
    } else
      u.push(d);
  }
  if (buildCommon.tryCombineChars(u), !a)
    return u;
  var b = r;
  if (t.length === 1) {
    var _ = t[0];
    _.type === "sizing" ? b = r.havingSize(_.size) : _.type === "styling" && (b = r.havingStyle(styleMap$1[_.style]));
  }
  var y = makeSpan$1([o[0] || "leftmost"], [], r), A = makeSpan$1([o[1] || "rightmost"], [], r), E = a === "root";
  return traverseNonSpaceNodes(u, (v, C) => {
    var R = C.classes[0], I = v.classes[0];
    R === "mbin" && utils.contains(binRightCanceller, I) ? C.classes[0] = "mord" : I === "mbin" && utils.contains(binLeftCanceller, R) && (v.classes[0] = "mord");
  }, {
    node: y
  }, A, E), traverseNonSpaceNodes(u, (v, C) => {
    var R = getTypeOfDomTree(C), I = getTypeOfDomTree(v), w = R && I ? v.hasClass("mtight") ? tightSpacings[R][I] : spacings[R][I] : null;
    if (w)
      return buildCommon.makeGlue(w, b);
  }, {
    node: y
  }, A, E), u;
}, traverseNonSpaceNodes = function e(t, r, a, o, u) {
  o && t.push(o);
  for (var c = 0; c < t.length; c++) {
    var d = t[c], g = checkPartialGroup(d);
    if (g) {
      e(g.children, r, a, null, u);
      continue;
    }
    var b = !d.hasClass("mspace");
    if (b) {
      var _ = r(d, a.node);
      _ && (a.insertAfter ? a.insertAfter(_) : (t.unshift(_), c++));
    }
    b ? a.node = d : u && d.hasClass("newline") && (a.node = makeSpan$1(["leftmost"])), a.insertAfter = /* @__PURE__ */ ((y) => (A) => {
      t.splice(y + 1, 0, A), c++;
    })(c);
  }
  o && t.pop();
}, checkPartialGroup = function e(t) {
  return t instanceof DocumentFragment || t instanceof Anchor$1 || t instanceof Span && t.hasClass("enclosing") ? t : null;
}, getOutermostNode = function e(t, r) {
  var a = checkPartialGroup(t);
  if (a) {
    var o = a.children;
    if (o.length) {
      if (r === "right")
        return e(o[o.length - 1], "right");
      if (r === "left")
        return e(o[0], "left");
    }
  }
  return t;
}, getTypeOfDomTree = function e(t, r) {
  return t ? (r && (t = getOutermostNode(t, r)), DomEnum[t.classes[0]] || null) : null;
}, makeNullDelimiter = function e(t, r) {
  var a = ["nulldelimiter"].concat(t.baseSizingClasses());
  return makeSpan$1(r.concat(a));
}, buildGroup$1 = function e(t, r, a) {
  if (!t)
    return makeSpan$1();
  if (_htmlGroupBuilders[t.type]) {
    var o = _htmlGroupBuilders[t.type](t, r);
    if (a && r.size !== a.size) {
      o = makeSpan$1(r.sizingClasses(a), [o], r);
      var u = r.sizeMultiplier / a.sizeMultiplier;
      o.height *= u, o.depth *= u;
    }
    return o;
  } else
    throw new ParseError("Got group of unknown type: '" + t.type + "'");
};
function buildHTMLUnbreakable(e, t) {
  var r = makeSpan$1(["base"], e, t), a = makeSpan$1(["strut"]);
  return a.style.height = makeEm(r.height + r.depth), r.depth && (a.style.verticalAlign = makeEm(-r.depth)), r.children.unshift(a), r;
}
function buildHTML(e, t) {
  var r = null;
  e.length === 1 && e[0].type === "tag" && (r = e[0].tag, e = e[0].body);
  var a = buildExpression$1(e, t, "root"), o;
  a.length === 2 && a[1].hasClass("tag") && (o = a.pop());
  for (var u = [], c = [], d = 0; d < a.length; d++)
    if (c.push(a[d]), a[d].hasClass("mbin") || a[d].hasClass("mrel") || a[d].hasClass("allowbreak")) {
      for (var g = !1; d < a.length - 1 && a[d + 1].hasClass("mspace") && !a[d + 1].hasClass("newline"); )
        d++, c.push(a[d]), a[d].hasClass("nobreak") && (g = !0);
      g || (u.push(buildHTMLUnbreakable(c, t)), c = []);
    } else a[d].hasClass("newline") && (c.pop(), c.length > 0 && (u.push(buildHTMLUnbreakable(c, t)), c = []), u.push(a[d]));
  c.length > 0 && u.push(buildHTMLUnbreakable(c, t));
  var b;
  r ? (b = buildHTMLUnbreakable(buildExpression$1(r, t, !0)), b.classes = ["tag"], u.push(b)) : o && u.push(o);
  var _ = makeSpan$1(["katex-html"], u);
  if (_.setAttribute("aria-hidden", "true"), b) {
    var y = b.children[0];
    y.style.height = makeEm(_.height + _.depth), _.depth && (y.style.verticalAlign = makeEm(-_.depth));
  }
  return _;
}
function newDocumentFragment(e) {
  return new DocumentFragment(e);
}
class MathNode {
  constructor(t, r, a) {
    this.type = void 0, this.attributes = void 0, this.children = void 0, this.classes = void 0, this.type = t, this.attributes = {}, this.children = r || [], this.classes = a || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(t, r) {
    this.attributes[t] = r;
  }
  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(t) {
    return this.attributes[t];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    var t = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && t.setAttribute(r, this.attributes[r]);
    this.classes.length > 0 && (t.className = createClass(this.classes));
    for (var a = 0; a < this.children.length; a++)
      if (this.children[a] instanceof TextNode && this.children[a + 1] instanceof TextNode) {
        for (var o = this.children[a].toText() + this.children[++a].toText(); this.children[a + 1] instanceof TextNode; )
          o += this.children[++a].toText();
        t.appendChild(new TextNode(o).toNode());
      } else
        t.appendChild(this.children[a].toNode());
    return t;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    var t = "<" + this.type;
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && (t += " " + r + '="', t += utils.escape(this.attributes[r]), t += '"');
    this.classes.length > 0 && (t += ' class ="' + utils.escape(createClass(this.classes)) + '"'), t += ">";
    for (var a = 0; a < this.children.length; a++)
      t += this.children[a].toMarkup();
    return t += "</" + this.type + ">", t;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((t) => t.toText()).join("");
  }
}
class TextNode {
  constructor(t) {
    this.text = void 0, this.text = t;
  }
  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return utils.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
}
class SpaceNode {
  /**
   * Create a Space node with width given in CSS ems.
   */
  constructor(t) {
    this.width = void 0, this.character = void 0, this.width = t, t >= 0.05555 && t <= 0.05556 ? this.character = "" : t >= 0.1666 && t <= 0.1667 ? this.character = "" : t >= 0.2222 && t <= 0.2223 ? this.character = "" : t >= 0.2777 && t <= 0.2778 ? this.character = "" : t >= -0.05556 && t <= -0.05555 ? this.character = "" : t >= -0.1667 && t <= -0.1666 ? this.character = "" : t >= -0.2223 && t <= -0.2222 ? this.character = "" : t >= -0.2778 && t <= -0.2777 ? this.character = "" : this.character = null;
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    if (this.character)
      return document.createTextNode(this.character);
    var t = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
    return t.setAttribute("width", makeEm(this.width)), t;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    return this.character ? "<mtext>" + this.character + "</mtext>" : '<mspace width="' + makeEm(this.width) + '"/>';
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */
  toText() {
    return this.character ? this.character : " ";
  }
}
var mathMLTree = {
  MathNode,
  TextNode,
  SpaceNode,
  newDocumentFragment
}, makeText = function e(t, r, a) {
  return symbols[r][t] && symbols[r][t].replace && t.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(t) && a && (a.fontFamily && a.fontFamily.slice(4, 6) === "tt" || a.font && a.font.slice(4, 6) === "tt")) && (t = symbols[r][t].replace), new mathMLTree.TextNode(t);
}, makeRow = function e(t) {
  return t.length === 1 ? t[0] : new mathMLTree.MathNode("mrow", t);
}, getVariant = function e(t, r) {
  if (r.fontFamily === "texttt")
    return "monospace";
  if (r.fontFamily === "textsf")
    return r.fontShape === "textit" && r.fontWeight === "textbf" ? "sans-serif-bold-italic" : r.fontShape === "textit" ? "sans-serif-italic" : r.fontWeight === "textbf" ? "bold-sans-serif" : "sans-serif";
  if (r.fontShape === "textit" && r.fontWeight === "textbf")
    return "bold-italic";
  if (r.fontShape === "textit")
    return "italic";
  if (r.fontWeight === "textbf")
    return "bold";
  var a = r.font;
  if (!a || a === "mathnormal")
    return null;
  var o = t.mode;
  if (a === "mathit")
    return "italic";
  if (a === "boldsymbol")
    return t.type === "textord" ? "bold" : "bold-italic";
  if (a === "mathbf")
    return "bold";
  if (a === "mathbb")
    return "double-struck";
  if (a === "mathsfit")
    return "sans-serif-italic";
  if (a === "mathfrak")
    return "fraktur";
  if (a === "mathscr" || a === "mathcal")
    return "script";
  if (a === "mathsf")
    return "sans-serif";
  if (a === "mathtt")
    return "monospace";
  var u = t.text;
  if (utils.contains(["\\imath", "\\jmath"], u))
    return null;
  symbols[o][u] && symbols[o][u].replace && (u = symbols[o][u].replace);
  var c = buildCommon.fontMap[a].fontName;
  return getCharacterMetrics(u, c, o) ? buildCommon.fontMap[a].variant : null;
};
function isNumberPunctuation(e) {
  if (!e)
    return !1;
  if (e.type === "mi" && e.children.length === 1) {
    var t = e.children[0];
    return t instanceof TextNode && t.text === ".";
  } else if (e.type === "mo" && e.children.length === 1 && e.getAttribute("separator") === "true" && e.getAttribute("lspace") === "0em" && e.getAttribute("rspace") === "0em") {
    var r = e.children[0];
    return r instanceof TextNode && r.text === ",";
  } else
    return !1;
}
var buildExpression = function e(t, r, a) {
  if (t.length === 1) {
    var o = buildGroup(t[0], r);
    return a && o instanceof MathNode && o.type === "mo" && (o.setAttribute("lspace", "0em"), o.setAttribute("rspace", "0em")), [o];
  }
  for (var u = [], c, d = 0; d < t.length; d++) {
    var g = buildGroup(t[d], r);
    if (g instanceof MathNode && c instanceof MathNode) {
      if (g.type === "mtext" && c.type === "mtext" && g.getAttribute("mathvariant") === c.getAttribute("mathvariant")) {
        c.children.push(...g.children);
        continue;
      } else if (g.type === "mn" && c.type === "mn") {
        c.children.push(...g.children);
        continue;
      } else if (isNumberPunctuation(g) && c.type === "mn") {
        c.children.push(...g.children);
        continue;
      } else if (g.type === "mn" && isNumberPunctuation(c))
        g.children = [...c.children, ...g.children], u.pop();
      else if ((g.type === "msup" || g.type === "msub") && g.children.length >= 1 && (c.type === "mn" || isNumberPunctuation(c))) {
        var b = g.children[0];
        b instanceof MathNode && b.type === "mn" && (b.children = [...c.children, ...b.children], u.pop());
      } else if (c.type === "mi" && c.children.length === 1) {
        var _ = c.children[0];
        if (_ instanceof TextNode && _.text === "" && (g.type === "mo" || g.type === "mi" || g.type === "mn")) {
          var y = g.children[0];
          y instanceof TextNode && y.text.length > 0 && (y.text = y.text.slice(0, 1) + "" + y.text.slice(1), u.pop());
        }
      }
    }
    u.push(g), c = g;
  }
  return u;
}, buildExpressionRow = function e(t, r, a) {
  return makeRow(buildExpression(t, r, a));
}, buildGroup = function e(t, r) {
  if (!t)
    return new mathMLTree.MathNode("mrow");
  if (_mathmlGroupBuilders[t.type]) {
    var a = _mathmlGroupBuilders[t.type](t, r);
    return a;
  } else
    throw new ParseError("Got group of unknown type: '" + t.type + "'");
};
function buildMathML(e, t, r, a, o) {
  var u = buildExpression(e, r), c;
  u.length === 1 && u[0] instanceof MathNode && utils.contains(["mrow", "mtable"], u[0].type) ? c = u[0] : c = new mathMLTree.MathNode("mrow", u);
  var d = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(t)]);
  d.setAttribute("encoding", "application/x-tex");
  var g = new mathMLTree.MathNode("semantics", [c, d]), b = new mathMLTree.MathNode("math", [g]);
  b.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"), a && b.setAttribute("display", "block");
  var _ = o ? "katex" : "katex-mathml";
  return buildCommon.makeSpan([_], [b]);
}
var optionsFromSettings = function e(t) {
  return new Options({
    style: t.displayMode ? Style$1.DISPLAY : Style$1.TEXT,
    maxSize: t.maxSize,
    minRuleThickness: t.minRuleThickness
  });
}, displayWrap = function e(t, r) {
  if (r.displayMode) {
    var a = ["katex-display"];
    r.leqno && a.push("leqno"), r.fleqn && a.push("fleqn"), t = buildCommon.makeSpan(a, [t]);
  }
  return t;
}, buildTree = function e(t, r, a) {
  var o = optionsFromSettings(a), u;
  if (a.output === "mathml")
    return buildMathML(t, r, o, a.displayMode, !0);
  if (a.output === "html") {
    var c = buildHTML(t, o);
    u = buildCommon.makeSpan(["katex"], [c]);
  } else {
    var d = buildMathML(t, r, o, a.displayMode, !1), g = buildHTML(t, o);
    u = buildCommon.makeSpan(["katex"], [d, g]);
  }
  return displayWrap(u, a);
}, stretchyCodePoint = {
  widehat: "^",
  widecheck: "",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "",
  underleftarrow: "",
  xleftarrow: "",
  overrightarrow: "",
  underrightarrow: "",
  xrightarrow: "",
  underbrace: "",
  overbrace: "",
  overgroup: "",
  undergroup: "",
  overleftrightarrow: "",
  underleftrightarrow: "",
  xleftrightarrow: "",
  Overrightarrow: "",
  xRightarrow: "",
  overleftharpoon: "",
  xleftharpoonup: "",
  overrightharpoon: "",
  xrightharpoonup: "",
  xLeftarrow: "",
  xLeftrightarrow: "",
  xhookleftarrow: "",
  xhookrightarrow: "",
  xmapsto: "",
  xrightharpoondown: "",
  xleftharpoondown: "",
  xrightleftharpoons: "",
  xleftrightharpoons: "",
  xtwoheadleftarrow: "",
  xtwoheadrightarrow: "",
  xlongequal: "=",
  xtofrom: "",
  xrightleftarrows: "",
  xrightequilibrium: "",
  // Not a perfect match.
  xleftequilibrium: "",
  // None better available.
  "\\cdrightarrow": "",
  "\\cdleftarrow": "",
  "\\cdlongequal": "="
}, mathMLnode = function e(t) {
  var r = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[t.replace(/^\\/, "")])]);
  return r.setAttribute("stretchy", "true"), r;
}, katexImagesData = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
  // CD minwwidth2.5pc
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
}, groupLength = function e(t) {
  return t.type === "ordgroup" ? t.body.length : 1;
}, svgSpan = function e(t, r) {
  function a() {
    var d = 4e5, g = t.label.slice(1);
    if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], g)) {
      var b = t, _ = groupLength(b.base), y, A, E;
      if (_ > 5)
        g === "widehat" || g === "widecheck" ? (y = 420, d = 2364, E = 0.42, A = g + "4") : (y = 312, d = 2340, E = 0.34, A = "tilde4");
      else {
        var v = [1, 1, 2, 2, 3, 3][_];
        g === "widehat" || g === "widecheck" ? (d = [0, 1062, 2364, 2364, 2364][v], y = [0, 239, 300, 360, 420][v], E = [0, 0.24, 0.3, 0.3, 0.36, 0.42][v], A = g + v) : (d = [0, 600, 1033, 2339, 2340][v], y = [0, 260, 286, 306, 312][v], E = [0, 0.26, 0.286, 0.3, 0.306, 0.34][v], A = "tilde" + v);
      }
      var C = new PathNode(A), R = new SvgNode([C], {
        width: "100%",
        height: makeEm(E),
        viewBox: "0 0 " + d + " " + y,
        preserveAspectRatio: "none"
      });
      return {
        span: buildCommon.makeSvgSpan([], [R], r),
        minWidth: 0,
        height: E
      };
    } else {
      var I = [], w = katexImagesData[g], [N, F, M] = w, x = M / 1e3, P = N.length, U, L;
      if (P === 1) {
        var H = w[3];
        U = ["hide-tail"], L = [H];
      } else if (P === 2)
        U = ["halfarrow-left", "halfarrow-right"], L = ["xMinYMin", "xMaxYMin"];
      else if (P === 3)
        U = ["brace-left", "brace-center", "brace-right"], L = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      else
        throw new Error(`Correct katexImagesData or update code here to support
                    ` + P + " children.");
      for (var B = 0; B < P; B++) {
        var V = new PathNode(N[B]), X = new SvgNode([V], {
          width: "400em",
          height: makeEm(x),
          viewBox: "0 0 " + d + " " + M,
          preserveAspectRatio: L[B] + " slice"
        }), de = buildCommon.makeSvgSpan([U[B]], [X], r);
        if (P === 1)
          return {
            span: de,
            minWidth: F,
            height: x
          };
        de.style.height = makeEm(x), I.push(de);
      }
      return {
        span: buildCommon.makeSpan(["stretchy"], I, r),
        minWidth: F,
        height: x
      };
    }
  }
  var {
    span: o,
    minWidth: u,
    height: c
  } = a();
  return o.height = c, o.style.height = makeEm(c), u > 0 && (o.style.minWidth = makeEm(u)), o;
}, encloseSpan = function e(t, r, a, o, u) {
  var c, d = t.height + t.depth + a + o;
  if (/fbox|color|angl/.test(r)) {
    if (c = buildCommon.makeSpan(["stretchy", r], [], u), r === "fbox") {
      var g = u.color && u.getColor();
      g && (c.style.borderColor = g);
    }
  } else {
    var b = [];
    /^[bx]cancel$/.test(r) && b.push(new LineNode({
      x1: "0",
      y1: "0",
      x2: "100%",
      y2: "100%",
      "stroke-width": "0.046em"
    })), /^x?cancel$/.test(r) && b.push(new LineNode({
      x1: "0",
      y1: "100%",
      x2: "100%",
      y2: "0",
      "stroke-width": "0.046em"
    }));
    var _ = new SvgNode(b, {
      width: "100%",
      height: makeEm(d)
    });
    c = buildCommon.makeSvgSpan([], [_], u);
  }
  return c.height = d, c.style.height = makeEm(d), c;
}, stretchy = {
  encloseSpan,
  mathMLnode,
  svgSpan
};
function assertNodeType(e, t) {
  if (!e || e.type !== t)
    throw new Error("Expected node of type " + t + ", but got " + (e ? "node of type " + e.type : String(e)));
  return e;
}
function assertSymbolNodeType(e) {
  var t = checkSymbolNodeType(e);
  if (!t)
    throw new Error("Expected node of symbol group type, but got " + (e ? "node of type " + e.type : String(e)));
  return t;
}
function checkSymbolNodeType(e) {
  return e && (e.type === "atom" || NON_ATOMS.hasOwnProperty(e.type)) ? e : null;
}
var htmlBuilder$a = (e, t) => {
  var r, a, o;
  e && e.type === "supsub" ? (a = assertNodeType(e.base, "accent"), r = a.base, e.base = r, o = assertSpan(buildGroup$1(e, t)), e.base = a) : (a = assertNodeType(e, "accent"), r = a.base);
  var u = buildGroup$1(r, t.havingCrampedStyle()), c = a.isShifty && utils.isCharacterBox(r), d = 0;
  if (c) {
    var g = utils.getBaseElem(r), b = buildGroup$1(g, t.havingCrampedStyle());
    d = assertSymbolDomNode(b).skew;
  }
  var _ = a.label === "\\c", y = _ ? u.height + u.depth : Math.min(u.height, t.fontMetrics().xHeight), A;
  if (a.isStretchy)
    A = stretchy.svgSpan(a, t), A = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: u
      }, {
        type: "elem",
        elem: A,
        wrapperClasses: ["svg-align"],
        wrapperStyle: d > 0 ? {
          width: "calc(100% - " + makeEm(2 * d) + ")",
          marginLeft: makeEm(2 * d)
        } : void 0
      }]
    }, t);
  else {
    var E, v;
    a.label === "\\vec" ? (E = buildCommon.staticSvg("vec", t), v = buildCommon.svgData.vec[1]) : (E = buildCommon.makeOrd({
      mode: a.mode,
      text: a.label
    }, t, "textord"), E = assertSymbolDomNode(E), E.italic = 0, v = E.width, _ && (y += E.depth)), A = buildCommon.makeSpan(["accent-body"], [E]);
    var C = a.label === "\\textcircled";
    C && (A.classes.push("accent-full"), y = u.height);
    var R = d;
    C || (R -= v / 2), A.style.left = makeEm(R), a.label === "\\textcircled" && (A.style.top = ".2em"), A = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: u
      }, {
        type: "kern",
        size: -y
      }, {
        type: "elem",
        elem: A
      }]
    }, t);
  }
  var I = buildCommon.makeSpan(["mord", "accent"], [A], t);
  return o ? (o.children[0] = I, o.height = Math.max(I.height, o.height), o.classes[0] = "mord", o) : I;
}, mathmlBuilder$9 = (e, t) => {
  var r = e.isStretchy ? stretchy.mathMLnode(e.label) : new mathMLTree.MathNode("mo", [makeText(e.label, e.mode)]), a = new mathMLTree.MathNode("mover", [buildGroup(e.base, t), r]);
  return a.setAttribute("accent", "true"), a;
}, NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((e) => "\\" + e).join("|"));
defineFunction({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (e, t) => {
    var r = normalizeArgument(t[0]), a = !NON_STRETCHY_ACCENT_REGEX.test(e.funcName), o = !a || e.funcName === "\\widehat" || e.funcName === "\\widetilde" || e.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: e.parser.mode,
      label: e.funcName,
      isStretchy: a,
      isShifty: o,
      base: r
    };
  },
  htmlBuilder: htmlBuilder$a,
  mathmlBuilder: mathmlBuilder$9
});
defineFunction({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    // unless in strict mode
    argTypes: ["primitive"]
  },
  handler: (e, t) => {
    var r = t[0], a = e.parser.mode;
    return a === "math" && (e.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + e.funcName + " works only in text mode"), a = "text"), {
      type: "accent",
      mode: a,
      label: e.funcName,
      isStretchy: !1,
      isShifty: !0,
      base: r
    };
  },
  htmlBuilder: htmlBuilder$a,
  mathmlBuilder: mathmlBuilder$9
});
defineFunction({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (e, t) => {
    var {
      parser: r,
      funcName: a
    } = e, o = t[0];
    return {
      type: "accentUnder",
      mode: r.mode,
      label: a,
      base: o
    };
  },
  htmlBuilder: (e, t) => {
    var r = buildGroup$1(e.base, t), a = stretchy.svgSpan(e, t), o = e.label === "\\utilde" ? 0.12 : 0, u = buildCommon.makeVList({
      positionType: "top",
      positionData: r.height,
      children: [{
        type: "elem",
        elem: a,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: o
      }, {
        type: "elem",
        elem: r
      }]
    }, t);
    return buildCommon.makeSpan(["mord", "accentunder"], [u], t);
  },
  mathmlBuilder: (e, t) => {
    var r = stretchy.mathMLnode(e.label), a = new mathMLTree.MathNode("munder", [buildGroup(e.base, t), r]);
    return a.setAttribute("accentunder", "true"), a;
  }
});
var paddedNode = (e) => {
  var t = new mathMLTree.MathNode("mpadded", e ? [e] : []);
  return t.setAttribute("width", "+0.6em"), t.setAttribute("lspace", "0.3em"), t;
};
defineFunction({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xrightleftharpoons",
    "\\xleftrightharpoons",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    "\\xtofrom",
    // The next 3 functions are here to support the mhchem extension.
    // Direct use of these functions is discouraged and may break someday.
    "\\xrightleftarrows",
    "\\xrightequilibrium",
    "\\xleftequilibrium",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(e, t, r) {
    var {
      parser: a,
      funcName: o
    } = e;
    return {
      type: "xArrow",
      mode: a.mode,
      label: o,
      body: t[0],
      below: r[0]
    };
  },
  // Flow is unable to correctly infer the type of `group`, even though it's
  // unambiguously determined from the passed-in `type` above.
  htmlBuilder(e, t) {
    var r = t.style, a = t.havingStyle(r.sup()), o = buildCommon.wrapFragment(buildGroup$1(e.body, a, t), t), u = e.label.slice(0, 2) === "\\x" ? "x" : "cd";
    o.classes.push(u + "-arrow-pad");
    var c;
    e.below && (a = t.havingStyle(r.sub()), c = buildCommon.wrapFragment(buildGroup$1(e.below, a, t), t), c.classes.push(u + "-arrow-pad"));
    var d = stretchy.svgSpan(e, t), g = -t.fontMetrics().axisHeight + 0.5 * d.height, b = -t.fontMetrics().axisHeight - 0.5 * d.height - 0.111;
    (o.depth > 0.25 || e.label === "\\xleftequilibrium") && (b -= o.depth);
    var _;
    if (c) {
      var y = -t.fontMetrics().axisHeight + c.height + 0.5 * d.height + 0.111;
      _ = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: o,
          shift: b
        }, {
          type: "elem",
          elem: d,
          shift: g
        }, {
          type: "elem",
          elem: c,
          shift: y
        }]
      }, t);
    } else
      _ = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: o,
          shift: b
        }, {
          type: "elem",
          elem: d,
          shift: g
        }]
      }, t);
    return _.children[0].children[0].children[1].classes.push("svg-align"), buildCommon.makeSpan(["mrel", "x-arrow"], [_], t);
  },
  mathmlBuilder(e, t) {
    var r = stretchy.mathMLnode(e.label);
    r.setAttribute("minsize", e.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    var a;
    if (e.body) {
      var o = paddedNode(buildGroup(e.body, t));
      if (e.below) {
        var u = paddedNode(buildGroup(e.below, t));
        a = new mathMLTree.MathNode("munderover", [r, u, o]);
      } else
        a = new mathMLTree.MathNode("mover", [r, o]);
    } else if (e.below) {
      var c = paddedNode(buildGroup(e.below, t));
      a = new mathMLTree.MathNode("munder", [r, c]);
    } else
      a = paddedNode(), a = new mathMLTree.MathNode("mover", [r, a]);
    return a;
  }
});
var makeSpan = buildCommon.makeSpan;
function htmlBuilder$9(e, t) {
  var r = buildExpression$1(e.body, t, !0);
  return makeSpan([e.mclass], r, t);
}
function mathmlBuilder$8(e, t) {
  var r, a = buildExpression(e.body, t);
  return e.mclass === "minner" ? r = new mathMLTree.MathNode("mpadded", a) : e.mclass === "mord" ? e.isCharacterBox ? (r = a[0], r.type = "mi") : r = new mathMLTree.MathNode("mi", a) : (e.isCharacterBox ? (r = a[0], r.type = "mo") : r = new mathMLTree.MathNode("mo", a), e.mclass === "mbin" ? (r.attributes.lspace = "0.22em", r.attributes.rspace = "0.22em") : e.mclass === "mpunct" ? (r.attributes.lspace = "0em", r.attributes.rspace = "0.17em") : e.mclass === "mopen" || e.mclass === "mclose" ? (r.attributes.lspace = "0em", r.attributes.rspace = "0em") : e.mclass === "minner" && (r.attributes.lspace = "0.0556em", r.attributes.width = "+0.1111em")), r;
}
defineFunction({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler(e, t) {
    var {
      parser: r,
      funcName: a
    } = e, o = t[0];
    return {
      type: "mclass",
      mode: r.mode,
      mclass: "m" + a.slice(5),
      // TODO(kevinb): don't prefix with 'm'
      body: ordargument(o),
      isCharacterBox: utils.isCharacterBox(o)
    };
  },
  htmlBuilder: htmlBuilder$9,
  mathmlBuilder: mathmlBuilder$8
});
var binrelClass = (e) => {
  var t = e.type === "ordgroup" && e.body.length ? e.body[0] : e;
  return t.type === "atom" && (t.family === "bin" || t.family === "rel") ? "m" + t.family : "mord";
};
defineFunction({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler(e, t) {
    var {
      parser: r
    } = e;
    return {
      type: "mclass",
      mode: r.mode,
      mclass: binrelClass(t[0]),
      body: ordargument(t[1]),
      isCharacterBox: utils.isCharacterBox(t[1])
    };
  }
});
defineFunction({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler(e, t) {
    var {
      parser: r,
      funcName: a
    } = e, o = t[1], u = t[0], c;
    a !== "\\stackrel" ? c = binrelClass(o) : c = "mrel";
    var d = {
      type: "op",
      mode: o.mode,
      limits: !0,
      alwaysHandleSupSub: !0,
      parentIsSupSub: !1,
      symbol: !1,
      suppressBaseShift: a !== "\\stackrel",
      body: ordargument(o)
    }, g = {
      type: "supsub",
      mode: u.mode,
      base: d,
      sup: a === "\\underset" ? null : u,
      sub: a === "\\underset" ? u : null
    };
    return {
      type: "mclass",
      mode: r.mode,
      mclass: c,
      body: [g],
      isCharacterBox: utils.isCharacterBox(g)
    };
  },
  htmlBuilder: htmlBuilder$9,
  mathmlBuilder: mathmlBuilder$8
});
defineFunction({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: r
    } = e;
    return {
      type: "pmb",
      mode: r.mode,
      mclass: binrelClass(t[0]),
      body: ordargument(t[0])
    };
  },
  htmlBuilder(e, t) {
    var r = buildExpression$1(e.body, t, !0), a = buildCommon.makeSpan([e.mclass], r, t);
    return a.style.textShadow = "0.02em 0.01em 0.04px", a;
  },
  mathmlBuilder(e, t) {
    var r = buildExpression(e.body, t), a = new mathMLTree.MathNode("mstyle", r);
    return a.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px"), a;
  }
});
var cdArrowFunctionName = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  A: "\\uparrow",
  V: "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
}, newCell = () => ({
  type: "styling",
  body: [],
  mode: "math",
  style: "display"
}), isStartOfArrow = (e) => e.type === "textord" && e.text === "@", isLabelEnd = (e, t) => (e.type === "mathord" || e.type === "atom") && e.text === t;
function cdArrow(e, t, r) {
  var a = cdArrowFunctionName[e];
  switch (a) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return r.callFunction(a, [t[0]], [t[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      var o = r.callFunction("\\\\cdleft", [t[0]], []), u = {
        type: "atom",
        text: a,
        mode: "math",
        family: "rel"
      }, c = r.callFunction("\\Big", [u], []), d = r.callFunction("\\\\cdright", [t[1]], []), g = {
        type: "ordgroup",
        mode: "math",
        body: [o, c, d]
      };
      return r.callFunction("\\\\cdparent", [g], []);
    }
    case "\\\\cdlongequal":
      return r.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      var b = {
        type: "textord",
        text: "\\Vert",
        mode: "math"
      };
      return r.callFunction("\\Big", [b], []);
    }
    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}
function parseCD(e) {
  var t = [];
  for (e.gullet.beginGroup(), e.gullet.macros.set("\\cr", "\\\\\\relax"), e.gullet.beginGroup(); ; ) {
    t.push(e.parseExpression(!1, "\\\\")), e.gullet.endGroup(), e.gullet.beginGroup();
    var r = e.fetch().text;
    if (r === "&" || r === "\\\\")
      e.consume();
    else if (r === "\\end") {
      t[t.length - 1].length === 0 && t.pop();
      break;
    } else
      throw new ParseError("Expected \\\\ or \\cr or \\end", e.nextToken);
  }
  for (var a = [], o = [a], u = 0; u < t.length; u++) {
    for (var c = t[u], d = newCell(), g = 0; g < c.length; g++)
      if (!isStartOfArrow(c[g]))
        d.body.push(c[g]);
      else {
        a.push(d), g += 1;
        var b = assertSymbolNodeType(c[g]).text, _ = new Array(2);
        if (_[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, _[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, !("=|.".indexOf(b) > -1)) if ("<>AV".indexOf(b) > -1)
          for (var y = 0; y < 2; y++) {
            for (var A = !0, E = g + 1; E < c.length; E++) {
              if (isLabelEnd(c[E], b)) {
                A = !1, g = E;
                break;
              }
              if (isStartOfArrow(c[E]))
                throw new ParseError("Missing a " + b + " character to complete a CD arrow.", c[E]);
              _[y].body.push(c[E]);
            }
            if (A)
              throw new ParseError("Missing a " + b + " character to complete a CD arrow.", c[g]);
          }
        else
          throw new ParseError('Expected one of "<>AV=|." after @', c[g]);
        var v = cdArrow(b, _, e), C = {
          type: "styling",
          body: [v],
          mode: "math",
          style: "display"
          // CD is always displaystyle.
        };
        a.push(C), d = newCell();
      }
    u % 2 === 0 ? a.push(d) : a.shift(), a = [], o.push(a);
  }
  e.gullet.endGroup(), e.gullet.endGroup();
  var R = new Array(o[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    // CD package sets \enskip between columns.
    postgap: 0.25
    // So pre and post each get half an \enskip, i.e. 0.25em.
  });
  return {
    type: "array",
    mode: "math",
    body: o,
    arraystretch: 1,
    addJot: !0,
    rowGaps: [null],
    cols: R,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(o.length + 1).fill([])
  };
}
defineFunction({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var {
      parser: r,
      funcName: a
    } = e;
    return {
      type: "cdlabel",
      mode: r.mode,
      side: a.slice(4),
      label: t[0]
    };
  },
  htmlBuilder(e, t) {
    var r = t.havingStyle(t.style.sup()), a = buildCommon.wrapFragment(buildGroup$1(e.label, r, t), t);
    return a.classes.push("cd-label-" + e.side), a.style.bottom = makeEm(0.8 - a.depth), a.height = 0, a.depth = 0, a;
  },
  mathmlBuilder(e, t) {
    var r = new mathMLTree.MathNode("mrow", [buildGroup(e.label, t)]);
    return r = new mathMLTree.MathNode("mpadded", [r]), r.setAttribute("width", "0"), e.side === "left" && r.setAttribute("lspace", "-1width"), r.setAttribute("voffset", "0.7em"), r = new mathMLTree.MathNode("mstyle", [r]), r.setAttribute("displaystyle", "false"), r.setAttribute("scriptlevel", "1"), r;
  }
});
defineFunction({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var {
      parser: r
    } = e;
    return {
      type: "cdlabelparent",
      mode: r.mode,
      fragment: t[0]
    };
  },
  htmlBuilder(e, t) {
    var r = buildCommon.wrapFragment(buildGroup$1(e.fragment, t), t);
    return r.classes.push("cd-vert-arrow"), r;
  },
  mathmlBuilder(e, t) {
    return new mathMLTree.MathNode("mrow", [buildGroup(e.fragment, t)]);
  }
});
defineFunction({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(e, t) {
    for (var {
      parser: r
    } = e, a = assertNodeType(t[0], "ordgroup"), o = a.body, u = "", c = 0; c < o.length; c++) {
      var d = assertNodeType(o[c], "textord");
      u += d.text;
    }
    var g = parseInt(u), b;
    if (isNaN(g))
      throw new ParseError("\\@char has non-numeric argument " + u);
    if (g < 0 || g >= 1114111)
      throw new ParseError("\\@char with invalid code point " + u);
    return g <= 65535 ? b = String.fromCharCode(g) : (g -= 65536, b = String.fromCharCode((g >> 10) + 55296, (g & 1023) + 56320)), {
      type: "textord",
      mode: r.mode,
      text: b
    };
  }
});
var htmlBuilder$8 = (e, t) => {
  var r = buildExpression$1(e.body, t.withColor(e.color), !1);
  return buildCommon.makeFragment(r);
}, mathmlBuilder$7 = (e, t) => {
  var r = buildExpression(e.body, t.withColor(e.color)), a = new mathMLTree.MathNode("mstyle", r);
  return a.setAttribute("mathcolor", e.color), a;
};
defineFunction({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "original"]
  },
  handler(e, t) {
    var {
      parser: r
    } = e, a = assertNodeType(t[0], "color-token").color, o = t[1];
    return {
      type: "color",
      mode: r.mode,
      color: a,
      body: ordargument(o)
    };
  },
  htmlBuilder: htmlBuilder$8,
  mathmlBuilder: mathmlBuilder$7
});
defineFunction({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    argTypes: ["color"]
  },
  handler(e, t) {
    var {
      parser: r,
      breakOnTokenText: a
    } = e, o = assertNodeType(t[0], "color-token").color;
    r.gullet.macros.set("\\current@color", o);
    var u = r.parseExpression(!0, a);
    return {
      type: "color",
      mode: r.mode,
      color: o,
      body: u
    };
  },
  htmlBuilder: htmlBuilder$8,
  mathmlBuilder: mathmlBuilder$7
});
defineFunction({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: !0
  },
  handler(e, t, r) {
    var {
      parser: a
    } = e, o = a.gullet.future().text === "[" ? a.parseSizeGroup(!0) : null, u = !a.settings.displayMode || !a.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
    return {
      type: "cr",
      mode: a.mode,
      newLine: u,
      size: o && assertNodeType(o, "size").value
    };
  },
  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder(e, t) {
    var r = buildCommon.makeSpan(["mspace"], [], t);
    return e.newLine && (r.classes.push("newline"), e.size && (r.style.marginTop = makeEm(calculateSize(e.size, t)))), r;
  },
  mathmlBuilder(e, t) {
    var r = new mathMLTree.MathNode("mspace");
    return e.newLine && (r.setAttribute("linebreak", "newline"), e.size && r.setAttribute("height", makeEm(calculateSize(e.size, t)))), r;
  }
});
var globalMap = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
}, checkControlSequence = (e) => {
  var t = e.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(t))
    throw new ParseError("Expected a control sequence", e);
  return t;
}, getRHS = (e) => {
  var t = e.gullet.popToken();
  return t.text === "=" && (t = e.gullet.popToken(), t.text === " " && (t = e.gullet.popToken())), t;
}, letCommand = (e, t, r, a) => {
  var o = e.gullet.macros.get(r.text);
  o == null && (r.noexpand = !0, o = {
    tokens: [r],
    numArgs: 0,
    // reproduce the same behavior in expansion
    unexpandable: !e.gullet.isExpandable(r.text)
  }), e.gullet.macros.set(t, o, a);
};
defineFunction({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(e) {
    var {
      parser: t,
      funcName: r
    } = e;
    t.consumeSpaces();
    var a = t.fetch();
    if (globalMap[a.text])
      return (r === "\\global" || r === "\\\\globallong") && (a.text = globalMap[a.text]), assertNodeType(t.parseFunction(), "internal");
    throw new ParseError("Invalid token after macro prefix", a);
  }
});
defineFunction({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(e) {
    var {
      parser: t,
      funcName: r
    } = e, a = t.gullet.popToken(), o = a.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(o))
      throw new ParseError("Expected a control sequence", a);
    for (var u = 0, c, d = [[]]; t.gullet.future().text !== "{"; )
      if (a = t.gullet.popToken(), a.text === "#") {
        if (t.gullet.future().text === "{") {
          c = t.gullet.future(), d[u].push("{");
          break;
        }
        if (a = t.gullet.popToken(), !/^[1-9]$/.test(a.text))
          throw new ParseError('Invalid argument number "' + a.text + '"');
        if (parseInt(a.text) !== u + 1)
          throw new ParseError('Argument number "' + a.text + '" out of order');
        u++, d.push([]);
      } else {
        if (a.text === "EOF")
          throw new ParseError("Expected a macro definition");
        d[u].push(a.text);
      }
    var {
      tokens: g
    } = t.gullet.consumeArg();
    return c && g.unshift(c), (r === "\\edef" || r === "\\xdef") && (g = t.gullet.expandTokens(g), g.reverse()), t.gullet.macros.set(o, {
      tokens: g,
      numArgs: u,
      delimiters: d
    }, r === globalMap[r]), {
      type: "internal",
      mode: t.mode
    };
  }
});
defineFunction({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(e) {
    var {
      parser: t,
      funcName: r
    } = e, a = checkControlSequence(t.gullet.popToken());
    t.gullet.consumeSpaces();
    var o = getRHS(t);
    return letCommand(t, a, o, r === "\\\\globallet"), {
      type: "internal",
      mode: t.mode
    };
  }
});
defineFunction({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(e) {
    var {
      parser: t,
      funcName: r
    } = e, a = checkControlSequence(t.gullet.popToken()), o = t.gullet.popToken(), u = t.gullet.popToken();
    return letCommand(t, a, u, r === "\\\\globalfuture"), t.gullet.pushToken(u), t.gullet.pushToken(o), {
      type: "internal",
      mode: t.mode
    };
  }
});
var getMetrics = function e(t, r, a) {
  var o = symbols.math[t] && symbols.math[t].replace, u = getCharacterMetrics(o || t, r, a);
  if (!u)
    throw new Error("Unsupported symbol " + t + " and font size " + r + ".");
  return u;
}, styleWrap = function e(t, r, a, o) {
  var u = a.havingBaseStyle(r), c = buildCommon.makeSpan(o.concat(u.sizingClasses(a)), [t], a), d = u.sizeMultiplier / a.sizeMultiplier;
  return c.height *= d, c.depth *= d, c.maxFontSize = u.sizeMultiplier, c;
}, centerSpan = function e(t, r, a) {
  var o = r.havingBaseStyle(a), u = (1 - r.sizeMultiplier / o.sizeMultiplier) * r.fontMetrics().axisHeight;
  t.classes.push("delimcenter"), t.style.top = makeEm(u), t.height -= u, t.depth += u;
}, makeSmallDelim = function e(t, r, a, o, u, c) {
  var d = buildCommon.makeSymbol(t, "Main-Regular", u, o), g = styleWrap(d, r, o, c);
  return a && centerSpan(g, o, r), g;
}, mathrmSize = function e(t, r, a, o) {
  return buildCommon.makeSymbol(t, "Size" + r + "-Regular", a, o);
}, makeLargeDelim = function e(t, r, a, o, u, c) {
  var d = mathrmSize(t, r, u, o), g = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + r], [d], o), Style$1.TEXT, o, c);
  return a && centerSpan(g, o, Style$1.TEXT), g;
}, makeGlyphSpan = function e(t, r, a) {
  var o;
  r === "Size1-Regular" ? o = "delim-size1" : o = "delim-size4";
  var u = buildCommon.makeSpan(["delimsizinginner", o], [buildCommon.makeSpan([], [buildCommon.makeSymbol(t, r, a)])]);
  return {
    type: "elem",
    elem: u
  };
}, makeInner = function e(t, r, a) {
  var o = fontMetricsData["Size4-Regular"][t.charCodeAt(0)] ? fontMetricsData["Size4-Regular"][t.charCodeAt(0)][4] : fontMetricsData["Size1-Regular"][t.charCodeAt(0)][4], u = new PathNode("inner", innerPath(t, Math.round(1e3 * r))), c = new SvgNode([u], {
    width: makeEm(o),
    height: makeEm(r),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + makeEm(o),
    viewBox: "0 0 " + 1e3 * o + " " + Math.round(1e3 * r),
    preserveAspectRatio: "xMinYMin"
  }), d = buildCommon.makeSvgSpan([], [c], a);
  return d.height = r, d.style.height = makeEm(r), d.style.width = makeEm(o), {
    type: "elem",
    elem: d
  };
}, lapInEms = 8e-3, lap = {
  type: "kern",
  size: -1 * lapInEms
}, verts = ["|", "\\lvert", "\\rvert", "\\vert"], doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"], makeStackedDelim = function e(t, r, a, o, u, c) {
  var d, g, b, _, y = "", A = 0;
  d = b = _ = t, g = null;
  var E = "Size1-Regular";
  t === "\\uparrow" ? b = _ = "" : t === "\\Uparrow" ? b = _ = "" : t === "\\downarrow" ? d = b = "" : t === "\\Downarrow" ? d = b = "" : t === "\\updownarrow" ? (d = "\\uparrow", b = "", _ = "\\downarrow") : t === "\\Updownarrow" ? (d = "\\Uparrow", b = "", _ = "\\Downarrow") : utils.contains(verts, t) ? (b = "", y = "vert", A = 333) : utils.contains(doubleVerts, t) ? (b = "", y = "doublevert", A = 556) : t === "[" || t === "\\lbrack" ? (d = "", b = "", _ = "", E = "Size4-Regular", y = "lbrack", A = 667) : t === "]" || t === "\\rbrack" ? (d = "", b = "", _ = "", E = "Size4-Regular", y = "rbrack", A = 667) : t === "\\lfloor" || t === "" ? (b = d = "", _ = "", E = "Size4-Regular", y = "lfloor", A = 667) : t === "\\lceil" || t === "" ? (d = "", b = _ = "", E = "Size4-Regular", y = "lceil", A = 667) : t === "\\rfloor" || t === "" ? (b = d = "", _ = "", E = "Size4-Regular", y = "rfloor", A = 667) : t === "\\rceil" || t === "" ? (d = "", b = _ = "", E = "Size4-Regular", y = "rceil", A = 667) : t === "(" || t === "\\lparen" ? (d = "", b = "", _ = "", E = "Size4-Regular", y = "lparen", A = 875) : t === ")" || t === "\\rparen" ? (d = "", b = "", _ = "", E = "Size4-Regular", y = "rparen", A = 875) : t === "\\{" || t === "\\lbrace" ? (d = "", g = "", _ = "", b = "", E = "Size4-Regular") : t === "\\}" || t === "\\rbrace" ? (d = "", g = "", _ = "", b = "", E = "Size4-Regular") : t === "\\lgroup" || t === "" ? (d = "", _ = "", b = "", E = "Size4-Regular") : t === "\\rgroup" || t === "" ? (d = "", _ = "", b = "", E = "Size4-Regular") : t === "\\lmoustache" || t === "" ? (d = "", _ = "", b = "", E = "Size4-Regular") : (t === "\\rmoustache" || t === "") && (d = "", _ = "", b = "", E = "Size4-Regular");
  var v = getMetrics(d, E, u), C = v.height + v.depth, R = getMetrics(b, E, u), I = R.height + R.depth, w = getMetrics(_, E, u), N = w.height + w.depth, F = 0, M = 1;
  if (g !== null) {
    var x = getMetrics(g, E, u);
    F = x.height + x.depth, M = 2;
  }
  var P = C + N + F, U = Math.max(0, Math.ceil((r - P) / (M * I))), L = P + U * M * I, H = o.fontMetrics().axisHeight;
  a && (H *= o.sizeMultiplier);
  var B = L / 2 - H, V = [];
  if (y.length > 0) {
    var X = L - C - N, de = Math.round(L * 1e3), Y = tallDelim(y, Math.round(X * 1e3)), se = new PathNode(y, Y), ue = (A / 1e3).toFixed(3) + "em", pe = (de / 1e3).toFixed(3) + "em", J = new SvgNode([se], {
      width: ue,
      height: pe,
      viewBox: "0 0 " + A + " " + de
    }), j = buildCommon.makeSvgSpan([], [J], o);
    j.height = de / 1e3, j.style.width = ue, j.style.height = pe, V.push({
      type: "elem",
      elem: j
    });
  } else {
    if (V.push(makeGlyphSpan(_, E, u)), V.push(lap), g === null) {
      var le = L - C - N + 2 * lapInEms;
      V.push(makeInner(b, le, o));
    } else {
      var Z = (L - C - N - F) / 2 + 2 * lapInEms;
      V.push(makeInner(b, Z, o)), V.push(lap), V.push(makeGlyphSpan(g, E, u)), V.push(lap), V.push(makeInner(b, Z, o));
    }
    V.push(lap), V.push(makeGlyphSpan(d, E, u));
  }
  var O = o.havingBaseStyle(Style$1.TEXT), z = buildCommon.makeVList({
    positionType: "bottom",
    positionData: B,
    children: V
  }, O);
  return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [z], O), Style$1.TEXT, o, c);
}, vbPad = 80, emPad = 0.08, sqrtSvg = function e(t, r, a, o, u) {
  var c = sqrtPath(t, o, a), d = new PathNode(t, c), g = new SvgNode([d], {
    // Note: 1000:1 ratio of viewBox to document em width.
    width: "400em",
    height: makeEm(r),
    viewBox: "0 0 400000 " + a,
    preserveAspectRatio: "xMinYMin slice"
  });
  return buildCommon.makeSvgSpan(["hide-tail"], [g], u);
}, makeSqrtImage = function e(t, r) {
  var a = r.havingBaseSizing(), o = traverseSequence("\\surd", t * a.sizeMultiplier, stackLargeDelimiterSequence, a), u = a.sizeMultiplier, c = Math.max(0, r.minRuleThickness - r.fontMetrics().sqrtRuleThickness), d, g = 0, b = 0, _ = 0, y;
  return o.type === "small" ? (_ = 1e3 + 1e3 * c + vbPad, t < 1 ? u = 1 : t < 1.4 && (u = 0.7), g = (1 + c + emPad) / u, b = (1 + c) / u, d = sqrtSvg("sqrtMain", g, _, c, r), d.style.minWidth = "0.853em", y = 0.833 / u) : o.type === "large" ? (_ = (1e3 + vbPad) * sizeToMaxHeight[o.size], b = (sizeToMaxHeight[o.size] + c) / u, g = (sizeToMaxHeight[o.size] + c + emPad) / u, d = sqrtSvg("sqrtSize" + o.size, g, _, c, r), d.style.minWidth = "1.02em", y = 1 / u) : (g = t + c + emPad, b = t + c, _ = Math.floor(1e3 * t + c) + vbPad, d = sqrtSvg("sqrtTall", g, _, c, r), d.style.minWidth = "0.742em", y = 1.056), d.height = b, d.style.height = makeEm(g), {
    span: d,
    advanceWidth: y,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: (r.fontMetrics().sqrtRuleThickness + c) * u
  };
}, stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "", "", "\\lceil", "\\rceil", "", "", "\\surd"], stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "", "", "\\lmoustache", "\\rmoustache", "", ""], stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"], sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3], makeSizedDelim = function e(t, r, a, o, u) {
  if (t === "<" || t === "\\lt" || t === "" ? t = "\\langle" : (t === ">" || t === "\\gt" || t === "") && (t = "\\rangle"), utils.contains(stackLargeDelimiters, t) || utils.contains(stackNeverDelimiters, t))
    return makeLargeDelim(t, r, !1, a, o, u);
  if (utils.contains(stackAlwaysDelimiters, t))
    return makeStackedDelim(t, sizeToMaxHeight[r], !1, a, o, u);
  throw new ParseError("Illegal delimiter: '" + t + "'");
}, stackNeverDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}], stackAlwaysDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "stack"
}], stackLargeDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}], delimTypeToFont = function e(t) {
  if (t.type === "small")
    return "Main-Regular";
  if (t.type === "large")
    return "Size" + t.size + "-Regular";
  if (t.type === "stack")
    return "Size4-Regular";
  throw new Error("Add support for delim type '" + t.type + "' here.");
}, traverseSequence = function e(t, r, a, o) {
  for (var u = Math.min(2, 3 - o.style.size), c = u; c < a.length && a[c].type !== "stack"; c++) {
    var d = getMetrics(t, delimTypeToFont(a[c]), "math"), g = d.height + d.depth;
    if (a[c].type === "small") {
      var b = o.havingBaseStyle(a[c].style);
      g *= b.sizeMultiplier;
    }
    if (g > r)
      return a[c];
  }
  return a[a.length - 1];
}, makeCustomSizedDelim = function e(t, r, a, o, u, c) {
  t === "<" || t === "\\lt" || t === "" ? t = "\\langle" : (t === ">" || t === "\\gt" || t === "") && (t = "\\rangle");
  var d;
  utils.contains(stackNeverDelimiters, t) ? d = stackNeverDelimiterSequence : utils.contains(stackLargeDelimiters, t) ? d = stackLargeDelimiterSequence : d = stackAlwaysDelimiterSequence;
  var g = traverseSequence(t, r, d, o);
  return g.type === "small" ? makeSmallDelim(t, g.style, a, o, u, c) : g.type === "large" ? makeLargeDelim(t, g.size, a, o, u, c) : makeStackedDelim(t, r, a, o, u, c);
}, makeLeftRightDelim = function e(t, r, a, o, u, c) {
  var d = o.fontMetrics().axisHeight * o.sizeMultiplier, g = 901, b = 5 / o.fontMetrics().ptPerEm, _ = Math.max(r - d, a + d), y = Math.max(
    // In real TeX, calculations are done using integral values which are
    // 65536 per pt, or 655360 per em. So, the division here truncates in
    // TeX but doesn't here, producing different results. If we wanted to
    // exactly match TeX's calculation, we could do
    //   Math.floor(655360 * maxDistFromAxis / 500) *
    //    delimiterFactor / 655360
    // (To see the difference, compare
    //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
    // in TeX and KaTeX)
    _ / 500 * g,
    2 * _ - b
  );
  return makeCustomSizedDelim(t, y, !0, o, u, c);
}, delimiter = {
  sqrtImage: makeSqrtImage,
  sizedDelim: makeSizedDelim,
  sizeToMaxHeight,
  customSizedDelim: makeCustomSizedDelim,
  leftRightDelim: makeLeftRightDelim
}, delimiterSizes = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
}, delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "", "", "\\lceil", "\\rceil", "", "", "<", ">", "\\langle", "", "\\rangle", "", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "", "", "\\lmoustache", "\\rmoustache", "", "", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
function checkDelimiter(e, t) {
  var r = checkSymbolNodeType(e);
  if (r && utils.contains(delimiters, r.text))
    return r;
  throw r ? new ParseError("Invalid delimiter '" + r.text + "' after '" + t.funcName + "'", e) : new ParseError("Invalid delimiter type '" + e.type + "'", e);
}
defineFunction({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (e, t) => {
    var r = checkDelimiter(t[0], e);
    return {
      type: "delimsizing",
      mode: e.parser.mode,
      size: delimiterSizes[e.funcName].size,
      mclass: delimiterSizes[e.funcName].mclass,
      delim: r.text
    };
  },
  htmlBuilder: (e, t) => e.delim === "." ? buildCommon.makeSpan([e.mclass]) : delimiter.sizedDelim(e.delim, e.size, t, e.mode, [e.mclass]),
  mathmlBuilder: (e) => {
    var t = [];
    e.delim !== "." && t.push(makeText(e.delim, e.mode));
    var r = new mathMLTree.MathNode("mo", t);
    e.mclass === "mopen" || e.mclass === "mclose" ? r.setAttribute("fence", "true") : r.setAttribute("fence", "false"), r.setAttribute("stretchy", "true");
    var a = makeEm(delimiter.sizeToMaxHeight[e.size]);
    return r.setAttribute("minsize", a), r.setAttribute("maxsize", a), r;
  }
});
function assertParsed(e) {
  if (!e.body)
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
}
defineFunction({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (e, t) => {
    var r = e.parser.gullet.macros.get("\\current@color");
    if (r && typeof r != "string")
      throw new ParseError("\\current@color set to non-string in \\right");
    return {
      type: "leftright-right",
      mode: e.parser.mode,
      delim: checkDelimiter(t[0], e).text,
      color: r
      // undefined if not set via \color
    };
  }
});
defineFunction({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (e, t) => {
    var r = checkDelimiter(t[0], e), a = e.parser;
    ++a.leftrightDepth;
    var o = a.parseExpression(!1);
    --a.leftrightDepth, a.expect("\\right", !1);
    var u = assertNodeType(a.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: a.mode,
      body: o,
      left: r.text,
      right: u.delim,
      rightColor: u.color
    };
  },
  htmlBuilder: (e, t) => {
    assertParsed(e);
    for (var r = buildExpression$1(e.body, t, !0, ["mopen", "mclose"]), a = 0, o = 0, u = !1, c = 0; c < r.length; c++)
      r[c].isMiddle ? u = !0 : (a = Math.max(r[c].height, a), o = Math.max(r[c].depth, o));
    a *= t.sizeMultiplier, o *= t.sizeMultiplier;
    var d;
    if (e.left === "." ? d = makeNullDelimiter(t, ["mopen"]) : d = delimiter.leftRightDelim(e.left, a, o, t, e.mode, ["mopen"]), r.unshift(d), u)
      for (var g = 1; g < r.length; g++) {
        var b = r[g], _ = b.isMiddle;
        _ && (r[g] = delimiter.leftRightDelim(_.delim, a, o, _.options, e.mode, []));
      }
    var y;
    if (e.right === ".")
      y = makeNullDelimiter(t, ["mclose"]);
    else {
      var A = e.rightColor ? t.withColor(e.rightColor) : t;
      y = delimiter.leftRightDelim(e.right, a, o, A, e.mode, ["mclose"]);
    }
    return r.push(y), buildCommon.makeSpan(["minner"], r, t);
  },
  mathmlBuilder: (e, t) => {
    assertParsed(e);
    var r = buildExpression(e.body, t);
    if (e.left !== ".") {
      var a = new mathMLTree.MathNode("mo", [makeText(e.left, e.mode)]);
      a.setAttribute("fence", "true"), r.unshift(a);
    }
    if (e.right !== ".") {
      var o = new mathMLTree.MathNode("mo", [makeText(e.right, e.mode)]);
      o.setAttribute("fence", "true"), e.rightColor && o.setAttribute("mathcolor", e.rightColor), r.push(o);
    }
    return makeRow(r);
  }
});
defineFunction({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (e, t) => {
    var r = checkDelimiter(t[0], e);
    if (!e.parser.leftrightDepth)
      throw new ParseError("\\middle without preceding \\left", r);
    return {
      type: "middle",
      mode: e.parser.mode,
      delim: r.text
    };
  },
  htmlBuilder: (e, t) => {
    var r;
    if (e.delim === ".")
      r = makeNullDelimiter(t, []);
    else {
      r = delimiter.sizedDelim(e.delim, 1, t, e.mode, []);
      var a = {
        delim: e.delim,
        options: t
      };
      r.isMiddle = a;
    }
    return r;
  },
  mathmlBuilder: (e, t) => {
    var r = e.delim === "\\vert" || e.delim === "|" ? makeText("|", "text") : makeText(e.delim, e.mode), a = new mathMLTree.MathNode("mo", [r]);
    return a.setAttribute("fence", "true"), a.setAttribute("lspace", "0.05em"), a.setAttribute("rspace", "0.05em"), a;
  }
});
var htmlBuilder$7 = (e, t) => {
  var r = buildCommon.wrapFragment(buildGroup$1(e.body, t), t), a = e.label.slice(1), o = t.sizeMultiplier, u, c = 0, d = utils.isCharacterBox(e.body);
  if (a === "sout")
    u = buildCommon.makeSpan(["stretchy", "sout"]), u.height = t.fontMetrics().defaultRuleThickness / o, c = -0.5 * t.fontMetrics().xHeight;
  else if (a === "phase") {
    var g = calculateSize({
      number: 0.6,
      unit: "pt"
    }, t), b = calculateSize({
      number: 0.35,
      unit: "ex"
    }, t), _ = t.havingBaseSizing();
    o = o / _.sizeMultiplier;
    var y = r.height + r.depth + g + b;
    r.style.paddingLeft = makeEm(y / 2 + g);
    var A = Math.floor(1e3 * y * o), E = phasePath(A), v = new SvgNode([new PathNode("phase", E)], {
      width: "400em",
      height: makeEm(A / 1e3),
      viewBox: "0 0 400000 " + A,
      preserveAspectRatio: "xMinYMin slice"
    });
    u = buildCommon.makeSvgSpan(["hide-tail"], [v], t), u.style.height = makeEm(y), c = r.depth + g + b;
  } else {
    /cancel/.test(a) ? d || r.classes.push("cancel-pad") : a === "angl" ? r.classes.push("anglpad") : r.classes.push("boxpad");
    var C = 0, R = 0, I = 0;
    /box/.test(a) ? (I = Math.max(
      t.fontMetrics().fboxrule,
      // default
      t.minRuleThickness
      // User override.
    ), C = t.fontMetrics().fboxsep + (a === "colorbox" ? 0 : I), R = C) : a === "angl" ? (I = Math.max(t.fontMetrics().defaultRuleThickness, t.minRuleThickness), C = 4 * I, R = Math.max(0, 0.25 - r.depth)) : (C = d ? 0.2 : 0, R = C), u = stretchy.encloseSpan(r, a, C, R, t), /fbox|boxed|fcolorbox/.test(a) ? (u.style.borderStyle = "solid", u.style.borderWidth = makeEm(I)) : a === "angl" && I !== 0.049 && (u.style.borderTopWidth = makeEm(I), u.style.borderRightWidth = makeEm(I)), c = r.depth + R, e.backgroundColor && (u.style.backgroundColor = e.backgroundColor, e.borderColor && (u.style.borderColor = e.borderColor));
  }
  var w;
  if (e.backgroundColor)
    w = buildCommon.makeVList({
      positionType: "individualShift",
      children: [
        // Put the color background behind inner;
        {
          type: "elem",
          elem: u,
          shift: c
        },
        {
          type: "elem",
          elem: r,
          shift: 0
        }
      ]
    }, t);
  else {
    var N = /cancel|phase/.test(a) ? ["svg-align"] : [];
    w = buildCommon.makeVList({
      positionType: "individualShift",
      children: [
        // Write the \cancel stroke on top of inner.
        {
          type: "elem",
          elem: r,
          shift: 0
        },
        {
          type: "elem",
          elem: u,
          shift: c,
          wrapperClasses: N
        }
      ]
    }, t);
  }
  return /cancel/.test(a) && (w.height = r.height, w.depth = r.depth), /cancel/.test(a) && !d ? buildCommon.makeSpan(["mord", "cancel-lap"], [w], t) : buildCommon.makeSpan(["mord"], [w], t);
}, mathmlBuilder$6 = (e, t) => {
  var r = 0, a = new mathMLTree.MathNode(e.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildGroup(e.body, t)]);
  switch (e.label) {
    case "\\cancel":
      a.setAttribute("notation", "updiagonalstrike");
      break;
    case "\\bcancel":
      a.setAttribute("notation", "downdiagonalstrike");
      break;
    case "\\phase":
      a.setAttribute("notation", "phasorangle");
      break;
    case "\\sout":
      a.setAttribute("notation", "horizontalstrike");
      break;
    case "\\fbox":
      a.setAttribute("notation", "box");
      break;
    case "\\angl":
      a.setAttribute("notation", "actuarial");
      break;
    case "\\fcolorbox":
    case "\\colorbox":
      if (r = t.fontMetrics().fboxsep * t.fontMetrics().ptPerEm, a.setAttribute("width", "+" + 2 * r + "pt"), a.setAttribute("height", "+" + 2 * r + "pt"), a.setAttribute("lspace", r + "pt"), a.setAttribute("voffset", r + "pt"), e.label === "\\fcolorbox") {
        var o = Math.max(
          t.fontMetrics().fboxrule,
          // default
          t.minRuleThickness
          // user override
        );
        a.setAttribute("style", "border: " + o + "em solid " + String(e.borderColor));
      }
      break;
    case "\\xcancel":
      a.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }
  return e.backgroundColor && a.setAttribute("mathbackground", e.backgroundColor), a;
};
defineFunction({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "text"]
  },
  handler(e, t, r) {
    var {
      parser: a,
      funcName: o
    } = e, u = assertNodeType(t[0], "color-token").color, c = t[1];
    return {
      type: "enclose",
      mode: a.mode,
      label: o,
      backgroundColor: u,
      body: c
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: !0,
    argTypes: ["color", "color", "text"]
  },
  handler(e, t, r) {
    var {
      parser: a,
      funcName: o
    } = e, u = assertNodeType(t[0], "color-token").color, c = assertNodeType(t[1], "color-token").color, d = t[2];
    return {
      type: "enclose",
      mode: a.mode,
      label: o,
      backgroundColor: c,
      borderColor: u,
      body: d
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: r
    } = e;
    return {
      type: "enclose",
      mode: r.mode,
      label: "\\fbox",
      body: t[0]
    };
  }
});
defineFunction({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var {
      parser: r,
      funcName: a
    } = e, o = t[0];
    return {
      type: "enclose",
      mode: r.mode,
      label: a,
      body: o
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !1
  },
  handler(e, t) {
    var {
      parser: r
    } = e;
    return {
      type: "enclose",
      mode: r.mode,
      label: "\\angl",
      body: t[0]
    };
  }
});
var _environments = {};
function defineEnvironment(e) {
  for (var {
    type: t,
    names: r,
    props: a,
    handler: o,
    htmlBuilder: u,
    mathmlBuilder: c
  } = e, d = {
    type: t,
    numArgs: a.numArgs || 0,
    allowedInText: !1,
    numOptionalArgs: 0,
    handler: o
  }, g = 0; g < r.length; ++g)
    _environments[r[g]] = d;
  u && (_htmlGroupBuilders[t] = u), c && (_mathmlGroupBuilders[t] = c);
}
var _macros = {};
function defineMacro(e, t) {
  _macros[e] = t;
}
function getHLines(e) {
  var t = [];
  e.consumeSpaces();
  var r = e.fetch().text;
  for (r === "\\relax" && (e.consume(), e.consumeSpaces(), r = e.fetch().text); r === "\\hline" || r === "\\hdashline"; )
    e.consume(), t.push(r === "\\hdashline"), e.consumeSpaces(), r = e.fetch().text;
  return t;
}
var validateAmsEnvironmentContext = (e) => {
  var t = e.parser.settings;
  if (!t.displayMode)
    throw new ParseError("{" + e.envName + "} can be used only in display mode.");
};
function getAutoTag(e) {
  if (e.indexOf("ed") === -1)
    return e.indexOf("*") === -1;
}
function parseArray(e, t, r) {
  var {
    hskipBeforeAndAfter: a,
    addJot: o,
    cols: u,
    arraystretch: c,
    colSeparationType: d,
    autoTag: g,
    singleRow: b,
    emptySingleRow: _,
    maxNumCols: y,
    leqno: A
  } = t;
  if (e.gullet.beginGroup(), b || e.gullet.macros.set("\\cr", "\\\\\\relax"), !c) {
    var E = e.gullet.expandMacroAsText("\\arraystretch");
    if (E == null)
      c = 1;
    else if (c = parseFloat(E), !c || c < 0)
      throw new ParseError("Invalid \\arraystretch: " + E);
  }
  e.gullet.beginGroup();
  var v = [], C = [v], R = [], I = [], w = g != null ? [] : void 0;
  function N() {
    g && e.gullet.macros.set("\\@eqnsw", "1", !0);
  }
  function F() {
    w && (e.gullet.macros.get("\\df@tag") ? (w.push(e.subparse([new Token("\\df@tag")])), e.gullet.macros.set("\\df@tag", void 0, !0)) : w.push(!!g && e.gullet.macros.get("\\@eqnsw") === "1"));
  }
  for (N(), I.push(getHLines(e)); ; ) {
    var M = e.parseExpression(!1, b ? "\\end" : "\\\\");
    e.gullet.endGroup(), e.gullet.beginGroup(), M = {
      type: "ordgroup",
      mode: e.mode,
      body: M
    }, r && (M = {
      type: "styling",
      mode: e.mode,
      style: r,
      body: [M]
    }), v.push(M);
    var x = e.fetch().text;
    if (x === "&") {
      if (y && v.length === y) {
        if (b || d)
          throw new ParseError("Too many tab characters: &", e.nextToken);
        e.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
      }
      e.consume();
    } else if (x === "\\end") {
      F(), v.length === 1 && M.type === "styling" && M.body[0].body.length === 0 && (C.length > 1 || !_) && C.pop(), I.length < C.length + 1 && I.push([]);
      break;
    } else if (x === "\\\\") {
      e.consume();
      var P = void 0;
      e.gullet.future().text !== " " && (P = e.parseSizeGroup(!0)), R.push(P ? P.value : null), F(), I.push(getHLines(e)), v = [], C.push(v), N();
    } else
      throw new ParseError("Expected & or \\\\ or \\cr or \\end", e.nextToken);
  }
  return e.gullet.endGroup(), e.gullet.endGroup(), {
    type: "array",
    mode: e.mode,
    addJot: o,
    arraystretch: c,
    body: C,
    cols: u,
    rowGaps: R,
    hskipBeforeAndAfter: a,
    hLinesBeforeRow: I,
    colSeparationType: d,
    tags: w,
    leqno: A
  };
}
function dCellStyle(e) {
  return e.slice(0, 1) === "d" ? "display" : "text";
}
var htmlBuilder$6 = function e(t, r) {
  var a, o, u = t.body.length, c = t.hLinesBeforeRow, d = 0, g = new Array(u), b = [], _ = Math.max(
    // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
    r.fontMetrics().arrayRuleWidth,
    r.minRuleThickness
    // User override.
  ), y = 1 / r.fontMetrics().ptPerEm, A = 5 * y;
  if (t.colSeparationType && t.colSeparationType === "small") {
    var E = r.havingStyle(Style$1.SCRIPT).sizeMultiplier;
    A = 0.2778 * (E / r.sizeMultiplier);
  }
  var v = t.colSeparationType === "CD" ? calculateSize({
    number: 3,
    unit: "ex"
  }, r) : 12 * y, C = 3 * y, R = t.arraystretch * v, I = 0.7 * R, w = 0.3 * R, N = 0;
  function F(Q) {
    for (var K = 0; K < Q.length; ++K)
      K > 0 && (N += 0.25), b.push({
        pos: N,
        isDashed: Q[K]
      });
  }
  for (F(c[0]), a = 0; a < t.body.length; ++a) {
    var M = t.body[a], x = I, P = w;
    d < M.length && (d = M.length);
    var U = new Array(M.length);
    for (o = 0; o < M.length; ++o) {
      var L = buildGroup$1(M[o], r);
      P < L.depth && (P = L.depth), x < L.height && (x = L.height), U[o] = L;
    }
    var H = t.rowGaps[a], B = 0;
    H && (B = calculateSize(H, r), B > 0 && (B += w, P < B && (P = B), B = 0)), t.addJot && (P += C), U.height = x, U.depth = P, N += x, U.pos = N, N += P + B, g[a] = U, F(c[a + 1]);
  }
  var V = N / 2 + r.fontMetrics().axisHeight, X = t.cols || [], de = [], Y, se, ue = [];
  if (t.tags && t.tags.some((Q) => Q))
    for (a = 0; a < u; ++a) {
      var pe = g[a], J = pe.pos - V, j = t.tags[a], le = void 0;
      j === !0 ? le = buildCommon.makeSpan(["eqn-num"], [], r) : j === !1 ? le = buildCommon.makeSpan([], [], r) : le = buildCommon.makeSpan([], buildExpression$1(j, r, !0), r), le.depth = pe.depth, le.height = pe.height, ue.push({
        type: "elem",
        elem: le,
        shift: J
      });
    }
  for (
    o = 0, se = 0;
    // Continue while either there are more columns or more column
    // descriptions, so trailing separators don't get lost.
    o < d || se < X.length;
    ++o, ++se
  ) {
    for (var Z = X[se] || {}, O = !0; Z.type === "separator"; ) {
      if (O || (Y = buildCommon.makeSpan(["arraycolsep"], []), Y.style.width = makeEm(r.fontMetrics().doubleRuleSep), de.push(Y)), Z.separator === "|" || Z.separator === ":") {
        var z = Z.separator === "|" ? "solid" : "dashed", W = buildCommon.makeSpan(["vertical-separator"], [], r);
        W.style.height = makeEm(N), W.style.borderRightWidth = makeEm(_), W.style.borderRightStyle = z, W.style.margin = "0 " + makeEm(-_ / 2);
        var ee = N - V;
        ee && (W.style.verticalAlign = makeEm(-ee)), de.push(W);
      } else
        throw new ParseError("Invalid separator type: " + Z.separator);
      se++, Z = X[se] || {}, O = !1;
    }
    if (!(o >= d)) {
      var ae = void 0;
      (o > 0 || t.hskipBeforeAndAfter) && (ae = utils.deflt(Z.pregap, A), ae !== 0 && (Y = buildCommon.makeSpan(["arraycolsep"], []), Y.style.width = makeEm(ae), de.push(Y)));
      var ie = [];
      for (a = 0; a < u; ++a) {
        var me = g[a], ye = me[o];
        if (ye) {
          var Re = me.pos - V;
          ye.depth = me.depth, ye.height = me.height, ie.push({
            type: "elem",
            elem: ye,
            shift: Re
          });
        }
      }
      ie = buildCommon.makeVList({
        positionType: "individualShift",
        children: ie
      }, r), ie = buildCommon.makeSpan(["col-align-" + (Z.align || "c")], [ie]), de.push(ie), (o < d - 1 || t.hskipBeforeAndAfter) && (ae = utils.deflt(Z.postgap, A), ae !== 0 && (Y = buildCommon.makeSpan(["arraycolsep"], []), Y.style.width = makeEm(ae), de.push(Y)));
    }
  }
  if (g = buildCommon.makeSpan(["mtable"], de), b.length > 0) {
    for (var De = buildCommon.makeLineSpan("hline", r, _), Pe = buildCommon.makeLineSpan("hdashline", r, _), he = [{
      type: "elem",
      elem: g,
      shift: 0
    }]; b.length > 0; ) {
      var Le = b.pop(), Ee = Le.pos - V;
      Le.isDashed ? he.push({
        type: "elem",
        elem: Pe,
        shift: Ee
      }) : he.push({
        type: "elem",
        elem: De,
        shift: Ee
      });
    }
    g = buildCommon.makeVList({
      positionType: "individualShift",
      children: he
    }, r);
  }
  if (ue.length === 0)
    return buildCommon.makeSpan(["mord"], [g], r);
  var Se = buildCommon.makeVList({
    positionType: "individualShift",
    children: ue
  }, r);
  return Se = buildCommon.makeSpan(["tag"], [Se], r), buildCommon.makeFragment([g, Se]);
}, alignMap = {
  c: "center ",
  l: "left ",
  r: "right "
}, mathmlBuilder$5 = function e(t, r) {
  for (var a = [], o = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]), u = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]), c = 0; c < t.body.length; c++) {
    for (var d = t.body[c], g = [], b = 0; b < d.length; b++)
      g.push(new mathMLTree.MathNode("mtd", [buildGroup(d[b], r)]));
    t.tags && t.tags[c] && (g.unshift(o), g.push(o), t.leqno ? g.unshift(u) : g.push(u)), a.push(new mathMLTree.MathNode("mtr", g));
  }
  var _ = new mathMLTree.MathNode("mtable", a), y = t.arraystretch === 0.5 ? 0.1 : 0.16 + t.arraystretch - 1 + (t.addJot ? 0.09 : 0);
  _.setAttribute("rowspacing", makeEm(y));
  var A = "", E = "";
  if (t.cols && t.cols.length > 0) {
    var v = t.cols, C = "", R = !1, I = 0, w = v.length;
    v[0].type === "separator" && (A += "top ", I = 1), v[v.length - 1].type === "separator" && (A += "bottom ", w -= 1);
    for (var N = I; N < w; N++)
      v[N].type === "align" ? (E += alignMap[v[N].align], R && (C += "none "), R = !0) : v[N].type === "separator" && R && (C += v[N].separator === "|" ? "solid " : "dashed ", R = !1);
    _.setAttribute("columnalign", E.trim()), /[sd]/.test(C) && _.setAttribute("columnlines", C.trim());
  }
  if (t.colSeparationType === "align") {
    for (var F = t.cols || [], M = "", x = 1; x < F.length; x++)
      M += x % 2 ? "0em " : "1em ";
    _.setAttribute("columnspacing", M.trim());
  } else t.colSeparationType === "alignat" || t.colSeparationType === "gather" ? _.setAttribute("columnspacing", "0em") : t.colSeparationType === "small" ? _.setAttribute("columnspacing", "0.2778em") : t.colSeparationType === "CD" ? _.setAttribute("columnspacing", "0.5em") : _.setAttribute("columnspacing", "1em");
  var P = "", U = t.hLinesBeforeRow;
  A += U[0].length > 0 ? "left " : "", A += U[U.length - 1].length > 0 ? "right " : "";
  for (var L = 1; L < U.length - 1; L++)
    P += U[L].length === 0 ? "none " : U[L][0] ? "dashed " : "solid ";
  return /[sd]/.test(P) && _.setAttribute("rowlines", P.trim()), A !== "" && (_ = new mathMLTree.MathNode("menclose", [_]), _.setAttribute("notation", A.trim())), t.arraystretch && t.arraystretch < 1 && (_ = new mathMLTree.MathNode("mstyle", [_]), _.setAttribute("scriptlevel", "1")), _;
}, alignedHandler = function e(t, r) {
  t.envName.indexOf("ed") === -1 && validateAmsEnvironmentContext(t);
  var a = [], o = t.envName.indexOf("at") > -1 ? "alignat" : "align", u = t.envName === "split", c = parseArray(t.parser, {
    cols: a,
    addJot: !0,
    autoTag: u ? void 0 : getAutoTag(t.envName),
    emptySingleRow: !0,
    colSeparationType: o,
    maxNumCols: u ? 2 : void 0,
    leqno: t.parser.settings.leqno
  }, "display"), d, g = 0, b = {
    type: "ordgroup",
    mode: t.mode,
    body: []
  };
  if (r[0] && r[0].type === "ordgroup") {
    for (var _ = "", y = 0; y < r[0].body.length; y++) {
      var A = assertNodeType(r[0].body[y], "textord");
      _ += A.text;
    }
    d = Number(_), g = d * 2;
  }
  var E = !g;
  c.body.forEach(function(I) {
    for (var w = 1; w < I.length; w += 2) {
      var N = assertNodeType(I[w], "styling"), F = assertNodeType(N.body[0], "ordgroup");
      F.body.unshift(b);
    }
    if (E)
      g < I.length && (g = I.length);
    else {
      var M = I.length / 2;
      if (d < M)
        throw new ParseError("Too many math in a row: " + ("expected " + d + ", but got " + M), I[0]);
    }
  });
  for (var v = 0; v < g; ++v) {
    var C = "r", R = 0;
    v % 2 === 1 ? C = "l" : v > 0 && E && (R = 1), a[v] = {
      type: "align",
      align: C,
      pregap: R,
      postgap: 0
    };
  }
  return c.colSeparationType = E ? "align" : "alignat", c;
};
defineEnvironment({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var r = checkSymbolNodeType(t[0]), a = r ? [t[0]] : assertNodeType(t[0], "ordgroup").body, o = a.map(function(c) {
      var d = assertSymbolNodeType(c), g = d.text;
      if ("lcr".indexOf(g) !== -1)
        return {
          type: "align",
          align: g
        };
      if (g === "|")
        return {
          type: "separator",
          separator: "|"
        };
      if (g === ":")
        return {
          type: "separator",
          separator: ":"
        };
      throw new ParseError("Unknown column alignment: " + g, c);
    }), u = {
      cols: o,
      hskipBeforeAndAfter: !0,
      // \@preamble in lttab.dtx
      maxNumCols: o.length
    };
    return parseArray(e.parser, u, dCellStyle(e.envName));
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },
  handler(e) {
    var t = {
      matrix: null,
      pmatrix: ["(", ")"],
      bmatrix: ["[", "]"],
      Bmatrix: ["\\{", "\\}"],
      vmatrix: ["|", "|"],
      Vmatrix: ["\\Vert", "\\Vert"]
    }[e.envName.replace("*", "")], r = "c", a = {
      hskipBeforeAndAfter: !1,
      cols: [{
        type: "align",
        align: r
      }]
    };
    if (e.envName.charAt(e.envName.length - 1) === "*") {
      var o = e.parser;
      if (o.consumeSpaces(), o.fetch().text === "[") {
        if (o.consume(), o.consumeSpaces(), r = o.fetch().text, "lcr".indexOf(r) === -1)
          throw new ParseError("Expected l or c or r", o.nextToken);
        o.consume(), o.consumeSpaces(), o.expect("]"), o.consume(), a.cols = [{
          type: "align",
          align: r
        }];
      }
    }
    var u = parseArray(e.parser, a, dCellStyle(e.envName)), c = Math.max(0, ...u.body.map((d) => d.length));
    return u.cols = new Array(c).fill({
      type: "align",
      align: r
    }), t ? {
      type: "leftright",
      mode: e.mode,
      body: [u],
      left: t[0],
      right: t[1],
      rightColor: void 0
      // \right uninfluenced by \color in array
    } : u;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(e) {
    var t = {
      arraystretch: 0.5
    }, r = parseArray(e.parser, t, "script");
    return r.colSeparationType = "small", r;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var r = checkSymbolNodeType(t[0]), a = r ? [t[0]] : assertNodeType(t[0], "ordgroup").body, o = a.map(function(c) {
      var d = assertSymbolNodeType(c), g = d.text;
      if ("lc".indexOf(g) !== -1)
        return {
          type: "align",
          align: g
        };
      throw new ParseError("Unknown column alignment: " + g, c);
    });
    if (o.length > 1)
      throw new ParseError("{subarray} can contain only one column");
    var u = {
      cols: o,
      hskipBeforeAndAfter: !1,
      arraystretch: 0.5
    };
    if (u = parseArray(e.parser, u, "script"), u.body.length > 0 && u.body[0].length > 1)
      throw new ParseError("{subarray} can contain only one column");
    return u;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(e) {
    var t = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1
        /* 1em quad */
      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    }, r = parseArray(e.parser, t, dCellStyle(e.envName));
    return {
      type: "leftright",
      mode: e.mode,
      body: [r],
      left: e.envName.indexOf("r") > -1 ? "." : "\\{",
      right: e.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: void 0
    };
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: alignedHandler,
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(e) {
    utils.contains(["gather", "gather*"], e.envName) && validateAmsEnvironmentContext(e);
    var t = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: !0,
      colSeparationType: "gather",
      autoTag: getAutoTag(e.envName),
      emptySingleRow: !0,
      leqno: e.parser.settings.leqno
    };
    return parseArray(e.parser, t, "display");
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: alignedHandler,
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(e) {
    validateAmsEnvironmentContext(e);
    var t = {
      autoTag: getAutoTag(e.envName),
      emptySingleRow: !0,
      singleRow: !0,
      maxNumCols: 1,
      leqno: e.parser.settings.leqno
    };
    return parseArray(e.parser, t, "display");
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(e) {
    return validateAmsEnvironmentContext(e), parseCD(e.parser);
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");
defineMacro("\\notag", "\\nonumber");
defineFunction({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !0
  },
  handler(e, t) {
    throw new ParseError(e.funcName + " valid only within array environment");
  }
});
var environments = _environments;
defineFunction({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler(e, t) {
    var {
      parser: r,
      funcName: a
    } = e, o = t[0];
    if (o.type !== "ordgroup")
      throw new ParseError("Invalid environment name", o);
    for (var u = "", c = 0; c < o.body.length; ++c)
      u += assertNodeType(o.body[c], "textord").text;
    if (a === "\\begin") {
      if (!environments.hasOwnProperty(u))
        throw new ParseError("No such environment: " + u, o);
      var d = environments[u], {
        args: g,
        optArgs: b
      } = r.parseArguments("\\begin{" + u + "}", d), _ = {
        mode: r.mode,
        envName: u,
        parser: r
      }, y = d.handler(_, g, b);
      r.expect("\\end", !1);
      var A = r.nextToken, E = assertNodeType(r.parseFunction(), "environment");
      if (E.name !== u)
        throw new ParseError("Mismatch: \\begin{" + u + "} matched by \\end{" + E.name + "}", A);
      return y;
    }
    return {
      type: "environment",
      mode: r.mode,
      name: u,
      nameGroup: o
    };
  }
});
var htmlBuilder$5 = (e, t) => {
  var r = e.font, a = t.withFont(r);
  return buildGroup$1(e.body, a);
}, mathmlBuilder$4 = (e, t) => {
  var r = e.font, a = t.withFont(r);
  return buildGroup(e.body, a);
}, fontAliases = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
defineFunction({
  type: "font",
  names: [
    // styles, except \boldsymbol defined below
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    "\\mathsfit",
    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathtt",
    // aliases, except \bm defined below
    "\\Bbb",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: !0
  },
  handler: (e, t) => {
    var {
      parser: r,
      funcName: a
    } = e, o = normalizeArgument(t[0]), u = a;
    return u in fontAliases && (u = fontAliases[u]), {
      type: "font",
      mode: r.mode,
      font: u.slice(1),
      body: o
    };
  },
  htmlBuilder: htmlBuilder$5,
  mathmlBuilder: mathmlBuilder$4
});
defineFunction({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (e, t) => {
    var {
      parser: r
    } = e, a = t[0], o = utils.isCharacterBox(a);
    return {
      type: "mclass",
      mode: r.mode,
      mclass: binrelClass(a),
      body: [{
        type: "font",
        mode: r.mode,
        font: "boldsymbol",
        body: a
      }],
      isCharacterBox: o
    };
  }
});
defineFunction({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: r,
      funcName: a,
      breakOnTokenText: o
    } = e, {
      mode: u
    } = r, c = r.parseExpression(!0, o), d = "math" + a.slice(1);
    return {
      type: "font",
      mode: u,
      font: d,
      body: {
        type: "ordgroup",
        mode: r.mode,
        body: c
      }
    };
  },
  htmlBuilder: htmlBuilder$5,
  mathmlBuilder: mathmlBuilder$4
});
var adjustStyle = (e, t) => {
  var r = t;
  return e === "display" ? r = r.id >= Style$1.SCRIPT.id ? r.text() : Style$1.DISPLAY : e === "text" && r.size === Style$1.DISPLAY.size ? r = Style$1.TEXT : e === "script" ? r = Style$1.SCRIPT : e === "scriptscript" && (r = Style$1.SCRIPTSCRIPT), r;
}, htmlBuilder$4 = (e, t) => {
  var r = adjustStyle(e.size, t.style), a = r.fracNum(), o = r.fracDen(), u;
  u = t.havingStyle(a);
  var c = buildGroup$1(e.numer, u, t);
  if (e.continued) {
    var d = 8.5 / t.fontMetrics().ptPerEm, g = 3.5 / t.fontMetrics().ptPerEm;
    c.height = c.height < d ? d : c.height, c.depth = c.depth < g ? g : c.depth;
  }
  u = t.havingStyle(o);
  var b = buildGroup$1(e.denom, u, t), _, y, A;
  e.hasBarLine ? (e.barSize ? (y = calculateSize(e.barSize, t), _ = buildCommon.makeLineSpan("frac-line", t, y)) : _ = buildCommon.makeLineSpan("frac-line", t), y = _.height, A = _.height) : (_ = null, y = 0, A = t.fontMetrics().defaultRuleThickness);
  var E, v, C;
  r.size === Style$1.DISPLAY.size || e.size === "display" ? (E = t.fontMetrics().num1, y > 0 ? v = 3 * A : v = 7 * A, C = t.fontMetrics().denom1) : (y > 0 ? (E = t.fontMetrics().num2, v = A) : (E = t.fontMetrics().num3, v = 3 * A), C = t.fontMetrics().denom2);
  var R;
  if (_) {
    var w = t.fontMetrics().axisHeight;
    E - c.depth - (w + 0.5 * y) < v && (E += v - (E - c.depth - (w + 0.5 * y))), w - 0.5 * y - (b.height - C) < v && (C += v - (w - 0.5 * y - (b.height - C)));
    var N = -(w - 0.5 * y);
    R = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: b,
        shift: C
      }, {
        type: "elem",
        elem: _,
        shift: N
      }, {
        type: "elem",
        elem: c,
        shift: -E
      }]
    }, t);
  } else {
    var I = E - c.depth - (b.height - C);
    I < v && (E += 0.5 * (v - I), C += 0.5 * (v - I)), R = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: b,
        shift: C
      }, {
        type: "elem",
        elem: c,
        shift: -E
      }]
    }, t);
  }
  u = t.havingStyle(r), R.height *= u.sizeMultiplier / t.sizeMultiplier, R.depth *= u.sizeMultiplier / t.sizeMultiplier;
  var F;
  r.size === Style$1.DISPLAY.size ? F = t.fontMetrics().delim1 : r.size === Style$1.SCRIPTSCRIPT.size ? F = t.havingStyle(Style$1.SCRIPT).fontMetrics().delim2 : F = t.fontMetrics().delim2;
  var M, x;
  return e.leftDelim == null ? M = makeNullDelimiter(t, ["mopen"]) : M = delimiter.customSizedDelim(e.leftDelim, F, !0, t.havingStyle(r), e.mode, ["mopen"]), e.continued ? x = buildCommon.makeSpan([]) : e.rightDelim == null ? x = makeNullDelimiter(t, ["mclose"]) : x = delimiter.customSizedDelim(e.rightDelim, F, !0, t.havingStyle(r), e.mode, ["mclose"]), buildCommon.makeSpan(["mord"].concat(u.sizingClasses(t)), [M, buildCommon.makeSpan(["mfrac"], [R]), x], t);
}, mathmlBuilder$3 = (e, t) => {
  var r = new mathMLTree.MathNode("mfrac", [buildGroup(e.numer, t), buildGroup(e.denom, t)]);
  if (!e.hasBarLine)
    r.setAttribute("linethickness", "0px");
  else if (e.barSize) {
    var a = calculateSize(e.barSize, t);
    r.setAttribute("linethickness", makeEm(a));
  }
  var o = adjustStyle(e.size, t.style);
  if (o.size !== t.style.size) {
    r = new mathMLTree.MathNode("mstyle", [r]);
    var u = o.size === Style$1.DISPLAY.size ? "true" : "false";
    r.setAttribute("displaystyle", u), r.setAttribute("scriptlevel", "0");
  }
  if (e.leftDelim != null || e.rightDelim != null) {
    var c = [];
    if (e.leftDelim != null) {
      var d = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(e.leftDelim.replace("\\", ""))]);
      d.setAttribute("fence", "true"), c.push(d);
    }
    if (c.push(r), e.rightDelim != null) {
      var g = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(e.rightDelim.replace("\\", ""))]);
      g.setAttribute("fence", "true"), c.push(g);
    }
    return makeRow(c);
  }
  return r;
};
defineFunction({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac",
    // cant be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac"
    // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: !0
  },
  handler: (e, t) => {
    var {
      parser: r,
      funcName: a
    } = e, o = t[0], u = t[1], c, d = null, g = null, b = "auto";
    switch (a) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        c = !0;
        break;
      case "\\\\atopfrac":
        c = !1;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        c = !1, d = "(", g = ")";
        break;
      case "\\\\bracefrac":
        c = !1, d = "\\{", g = "\\}";
        break;
      case "\\\\brackfrac":
        c = !1, d = "[", g = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }
    switch (a) {
      case "\\dfrac":
      case "\\dbinom":
        b = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        b = "text";
        break;
    }
    return {
      type: "genfrac",
      mode: r.mode,
      continued: !1,
      numer: o,
      denom: u,
      hasBarLine: c,
      leftDelim: d,
      rightDelim: g,
      size: b,
      barSize: null
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
defineFunction({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (e, t) => {
    var {
      parser: r,
      funcName: a
    } = e, o = t[0], u = t[1];
    return {
      type: "genfrac",
      mode: r.mode,
      continued: !0,
      numer: o,
      denom: u,
      hasBarLine: !0,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
});
defineFunction({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: !0
  },
  handler(e) {
    var {
      parser: t,
      funcName: r,
      token: a
    } = e, o;
    switch (r) {
      case "\\over":
        o = "\\frac";
        break;
      case "\\choose":
        o = "\\binom";
        break;
      case "\\atop":
        o = "\\\\atopfrac";
        break;
      case "\\brace":
        o = "\\\\bracefrac";
        break;
      case "\\brack":
        o = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: t.mode,
      replaceWith: o,
      token: a
    };
  }
});
var stylArray = ["display", "text", "script", "scriptscript"], delimFromValue = function e(t) {
  var r = null;
  return t.length > 0 && (r = t, r = r === "." ? null : r), r;
};
defineFunction({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: !0,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler(e, t) {
    var {
      parser: r
    } = e, a = t[4], o = t[5], u = normalizeArgument(t[0]), c = u.type === "atom" && u.family === "open" ? delimFromValue(u.text) : null, d = normalizeArgument(t[1]), g = d.type === "atom" && d.family === "close" ? delimFromValue(d.text) : null, b = assertNodeType(t[2], "size"), _, y = null;
    b.isBlank ? _ = !0 : (y = b.value, _ = y.number > 0);
    var A = "auto", E = t[3];
    if (E.type === "ordgroup") {
      if (E.body.length > 0) {
        var v = assertNodeType(E.body[0], "textord");
        A = stylArray[Number(v.text)];
      }
    } else
      E = assertNodeType(E, "textord"), A = stylArray[Number(E.text)];
    return {
      type: "genfrac",
      mode: r.mode,
      numer: a,
      denom: o,
      continued: !1,
      hasBarLine: _,
      barSize: y,
      leftDelim: c,
      rightDelim: g,
      size: A
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
defineFunction({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: !0
  },
  handler(e, t) {
    var {
      parser: r,
      funcName: a,
      token: o
    } = e;
    return {
      type: "infix",
      mode: r.mode,
      replaceWith: "\\\\abovefrac",
      size: assertNodeType(t[0], "size").value,
      token: o
    };
  }
});
defineFunction({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (e, t) => {
    var {
      parser: r,
      funcName: a
    } = e, o = t[0], u = assert(assertNodeType(t[1], "infix").size), c = t[2], d = u.number > 0;
    return {
      type: "genfrac",
      mode: r.mode,
      numer: o,
      denom: c,
      continued: !1,
      hasBarLine: d,
      barSize: u,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
var htmlBuilder$3 = (e, t) => {
  var r = t.style, a, o;
  e.type === "supsub" ? (a = e.sup ? buildGroup$1(e.sup, t.havingStyle(r.sup()), t) : buildGroup$1(e.sub, t.havingStyle(r.sub()), t), o = assertNodeType(e.base, "horizBrace")) : o = assertNodeType(e, "horizBrace");
  var u = buildGroup$1(o.base, t.havingBaseStyle(Style$1.DISPLAY)), c = stretchy.svgSpan(o, t), d;
  if (o.isOver ? (d = buildCommon.makeVList({
    positionType: "firstBaseline",
    children: [{
      type: "elem",
      elem: u
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: c
    }]
  }, t), d.children[0].children[0].children[1].classes.push("svg-align")) : (d = buildCommon.makeVList({
    positionType: "bottom",
    positionData: u.depth + 0.1 + c.height,
    children: [{
      type: "elem",
      elem: c
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: u
    }]
  }, t), d.children[0].children[0].children[0].classes.push("svg-align")), a) {
    var g = buildCommon.makeSpan(["mord", o.isOver ? "mover" : "munder"], [d], t);
    o.isOver ? d = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: g
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: a
      }]
    }, t) : d = buildCommon.makeVList({
      positionType: "bottom",
      positionData: g.depth + 0.2 + a.height + a.depth,
      children: [{
        type: "elem",
        elem: a
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: g
      }]
    }, t);
  }
  return buildCommon.makeSpan(["mord", o.isOver ? "mover" : "munder"], [d], t);
}, mathmlBuilder$2 = (e, t) => {
  var r = stretchy.mathMLnode(e.label);
  return new mathMLTree.MathNode(e.isOver ? "mover" : "munder", [buildGroup(e.base, t), r]);
};
defineFunction({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var {
      parser: r,
      funcName: a
    } = e;
    return {
      type: "horizBrace",
      mode: r.mode,
      label: a,
      isOver: /^\\over/.test(a),
      base: t[0]
    };
  },
  htmlBuilder: htmlBuilder$3,
  mathmlBuilder: mathmlBuilder$2
});
defineFunction({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: r
    } = e, a = t[1], o = assertNodeType(t[0], "url").url;
    return r.settings.isTrusted({
      command: "\\href",
      url: o
    }) ? {
      type: "href",
      mode: r.mode,
      href: o,
      body: ordargument(a)
    } : r.formatUnsupportedCmd("\\href");
  },
  htmlBuilder: (e, t) => {
    var r = buildExpression$1(e.body, t, !1);
    return buildCommon.makeAnchor(e.href, [], r, t);
  },
  mathmlBuilder: (e, t) => {
    var r = buildExpressionRow(e.body, t);
    return r instanceof MathNode || (r = new MathNode("mrow", [r])), r.setAttribute("href", e.href), r;
  }
});
defineFunction({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: r
    } = e, a = assertNodeType(t[0], "url").url;
    if (!r.settings.isTrusted({
      command: "\\url",
      url: a
    }))
      return r.formatUnsupportedCmd("\\url");
    for (var o = [], u = 0; u < a.length; u++) {
      var c = a[u];
      c === "~" && (c = "\\textasciitilde"), o.push({
        type: "textord",
        mode: "text",
        text: c
      });
    }
    var d = {
      type: "text",
      mode: r.mode,
      font: "\\texttt",
      body: o
    };
    return {
      type: "href",
      mode: r.mode,
      href: a,
      body: ordargument(d)
    };
  }
});
defineFunction({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: !0,
    primitive: !0
  },
  handler(e, t) {
    var {
      parser: r
    } = e;
    return {
      type: "hbox",
      mode: r.mode,
      body: ordargument(t[0])
    };
  },
  htmlBuilder(e, t) {
    var r = buildExpression$1(e.body, t, !1);
    return buildCommon.makeFragment(r);
  },
  mathmlBuilder(e, t) {
    return new mathMLTree.MathNode("mrow", buildExpression(e.body, t));
  }
});
defineFunction({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: r,
      funcName: a,
      token: o
    } = e, u = assertNodeType(t[0], "raw").string, c = t[1];
    r.settings.strict && r.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    var d, g = {};
    switch (a) {
      case "\\htmlClass":
        g.class = u, d = {
          command: "\\htmlClass",
          class: u
        };
        break;
      case "\\htmlId":
        g.id = u, d = {
          command: "\\htmlId",
          id: u
        };
        break;
      case "\\htmlStyle":
        g.style = u, d = {
          command: "\\htmlStyle",
          style: u
        };
        break;
      case "\\htmlData": {
        for (var b = u.split(","), _ = 0; _ < b.length; _++) {
          var y = b[_].split("=");
          if (y.length !== 2)
            throw new ParseError("Error parsing key-value for \\htmlData");
          g["data-" + y[0].trim()] = y[1].trim();
        }
        d = {
          command: "\\htmlData",
          attributes: g
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }
    return r.settings.isTrusted(d) ? {
      type: "html",
      mode: r.mode,
      attributes: g,
      body: ordargument(c)
    } : r.formatUnsupportedCmd(a);
  },
  htmlBuilder: (e, t) => {
    var r = buildExpression$1(e.body, t, !1), a = ["enclosing"];
    e.attributes.class && a.push(...e.attributes.class.trim().split(/\s+/));
    var o = buildCommon.makeSpan(a, r, t);
    for (var u in e.attributes)
      u !== "class" && e.attributes.hasOwnProperty(u) && o.setAttribute(u, e.attributes[u]);
    return o;
  },
  mathmlBuilder: (e, t) => buildExpressionRow(e.body, t)
});
defineFunction({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: r
    } = e;
    return {
      type: "htmlmathml",
      mode: r.mode,
      html: ordargument(t[0]),
      mathml: ordargument(t[1])
    };
  },
  htmlBuilder: (e, t) => {
    var r = buildExpression$1(e.html, t, !1);
    return buildCommon.makeFragment(r);
  },
  mathmlBuilder: (e, t) => buildExpressionRow(e.mathml, t)
});
var sizeData = function e(t) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(t))
    return {
      number: +t,
      unit: "bp"
    };
  var r = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(t);
  if (!r)
    throw new ParseError("Invalid size: '" + t + "' in \\includegraphics");
  var a = {
    number: +(r[1] + r[2]),
    // sign + magnitude, cast to number
    unit: r[3]
  };
  if (!validUnit(a))
    throw new ParseError("Invalid unit: '" + a.unit + "' in \\includegraphics.");
  return a;
};
defineFunction({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: !1
  },
  handler: (e, t, r) => {
    var {
      parser: a
    } = e, o = {
      number: 0,
      unit: "em"
    }, u = {
      number: 0.9,
      unit: "em"
    }, c = {
      number: 0,
      unit: "em"
    }, d = "";
    if (r[0])
      for (var g = assertNodeType(r[0], "raw").string, b = g.split(","), _ = 0; _ < b.length; _++) {
        var y = b[_].split("=");
        if (y.length === 2) {
          var A = y[1].trim();
          switch (y[0].trim()) {
            case "alt":
              d = A;
              break;
            case "width":
              o = sizeData(A);
              break;
            case "height":
              u = sizeData(A);
              break;
            case "totalheight":
              c = sizeData(A);
              break;
            default:
              throw new ParseError("Invalid key: '" + y[0] + "' in \\includegraphics.");
          }
        }
      }
    var E = assertNodeType(t[0], "url").url;
    return d === "" && (d = E, d = d.replace(/^.*[\\/]/, ""), d = d.substring(0, d.lastIndexOf("."))), a.settings.isTrusted({
      command: "\\includegraphics",
      url: E
    }) ? {
      type: "includegraphics",
      mode: a.mode,
      alt: d,
      width: o,
      height: u,
      totalheight: c,
      src: E
    } : a.formatUnsupportedCmd("\\includegraphics");
  },
  htmlBuilder: (e, t) => {
    var r = calculateSize(e.height, t), a = 0;
    e.totalheight.number > 0 && (a = calculateSize(e.totalheight, t) - r);
    var o = 0;
    e.width.number > 0 && (o = calculateSize(e.width, t));
    var u = {
      height: makeEm(r + a)
    };
    o > 0 && (u.width = makeEm(o)), a > 0 && (u.verticalAlign = makeEm(-a));
    var c = new Img(e.src, e.alt, u);
    return c.height = r, c.depth = a, c;
  },
  mathmlBuilder: (e, t) => {
    var r = new mathMLTree.MathNode("mglyph", []);
    r.setAttribute("alt", e.alt);
    var a = calculateSize(e.height, t), o = 0;
    if (e.totalheight.number > 0 && (o = calculateSize(e.totalheight, t) - a, r.setAttribute("valign", makeEm(-o))), r.setAttribute("height", makeEm(a + o)), e.width.number > 0) {
      var u = calculateSize(e.width, t);
      r.setAttribute("width", makeEm(u));
    }
    return r.setAttribute("src", e.src), r;
  }
});
defineFunction({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: !0,
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: r,
      funcName: a
    } = e, o = assertNodeType(t[0], "size");
    if (r.settings.strict) {
      var u = a[1] === "m", c = o.value.unit === "mu";
      u ? (c || r.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + a + " supports only mu units, " + ("not " + o.value.unit + " units")), r.mode !== "math" && r.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + a + " works only in math mode")) : c && r.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + a + " doesn't support mu units");
    }
    return {
      type: "kern",
      mode: r.mode,
      dimension: o.value
    };
  },
  htmlBuilder(e, t) {
    return buildCommon.makeGlue(e.dimension, t);
  },
  mathmlBuilder(e, t) {
    var r = calculateSize(e.dimension, t);
    return new mathMLTree.SpaceNode(r);
  }
});
defineFunction({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: r,
      funcName: a
    } = e, o = t[0];
    return {
      type: "lap",
      mode: r.mode,
      alignment: a.slice(5),
      body: o
    };
  },
  htmlBuilder: (e, t) => {
    var r;
    e.alignment === "clap" ? (r = buildCommon.makeSpan([], [buildGroup$1(e.body, t)]), r = buildCommon.makeSpan(["inner"], [r], t)) : r = buildCommon.makeSpan(["inner"], [buildGroup$1(e.body, t)]);
    var a = buildCommon.makeSpan(["fix"], []), o = buildCommon.makeSpan([e.alignment], [r, a], t), u = buildCommon.makeSpan(["strut"]);
    return u.style.height = makeEm(o.height + o.depth), o.depth && (u.style.verticalAlign = makeEm(-o.depth)), o.children.unshift(u), o = buildCommon.makeSpan(["thinbox"], [o], t), buildCommon.makeSpan(["mord", "vbox"], [o], t);
  },
  mathmlBuilder: (e, t) => {
    var r = new mathMLTree.MathNode("mpadded", [buildGroup(e.body, t)]);
    if (e.alignment !== "rlap") {
      var a = e.alignment === "llap" ? "-1" : "-0.5";
      r.setAttribute("lspace", a + "width");
    }
    return r.setAttribute("width", "0px"), r;
  }
});
defineFunction({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(e, t) {
    var {
      funcName: r,
      parser: a
    } = e, o = a.mode;
    a.switchMode("math");
    var u = r === "\\(" ? "\\)" : "$", c = a.parseExpression(!1, u);
    return a.expect(u), a.switchMode(o), {
      type: "styling",
      mode: a.mode,
      style: "text",
      body: c
    };
  }
});
defineFunction({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(e, t) {
    throw new ParseError("Mismatched " + e.funcName);
  }
});
var chooseMathStyle = (e, t) => {
  switch (t.style.size) {
    case Style$1.DISPLAY.size:
      return e.display;
    case Style$1.TEXT.size:
      return e.text;
    case Style$1.SCRIPT.size:
      return e.script;
    case Style$1.SCRIPTSCRIPT.size:
      return e.scriptscript;
    default:
      return e.text;
  }
};
defineFunction({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: !0
  },
  handler: (e, t) => {
    var {
      parser: r
    } = e;
    return {
      type: "mathchoice",
      mode: r.mode,
      display: ordargument(t[0]),
      text: ordargument(t[1]),
      script: ordargument(t[2]),
      scriptscript: ordargument(t[3])
    };
  },
  htmlBuilder: (e, t) => {
    var r = chooseMathStyle(e, t), a = buildExpression$1(r, t, !1);
    return buildCommon.makeFragment(a);
  },
  mathmlBuilder: (e, t) => {
    var r = chooseMathStyle(e, t);
    return buildExpressionRow(r, t);
  }
});
var assembleSupSub = (e, t, r, a, o, u, c) => {
  e = buildCommon.makeSpan([], [e]);
  var d = r && utils.isCharacterBox(r), g, b;
  if (t) {
    var _ = buildGroup$1(t, a.havingStyle(o.sup()), a);
    b = {
      elem: _,
      kern: Math.max(a.fontMetrics().bigOpSpacing1, a.fontMetrics().bigOpSpacing3 - _.depth)
    };
  }
  if (r) {
    var y = buildGroup$1(r, a.havingStyle(o.sub()), a);
    g = {
      elem: y,
      kern: Math.max(a.fontMetrics().bigOpSpacing2, a.fontMetrics().bigOpSpacing4 - y.height)
    };
  }
  var A;
  if (b && g) {
    var E = a.fontMetrics().bigOpSpacing5 + g.elem.height + g.elem.depth + g.kern + e.depth + c;
    A = buildCommon.makeVList({
      positionType: "bottom",
      positionData: E,
      children: [{
        type: "kern",
        size: a.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: g.elem,
        marginLeft: makeEm(-u)
      }, {
        type: "kern",
        size: g.kern
      }, {
        type: "elem",
        elem: e
      }, {
        type: "kern",
        size: b.kern
      }, {
        type: "elem",
        elem: b.elem,
        marginLeft: makeEm(u)
      }, {
        type: "kern",
        size: a.fontMetrics().bigOpSpacing5
      }]
    }, a);
  } else if (g) {
    var v = e.height - c;
    A = buildCommon.makeVList({
      positionType: "top",
      positionData: v,
      children: [{
        type: "kern",
        size: a.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: g.elem,
        marginLeft: makeEm(-u)
      }, {
        type: "kern",
        size: g.kern
      }, {
        type: "elem",
        elem: e
      }]
    }, a);
  } else if (b) {
    var C = e.depth + c;
    A = buildCommon.makeVList({
      positionType: "bottom",
      positionData: C,
      children: [{
        type: "elem",
        elem: e
      }, {
        type: "kern",
        size: b.kern
      }, {
        type: "elem",
        elem: b.elem,
        marginLeft: makeEm(u)
      }, {
        type: "kern",
        size: a.fontMetrics().bigOpSpacing5
      }]
    }, a);
  } else
    return e;
  var R = [A];
  if (g && u !== 0 && !d) {
    var I = buildCommon.makeSpan(["mspace"], [], a);
    I.style.marginRight = makeEm(u), R.unshift(I);
  }
  return buildCommon.makeSpan(["mop", "op-limits"], R, a);
}, noSuccessor = ["\\smallint"], htmlBuilder$2 = (e, t) => {
  var r, a, o = !1, u;
  e.type === "supsub" ? (r = e.sup, a = e.sub, u = assertNodeType(e.base, "op"), o = !0) : u = assertNodeType(e, "op");
  var c = t.style, d = !1;
  c.size === Style$1.DISPLAY.size && u.symbol && !utils.contains(noSuccessor, u.name) && (d = !0);
  var g;
  if (u.symbol) {
    var b = d ? "Size2-Regular" : "Size1-Regular", _ = "";
    if ((u.name === "\\oiint" || u.name === "\\oiiint") && (_ = u.name.slice(1), u.name = _ === "oiint" ? "\\iint" : "\\iiint"), g = buildCommon.makeSymbol(u.name, b, "math", t, ["mop", "op-symbol", d ? "large-op" : "small-op"]), _.length > 0) {
      var y = g.italic, A = buildCommon.staticSvg(_ + "Size" + (d ? "2" : "1"), t);
      g = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: g,
          shift: 0
        }, {
          type: "elem",
          elem: A,
          shift: d ? 0.08 : 0
        }]
      }, t), u.name = "\\" + _, g.classes.unshift("mop"), g.italic = y;
    }
  } else if (u.body) {
    var E = buildExpression$1(u.body, t, !0);
    E.length === 1 && E[0] instanceof SymbolNode ? (g = E[0], g.classes[0] = "mop") : g = buildCommon.makeSpan(["mop"], E, t);
  } else {
    for (var v = [], C = 1; C < u.name.length; C++)
      v.push(buildCommon.mathsym(u.name[C], u.mode, t));
    g = buildCommon.makeSpan(["mop"], v, t);
  }
  var R = 0, I = 0;
  return (g instanceof SymbolNode || u.name === "\\oiint" || u.name === "\\oiiint") && !u.suppressBaseShift && (R = (g.height - g.depth) / 2 - t.fontMetrics().axisHeight, I = g.italic), o ? assembleSupSub(g, r, a, t, c, I, R) : (R && (g.style.position = "relative", g.style.top = makeEm(R)), g);
}, mathmlBuilder$1 = (e, t) => {
  var r;
  if (e.symbol)
    r = new MathNode("mo", [makeText(e.name, e.mode)]), utils.contains(noSuccessor, e.name) && r.setAttribute("largeop", "false");
  else if (e.body)
    r = new MathNode("mo", buildExpression(e.body, t));
  else {
    r = new MathNode("mi", [new TextNode(e.name.slice(1))]);
    var a = new MathNode("mo", [makeText("", "text")]);
    e.parentIsSupSub ? r = new MathNode("mrow", [r, a]) : r = newDocumentFragment([r, a]);
  }
  return r;
}, singleCharBigOps = {
  "": "\\prod",
  "": "\\coprod",
  "": "\\sum",
  "": "\\bigwedge",
  "": "\\bigvee",
  "": "\\bigcap",
  "": "\\bigcup",
  "": "\\bigodot",
  "": "\\bigoplus",
  "": "\\bigotimes",
  "": "\\biguplus",
  "": "\\bigsqcup"
};
defineFunction({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "", "", "", "", "", "", "", "", "", "", "", ""],
  props: {
    numArgs: 0
  },
  handler: (e, t) => {
    var {
      parser: r,
      funcName: a
    } = e, o = a;
    return o.length === 1 && (o = singleCharBigOps[o]), {
      type: "op",
      mode: r.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !0,
      name: o
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (e, t) => {
    var {
      parser: r
    } = e, a = t[0];
    return {
      type: "op",
      mode: r.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      body: ordargument(a)
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
var singleCharIntegrals = {
  "": "\\int",
  "": "\\iint",
  "": "\\iiint",
  "": "\\oint",
  "": "\\oiint",
  "": "\\oiiint"
};
defineFunction({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },
  handler(e) {
    var {
      parser: t,
      funcName: r
    } = e;
    return {
      type: "op",
      mode: t.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      name: r
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler(e) {
    var {
      parser: t,
      funcName: r
    } = e;
    return {
      type: "op",
      mode: t.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !1,
      name: r
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "", "", "", "", "", ""],
  props: {
    numArgs: 0
  },
  handler(e) {
    var {
      parser: t,
      funcName: r
    } = e, a = r;
    return a.length === 1 && (a = singleCharIntegrals[a]), {
      type: "op",
      mode: t.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !0,
      name: a
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
var htmlBuilder$1 = (e, t) => {
  var r, a, o = !1, u;
  e.type === "supsub" ? (r = e.sup, a = e.sub, u = assertNodeType(e.base, "operatorname"), o = !0) : u = assertNodeType(e, "operatorname");
  var c;
  if (u.body.length > 0) {
    for (var d = u.body.map((y) => {
      var A = y.text;
      return typeof A == "string" ? {
        type: "textord",
        mode: y.mode,
        text: A
      } : y;
    }), g = buildExpression$1(d, t.withFont("mathrm"), !0), b = 0; b < g.length; b++) {
      var _ = g[b];
      _ instanceof SymbolNode && (_.text = _.text.replace(/\u2212/, "-").replace(/\u2217/, "*"));
    }
    c = buildCommon.makeSpan(["mop"], g, t);
  } else
    c = buildCommon.makeSpan(["mop"], [], t);
  return o ? assembleSupSub(c, r, a, t, t.style, 0, 0) : c;
}, mathmlBuilder = (e, t) => {
  for (var r = buildExpression(e.body, t.withFont("mathrm")), a = !0, o = 0; o < r.length; o++) {
    var u = r[o];
    if (!(u instanceof mathMLTree.SpaceNode)) if (u instanceof mathMLTree.MathNode)
      switch (u.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        case "mo": {
          var c = u.children[0];
          u.children.length === 1 && c instanceof mathMLTree.TextNode ? c.text = c.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : a = !1;
          break;
        }
        default:
          a = !1;
      }
    else
      a = !1;
  }
  if (a) {
    var d = r.map((_) => _.toText()).join("");
    r = [new mathMLTree.TextNode(d)];
  }
  var g = new mathMLTree.MathNode("mi", r);
  g.setAttribute("mathvariant", "normal");
  var b = new mathMLTree.MathNode("mo", [makeText("", "text")]);
  return e.parentIsSupSub ? new mathMLTree.MathNode("mrow", [g, b]) : mathMLTree.newDocumentFragment([g, b]);
};
defineFunction({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (e, t) => {
    var {
      parser: r,
      funcName: a
    } = e, o = t[0];
    return {
      type: "operatorname",
      mode: r.mode,
      body: ordargument(o),
      alwaysHandleSupSub: a === "\\operatornamewithlimits",
      limits: !1,
      parentIsSupSub: !1
    };
  },
  htmlBuilder: htmlBuilder$1,
  mathmlBuilder
});
defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
defineFunctionBuilders({
  type: "ordgroup",
  htmlBuilder(e, t) {
    return e.semisimple ? buildCommon.makeFragment(buildExpression$1(e.body, t, !1)) : buildCommon.makeSpan(["mord"], buildExpression$1(e.body, t, !0), t);
  },
  mathmlBuilder(e, t) {
    return buildExpressionRow(e.body, t, !0);
  }
});
defineFunction({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },
  handler(e, t) {
    var {
      parser: r
    } = e, a = t[0];
    return {
      type: "overline",
      mode: r.mode,
      body: a
    };
  },
  htmlBuilder(e, t) {
    var r = buildGroup$1(e.body, t.havingCrampedStyle()), a = buildCommon.makeLineSpan("overline-line", t), o = t.fontMetrics().defaultRuleThickness, u = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: 3 * o
      }, {
        type: "elem",
        elem: a
      }, {
        type: "kern",
        size: o
      }]
    }, t);
    return buildCommon.makeSpan(["mord", "overline"], [u], t);
  },
  mathmlBuilder(e, t) {
    var r = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("")]);
    r.setAttribute("stretchy", "true");
    var a = new mathMLTree.MathNode("mover", [buildGroup(e.body, t), r]);
    return a.setAttribute("accent", "true"), a;
  }
});
defineFunction({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: r
    } = e, a = t[0];
    return {
      type: "phantom",
      mode: r.mode,
      body: ordargument(a)
    };
  },
  htmlBuilder: (e, t) => {
    var r = buildExpression$1(e.body, t.withPhantom(), !1);
    return buildCommon.makeFragment(r);
  },
  mathmlBuilder: (e, t) => {
    var r = buildExpression(e.body, t);
    return new mathMLTree.MathNode("mphantom", r);
  }
});
defineFunction({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: r
    } = e, a = t[0];
    return {
      type: "hphantom",
      mode: r.mode,
      body: a
    };
  },
  htmlBuilder: (e, t) => {
    var r = buildCommon.makeSpan([], [buildGroup$1(e.body, t.withPhantom())]);
    if (r.height = 0, r.depth = 0, r.children)
      for (var a = 0; a < r.children.length; a++)
        r.children[a].height = 0, r.children[a].depth = 0;
    return r = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: r
      }]
    }, t), buildCommon.makeSpan(["mord"], [r], t);
  },
  mathmlBuilder: (e, t) => {
    var r = buildExpression(ordargument(e.body), t), a = new mathMLTree.MathNode("mphantom", r), o = new mathMLTree.MathNode("mpadded", [a]);
    return o.setAttribute("height", "0px"), o.setAttribute("depth", "0px"), o;
  }
});
defineFunction({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      parser: r
    } = e, a = t[0];
    return {
      type: "vphantom",
      mode: r.mode,
      body: a
    };
  },
  htmlBuilder: (e, t) => {
    var r = buildCommon.makeSpan(["inner"], [buildGroup$1(e.body, t.withPhantom())]), a = buildCommon.makeSpan(["fix"], []);
    return buildCommon.makeSpan(["mord", "rlap"], [r, a], t);
  },
  mathmlBuilder: (e, t) => {
    var r = buildExpression(ordargument(e.body), t), a = new mathMLTree.MathNode("mphantom", r), o = new mathMLTree.MathNode("mpadded", [a]);
    return o.setAttribute("width", "0px"), o;
  }
});
defineFunction({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: r
    } = e, a = assertNodeType(t[0], "size").value, o = t[1];
    return {
      type: "raisebox",
      mode: r.mode,
      dy: a,
      body: o
    };
  },
  htmlBuilder(e, t) {
    var r = buildGroup$1(e.body, t), a = calculateSize(e.dy, t);
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: -a,
      children: [{
        type: "elem",
        elem: r
      }]
    }, t);
  },
  mathmlBuilder(e, t) {
    var r = new mathMLTree.MathNode("mpadded", [buildGroup(e.body, t)]), a = e.dy.number + e.dy.unit;
    return r.setAttribute("voffset", a), r;
  }
});
defineFunction({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(e) {
    var {
      parser: t
    } = e;
    return {
      type: "internal",
      mode: t.mode
    };
  }
});
defineFunction({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    argTypes: ["size", "size", "size"]
  },
  handler(e, t, r) {
    var {
      parser: a
    } = e, o = r[0], u = assertNodeType(t[0], "size"), c = assertNodeType(t[1], "size");
    return {
      type: "rule",
      mode: a.mode,
      shift: o && assertNodeType(o, "size").value,
      width: u.value,
      height: c.value
    };
  },
  htmlBuilder(e, t) {
    var r = buildCommon.makeSpan(["mord", "rule"], [], t), a = calculateSize(e.width, t), o = calculateSize(e.height, t), u = e.shift ? calculateSize(e.shift, t) : 0;
    return r.style.borderRightWidth = makeEm(a), r.style.borderTopWidth = makeEm(o), r.style.bottom = makeEm(u), r.width = a, r.height = o + u, r.depth = -u, r.maxFontSize = o * 1.125 * t.sizeMultiplier, r;
  },
  mathmlBuilder(e, t) {
    var r = calculateSize(e.width, t), a = calculateSize(e.height, t), o = e.shift ? calculateSize(e.shift, t) : 0, u = t.color && t.getColor() || "black", c = new mathMLTree.MathNode("mspace");
    c.setAttribute("mathbackground", u), c.setAttribute("width", makeEm(r)), c.setAttribute("height", makeEm(a));
    var d = new mathMLTree.MathNode("mpadded", [c]);
    return o >= 0 ? d.setAttribute("height", makeEm(o)) : (d.setAttribute("height", makeEm(o)), d.setAttribute("depth", makeEm(-o))), d.setAttribute("voffset", makeEm(o)), d;
  }
});
function sizingGroup(e, t, r) {
  for (var a = buildExpression$1(e, t, !1), o = t.sizeMultiplier / r.sizeMultiplier, u = 0; u < a.length; u++) {
    var c = a[u].classes.indexOf("sizing");
    c < 0 ? Array.prototype.push.apply(a[u].classes, t.sizingClasses(r)) : a[u].classes[c + 1] === "reset-size" + t.size && (a[u].classes[c + 1] = "reset-size" + r.size), a[u].height *= o, a[u].depth *= o;
  }
  return buildCommon.makeFragment(a);
}
var sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"], htmlBuilder = (e, t) => {
  var r = t.havingSize(e.size);
  return sizingGroup(e.body, r, t);
};
defineFunction({
  type: "sizing",
  names: sizeFuncs,
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (e, t) => {
    var {
      breakOnTokenText: r,
      funcName: a,
      parser: o
    } = e, u = o.parseExpression(!1, r);
    return {
      type: "sizing",
      mode: o.mode,
      // Figure out what size to use based on the list of functions above
      size: sizeFuncs.indexOf(a) + 1,
      body: u
    };
  },
  htmlBuilder,
  mathmlBuilder: (e, t) => {
    var r = t.havingSize(e.size), a = buildExpression(e.body, r), o = new mathMLTree.MathNode("mstyle", a);
    return o.setAttribute("mathsize", makeEm(r.sizeMultiplier)), o;
  }
});
defineFunction({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: !0
  },
  handler: (e, t, r) => {
    var {
      parser: a
    } = e, o = !1, u = !1, c = r[0] && assertNodeType(r[0], "ordgroup");
    if (c)
      for (var d = "", g = 0; g < c.body.length; ++g) {
        var b = c.body[g];
        if (d = b.text, d === "t")
          o = !0;
        else if (d === "b")
          u = !0;
        else {
          o = !1, u = !1;
          break;
        }
      }
    else
      o = !0, u = !0;
    var _ = t[0];
    return {
      type: "smash",
      mode: a.mode,
      body: _,
      smashHeight: o,
      smashDepth: u
    };
  },
  htmlBuilder: (e, t) => {
    var r = buildCommon.makeSpan([], [buildGroup$1(e.body, t)]);
    if (!e.smashHeight && !e.smashDepth)
      return r;
    if (e.smashHeight && (r.height = 0, r.children))
      for (var a = 0; a < r.children.length; a++)
        r.children[a].height = 0;
    if (e.smashDepth && (r.depth = 0, r.children))
      for (var o = 0; o < r.children.length; o++)
        r.children[o].depth = 0;
    var u = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: r
      }]
    }, t);
    return buildCommon.makeSpan(["mord"], [u], t);
  },
  mathmlBuilder: (e, t) => {
    var r = new mathMLTree.MathNode("mpadded", [buildGroup(e.body, t)]);
    return e.smashHeight && r.setAttribute("height", "0px"), e.smashDepth && r.setAttribute("depth", "0px"), r;
  }
});
defineFunction({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(e, t, r) {
    var {
      parser: a
    } = e, o = r[0], u = t[0];
    return {
      type: "sqrt",
      mode: a.mode,
      body: u,
      index: o
    };
  },
  htmlBuilder(e, t) {
    var r = buildGroup$1(e.body, t.havingCrampedStyle());
    r.height === 0 && (r.height = t.fontMetrics().xHeight), r = buildCommon.wrapFragment(r, t);
    var a = t.fontMetrics(), o = a.defaultRuleThickness, u = o;
    t.style.id < Style$1.TEXT.id && (u = t.fontMetrics().xHeight);
    var c = o + u / 4, d = r.height + r.depth + c + o, {
      span: g,
      ruleWidth: b,
      advanceWidth: _
    } = delimiter.sqrtImage(d, t), y = g.height - b;
    y > r.height + r.depth + c && (c = (c + y - r.height - r.depth) / 2);
    var A = g.height - r.height - c - b;
    r.style.paddingLeft = makeEm(_);
    var E = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: r,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(r.height + A)
      }, {
        type: "elem",
        elem: g
      }, {
        type: "kern",
        size: b
      }]
    }, t);
    if (e.index) {
      var v = t.havingStyle(Style$1.SCRIPTSCRIPT), C = buildGroup$1(e.index, v, t), R = 0.6 * (E.height - E.depth), I = buildCommon.makeVList({
        positionType: "shift",
        positionData: -R,
        children: [{
          type: "elem",
          elem: C
        }]
      }, t), w = buildCommon.makeSpan(["root"], [I]);
      return buildCommon.makeSpan(["mord", "sqrt"], [w, E], t);
    } else
      return buildCommon.makeSpan(["mord", "sqrt"], [E], t);
  },
  mathmlBuilder(e, t) {
    var {
      body: r,
      index: a
    } = e;
    return a ? new mathMLTree.MathNode("mroot", [buildGroup(r, t), buildGroup(a, t)]) : new mathMLTree.MathNode("msqrt", [buildGroup(r, t)]);
  }
});
var styleMap = {
  display: Style$1.DISPLAY,
  text: Style$1.TEXT,
  script: Style$1.SCRIPT,
  scriptscript: Style$1.SCRIPTSCRIPT
};
defineFunction({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(e, t) {
    var {
      breakOnTokenText: r,
      funcName: a,
      parser: o
    } = e, u = o.parseExpression(!0, r), c = a.slice(1, a.length - 5);
    return {
      type: "styling",
      mode: o.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style: c,
      body: u
    };
  },
  htmlBuilder(e, t) {
    var r = styleMap[e.style], a = t.havingStyle(r).withFont("");
    return sizingGroup(e.body, a, t);
  },
  mathmlBuilder(e, t) {
    var r = styleMap[e.style], a = t.havingStyle(r), o = buildExpression(e.body, a), u = new mathMLTree.MathNode("mstyle", o), c = {
      display: ["0", "true"],
      text: ["0", "false"],
      script: ["1", "false"],
      scriptscript: ["2", "false"]
    }, d = c[e.style];
    return u.setAttribute("scriptlevel", d[0]), u.setAttribute("displaystyle", d[1]), u;
  }
});
var htmlBuilderDelegate = function e(t, r) {
  var a = t.base;
  if (a)
    if (a.type === "op") {
      var o = a.limits && (r.style.size === Style$1.DISPLAY.size || a.alwaysHandleSupSub);
      return o ? htmlBuilder$2 : null;
    } else if (a.type === "operatorname") {
      var u = a.alwaysHandleSupSub && (r.style.size === Style$1.DISPLAY.size || a.limits);
      return u ? htmlBuilder$1 : null;
    } else {
      if (a.type === "accent")
        return utils.isCharacterBox(a.base) ? htmlBuilder$a : null;
      if (a.type === "horizBrace") {
        var c = !t.sub;
        return c === a.isOver ? htmlBuilder$3 : null;
      } else
        return null;
    }
  else return null;
};
defineFunctionBuilders({
  type: "supsub",
  htmlBuilder(e, t) {
    var r = htmlBuilderDelegate(e, t);
    if (r)
      return r(e, t);
    var {
      base: a,
      sup: o,
      sub: u
    } = e, c = buildGroup$1(a, t), d, g, b = t.fontMetrics(), _ = 0, y = 0, A = a && utils.isCharacterBox(a);
    if (o) {
      var E = t.havingStyle(t.style.sup());
      d = buildGroup$1(o, E, t), A || (_ = c.height - E.fontMetrics().supDrop * E.sizeMultiplier / t.sizeMultiplier);
    }
    if (u) {
      var v = t.havingStyle(t.style.sub());
      g = buildGroup$1(u, v, t), A || (y = c.depth + v.fontMetrics().subDrop * v.sizeMultiplier / t.sizeMultiplier);
    }
    var C;
    t.style === Style$1.DISPLAY ? C = b.sup1 : t.style.cramped ? C = b.sup3 : C = b.sup2;
    var R = t.sizeMultiplier, I = makeEm(0.5 / b.ptPerEm / R), w = null;
    if (g) {
      var N = e.base && e.base.type === "op" && e.base.name && (e.base.name === "\\oiint" || e.base.name === "\\oiiint");
      (c instanceof SymbolNode || N) && (w = makeEm(-c.italic));
    }
    var F;
    if (d && g) {
      _ = Math.max(_, C, d.depth + 0.25 * b.xHeight), y = Math.max(y, b.sub2);
      var M = b.defaultRuleThickness, x = 4 * M;
      if (_ - d.depth - (g.height - y) < x) {
        y = x - (_ - d.depth) + g.height;
        var P = 0.8 * b.xHeight - (_ - d.depth);
        P > 0 && (_ += P, y -= P);
      }
      var U = [{
        type: "elem",
        elem: g,
        shift: y,
        marginRight: I,
        marginLeft: w
      }, {
        type: "elem",
        elem: d,
        shift: -_,
        marginRight: I
      }];
      F = buildCommon.makeVList({
        positionType: "individualShift",
        children: U
      }, t);
    } else if (g) {
      y = Math.max(y, b.sub1, g.height - 0.8 * b.xHeight);
      var L = [{
        type: "elem",
        elem: g,
        marginLeft: w,
        marginRight: I
      }];
      F = buildCommon.makeVList({
        positionType: "shift",
        positionData: y,
        children: L
      }, t);
    } else if (d)
      _ = Math.max(_, C, d.depth + 0.25 * b.xHeight), F = buildCommon.makeVList({
        positionType: "shift",
        positionData: -_,
        children: [{
          type: "elem",
          elem: d,
          marginRight: I
        }]
      }, t);
    else
      throw new Error("supsub must have either sup or sub.");
    var H = getTypeOfDomTree(c, "right") || "mord";
    return buildCommon.makeSpan([H], [c, buildCommon.makeSpan(["msupsub"], [F])], t);
  },
  mathmlBuilder(e, t) {
    var r = !1, a, o;
    e.base && e.base.type === "horizBrace" && (o = !!e.sup, o === e.base.isOver && (r = !0, a = e.base.isOver)), e.base && (e.base.type === "op" || e.base.type === "operatorname") && (e.base.parentIsSupSub = !0);
    var u = [buildGroup(e.base, t)];
    e.sub && u.push(buildGroup(e.sub, t)), e.sup && u.push(buildGroup(e.sup, t));
    var c;
    if (r)
      c = a ? "mover" : "munder";
    else if (e.sub)
      if (e.sup) {
        var b = e.base;
        b && b.type === "op" && b.limits && t.style === Style$1.DISPLAY || b && b.type === "operatorname" && b.alwaysHandleSupSub && (t.style === Style$1.DISPLAY || b.limits) ? c = "munderover" : c = "msubsup";
      } else {
        var g = e.base;
        g && g.type === "op" && g.limits && (t.style === Style$1.DISPLAY || g.alwaysHandleSupSub) || g && g.type === "operatorname" && g.alwaysHandleSupSub && (g.limits || t.style === Style$1.DISPLAY) ? c = "munder" : c = "msub";
      }
    else {
      var d = e.base;
      d && d.type === "op" && d.limits && (t.style === Style$1.DISPLAY || d.alwaysHandleSupSub) || d && d.type === "operatorname" && d.alwaysHandleSupSub && (d.limits || t.style === Style$1.DISPLAY) ? c = "mover" : c = "msup";
    }
    return new mathMLTree.MathNode(c, u);
  }
});
defineFunctionBuilders({
  type: "atom",
  htmlBuilder(e, t) {
    return buildCommon.mathsym(e.text, e.mode, t, ["m" + e.family]);
  },
  mathmlBuilder(e, t) {
    var r = new mathMLTree.MathNode("mo", [makeText(e.text, e.mode)]);
    if (e.family === "bin") {
      var a = getVariant(e, t);
      a === "bold-italic" && r.setAttribute("mathvariant", a);
    } else e.family === "punct" ? r.setAttribute("separator", "true") : (e.family === "open" || e.family === "close") && r.setAttribute("stretchy", "false");
    return r;
  }
});
var defaultVariant = {
  mi: "italic",
  mn: "normal",
  mtext: "normal"
};
defineFunctionBuilders({
  type: "mathord",
  htmlBuilder(e, t) {
    return buildCommon.makeOrd(e, t, "mathord");
  },
  mathmlBuilder(e, t) {
    var r = new mathMLTree.MathNode("mi", [makeText(e.text, e.mode, t)]), a = getVariant(e, t) || "italic";
    return a !== defaultVariant[r.type] && r.setAttribute("mathvariant", a), r;
  }
});
defineFunctionBuilders({
  type: "textord",
  htmlBuilder(e, t) {
    return buildCommon.makeOrd(e, t, "textord");
  },
  mathmlBuilder(e, t) {
    var r = makeText(e.text, e.mode, t), a = getVariant(e, t) || "normal", o;
    return e.mode === "text" ? o = new mathMLTree.MathNode("mtext", [r]) : /[0-9]/.test(e.text) ? o = new mathMLTree.MathNode("mn", [r]) : e.text === "\\prime" ? o = new mathMLTree.MathNode("mo", [r]) : o = new mathMLTree.MathNode("mi", [r]), a !== defaultVariant[o.type] && o.setAttribute("mathvariant", a), o;
  }
});
var cssSpace = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
}, regularSpace = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};
defineFunctionBuilders({
  type: "spacing",
  htmlBuilder(e, t) {
    if (regularSpace.hasOwnProperty(e.text)) {
      var r = regularSpace[e.text].className || "";
      if (e.mode === "text") {
        var a = buildCommon.makeOrd(e, t, "textord");
        return a.classes.push(r), a;
      } else
        return buildCommon.makeSpan(["mspace", r], [buildCommon.mathsym(e.text, e.mode, t)], t);
    } else {
      if (cssSpace.hasOwnProperty(e.text))
        return buildCommon.makeSpan(["mspace", cssSpace[e.text]], [], t);
      throw new ParseError('Unknown type of space "' + e.text + '"');
    }
  },
  mathmlBuilder(e, t) {
    var r;
    if (regularSpace.hasOwnProperty(e.text))
      r = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("")]);
    else {
      if (cssSpace.hasOwnProperty(e.text))
        return new mathMLTree.MathNode("mspace");
      throw new ParseError('Unknown type of space "' + e.text + '"');
    }
    return r;
  }
});
var pad = () => {
  var e = new mathMLTree.MathNode("mtd", []);
  return e.setAttribute("width", "50%"), e;
};
defineFunctionBuilders({
  type: "tag",
  mathmlBuilder(e, t) {
    var r = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(e.body, t)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(e.tag, t)])])]);
    return r.setAttribute("width", "100%"), r;
  }
});
var textFontFamilies = {
  "\\text": void 0,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
}, textFontWeights = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
}, textFontShapes = {
  "\\textit": "textit",
  "\\textup": "textup"
}, optionsWithFont = (e, t) => {
  var r = e.font;
  if (r) {
    if (textFontFamilies[r])
      return t.withTextFontFamily(textFontFamilies[r]);
    if (textFontWeights[r])
      return t.withTextFontWeight(textFontWeights[r]);
    if (r === "\\emph")
      return t.fontShape === "textit" ? t.withTextFontShape("textup") : t.withTextFontShape("textit");
  } else return t;
  return t.withTextFontShape(textFontShapes[r]);
};
defineFunction({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup",
    "\\emph"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: !0,
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: r,
      funcName: a
    } = e, o = t[0];
    return {
      type: "text",
      mode: r.mode,
      body: ordargument(o),
      font: a
    };
  },
  htmlBuilder(e, t) {
    var r = optionsWithFont(e, t), a = buildExpression$1(e.body, r, !0);
    return buildCommon.makeSpan(["mord", "text"], a, r);
  },
  mathmlBuilder(e, t) {
    var r = optionsWithFont(e, t);
    return buildExpressionRow(e.body, r);
  }
});
defineFunction({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(e, t) {
    var {
      parser: r
    } = e;
    return {
      type: "underline",
      mode: r.mode,
      body: t[0]
    };
  },
  htmlBuilder(e, t) {
    var r = buildGroup$1(e.body, t), a = buildCommon.makeLineSpan("underline-line", t), o = t.fontMetrics().defaultRuleThickness, u = buildCommon.makeVList({
      positionType: "top",
      positionData: r.height,
      children: [{
        type: "kern",
        size: o
      }, {
        type: "elem",
        elem: a
      }, {
        type: "kern",
        size: 3 * o
      }, {
        type: "elem",
        elem: r
      }]
    }, t);
    return buildCommon.makeSpan(["mord", "underline"], [u], t);
  },
  mathmlBuilder(e, t) {
    var r = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("")]);
    r.setAttribute("stretchy", "true");
    var a = new mathMLTree.MathNode("munder", [buildGroup(e.body, t), r]);
    return a.setAttribute("accentunder", "true"), a;
  }
});
defineFunction({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    // In LaTeX, \vcenter can act only on a box.
    allowedInText: !1
  },
  handler(e, t) {
    var {
      parser: r
    } = e;
    return {
      type: "vcenter",
      mode: r.mode,
      body: t[0]
    };
  },
  htmlBuilder(e, t) {
    var r = buildGroup$1(e.body, t), a = t.fontMetrics().axisHeight, o = 0.5 * (r.height - a - (r.depth + a));
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: o,
      children: [{
        type: "elem",
        elem: r
      }]
    }, t);
  },
  mathmlBuilder(e, t) {
    return new mathMLTree.MathNode("mpadded", [buildGroup(e.body, t)], ["vcenter"]);
  }
});
defineFunction({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(e, t, r) {
    throw new ParseError("\\verb ended by end of line instead of matching delimiter");
  },
  htmlBuilder(e, t) {
    for (var r = makeVerb(e), a = [], o = t.havingStyle(t.style.text()), u = 0; u < r.length; u++) {
      var c = r[u];
      c === "~" && (c = "\\textasciitilde"), a.push(buildCommon.makeSymbol(c, "Typewriter-Regular", e.mode, o, ["mord", "texttt"]));
    }
    return buildCommon.makeSpan(["mord", "text"].concat(o.sizingClasses(t)), buildCommon.tryCombineChars(a), o);
  },
  mathmlBuilder(e, t) {
    var r = new mathMLTree.TextNode(makeVerb(e)), a = new mathMLTree.MathNode("mtext", [r]);
    return a.setAttribute("mathvariant", "monospace"), a;
  }
});
var makeVerb = (e) => e.body.replace(/ /g, e.star ? "" : ""), functions = _functions, spaceRegexString = `[ \r
	]`, controlWordRegexString = "\\\\[a-zA-Z@]+", controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]", controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*", controlSpaceRegexString = `\\\\(
|[ \r	]+
?)[ \r	]*`, combiningDiacriticalMarkString = "[-]", combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$"), tokenRegexString = "(" + spaceRegexString + "+)|" + // whitespace
(controlSpaceRegexString + "|") + // \whitespace
"([!-\\[\\]---]" + // single codepoint
(combiningDiacriticalMarkString + "*") + // ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
(combiningDiacriticalMarkString + "*") + // ...plus accents
"|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
("|" + controlWordWhitespaceRegexString) + // \macroName + spaces
("|" + controlSymbolRegexString + ")");
class Lexer {
  // Category codes. The lexer only supports comment characters (14) for now.
  // MacroExpander additionally distinguishes active (13).
  constructor(t, r) {
    this.input = void 0, this.settings = void 0, this.tokenRegex = void 0, this.catcodes = void 0, this.input = t, this.settings = r, this.tokenRegex = new RegExp(tokenRegexString, "g"), this.catcodes = {
      "%": 14,
      // comment character
      "~": 13
      // active character
    };
  }
  setCatcode(t, r) {
    this.catcodes[t] = r;
  }
  /**
   * This function lexes a single token.
   */
  lex() {
    var t = this.input, r = this.tokenRegex.lastIndex;
    if (r === t.length)
      return new Token("EOF", new SourceLocation(this, r, r));
    var a = this.tokenRegex.exec(t);
    if (a === null || a.index !== r)
      throw new ParseError("Unexpected character: '" + t[r] + "'", new Token(t[r], new SourceLocation(this, r, r + 1)));
    var o = a[6] || a[3] || (a[2] ? "\\ " : " ");
    if (this.catcodes[o] === 14) {
      var u = t.indexOf(`
`, this.tokenRegex.lastIndex);
      return u === -1 ? (this.tokenRegex.lastIndex = t.length, this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)")) : this.tokenRegex.lastIndex = u + 1, this.lex();
    }
    return new Token(o, new SourceLocation(this, r, this.tokenRegex.lastIndex));
  }
}
class Namespace {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(t, r) {
    t === void 0 && (t = {}), r === void 0 && (r = {}), this.current = void 0, this.builtins = void 0, this.undefStack = void 0, this.current = r, this.builtins = t, this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0)
      throw new ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
    var t = this.undefStack.pop();
    for (var r in t)
      t.hasOwnProperty(r) && (t[r] == null ? delete this.current[r] : this.current[r] = t[r]);
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    for (; this.undefStack.length > 0; )
      this.endGroup();
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(t) {
    return this.current.hasOwnProperty(t) || this.builtins.hasOwnProperty(t);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(t) {
    return this.current.hasOwnProperty(t) ? this.current[t] : this.builtins[t];
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   * A value of undefined means to delete existing definitions.
   */
  set(t, r, a) {
    if (a === void 0 && (a = !1), a) {
      for (var o = 0; o < this.undefStack.length; o++)
        delete this.undefStack[o][t];
      this.undefStack.length > 0 && (this.undefStack[this.undefStack.length - 1][t] = r);
    } else {
      var u = this.undefStack[this.undefStack.length - 1];
      u && !u.hasOwnProperty(t) && (u[t] = this.current[t]);
    }
    r == null ? delete this.current[t] : this.current[t] = r;
  }
}
var macros = _macros;
defineMacro("\\noexpand", function(e) {
  var t = e.popToken();
  return e.isExpandable(t.text) && (t.noexpand = !0, t.treatAsRelax = !0), {
    tokens: [t],
    numArgs: 0
  };
});
defineMacro("\\expandafter", function(e) {
  var t = e.popToken();
  return e.expandOnce(!0), {
    tokens: [t],
    numArgs: 0
  };
});
defineMacro("\\@firstoftwo", function(e) {
  var t = e.consumeArgs(2);
  return {
    tokens: t[0],
    numArgs: 0
  };
});
defineMacro("\\@secondoftwo", function(e) {
  var t = e.consumeArgs(2);
  return {
    tokens: t[1],
    numArgs: 0
  };
});
defineMacro("\\@ifnextchar", function(e) {
  var t = e.consumeArgs(3);
  e.consumeSpaces();
  var r = e.future();
  return t[0].length === 1 && t[0][0].text === r.text ? {
    tokens: t[1],
    numArgs: 0
  } : {
    tokens: t[2],
    numArgs: 0
  };
});
defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
defineMacro("\\TextOrMath", function(e) {
  var t = e.consumeArgs(2);
  return e.mode === "text" ? {
    tokens: t[0],
    numArgs: 0
  } : {
    tokens: t[1],
    numArgs: 0
  };
});
var digitToNumber = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
defineMacro("\\char", function(e) {
  var t = e.popToken(), r, a = "";
  if (t.text === "'")
    r = 8, t = e.popToken();
  else if (t.text === '"')
    r = 16, t = e.popToken();
  else if (t.text === "`")
    if (t = e.popToken(), t.text[0] === "\\")
      a = t.text.charCodeAt(1);
    else {
      if (t.text === "EOF")
        throw new ParseError("\\char` missing argument");
      a = t.text.charCodeAt(0);
    }
  else
    r = 10;
  if (r) {
    if (a = digitToNumber[t.text], a == null || a >= r)
      throw new ParseError("Invalid base-" + r + " digit " + t.text);
    for (var o; (o = digitToNumber[e.future().text]) != null && o < r; )
      a *= r, a += o, e.popToken();
  }
  return "\\@char{" + a + "}";
});
var newcommand = (e, t, r, a) => {
  var o = e.consumeArg().tokens;
  if (o.length !== 1)
    throw new ParseError("\\newcommand's first argument must be a macro name");
  var u = o[0].text, c = e.isDefined(u);
  if (c && !t)
    throw new ParseError("\\newcommand{" + u + "} attempting to redefine " + (u + "; use \\renewcommand"));
  if (!c && !r)
    throw new ParseError("\\renewcommand{" + u + "} when command " + u + " does not yet exist; use \\newcommand");
  var d = 0;
  if (o = e.consumeArg().tokens, o.length === 1 && o[0].text === "[") {
    for (var g = "", b = e.expandNextToken(); b.text !== "]" && b.text !== "EOF"; )
      g += b.text, b = e.expandNextToken();
    if (!g.match(/^\s*[0-9]+\s*$/))
      throw new ParseError("Invalid number of arguments: " + g);
    d = parseInt(g), o = e.consumeArg().tokens;
  }
  return c && a || e.macros.set(u, {
    tokens: o,
    numArgs: d
  }), "";
};
defineMacro("\\newcommand", (e) => newcommand(e, !1, !0, !1));
defineMacro("\\renewcommand", (e) => newcommand(e, !0, !1, !1));
defineMacro("\\providecommand", (e) => newcommand(e, !0, !0, !0));
defineMacro("\\message", (e) => {
  var t = e.consumeArgs(1)[0];
  return console.log(t.reverse().map((r) => r.text).join("")), "";
});
defineMacro("\\errmessage", (e) => {
  var t = e.consumeArgs(1)[0];
  return console.error(t.reverse().map((r) => r.text).join("")), "";
});
defineMacro("\\show", (e) => {
  var t = e.popToken(), r = t.text;
  return console.log(t, e.macros.get(r), functions[r], symbols.math[r], symbols.text[r]), "";
});
defineMacro("\\bgroup", "{");
defineMacro("\\egroup", "}");
defineMacro("~", "\\nobreakspace");
defineMacro("\\lq", "`");
defineMacro("\\rq", "'");
defineMacro("\\aa", "\\r a");
defineMacro("\\AA", "\\r A");
defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`}");
defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`}");
defineMacro("", "\\mathscr{B}");
defineMacro("", "\\mathscr{E}");
defineMacro("", "\\mathscr{F}");
defineMacro("", "\\mathscr{H}");
defineMacro("", "\\mathscr{I}");
defineMacro("", "\\mathscr{L}");
defineMacro("", "\\mathscr{M}");
defineMacro("", "\\mathscr{R}");
defineMacro("", "\\mathfrak{C}");
defineMacro("", "\\mathfrak{H}");
defineMacro("", "\\mathfrak{Z}");
defineMacro("\\Bbbk", "\\Bbb{k}");
defineMacro("", "\\cdotp");
defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
defineMacro("\\mathstrut", "\\vphantom{(}");
defineMacro("\\underbar", "\\underline{\\text{#1}}");
defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`}}");
defineMacro("\\ne", "\\neq");
defineMacro("", "\\neq");
defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`}}");
defineMacro("", "\\notin");
defineMacro("", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\perp");
defineMacro("", "\\mathclose{!\\mkern-0.8mu!}");
defineMacro("", "\\notni");
defineMacro("", "\\ulcorner");
defineMacro("", "\\urcorner");
defineMacro("", "\\llcorner");
defineMacro("", "\\lrcorner");
defineMacro("", "\\copyright");
defineMacro("", "\\textregistered");
defineMacro("", "\\textregistered");
defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
defineMacro("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
defineMacro("", "\\vdots");
defineMacro("\\varGamma", "\\mathit{\\Gamma}");
defineMacro("\\varDelta", "\\mathit{\\Delta}");
defineMacro("\\varTheta", "\\mathit{\\Theta}");
defineMacro("\\varLambda", "\\mathit{\\Lambda}");
defineMacro("\\varXi", "\\mathit{\\Xi}");
defineMacro("\\varPi", "\\mathit{\\Pi}");
defineMacro("\\varSigma", "\\mathit{\\Sigma}");
defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
defineMacro("\\varPhi", "\\mathit{\\Phi}");
defineMacro("\\varPsi", "\\mathit{\\Psi}");
defineMacro("\\varOmega", "\\mathit{\\Omega}");
defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
defineMacro("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
defineMacro("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
var dotsByToken = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};
defineMacro("\\dots", function(e) {
  var t = "\\dotso", r = e.expandAfterFuture().text;
  return r in dotsByToken ? t = dotsByToken[r] : (r.slice(0, 4) === "\\not" || r in symbols.math && utils.contains(["bin", "rel"], symbols.math[r].group)) && (t = "\\dotsb"), t;
});
var spaceAfterDots = {
  // \rightdelim@ checks for the following:
  ")": !0,
  "]": !0,
  "\\rbrack": !0,
  "\\}": !0,
  "\\rbrace": !0,
  "\\rangle": !0,
  "\\rceil": !0,
  "\\rfloor": !0,
  "\\rgroup": !0,
  "\\rmoustache": !0,
  "\\right": !0,
  "\\bigr": !0,
  "\\biggr": !0,
  "\\Bigr": !0,
  "\\Biggr": !0,
  // \extra@ also tests for the following:
  $: !0,
  // \extrap@ checks for the following:
  ";": !0,
  ".": !0,
  ",": !0
};
defineMacro("\\dotso", function(e) {
  var t = e.future().text;
  return t in spaceAfterDots ? "\\ldots\\," : "\\ldots";
});
defineMacro("\\dotsc", function(e) {
  var t = e.future().text;
  return t in spaceAfterDots && t !== "," ? "\\ldots\\," : "\\ldots";
});
defineMacro("\\cdots", function(e) {
  var t = e.future().text;
  return t in spaceAfterDots ? "\\@cdots\\," : "\\@cdots";
});
defineMacro("\\dotsb", "\\cdots");
defineMacro("\\dotsm", "\\cdots");
defineMacro("\\dotsi", "\\!\\cdots");
defineMacro("\\dotsx", "\\ldots\\,");
defineMacro("\\DOTSI", "\\relax");
defineMacro("\\DOTSB", "\\relax");
defineMacro("\\DOTSX", "\\relax");
defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
defineMacro("\\thinspace", "\\,");
defineMacro("\\>", "\\mskip{4mu}");
defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
defineMacro("\\medspace", "\\:");
defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
defineMacro("\\thickspace", "\\;");
defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
defineMacro("\\negthinspace", "\\!");
defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
defineMacro("\\enspace", "\\kern.5em ");
defineMacro("\\enskip", "\\hskip.5em\\relax");
defineMacro("\\quad", "\\hskip1em\\relax");
defineMacro("\\qquad", "\\hskip2em\\relax");
defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
defineMacro("\\tag@literal", (e) => {
  if (e.macros.get("\\df@tag"))
    throw new ParseError("Multiple \\tag");
  return "\\gdef\\df@tag{\\text{#1}}";
});
defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
defineMacro("\\newline", "\\\\\\relax");
defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
var latexRaiseA = makeEm(fontMetricsData["Main-Regular"][84][1] - 0.7 * fontMetricsData["Main-Regular"][65][1]);
defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
defineMacro("\\@hspace", "\\hskip #1\\relax");
defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
defineMacro("\\ordinarycolon", ":");
defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
defineMacro("", "\\dblcolon");
defineMacro("", "\\eqcolon");
defineMacro("", "\\coloneqq");
defineMacro("", "\\eqqcolon");
defineMacro("", "\\Coloneqq");
defineMacro("\\ratio", "\\vcentcolon");
defineMacro("\\coloncolon", "\\dblcolon");
defineMacro("\\colonequals", "\\coloneqq");
defineMacro("\\coloncolonequals", "\\Coloneqq");
defineMacro("\\equalscolon", "\\eqqcolon");
defineMacro("\\equalscoloncolon", "\\Eqqcolon");
defineMacro("\\colonminus", "\\coloneq");
defineMacro("\\coloncolonminus", "\\Coloneq");
defineMacro("\\minuscolon", "\\eqcolon");
defineMacro("\\minuscoloncolon", "\\Eqcolon");
defineMacro("\\coloncolonapprox", "\\Colonapprox");
defineMacro("\\coloncolonsim", "\\Colonsim");
defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`}}");
defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{}");
defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{}");
defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{}");
defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{}");
defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{}");
defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{}");
defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{}");
defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{}");
defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{}");
defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{}");
defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{}");
defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{}");
defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{}");
defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{}");
defineMacro("\\imath", "\\html@mathml{\\@imath}{}");
defineMacro("\\jmath", "\\html@mathml{\\@jmath}{}");
defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`}}");
defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`}}");
defineMacro("", "\\llbracket");
defineMacro("", "\\rrbracket");
defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`}}");
defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`}}");
defineMacro("", "\\lBrace");
defineMacro("", "\\rBrace");
defineMacro("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`}}");
defineMacro("", "\\minuso");
defineMacro("\\darr", "\\downarrow");
defineMacro("\\dArr", "\\Downarrow");
defineMacro("\\Darr", "\\Downarrow");
defineMacro("\\lang", "\\langle");
defineMacro("\\rang", "\\rangle");
defineMacro("\\uarr", "\\uparrow");
defineMacro("\\uArr", "\\Uparrow");
defineMacro("\\Uarr", "\\Uparrow");
defineMacro("\\N", "\\mathbb{N}");
defineMacro("\\R", "\\mathbb{R}");
defineMacro("\\Z", "\\mathbb{Z}");
defineMacro("\\alef", "\\aleph");
defineMacro("\\alefsym", "\\aleph");
defineMacro("\\Alpha", "\\mathrm{A}");
defineMacro("\\Beta", "\\mathrm{B}");
defineMacro("\\bull", "\\bullet");
defineMacro("\\Chi", "\\mathrm{X}");
defineMacro("\\clubs", "\\clubsuit");
defineMacro("\\cnums", "\\mathbb{C}");
defineMacro("\\Complex", "\\mathbb{C}");
defineMacro("\\Dagger", "\\ddagger");
defineMacro("\\diamonds", "\\diamondsuit");
defineMacro("\\empty", "\\emptyset");
defineMacro("\\Epsilon", "\\mathrm{E}");
defineMacro("\\Eta", "\\mathrm{H}");
defineMacro("\\exist", "\\exists");
defineMacro("\\harr", "\\leftrightarrow");
defineMacro("\\hArr", "\\Leftrightarrow");
defineMacro("\\Harr", "\\Leftrightarrow");
defineMacro("\\hearts", "\\heartsuit");
defineMacro("\\image", "\\Im");
defineMacro("\\infin", "\\infty");
defineMacro("\\Iota", "\\mathrm{I}");
defineMacro("\\isin", "\\in");
defineMacro("\\Kappa", "\\mathrm{K}");
defineMacro("\\larr", "\\leftarrow");
defineMacro("\\lArr", "\\Leftarrow");
defineMacro("\\Larr", "\\Leftarrow");
defineMacro("\\lrarr", "\\leftrightarrow");
defineMacro("\\lrArr", "\\Leftrightarrow");
defineMacro("\\Lrarr", "\\Leftrightarrow");
defineMacro("\\Mu", "\\mathrm{M}");
defineMacro("\\natnums", "\\mathbb{N}");
defineMacro("\\Nu", "\\mathrm{N}");
defineMacro("\\Omicron", "\\mathrm{O}");
defineMacro("\\plusmn", "\\pm");
defineMacro("\\rarr", "\\rightarrow");
defineMacro("\\rArr", "\\Rightarrow");
defineMacro("\\Rarr", "\\Rightarrow");
defineMacro("\\real", "\\Re");
defineMacro("\\reals", "\\mathbb{R}");
defineMacro("\\Reals", "\\mathbb{R}");
defineMacro("\\Rho", "\\mathrm{P}");
defineMacro("\\sdot", "\\cdot");
defineMacro("\\sect", "\\S");
defineMacro("\\spades", "\\spadesuit");
defineMacro("\\sub", "\\subset");
defineMacro("\\sube", "\\subseteq");
defineMacro("\\supe", "\\supseteq");
defineMacro("\\Tau", "\\mathrm{T}");
defineMacro("\\thetasym", "\\vartheta");
defineMacro("\\weierp", "\\wp");
defineMacro("\\Zeta", "\\mathrm{Z}");
defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
defineMacro("\\Bra", "\\left\\langle#1\\right|");
defineMacro("\\Ket", "\\left|#1\\right\\rangle");
var braketHelper = (e) => (t) => {
  var r = t.consumeArg().tokens, a = t.consumeArg().tokens, o = t.consumeArg().tokens, u = t.consumeArg().tokens, c = t.macros.get("|"), d = t.macros.get("\\|");
  t.macros.beginGroup();
  var g = (y) => (A) => {
    e && (A.macros.set("|", c), o.length && A.macros.set("\\|", d));
    var E = y;
    if (!y && o.length) {
      var v = A.future();
      v.text === "|" && (A.popToken(), E = !0);
    }
    return {
      tokens: E ? o : a,
      numArgs: 0
    };
  };
  t.macros.set("|", g(!1)), o.length && t.macros.set("\\|", g(!0));
  var b = t.consumeArg().tokens, _ = t.expandTokens([
    ...u,
    ...b,
    ...r
    // reversed
  ]);
  return t.macros.endGroup(), {
    tokens: _.reverse(),
    numArgs: 0
  };
};
defineMacro("\\bra@ket", braketHelper(!1));
defineMacro("\\bra@set", braketHelper(!0));
defineMacro("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
defineMacro("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
defineMacro("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
defineMacro("\\angln", "{\\angl n}");
defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
defineMacro("\\red", "\\textcolor{##df0030}{#1}");
defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
defineMacro("\\gray", "\\textcolor{gray}{#1}");
defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
var implicitCommands = {
  "^": !0,
  // Parser.js
  _: !0,
  // Parser.js
  "\\limits": !0,
  // Parser.js
  "\\nolimits": !0
  // Parser.js
};
class MacroExpander {
  constructor(t, r, a) {
    this.settings = void 0, this.expansionCount = void 0, this.lexer = void 0, this.macros = void 0, this.stack = void 0, this.mode = void 0, this.settings = r, this.expansionCount = 0, this.feed(t), this.macros = new Namespace(macros, r.macros), this.mode = a, this.stack = [];
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(t) {
    this.lexer = new Lexer(t, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(t) {
    this.mode = t;
  }
  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    this.macros.endGroups();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    return this.stack.length === 0 && this.pushToken(this.lexer.lex()), this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    return this.future(), this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(t) {
    this.stack.push(t);
  }
  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(t) {
    this.stack.push(...t);
  }
  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(t) {
    var r, a, o;
    if (t) {
      if (this.consumeSpaces(), this.future().text !== "[")
        return null;
      r = this.popToken(), {
        tokens: o,
        end: a
      } = this.consumeArg(["]"]);
    } else
      ({
        tokens: o,
        start: r,
        end: a
      } = this.consumeArg());
    return this.pushToken(new Token("EOF", a.loc)), this.pushTokens(o), r.range(a, "");
  }
  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (; ; ) {
      var t = this.future();
      if (t.text === " ")
        this.stack.pop();
      else
        break;
    }
  }
  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(t) {
    var r = [], a = t && t.length > 0;
    a || this.consumeSpaces();
    var o = this.future(), u, c = 0, d = 0;
    do {
      if (u = this.popToken(), r.push(u), u.text === "{")
        ++c;
      else if (u.text === "}") {
        if (--c, c === -1)
          throw new ParseError("Extra }", u);
      } else if (u.text === "EOF")
        throw new ParseError("Unexpected end of input in a macro argument, expected '" + (t && a ? t[d] : "}") + "'", u);
      if (t && a)
        if ((c === 0 || c === 1 && t[d] === "{") && u.text === t[d]) {
          if (++d, d === t.length) {
            r.splice(-d, d);
            break;
          }
        } else
          d = 0;
    } while (c !== 0 || a);
    return o.text === "{" && r[r.length - 1].text === "}" && (r.pop(), r.shift()), r.reverse(), {
      tokens: r,
      start: o,
      end: u
    };
  }
  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(t, r) {
    if (r) {
      if (r.length !== t + 1)
        throw new ParseError("The length of delimiters doesn't match the number of args!");
      for (var a = r[0], o = 0; o < a.length; o++) {
        var u = this.popToken();
        if (a[o] !== u.text)
          throw new ParseError("Use of the macro doesn't match its definition", u);
      }
    }
    for (var c = [], d = 0; d < t; d++)
      c.push(this.consumeArg(r && r[d + 1]).tokens);
    return c;
  }
  /**
   * Increment `expansionCount` by the specified amount.
   * Throw an error if it exceeds `maxExpand`.
   */
  countExpansion(t) {
    if (this.expansionCount += t, this.expansionCount > this.settings.maxExpand)
      throw new ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(t) {
    var r = this.popToken(), a = r.text, o = r.noexpand ? null : this._getExpansion(a);
    if (o == null || t && o.unexpandable) {
      if (t && o == null && a[0] === "\\" && !this.isDefined(a))
        throw new ParseError("Undefined control sequence: " + a);
      return this.pushToken(r), !1;
    }
    this.countExpansion(1);
    var u = o.tokens, c = this.consumeArgs(o.numArgs, o.delimiters);
    if (o.numArgs) {
      u = u.slice();
      for (var d = u.length - 1; d >= 0; --d) {
        var g = u[d];
        if (g.text === "#") {
          if (d === 0)
            throw new ParseError("Incomplete placeholder at end of macro body", g);
          if (g = u[--d], g.text === "#")
            u.splice(d + 1, 1);
          else if (/^[1-9]$/.test(g.text))
            u.splice(d, 2, ...c[+g.text - 1]);
          else
            throw new ParseError("Not a valid argument number", g);
        }
      }
    }
    return this.pushTokens(u), u.length;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    return this.expandOnce(), this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (; ; )
      if (this.expandOnce() === !1) {
        var t = this.stack.pop();
        return t.treatAsRelax && (t.text = "\\relax"), t;
      }
    throw new Error();
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(t) {
    return this.macros.has(t) ? this.expandTokens([new Token(t)]) : void 0;
  }
  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(t) {
    var r = [], a = this.stack.length;
    for (this.pushTokens(t); this.stack.length > a; )
      if (this.expandOnce(!0) === !1) {
        var o = this.stack.pop();
        o.treatAsRelax && (o.noexpand = !1, o.treatAsRelax = !1), r.push(o);
      }
    return this.countExpansion(r.length), r;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(t) {
    var r = this.expandMacro(t);
    return r && r.map((a) => a.text).join("");
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(t) {
    var r = this.macros.get(t);
    if (r == null)
      return r;
    if (t.length === 1) {
      var a = this.lexer.catcodes[t];
      if (a != null && a !== 13)
        return;
    }
    var o = typeof r == "function" ? r(this) : r;
    if (typeof o == "string") {
      var u = 0;
      if (o.indexOf("#") !== -1)
        for (var c = o.replace(/##/g, ""); c.indexOf("#" + (u + 1)) !== -1; )
          ++u;
      for (var d = new Lexer(o, this.settings), g = [], b = d.lex(); b.text !== "EOF"; )
        g.push(b), b = d.lex();
      g.reverse();
      var _ = {
        tokens: g,
        numArgs: u
      };
      return _;
    }
    return o;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(t) {
    return this.macros.has(t) || functions.hasOwnProperty(t) || symbols.math.hasOwnProperty(t) || symbols.text.hasOwnProperty(t) || implicitCommands.hasOwnProperty(t);
  }
  /**
   * Determine whether a command is expandable.
   */
  isExpandable(t) {
    var r = this.macros.get(t);
    return r != null ? typeof r == "string" || typeof r == "function" || !r.unexpandable : functions.hasOwnProperty(t) && !functions[t].primitive;
  }
}
var unicodeSubRegEx = /^[]/, uSubsAndSups = Object.freeze({
  "": "+",
  "": "-",
  "": "=",
  "": "(",
  "": ")",
  "": "0",
  "": "1",
  "": "2",
  "": "3",
  "": "4",
  "": "5",
  "": "6",
  "": "7",
  "": "8",
  "": "9",
  "": "a",
  "": "e",
  "": "h",
  "": "i",
  "": "j",
  "": "k",
  "": "l",
  "": "m",
  "": "n",
  "": "o",
  "": "p",
  "": "r",
  "": "s",
  "": "t",
  "": "u",
  "": "v",
  "": "x",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "+",
  "": "-",
  "": "=",
  "": "(",
  "": ")",
  "": "0",
  "": "1",
  "": "2",
  "": "3",
  "": "4",
  "": "5",
  "": "6",
  "": "7",
  "": "8",
  "": "9",
  "": "A",
  "": "B",
  "": "D",
  "": "E",
  "": "G",
  "": "H",
  "": "I",
  "": "J",
  "": "K",
  "": "L",
  "": "M",
  "": "N",
  "": "O",
  "": "P",
  "": "R",
  "": "T",
  "": "U",
  "": "V",
  "": "W",
  "": "a",
  "": "b",
  "": "c",
  "": "d",
  "": "e",
  "": "f",
  "": "g",
  : "h",
  "": "i",
  : "j",
  "": "k",
  : "l",
  "": "m",
  : "n",
  "": "o",
  "": "p",
  : "r",
  : "s",
  "": "t",
  "": "u",
  "": "v",
  : "w",
  : "x",
  : "y",
  "": "z",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": ""
}), unicodeAccents = {
  "": {
    text: "\\'",
    math: "\\acute"
  },
  "": {
    text: "\\`",
    math: "\\grave"
  },
  "": {
    text: '\\"',
    math: "\\ddot"
  },
  "": {
    text: "\\~",
    math: "\\tilde"
  },
  "": {
    text: "\\=",
    math: "\\bar"
  },
  "": {
    text: "\\u",
    math: "\\breve"
  },
  "": {
    text: "\\v",
    math: "\\check"
  },
  "": {
    text: "\\^",
    math: "\\hat"
  },
  "": {
    text: "\\.",
    math: "\\dot"
  },
  "": {
    text: "\\r",
    math: "\\mathring"
  },
  "": {
    text: "\\H"
  },
  "": {
    text: "\\c"
  }
}, unicodeSymbols = {
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "b",
  : "c",
  : "c",
  : "c",
  : "c",
  : "c",
  : "c",
  : "d",
  : "d",
  : "d",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "f",
  : "g",
  : "g",
  : "g",
  : "g",
  : "g",
  : "g",
  : "g",
  : "h",
  : "h",
  : "h",
  : "h",
  : "h",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "j",
  : "j",
  : "k",
  : "k",
  : "k",
  : "l",
  : "l",
  : "l",
  : "m",
  : "m",
  : "n",
  : "n",
  : "n",
  : "n",
  : "n",
  : "n",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "p",
  : "p",
  : "r",
  : "r",
  : "r",
  : "r",
  : "s",
  : "s",
  : "s",
  : "s",
  : "s",
  : "s",
  : "s",
  : "t",
  : "t",
  : "t",
  : "t",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "v",
  : "w",
  : "w",
  : "w",
  : "w",
  : "w",
  : "w",
  : "x",
  : "x",
  : "y",
  : "y",
  : "y",
  : "y",
  : "y",
  : "y",
  : "y",
  : "y",
  : "z",
  : "z",
  : "z",
  : "z",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "B",
  : "C",
  : "C",
  : "C",
  : "C",
  : "C",
  : "C",
  : "D",
  : "D",
  : "D",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "F",
  : "G",
  : "G",
  : "G",
  : "G",
  : "G",
  : "G",
  : "G",
  : "H",
  : "H",
  : "H",
  : "H",
  : "H",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "J",
  : "K",
  : "K",
  : "K",
  : "L",
  : "L",
  : "L",
  : "M",
  : "M",
  : "N",
  : "N",
  : "N",
  : "N",
  : "N",
  : "N",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "P",
  : "P",
  : "R",
  : "R",
  : "R",
  : "R",
  : "S",
  : "S",
  : "S",
  : "S",
  : "S",
  : "S",
  : "S",
  : "T",
  : "T",
  : "T",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "V",
  : "W",
  : "W",
  : "W",
  : "W",
  : "W",
  : "X",
  : "X",
  : "Y",
  : "Y",
  : "Y",
  : "Y",
  : "Y",
  : "Y",
  : "Y",
  : "Z",
  : "Z",
  : "Z",
  : "Z",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : "",
  : ""
};
let Parser$2 = class Ar {
  constructor(t, r) {
    this.mode = void 0, this.gullet = void 0, this.settings = void 0, this.leftrightDepth = void 0, this.nextToken = void 0, this.mode = "math", this.gullet = new MacroExpander(t, r, this.mode), this.settings = r, this.leftrightDepth = 0;
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(t, r) {
    if (r === void 0 && (r = !0), this.fetch().text !== t)
      throw new ParseError("Expected '" + t + "', got '" + this.fetch().text + "'", this.fetch());
    r && this.consume();
  }
  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }
  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    return this.nextToken == null && (this.nextToken = this.gullet.expandNextToken()), this.nextToken;
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(t) {
    this.mode = t, this.gullet.switchMode(t);
  }
  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    this.settings.globalGroup || this.gullet.beginGroup(), this.settings.colorIsTextColor && this.gullet.macros.set("\\color", "\\textcolor");
    try {
      var t = this.parseExpression(!1);
      return this.expect("EOF"), this.settings.globalGroup || this.gullet.endGroup(), t;
    } finally {
      this.gullet.endGroups();
    }
  }
  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(t) {
    var r = this.nextToken;
    this.consume(), this.gullet.pushToken(new Token("}")), this.gullet.pushTokens(t);
    var a = this.parseExpression(!1);
    return this.expect("}"), this.nextToken = r, a;
  }
  /**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */
  parseExpression(t, r) {
    for (var a = []; ; ) {
      this.mode === "math" && this.consumeSpaces();
      var o = this.fetch();
      if (Ar.endOfExpression.indexOf(o.text) !== -1 || r && o.text === r || t && functions[o.text] && functions[o.text].infix)
        break;
      var u = this.parseAtom(r);
      if (u) {
        if (u.type === "internal")
          continue;
      } else break;
      a.push(u);
    }
    return this.mode === "text" && this.formLigatures(a), this.handleInfixNodes(a);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(t) {
    for (var r = -1, a, o = 0; o < t.length; o++)
      if (t[o].type === "infix") {
        if (r !== -1)
          throw new ParseError("only one infix operator per group", t[o].token);
        r = o, a = t[o].replaceWith;
      }
    if (r !== -1 && a) {
      var u, c, d = t.slice(0, r), g = t.slice(r + 1);
      d.length === 1 && d[0].type === "ordgroup" ? u = d[0] : u = {
        type: "ordgroup",
        mode: this.mode,
        body: d
      }, g.length === 1 && g[0].type === "ordgroup" ? c = g[0] : c = {
        type: "ordgroup",
        mode: this.mode,
        body: g
      };
      var b;
      return a === "\\\\abovefrac" ? b = this.callFunction(a, [u, t[r], c], []) : b = this.callFunction(a, [u, c], []), [b];
    } else
      return t;
  }
  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(t) {
    var r = this.fetch(), a = r.text;
    this.consume(), this.consumeSpaces();
    var o = this.parseGroup(t);
    if (!o)
      throw new ParseError("Expected group after '" + a + "'", r);
    return o;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(t) {
    for (var r = [], a = 0; a < t.length; a++)
      r.push({
        type: "textord",
        mode: "text",
        text: t[a]
      });
    var o = {
      type: "text",
      mode: this.mode,
      body: r
    }, u = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [o]
    };
    return u;
  }
  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(t) {
    var r = this.parseGroup("atom", t);
    if (this.mode === "text")
      return r;
    for (var a, o; ; ) {
      this.consumeSpaces();
      var u = this.fetch();
      if (u.text === "\\limits" || u.text === "\\nolimits") {
        if (r && r.type === "op") {
          var c = u.text === "\\limits";
          r.limits = c, r.alwaysHandleSupSub = !0;
        } else if (r && r.type === "operatorname")
          r.alwaysHandleSupSub && (r.limits = u.text === "\\limits");
        else
          throw new ParseError("Limit controls must follow a math operator", u);
        this.consume();
      } else if (u.text === "^") {
        if (a)
          throw new ParseError("Double superscript", u);
        a = this.handleSupSubscript("superscript");
      } else if (u.text === "_") {
        if (o)
          throw new ParseError("Double subscript", u);
        o = this.handleSupSubscript("subscript");
      } else if (u.text === "'") {
        if (a)
          throw new ParseError("Double superscript", u);
        var d = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        }, g = [d];
        for (this.consume(); this.fetch().text === "'"; )
          g.push(d), this.consume();
        this.fetch().text === "^" && g.push(this.handleSupSubscript("superscript")), a = {
          type: "ordgroup",
          mode: this.mode,
          body: g
        };
      } else if (uSubsAndSups[u.text]) {
        var b = unicodeSubRegEx.test(u.text), _ = [];
        for (_.push(new Token(uSubsAndSups[u.text])), this.consume(); ; ) {
          var y = this.fetch().text;
          if (!uSubsAndSups[y] || unicodeSubRegEx.test(y) !== b)
            break;
          _.unshift(new Token(uSubsAndSups[y])), this.consume();
        }
        var A = this.subparse(_);
        b ? o = {
          type: "ordgroup",
          mode: "math",
          body: A
        } : a = {
          type: "ordgroup",
          mode: "math",
          body: A
        };
      } else
        break;
    }
    return a || o ? {
      type: "supsub",
      mode: this.mode,
      base: r,
      sup: a,
      sub: o
    } : r;
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(t, r) {
    var a = this.fetch(), o = a.text, u = functions[o];
    if (!u)
      return null;
    if (this.consume(), r && r !== "atom" && !u.allowedInArgument)
      throw new ParseError("Got function '" + o + "' with no arguments" + (r ? " as " + r : ""), a);
    if (this.mode === "text" && !u.allowedInText)
      throw new ParseError("Can't use function '" + o + "' in text mode", a);
    if (this.mode === "math" && u.allowedInMath === !1)
      throw new ParseError("Can't use function '" + o + "' in math mode", a);
    var {
      args: c,
      optArgs: d
    } = this.parseArguments(o, u);
    return this.callFunction(o, c, d, a, t);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(t, r, a, o, u) {
    var c = {
      funcName: t,
      parser: this,
      token: o,
      breakOnTokenText: u
    }, d = functions[t];
    if (d && d.handler)
      return d.handler(c, r, a);
    throw new ParseError("No function handler for " + t);
  }
  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(t, r) {
    var a = r.numArgs + r.numOptionalArgs;
    if (a === 0)
      return {
        args: [],
        optArgs: []
      };
    for (var o = [], u = [], c = 0; c < a; c++) {
      var d = r.argTypes && r.argTypes[c], g = c < r.numOptionalArgs;
      (r.primitive && d == null || // \sqrt expands into primitive if optional argument doesn't exist
      r.type === "sqrt" && c === 1 && u[0] == null) && (d = "primitive");
      var b = this.parseGroupOfType("argument to '" + t + "'", d, g);
      if (g)
        u.push(b);
      else if (b != null)
        o.push(b);
      else
        throw new ParseError("Null argument, please report this as a bug");
    }
    return {
      args: o,
      optArgs: u
    };
  }
  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(t, r, a) {
    switch (r) {
      case "color":
        return this.parseColorGroup(a);
      case "size":
        return this.parseSizeGroup(a);
      case "url":
        return this.parseUrlGroup(a);
      case "math":
      case "text":
        return this.parseArgumentGroup(a, r);
      case "hbox": {
        var o = this.parseArgumentGroup(a, "text");
        return o != null ? {
          type: "styling",
          mode: o.mode,
          body: [o],
          style: "text"
          // simulate \textstyle
        } : null;
      }
      case "raw": {
        var u = this.parseStringGroup("raw", a);
        return u != null ? {
          type: "raw",
          mode: "text",
          string: u.text
        } : null;
      }
      case "primitive": {
        if (a)
          throw new ParseError("A primitive argument cannot be optional");
        var c = this.parseGroup(t);
        if (c == null)
          throw new ParseError("Expected group as " + t, this.fetch());
        return c;
      }
      case "original":
      case null:
      case void 0:
        return this.parseArgumentGroup(a);
      default:
        throw new ParseError("Unknown group type as " + t, this.fetch());
    }
  }
  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    for (; this.fetch().text === " "; )
      this.consume();
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(t, r) {
    var a = this.gullet.scanArgument(r);
    if (a == null)
      return null;
    for (var o = "", u; (u = this.fetch()).text !== "EOF"; )
      o += u.text, this.consume();
    return this.consume(), a.text = o, a;
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(t, r) {
    for (var a = this.fetch(), o = a, u = "", c; (c = this.fetch()).text !== "EOF" && t.test(u + c.text); )
      o = c, u += o.text, this.consume();
    if (u === "")
      throw new ParseError("Invalid " + r + ": '" + a.text + "'", a);
    return a.range(o, u);
  }
  /**
   * Parses a color description.
   */
  parseColorGroup(t) {
    var r = this.parseStringGroup("color", t);
    if (r == null)
      return null;
    var a = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(r.text);
    if (!a)
      throw new ParseError("Invalid color: '" + r.text + "'", r);
    var o = a[0];
    return /^[0-9a-f]{6}$/i.test(o) && (o = "#" + o), {
      type: "color-token",
      mode: this.mode,
      color: o
    };
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(t) {
    var r, a = !1;
    if (this.gullet.consumeSpaces(), !t && this.gullet.future().text !== "{" ? r = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size") : r = this.parseStringGroup("size", t), !r)
      return null;
    !t && r.text.length === 0 && (r.text = "0pt", a = !0);
    var o = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(r.text);
    if (!o)
      throw new ParseError("Invalid size: '" + r.text + "'", r);
    var u = {
      number: +(o[1] + o[2]),
      // sign + magnitude, cast to number
      unit: o[3]
    };
    if (!validUnit(u))
      throw new ParseError("Invalid unit: '" + u.unit + "'", r);
    return {
      type: "size",
      mode: this.mode,
      value: u,
      isBlank: a
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(t) {
    this.gullet.lexer.setCatcode("%", 13), this.gullet.lexer.setCatcode("~", 12);
    var r = this.parseStringGroup("url", t);
    if (this.gullet.lexer.setCatcode("%", 14), this.gullet.lexer.setCatcode("~", 13), r == null)
      return null;
    var a = r.text.replace(/\\([#$%&~_^{}])/g, "$1");
    return {
      type: "url",
      mode: this.mode,
      url: a
    };
  }
  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(t, r) {
    var a = this.gullet.scanArgument(t);
    if (a == null)
      return null;
    var o = this.mode;
    r && this.switchMode(r), this.gullet.beginGroup();
    var u = this.parseExpression(!1, "EOF");
    this.expect("EOF"), this.gullet.endGroup();
    var c = {
      type: "ordgroup",
      mode: this.mode,
      loc: a.loc,
      body: u
    };
    return r && this.switchMode(o), c;
  }
  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(t, r) {
    var a = this.fetch(), o = a.text, u;
    if (o === "{" || o === "\\begingroup") {
      this.consume();
      var c = o === "{" ? "}" : "\\endgroup";
      this.gullet.beginGroup();
      var d = this.parseExpression(!1, c), g = this.fetch();
      this.expect(c), this.gullet.endGroup(), u = {
        type: "ordgroup",
        mode: this.mode,
        loc: SourceLocation.range(a, g),
        body: d,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/when-should-one-
        // use-begingroup-instead-of-bgroup
        semisimple: o === "\\begingroup" || void 0
      };
    } else if (u = this.parseFunction(r, t) || this.parseSymbol(), u == null && o[0] === "\\" && !implicitCommands.hasOwnProperty(o)) {
      if (this.settings.throwOnError)
        throw new ParseError("Undefined control sequence: " + o, a);
      u = this.formatUnsupportedCmd(o), this.consume();
    }
    return u;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(t) {
    for (var r = t.length - 1, a = 0; a < r; ++a) {
      var o = t[a], u = o.text;
      u === "-" && t[a + 1].text === "-" && (a + 1 < r && t[a + 2].text === "-" ? (t.splice(a, 3, {
        type: "textord",
        mode: "text",
        loc: SourceLocation.range(o, t[a + 2]),
        text: "---"
      }), r -= 2) : (t.splice(a, 2, {
        type: "textord",
        mode: "text",
        loc: SourceLocation.range(o, t[a + 1]),
        text: "--"
      }), r -= 1)), (u === "'" || u === "`") && t[a + 1].text === u && (t.splice(a, 2, {
        type: "textord",
        mode: "text",
        loc: SourceLocation.range(o, t[a + 1]),
        text: u + u
      }), r -= 1);
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    var t = this.fetch(), r = t.text;
    if (/^\\verb[^a-zA-Z]/.test(r)) {
      this.consume();
      var a = r.slice(5), o = a.charAt(0) === "*";
      if (o && (a = a.slice(1)), a.length < 2 || a.charAt(0) !== a.slice(-1))
        throw new ParseError(`\\verb assertion failed --
                    please report what input caused this bug`);
      return a = a.slice(1, -1), {
        type: "verb",
        mode: "text",
        body: a,
        star: o
      };
    }
    unicodeSymbols.hasOwnProperty(r[0]) && !symbols[this.mode][r[0]] && (this.settings.strict && this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + r[0] + '" used in math mode', t), r = unicodeSymbols[r[0]] + r.slice(1));
    var u = combiningDiacriticalMarksEndRegex.exec(r);
    u && (r = r.substring(0, u.index), r === "i" ? r = "" : r === "j" && (r = ""));
    var c;
    if (symbols[this.mode][r]) {
      this.settings.strict && this.mode === "math" && extraLatin.indexOf(r) >= 0 && this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + r[0] + '" used in math mode', t);
      var d = symbols[this.mode][r].group, g = SourceLocation.range(t), b;
      if (ATOMS.hasOwnProperty(d)) {
        var _ = d;
        b = {
          type: "atom",
          mode: this.mode,
          family: _,
          loc: g,
          text: r
        };
      } else
        b = {
          type: d,
          mode: this.mode,
          loc: g,
          text: r
        };
      c = b;
    } else if (r.charCodeAt(0) >= 128)
      this.settings.strict && (supportedCodepoint(r.charCodeAt(0)) ? this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + r[0] + '" used in math mode', t) : this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + r[0] + '"' + (" (" + r.charCodeAt(0) + ")"), t)), c = {
        type: "textord",
        mode: "text",
        loc: SourceLocation.range(t),
        text: r
      };
    else
      return null;
    if (this.consume(), u)
      for (var y = 0; y < u[0].length; y++) {
        var A = u[0][y];
        if (!unicodeAccents[A])
          throw new ParseError("Unknown accent ' " + A + "'", t);
        var E = unicodeAccents[A][this.mode] || unicodeAccents[A].text;
        if (!E)
          throw new ParseError("Accent " + A + " unsupported in " + this.mode + " mode", t);
        c = {
          type: "accent",
          mode: this.mode,
          loc: SourceLocation.range(t),
          label: E,
          isStretchy: !1,
          isShifty: !0,
          // $FlowFixMe
          base: c
        };
      }
    return c;
  }
};
Parser$2.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
var parseTree = function e(t, r) {
  if (!(typeof t == "string" || t instanceof String))
    throw new TypeError("KaTeX can only parse string typed expression");
  var a = new Parser$2(t, r);
  delete a.gullet.macros.current["\\df@tag"];
  var o = a.parse();
  if (delete a.gullet.macros.current["\\current@color"], delete a.gullet.macros.current["\\color"], a.gullet.macros.get("\\df@tag")) {
    if (!r.displayMode)
      throw new ParseError("\\tag works only in display equations");
    o = [{
      type: "tag",
      mode: "text",
      body: o,
      tag: a.subparse([new Token("\\df@tag")])
    }];
  }
  return o;
};
typeof document < "u" && document.compatMode !== "CSS1Compat" && typeof console < "u" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
var renderToString = function e(t, r) {
  var a = renderToDomTree(t, r).toMarkup();
  return a;
}, renderError = function e(t, r, a) {
  if (a.throwOnError || !(t instanceof ParseError))
    throw t;
  var o = buildCommon.makeSpan(["katex-error"], [new SymbolNode(r)]);
  return o.setAttribute("title", t.toString()), o.setAttribute("style", "color:" + a.errorColor), o;
}, renderToDomTree = function e(t, r) {
  var a = new Settings(r);
  try {
    var o = parseTree(t, a);
    return buildTree(o, t, a);
  } catch (u) {
    return renderError(u, t, a);
  }
}, katex = {
  /**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */
  renderToString
};
const emptyOptions$4 = {}, emptyClasses = [];
function rehypeKatex(e) {
  const t = e || emptyOptions$4;
  return function(r, a) {
    visitParents(r, "element", function(o, u) {
      const c = Array.isArray(o.properties.className) ? o.properties.className : emptyClasses, d = c.includes("language-math"), g = c.includes("math-display"), b = c.includes("math-inline");
      let _ = g;
      if (!d && !g && !b)
        return;
      let y = u[u.length - 1], A = o;
      if (o.tagName === "code" && d && y && y.type === "element" && y.tagName === "pre" && (A = y, y = u[u.length - 2], _ = !0), !y) return;
      const E = toText(A, {
        whitespace: "pre"
      });
      let v;
      try {
        v = katex.renderToString(E, {
          ...t,
          displayMode: _,
          throwOnError: !0
        });
      } catch (R) {
        const I = (
          /** @type {Error} */
          R
        ), w = I.name.toLowerCase();
        a.message("Could not render math with KaTeX", {
          ancestors: [...u, o],
          cause: I,
          place: o.position,
          ruleId: w,
          source: "rehype-katex"
        });
        try {
          v = katex.renderToString(E, {
            ...t,
            displayMode: _,
            strict: "ignore",
            throwOnError: !1
          });
        } catch {
          v = [{
            type: "element",
            tagName: "span",
            properties: {
              className: ["katex-error"],
              style: "color:" + (t.errorColor || "#cc0000"),
              title: String(R)
            },
            children: [{
              type: "text",
              value: E
            }]
          }];
        }
      }
      typeof v == "string" && (v = /** @type {Array<ElementContent>} */
      fromHtmlIsomorphic(v).children);
      const C = y.children.indexOf(A);
      return y.children.splice(C, 1, ...v), SKIP;
    });
  };
}
const search$1 = /\r?\n|\r/g;
function location(e) {
  const t = String(e), r = [];
  for (search$1.lastIndex = 0; search$1.test(t); )
    r.push(search$1.lastIndex);
  return r.push(t.length + 1), {
    toPoint: a,
    toOffset: o
  };
  function a(u) {
    let c = -1;
    if (typeof u == "number" && u > -1 && u < r[r.length - 1]) {
      for (; ++c < r.length; )
        if (r[c] > u)
          return {
            line: c + 1,
            column: u - (c > 0 ? r[c - 1] : 0) + 1,
            offset: u
          };
    }
  }
  function o(u) {
    const c = u && u.line, d = u && u.column;
    if (typeof c == "number" && typeof d == "number" && !Number.isNaN(c) && !Number.isNaN(d) && c - 1 in r) {
      const g = (r[c - 2] || 0) + d - 1 || 0;
      if (g > -1 && g < r[r.length - 1])
        return g;
    }
  }
}
const own$9 = {}.hasOwnProperty, proto$2 = Object.prototype;
function fromParse5(e, t) {
  const r = t || {};
  return one$1({
    file: r.file || void 0,
    location: !1,
    schema: r.space === "svg" ? svg : html$4,
    verbose: r.verbose || !1
  }, e);
}
function one$1(e, t) {
  let r;
  switch (t.nodeName) {
    case "#comment": {
      const a = (
        /** @type {P5Comment} */
        t
      );
      return r = {
        type: "comment",
        value: a.data
      }, patch$2(e, a, r), r;
    }
    case "#document":
    case "#document-fragment": {
      const a = (
        /** @type {P5Document | P5DocumentFragment} */
        t
      ), o = "mode" in a ? a.mode === "quirks" || a.mode === "limited-quirks" : !1;
      if (r = {
        type: "root",
        children: all$2(e, t.childNodes),
        data: {
          quirksMode: o
        }
      }, e.file && e.location) {
        const u = String(e.file), c = location(u), d = c.toPoint(0), g = c.toPoint(u.length);
        r.position = {
          start: d,
          end: g
        };
      }
      return r;
    }
    case "#documentType": {
      const a = (
        /** @type {P5DocumentType} */
        t
      );
      return r = {
        type: "doctype"
      }, patch$2(e, a, r), r;
    }
    case "#text": {
      const a = (
        /** @type {P5Text} */
        t
      );
      return r = {
        type: "text",
        value: a.value
      }, patch$2(e, a, r), r;
    }
    default:
      return r = element$9(
        e,
        /** @type {P5Element} */
        t
      ), r;
  }
}
function all$2(e, t) {
  let r = -1;
  const a = [];
  for (; ++r < t.length; ) {
    const o = (
      /** @type {RootContent} */
      one$1(e, t[r])
    );
    a.push(o);
  }
  return a;
}
function element$9(e, t) {
  const r = e.schema;
  e.schema = t.namespaceURI === webNamespaces.svg ? svg : html$4;
  let a = -1;
  const o = {};
  for (; ++a < t.attrs.length; ) {
    const d = t.attrs[a], g = (d.prefix ? d.prefix + ":" : "") + d.name;
    own$9.call(proto$2, g) || (o[g] = d.value);
  }
  const c = (e.schema.space === "svg" ? s : h$2)(t.tagName, o, all$2(e, t.childNodes));
  if (patch$2(e, t, c), c.tagName === "template") {
    const d = (
      /** @type {P5Template} */
      t
    ), g = d.sourceCodeLocation, b = g && g.startTag && position(g.startTag), _ = g && g.endTag && position(g.endTag), y = (
      /** @type {Root} */
      one$1(e, d.content)
    );
    b && _ && e.file && (y.position = {
      start: b.end,
      end: _.start
    }), c.content = y;
  }
  return e.schema = r, c;
}
function patch$2(e, t, r) {
  if ("sourceCodeLocation" in t && t.sourceCodeLocation && e.file) {
    const a = createLocation$1(e, r, t.sourceCodeLocation);
    a && (e.location = !0, r.position = a);
  }
}
function createLocation$1(e, t, r) {
  const a = position(r);
  if (t.type === "element") {
    const o = t.children[t.children.length - 1];
    if (a && !r.endTag && o && o.position && o.position.end && (a.end = Object.assign({}, o.position.end)), e.verbose) {
      const u = {};
      let c;
      if (r.attrs)
        for (c in r.attrs)
          own$9.call(r.attrs, c) && (u[find$2(e.schema, c).property] = position(r.attrs[c]));
      r.startTag;
      const d = position(r.startTag), g = r.endTag ? position(r.endTag) : void 0, b = {
        opening: d
      };
      g && (b.closing = g), b.properties = u, t.data = {
        position: b
      };
    }
  }
  return a;
}
function position(e) {
  const t = point({
    line: e.startLine,
    column: e.startCol,
    offset: e.startOffset
  }), r = point({
    line: e.endLine,
    column: e.endCol,
    offset: e.endOffset
  });
  return t || r ? {
    start: t,
    end: r
  } : void 0;
}
function point(e) {
  return e.line && e.column ? e : void 0;
}
const own$8 = {}.hasOwnProperty;
function zwitch(e, t) {
  const r = t || {};
  function a(o, ...u) {
    let c = a.invalid;
    const d = a.handlers;
    if (o && own$8.call(o, e)) {
      const g = String(o[e]);
      c = own$8.call(d, g) ? d[g] : a.unknown;
    }
    if (c)
      return c.call(this, o, ...u);
  }
  return a.handlers = r.handlers || {}, a.invalid = r.invalid, a.unknown = r.unknown, a;
}
const emptyOptions$3 = {}, own$7 = {}.hasOwnProperty, one = zwitch("type", {
  handlers: {
    root: root$3,
    element: element$8,
    text: text$5,
    comment: comment$2,
    doctype: doctype$2
  }
});
function toParse5(e, t) {
  const a = (t || emptyOptions$3).space;
  return one(e, a === "svg" ? svg : html$4);
}
function root$3(e, t) {
  const r = {
    nodeName: "#document",
    // @ts-expect-error: `parse5` uses enums, which are actually strings.
    mode: (e.data || {}).quirksMode ? "quirks" : "no-quirks",
    childNodes: []
  };
  return r.childNodes = all$1(e.children, r, t), patch$1(e, r), r;
}
function fragment(e, t) {
  const r = {
    nodeName: "#document-fragment",
    childNodes: []
  };
  return r.childNodes = all$1(e.children, r, t), patch$1(e, r), r;
}
function doctype$2(e) {
  const t = {
    nodeName: "#documentType",
    name: "html",
    publicId: "",
    systemId: "",
    parentNode: null
  };
  return patch$1(e, t), t;
}
function text$5(e) {
  const t = {
    nodeName: "#text",
    value: e.value,
    parentNode: null
  };
  return patch$1(e, t), t;
}
function comment$2(e) {
  const t = {
    nodeName: "#comment",
    data: e.value,
    parentNode: null
  };
  return patch$1(e, t), t;
}
function element$8(e, t) {
  const r = t;
  let a = r;
  e.type === "element" && e.tagName.toLowerCase() === "svg" && r.space === "html" && (a = svg);
  const o = [];
  let u;
  if (e.properties) {
    for (u in e.properties)
      if (u !== "children" && own$7.call(e.properties, u)) {
        const g = createProperty(a, u, e.properties[u]);
        g && o.push(g);
      }
  }
  const c = a.space, d = {
    nodeName: e.tagName,
    tagName: e.tagName,
    attrs: o,
    // @ts-expect-error: `parse5` types are wrong.
    namespaceURI: webNamespaces[c],
    childNodes: [],
    parentNode: null
  };
  return d.childNodes = all$1(e.children, d, a), patch$1(e, d), e.tagName === "template" && e.content && (d.content = fragment(e.content, a)), d;
}
function createProperty(e, t, r) {
  const a = find$2(e, t);
  if (r === !1 || r === null || r === void 0 || typeof r == "number" && Number.isNaN(r) || !r && a.boolean)
    return;
  Array.isArray(r) && (r = a.commaSeparated ? stringify$4(r) : stringify$3(r));
  const o = {
    name: a.attribute,
    value: r === !0 ? "" : String(r)
  };
  if (a.space && a.space !== "html" && a.space !== "svg") {
    const u = o.name.indexOf(":");
    u < 0 ? o.prefix = "" : (o.name = o.name.slice(u + 1), o.prefix = a.attribute.slice(0, u)), o.namespace = webNamespaces[a.space];
  }
  return o;
}
function all$1(e, t, r) {
  let a = -1;
  const o = [];
  if (e)
    for (; ++a < e.length; ) {
      const u = one(e[a], r);
      u.parentNode = t, o.push(u);
    }
  return o;
}
function patch$1(e, t) {
  const r = e.position;
  r && r.start && r.end && (r.start.offset, r.end.offset, t.sourceCodeLocation = {
    startLine: r.start.line,
    startCol: r.start.column,
    startOffset: r.start.offset,
    endLine: r.end.line,
    endCol: r.end.column,
    endOffset: r.end.offset
  });
}
const htmlVoidElements = ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"], UNDEFINED_CODE_POINTS = /* @__PURE__ */ new Set([65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111]), REPLACEMENT_CHARACTER = "";
var CODE_POINTS;
(function(e) {
  e[e.EOF = -1] = "EOF", e[e.NULL = 0] = "NULL", e[e.TABULATION = 9] = "TABULATION", e[e.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", e[e.LINE_FEED = 10] = "LINE_FEED", e[e.FORM_FEED = 12] = "FORM_FEED", e[e.SPACE = 32] = "SPACE", e[e.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", e[e.QUOTATION_MARK = 34] = "QUOTATION_MARK", e[e.NUMBER_SIGN = 35] = "NUMBER_SIGN", e[e.AMPERSAND = 38] = "AMPERSAND", e[e.APOSTROPHE = 39] = "APOSTROPHE", e[e.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", e[e.SOLIDUS = 47] = "SOLIDUS", e[e.DIGIT_0 = 48] = "DIGIT_0", e[e.DIGIT_9 = 57] = "DIGIT_9", e[e.SEMICOLON = 59] = "SEMICOLON", e[e.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", e[e.EQUALS_SIGN = 61] = "EQUALS_SIGN", e[e.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", e[e.QUESTION_MARK = 63] = "QUESTION_MARK", e[e.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", e[e.LATIN_CAPITAL_F = 70] = "LATIN_CAPITAL_F", e[e.LATIN_CAPITAL_X = 88] = "LATIN_CAPITAL_X", e[e.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", e[e.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", e[e.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", e[e.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", e[e.LATIN_SMALL_F = 102] = "LATIN_SMALL_F", e[e.LATIN_SMALL_X = 120] = "LATIN_SMALL_X", e[e.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z", e[e.REPLACEMENT_CHARACTER = 65533] = "REPLACEMENT_CHARACTER";
})(CODE_POINTS = CODE_POINTS || (CODE_POINTS = {}));
const SEQUENCES = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function isSurrogate(e) {
  return e >= 55296 && e <= 57343;
}
function isSurrogatePair(e) {
  return e >= 56320 && e <= 57343;
}
function getSurrogatePairCodePoint(e, t) {
  return (e - 55296) * 1024 + 9216 + t;
}
function isControlCodePoint(e) {
  return e !== 32 && e !== 10 && e !== 13 && e !== 9 && e !== 12 && e >= 1 && e <= 31 || e >= 127 && e <= 159;
}
function isUndefinedCodePoint(e) {
  return e >= 64976 && e <= 65007 || UNDEFINED_CODE_POINTS.has(e);
}
var ERR;
(function(e) {
  e.controlCharacterInInputStream = "control-character-in-input-stream", e.noncharacterInInputStream = "noncharacter-in-input-stream", e.surrogateInInputStream = "surrogate-in-input-stream", e.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", e.endTagWithAttributes = "end-tag-with-attributes", e.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", e.unexpectedSolidusInTag = "unexpected-solidus-in-tag", e.unexpectedNullCharacter = "unexpected-null-character", e.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", e.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", e.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", e.missingEndTagName = "missing-end-tag-name", e.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", e.unknownNamedCharacterReference = "unknown-named-character-reference", e.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", e.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", e.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", e.eofBeforeTagName = "eof-before-tag-name", e.eofInTag = "eof-in-tag", e.missingAttributeValue = "missing-attribute-value", e.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", e.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", e.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", e.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", e.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", e.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", e.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", e.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", e.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", e.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", e.cdataInHtmlContent = "cdata-in-html-content", e.incorrectlyOpenedComment = "incorrectly-opened-comment", e.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", e.eofInDoctype = "eof-in-doctype", e.nestedComment = "nested-comment", e.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", e.eofInComment = "eof-in-comment", e.incorrectlyClosedComment = "incorrectly-closed-comment", e.eofInCdata = "eof-in-cdata", e.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", e.nullCharacterReference = "null-character-reference", e.surrogateCharacterReference = "surrogate-character-reference", e.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", e.controlCharacterReference = "control-character-reference", e.noncharacterCharacterReference = "noncharacter-character-reference", e.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", e.missingDoctypeName = "missing-doctype-name", e.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", e.duplicateAttribute = "duplicate-attribute", e.nonConformingDoctype = "non-conforming-doctype", e.missingDoctype = "missing-doctype", e.misplacedDoctype = "misplaced-doctype", e.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", e.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", e.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", e.openElementsLeftAfterEof = "open-elements-left-after-eof", e.abandonedHeadElementChild = "abandoned-head-element-child", e.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", e.nestedNoscriptInHead = "nested-noscript-in-head", e.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text";
})(ERR = ERR || (ERR = {}));
const DEFAULT_BUFFER_WATERLINE = 65536;
class Preprocessor {
  constructor(t) {
    this.handler = t, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = DEFAULT_BUFFER_WATERLINE, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(t) {
    const {
      line: r,
      col: a,
      offset: o
    } = this;
    return {
      code: t,
      startLine: r,
      endLine: r,
      startCol: a,
      endCol: a,
      startOffset: o,
      endOffset: o
    };
  }
  _err(t) {
    this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(t)));
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos;
  }
  _processSurrogate(t) {
    if (this.pos !== this.html.length - 1) {
      const r = this.html.charCodeAt(this.pos + 1);
      if (isSurrogatePair(r))
        return this.pos++, this._addGap(), getSurrogatePairCodePoint(t, r);
    } else if (!this.lastChunkWritten)
      return this.endOfChunkHit = !0, CODE_POINTS.EOF;
    return this._err(ERR.surrogateInInputStream), t;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0);
  }
  write(t, r) {
    this.html.length > 0 ? this.html += t : this.html = t, this.endOfChunkHit = !1, this.lastChunkWritten = r;
  }
  insertHtmlAtCurrentPos(t) {
    this.html = this.html.substring(0, this.pos + 1) + t + this.html.substring(this.pos + 1), this.endOfChunkHit = !1;
  }
  startsWith(t, r) {
    if (this.pos + t.length > this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, !1;
    if (r)
      return this.html.startsWith(t, this.pos);
    for (let a = 0; a < t.length; a++)
      if ((this.html.charCodeAt(this.pos + a) | 32) !== t.charCodeAt(a))
        return !1;
    return !0;
  }
  peek(t) {
    const r = this.pos + t;
    if (r >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, CODE_POINTS.EOF;
    const a = this.html.charCodeAt(r);
    return a === CODE_POINTS.CARRIAGE_RETURN ? CODE_POINTS.LINE_FEED : a;
  }
  advance() {
    if (this.pos++, this.isEol && (this.isEol = !1, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, CODE_POINTS.EOF;
    let t = this.html.charCodeAt(this.pos);
    return t === CODE_POINTS.CARRIAGE_RETURN ? (this.isEol = !0, this.skipNextNewLine = !0, CODE_POINTS.LINE_FEED) : t === CODE_POINTS.LINE_FEED && (this.isEol = !0, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = !1, this._addGap(), this.advance()) : (this.skipNextNewLine = !1, isSurrogate(t) && (t = this._processSurrogate(t)), this.handler.onParseError === null || t > 31 && t < 127 || t === CODE_POINTS.LINE_FEED || t === CODE_POINTS.CARRIAGE_RETURN || t > 159 && t < 64976 || this._checkForProblematicCharacters(t), t);
  }
  _checkForProblematicCharacters(t) {
    isControlCodePoint(t) ? this._err(ERR.controlCharacterInInputStream) : isUndefinedCodePoint(t) && this._err(ERR.noncharacterInInputStream);
  }
  retreat(t) {
    for (this.pos -= t; this.pos < this.lastGapPos; )
      this.lastGapPos = this.gapStack.pop(), this.pos--;
    this.isEol = !1;
  }
}
var TokenType;
(function(e) {
  e[e.CHARACTER = 0] = "CHARACTER", e[e.NULL_CHARACTER = 1] = "NULL_CHARACTER", e[e.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", e[e.START_TAG = 3] = "START_TAG", e[e.END_TAG = 4] = "END_TAG", e[e.COMMENT = 5] = "COMMENT", e[e.DOCTYPE = 6] = "DOCTYPE", e[e.EOF = 7] = "EOF", e[e.HIBERNATION = 8] = "HIBERNATION";
})(TokenType = TokenType || (TokenType = {}));
function getTokenAttr(e, t) {
  for (let r = e.attrs.length - 1; r >= 0; r--)
    if (e.attrs[r].name === t)
      return e.attrs[r].value;
  return null;
}
const htmlDecodeTree = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map((e) => e.charCodeAt(0))
), xmlDecodeTree = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map((e) => e.charCodeAt(0))
);
var _a$1;
const decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), fromCodePoint$1 = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a$1 = String.fromCodePoint) !== null && _a$1 !== void 0 ? _a$1 : function(e) {
    let t = "";
    return e > 65535 && (e -= 65536, t += String.fromCharCode(e >>> 10 & 1023 | 55296), e = 56320 | e & 1023), t += String.fromCharCode(e), t;
  }
);
function replaceCodePoint(e) {
  var t;
  return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (t = decodeMap.get(e)) !== null && t !== void 0 ? t : e;
}
var CharCodes;
(function(e) {
  e[e.NUM = 35] = "NUM", e[e.SEMI = 59] = "SEMI", e[e.EQUALS = 61] = "EQUALS", e[e.ZERO = 48] = "ZERO", e[e.NINE = 57] = "NINE", e[e.LOWER_A = 97] = "LOWER_A", e[e.LOWER_F = 102] = "LOWER_F", e[e.LOWER_X = 120] = "LOWER_X", e[e.LOWER_Z = 122] = "LOWER_Z", e[e.UPPER_A = 65] = "UPPER_A", e[e.UPPER_F = 70] = "UPPER_F", e[e.UPPER_Z = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
const TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(e) {
  e[e.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e[e.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e[e.JUMP_TABLE = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(e) {
  return e >= CharCodes.ZERO && e <= CharCodes.NINE;
}
function isHexadecimalCharacter(e) {
  return e >= CharCodes.UPPER_A && e <= CharCodes.UPPER_F || e >= CharCodes.LOWER_A && e <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric$1(e) {
  return e >= CharCodes.UPPER_A && e <= CharCodes.UPPER_Z || e >= CharCodes.LOWER_A && e <= CharCodes.LOWER_Z || isNumber(e);
}
function isEntityInAttributeInvalidEnd$1(e) {
  return e === CharCodes.EQUALS || isAsciiAlphaNumeric$1(e);
}
var EntityDecoderState;
(function(e) {
  e[e.EntityStart = 0] = "EntityStart", e[e.NumericStart = 1] = "NumericStart", e[e.NumericDecimal = 2] = "NumericDecimal", e[e.NumericHex = 3] = "NumericHex", e[e.NamedEntity = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(e) {
  e[e.Legacy = 0] = "Legacy", e[e.Strict = 1] = "Strict", e[e.Attribute = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
class EntityDecoder {
  constructor(t, r, a) {
    this.decodeTree = t, this.emitCodePoint = r, this.errors = a, this.state = EntityDecoderState.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(t) {
    this.decodeMode = t, this.state = EntityDecoderState.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(t, r) {
    switch (this.state) {
      case EntityDecoderState.EntityStart:
        return t.charCodeAt(r) === CharCodes.NUM ? (this.state = EntityDecoderState.NumericStart, this.consumed += 1, this.stateNumericStart(t, r + 1)) : (this.state = EntityDecoderState.NamedEntity, this.stateNamedEntity(t, r));
      case EntityDecoderState.NumericStart:
        return this.stateNumericStart(t, r);
      case EntityDecoderState.NumericDecimal:
        return this.stateNumericDecimal(t, r);
      case EntityDecoderState.NumericHex:
        return this.stateNumericHex(t, r);
      case EntityDecoderState.NamedEntity:
        return this.stateNamedEntity(t, r);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(t, r) {
    return r >= t.length ? -1 : (t.charCodeAt(r) | TO_LOWER_BIT) === CharCodes.LOWER_X ? (this.state = EntityDecoderState.NumericHex, this.consumed += 1, this.stateNumericHex(t, r + 1)) : (this.state = EntityDecoderState.NumericDecimal, this.stateNumericDecimal(t, r));
  }
  addToNumericResult(t, r, a, o) {
    if (r !== a) {
      const u = a - r;
      this.result = this.result * Math.pow(o, u) + parseInt(t.substr(r, u), o), this.consumed += u;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(t, r) {
    const a = r;
    for (; r < t.length; ) {
      const o = t.charCodeAt(r);
      if (isNumber(o) || isHexadecimalCharacter(o))
        r += 1;
      else
        return this.addToNumericResult(t, a, r, 16), this.emitNumericEntity(o, 3);
    }
    return this.addToNumericResult(t, a, r, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(t, r) {
    const a = r;
    for (; r < t.length; ) {
      const o = t.charCodeAt(r);
      if (isNumber(o))
        r += 1;
      else
        return this.addToNumericResult(t, a, r, 10), this.emitNumericEntity(o, 2);
    }
    return this.addToNumericResult(t, a, r, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(t, r) {
    var a;
    if (this.consumed <= r)
      return (a = this.errors) === null || a === void 0 || a.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (t === CharCodes.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === DecodingMode.Strict)
      return 0;
    return this.emitCodePoint(replaceCodePoint(this.result), this.consumed), this.errors && (t !== CharCodes.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(t, r) {
    const {
      decodeTree: a
    } = this;
    let o = a[this.treeIndex], u = (o & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; r < t.length; r++, this.excess++) {
      const c = t.charCodeAt(r);
      if (this.treeIndex = determineBranch(a, o, this.treeIndex + Math.max(1, u), c), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (u === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd$1(c)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (o = a[this.treeIndex], u = (o & BinTrieFlags.VALUE_LENGTH) >> 14, u !== 0) {
        if (c === CharCodes.SEMI)
          return this.emitNamedEntityData(this.treeIndex, u, this.consumed + this.excess);
        this.decodeMode !== DecodingMode.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var t;
    const {
      result: r,
      decodeTree: a
    } = this, o = (a[r] & BinTrieFlags.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(r, o, this.consumed), (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(t, r, a) {
    const {
      decodeTree: o
    } = this;
    return this.emitCodePoint(r === 1 ? o[t] & ~BinTrieFlags.VALUE_LENGTH : o[t + 1], a), r === 3 && this.emitCodePoint(o[t + 2], a), a;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var t;
    switch (this.state) {
      case EntityDecoderState.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case EntityDecoderState.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case EntityDecoderState.NumericHex:
        return this.emitNumericEntity(0, 3);
      case EntityDecoderState.NumericStart:
        return (t = this.errors) === null || t === void 0 || t.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case EntityDecoderState.EntityStart:
        return 0;
    }
  }
}
function getDecoder(e) {
  let t = "";
  const r = new EntityDecoder(e, (a) => t += fromCodePoint$1(a));
  return function(o, u) {
    let c = 0, d = 0;
    for (; (d = o.indexOf("&", d)) >= 0; ) {
      t += o.slice(c, d), r.startEntity(u);
      const b = r.write(
        o,
        // Skip the "&"
        d + 1
      );
      if (b < 0) {
        c = d + r.end();
        break;
      }
      c = d + b, d = b === 0 ? c + 1 : c;
    }
    const g = t + o.slice(c);
    return t = "", g;
  };
}
function determineBranch(e, t, r, a) {
  const o = (t & BinTrieFlags.BRANCH_LENGTH) >> 7, u = t & BinTrieFlags.JUMP_TABLE;
  if (o === 0)
    return u !== 0 && a === u ? r : -1;
  if (u) {
    const g = a - u;
    return g < 0 || g >= o ? -1 : e[r + g] - 1;
  }
  let c = r, d = c + o - 1;
  for (; c <= d; ) {
    const g = c + d >>> 1, b = e[g];
    if (b < a)
      c = g + 1;
    else if (b > a)
      d = g - 1;
    else
      return e[g + o];
  }
  return -1;
}
getDecoder(htmlDecodeTree);
getDecoder(xmlDecodeTree);
var NS;
(function(e) {
  e.HTML = "http://www.w3.org/1999/xhtml", e.MATHML = "http://www.w3.org/1998/Math/MathML", e.SVG = "http://www.w3.org/2000/svg", e.XLINK = "http://www.w3.org/1999/xlink", e.XML = "http://www.w3.org/XML/1998/namespace", e.XMLNS = "http://www.w3.org/2000/xmlns/";
})(NS = NS || (NS = {}));
var ATTRS;
(function(e) {
  e.TYPE = "type", e.ACTION = "action", e.ENCODING = "encoding", e.PROMPT = "prompt", e.NAME = "name", e.COLOR = "color", e.FACE = "face", e.SIZE = "size";
})(ATTRS = ATTRS || (ATTRS = {}));
var DOCUMENT_MODE;
(function(e) {
  e.NO_QUIRKS = "no-quirks", e.QUIRKS = "quirks", e.LIMITED_QUIRKS = "limited-quirks";
})(DOCUMENT_MODE = DOCUMENT_MODE || (DOCUMENT_MODE = {}));
var TAG_NAMES;
(function(e) {
  e.A = "a", e.ADDRESS = "address", e.ANNOTATION_XML = "annotation-xml", e.APPLET = "applet", e.AREA = "area", e.ARTICLE = "article", e.ASIDE = "aside", e.B = "b", e.BASE = "base", e.BASEFONT = "basefont", e.BGSOUND = "bgsound", e.BIG = "big", e.BLOCKQUOTE = "blockquote", e.BODY = "body", e.BR = "br", e.BUTTON = "button", e.CAPTION = "caption", e.CENTER = "center", e.CODE = "code", e.COL = "col", e.COLGROUP = "colgroup", e.DD = "dd", e.DESC = "desc", e.DETAILS = "details", e.DIALOG = "dialog", e.DIR = "dir", e.DIV = "div", e.DL = "dl", e.DT = "dt", e.EM = "em", e.EMBED = "embed", e.FIELDSET = "fieldset", e.FIGCAPTION = "figcaption", e.FIGURE = "figure", e.FONT = "font", e.FOOTER = "footer", e.FOREIGN_OBJECT = "foreignObject", e.FORM = "form", e.FRAME = "frame", e.FRAMESET = "frameset", e.H1 = "h1", e.H2 = "h2", e.H3 = "h3", e.H4 = "h4", e.H5 = "h5", e.H6 = "h6", e.HEAD = "head", e.HEADER = "header", e.HGROUP = "hgroup", e.HR = "hr", e.HTML = "html", e.I = "i", e.IMG = "img", e.IMAGE = "image", e.INPUT = "input", e.IFRAME = "iframe", e.KEYGEN = "keygen", e.LABEL = "label", e.LI = "li", e.LINK = "link", e.LISTING = "listing", e.MAIN = "main", e.MALIGNMARK = "malignmark", e.MARQUEE = "marquee", e.MATH = "math", e.MENU = "menu", e.META = "meta", e.MGLYPH = "mglyph", e.MI = "mi", e.MO = "mo", e.MN = "mn", e.MS = "ms", e.MTEXT = "mtext", e.NAV = "nav", e.NOBR = "nobr", e.NOFRAMES = "noframes", e.NOEMBED = "noembed", e.NOSCRIPT = "noscript", e.OBJECT = "object", e.OL = "ol", e.OPTGROUP = "optgroup", e.OPTION = "option", e.P = "p", e.PARAM = "param", e.PLAINTEXT = "plaintext", e.PRE = "pre", e.RB = "rb", e.RP = "rp", e.RT = "rt", e.RTC = "rtc", e.RUBY = "ruby", e.S = "s", e.SCRIPT = "script", e.SECTION = "section", e.SELECT = "select", e.SOURCE = "source", e.SMALL = "small", e.SPAN = "span", e.STRIKE = "strike", e.STRONG = "strong", e.STYLE = "style", e.SUB = "sub", e.SUMMARY = "summary", e.SUP = "sup", e.TABLE = "table", e.TBODY = "tbody", e.TEMPLATE = "template", e.TEXTAREA = "textarea", e.TFOOT = "tfoot", e.TD = "td", e.TH = "th", e.THEAD = "thead", e.TITLE = "title", e.TR = "tr", e.TRACK = "track", e.TT = "tt", e.U = "u", e.UL = "ul", e.SVG = "svg", e.VAR = "var", e.WBR = "wbr", e.XMP = "xmp";
})(TAG_NAMES = TAG_NAMES || (TAG_NAMES = {}));
var TAG_ID;
(function(e) {
  e[e.UNKNOWN = 0] = "UNKNOWN", e[e.A = 1] = "A", e[e.ADDRESS = 2] = "ADDRESS", e[e.ANNOTATION_XML = 3] = "ANNOTATION_XML", e[e.APPLET = 4] = "APPLET", e[e.AREA = 5] = "AREA", e[e.ARTICLE = 6] = "ARTICLE", e[e.ASIDE = 7] = "ASIDE", e[e.B = 8] = "B", e[e.BASE = 9] = "BASE", e[e.BASEFONT = 10] = "BASEFONT", e[e.BGSOUND = 11] = "BGSOUND", e[e.BIG = 12] = "BIG", e[e.BLOCKQUOTE = 13] = "BLOCKQUOTE", e[e.BODY = 14] = "BODY", e[e.BR = 15] = "BR", e[e.BUTTON = 16] = "BUTTON", e[e.CAPTION = 17] = "CAPTION", e[e.CENTER = 18] = "CENTER", e[e.CODE = 19] = "CODE", e[e.COL = 20] = "COL", e[e.COLGROUP = 21] = "COLGROUP", e[e.DD = 22] = "DD", e[e.DESC = 23] = "DESC", e[e.DETAILS = 24] = "DETAILS", e[e.DIALOG = 25] = "DIALOG", e[e.DIR = 26] = "DIR", e[e.DIV = 27] = "DIV", e[e.DL = 28] = "DL", e[e.DT = 29] = "DT", e[e.EM = 30] = "EM", e[e.EMBED = 31] = "EMBED", e[e.FIELDSET = 32] = "FIELDSET", e[e.FIGCAPTION = 33] = "FIGCAPTION", e[e.FIGURE = 34] = "FIGURE", e[e.FONT = 35] = "FONT", e[e.FOOTER = 36] = "FOOTER", e[e.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", e[e.FORM = 38] = "FORM", e[e.FRAME = 39] = "FRAME", e[e.FRAMESET = 40] = "FRAMESET", e[e.H1 = 41] = "H1", e[e.H2 = 42] = "H2", e[e.H3 = 43] = "H3", e[e.H4 = 44] = "H4", e[e.H5 = 45] = "H5", e[e.H6 = 46] = "H6", e[e.HEAD = 47] = "HEAD", e[e.HEADER = 48] = "HEADER", e[e.HGROUP = 49] = "HGROUP", e[e.HR = 50] = "HR", e[e.HTML = 51] = "HTML", e[e.I = 52] = "I", e[e.IMG = 53] = "IMG", e[e.IMAGE = 54] = "IMAGE", e[e.INPUT = 55] = "INPUT", e[e.IFRAME = 56] = "IFRAME", e[e.KEYGEN = 57] = "KEYGEN", e[e.LABEL = 58] = "LABEL", e[e.LI = 59] = "LI", e[e.LINK = 60] = "LINK", e[e.LISTING = 61] = "LISTING", e[e.MAIN = 62] = "MAIN", e[e.MALIGNMARK = 63] = "MALIGNMARK", e[e.MARQUEE = 64] = "MARQUEE", e[e.MATH = 65] = "MATH", e[e.MENU = 66] = "MENU", e[e.META = 67] = "META", e[e.MGLYPH = 68] = "MGLYPH", e[e.MI = 69] = "MI", e[e.MO = 70] = "MO", e[e.MN = 71] = "MN", e[e.MS = 72] = "MS", e[e.MTEXT = 73] = "MTEXT", e[e.NAV = 74] = "NAV", e[e.NOBR = 75] = "NOBR", e[e.NOFRAMES = 76] = "NOFRAMES", e[e.NOEMBED = 77] = "NOEMBED", e[e.NOSCRIPT = 78] = "NOSCRIPT", e[e.OBJECT = 79] = "OBJECT", e[e.OL = 80] = "OL", e[e.OPTGROUP = 81] = "OPTGROUP", e[e.OPTION = 82] = "OPTION", e[e.P = 83] = "P", e[e.PARAM = 84] = "PARAM", e[e.PLAINTEXT = 85] = "PLAINTEXT", e[e.PRE = 86] = "PRE", e[e.RB = 87] = "RB", e[e.RP = 88] = "RP", e[e.RT = 89] = "RT", e[e.RTC = 90] = "RTC", e[e.RUBY = 91] = "RUBY", e[e.S = 92] = "S", e[e.SCRIPT = 93] = "SCRIPT", e[e.SECTION = 94] = "SECTION", e[e.SELECT = 95] = "SELECT", e[e.SOURCE = 96] = "SOURCE", e[e.SMALL = 97] = "SMALL", e[e.SPAN = 98] = "SPAN", e[e.STRIKE = 99] = "STRIKE", e[e.STRONG = 100] = "STRONG", e[e.STYLE = 101] = "STYLE", e[e.SUB = 102] = "SUB", e[e.SUMMARY = 103] = "SUMMARY", e[e.SUP = 104] = "SUP", e[e.TABLE = 105] = "TABLE", e[e.TBODY = 106] = "TBODY", e[e.TEMPLATE = 107] = "TEMPLATE", e[e.TEXTAREA = 108] = "TEXTAREA", e[e.TFOOT = 109] = "TFOOT", e[e.TD = 110] = "TD", e[e.TH = 111] = "TH", e[e.THEAD = 112] = "THEAD", e[e.TITLE = 113] = "TITLE", e[e.TR = 114] = "TR", e[e.TRACK = 115] = "TRACK", e[e.TT = 116] = "TT", e[e.U = 117] = "U", e[e.UL = 118] = "UL", e[e.SVG = 119] = "SVG", e[e.VAR = 120] = "VAR", e[e.WBR = 121] = "WBR", e[e.XMP = 122] = "XMP";
})(TAG_ID = TAG_ID || (TAG_ID = {}));
const TAG_NAME_TO_ID = /* @__PURE__ */ new Map([[TAG_NAMES.A, TAG_ID.A], [TAG_NAMES.ADDRESS, TAG_ID.ADDRESS], [TAG_NAMES.ANNOTATION_XML, TAG_ID.ANNOTATION_XML], [TAG_NAMES.APPLET, TAG_ID.APPLET], [TAG_NAMES.AREA, TAG_ID.AREA], [TAG_NAMES.ARTICLE, TAG_ID.ARTICLE], [TAG_NAMES.ASIDE, TAG_ID.ASIDE], [TAG_NAMES.B, TAG_ID.B], [TAG_NAMES.BASE, TAG_ID.BASE], [TAG_NAMES.BASEFONT, TAG_ID.BASEFONT], [TAG_NAMES.BGSOUND, TAG_ID.BGSOUND], [TAG_NAMES.BIG, TAG_ID.BIG], [TAG_NAMES.BLOCKQUOTE, TAG_ID.BLOCKQUOTE], [TAG_NAMES.BODY, TAG_ID.BODY], [TAG_NAMES.BR, TAG_ID.BR], [TAG_NAMES.BUTTON, TAG_ID.BUTTON], [TAG_NAMES.CAPTION, TAG_ID.CAPTION], [TAG_NAMES.CENTER, TAG_ID.CENTER], [TAG_NAMES.CODE, TAG_ID.CODE], [TAG_NAMES.COL, TAG_ID.COL], [TAG_NAMES.COLGROUP, TAG_ID.COLGROUP], [TAG_NAMES.DD, TAG_ID.DD], [TAG_NAMES.DESC, TAG_ID.DESC], [TAG_NAMES.DETAILS, TAG_ID.DETAILS], [TAG_NAMES.DIALOG, TAG_ID.DIALOG], [TAG_NAMES.DIR, TAG_ID.DIR], [TAG_NAMES.DIV, TAG_ID.DIV], [TAG_NAMES.DL, TAG_ID.DL], [TAG_NAMES.DT, TAG_ID.DT], [TAG_NAMES.EM, TAG_ID.EM], [TAG_NAMES.EMBED, TAG_ID.EMBED], [TAG_NAMES.FIELDSET, TAG_ID.FIELDSET], [TAG_NAMES.FIGCAPTION, TAG_ID.FIGCAPTION], [TAG_NAMES.FIGURE, TAG_ID.FIGURE], [TAG_NAMES.FONT, TAG_ID.FONT], [TAG_NAMES.FOOTER, TAG_ID.FOOTER], [TAG_NAMES.FOREIGN_OBJECT, TAG_ID.FOREIGN_OBJECT], [TAG_NAMES.FORM, TAG_ID.FORM], [TAG_NAMES.FRAME, TAG_ID.FRAME], [TAG_NAMES.FRAMESET, TAG_ID.FRAMESET], [TAG_NAMES.H1, TAG_ID.H1], [TAG_NAMES.H2, TAG_ID.H2], [TAG_NAMES.H3, TAG_ID.H3], [TAG_NAMES.H4, TAG_ID.H4], [TAG_NAMES.H5, TAG_ID.H5], [TAG_NAMES.H6, TAG_ID.H6], [TAG_NAMES.HEAD, TAG_ID.HEAD], [TAG_NAMES.HEADER, TAG_ID.HEADER], [TAG_NAMES.HGROUP, TAG_ID.HGROUP], [TAG_NAMES.HR, TAG_ID.HR], [TAG_NAMES.HTML, TAG_ID.HTML], [TAG_NAMES.I, TAG_ID.I], [TAG_NAMES.IMG, TAG_ID.IMG], [TAG_NAMES.IMAGE, TAG_ID.IMAGE], [TAG_NAMES.INPUT, TAG_ID.INPUT], [TAG_NAMES.IFRAME, TAG_ID.IFRAME], [TAG_NAMES.KEYGEN, TAG_ID.KEYGEN], [TAG_NAMES.LABEL, TAG_ID.LABEL], [TAG_NAMES.LI, TAG_ID.LI], [TAG_NAMES.LINK, TAG_ID.LINK], [TAG_NAMES.LISTING, TAG_ID.LISTING], [TAG_NAMES.MAIN, TAG_ID.MAIN], [TAG_NAMES.MALIGNMARK, TAG_ID.MALIGNMARK], [TAG_NAMES.MARQUEE, TAG_ID.MARQUEE], [TAG_NAMES.MATH, TAG_ID.MATH], [TAG_NAMES.MENU, TAG_ID.MENU], [TAG_NAMES.META, TAG_ID.META], [TAG_NAMES.MGLYPH, TAG_ID.MGLYPH], [TAG_NAMES.MI, TAG_ID.MI], [TAG_NAMES.MO, TAG_ID.MO], [TAG_NAMES.MN, TAG_ID.MN], [TAG_NAMES.MS, TAG_ID.MS], [TAG_NAMES.MTEXT, TAG_ID.MTEXT], [TAG_NAMES.NAV, TAG_ID.NAV], [TAG_NAMES.NOBR, TAG_ID.NOBR], [TAG_NAMES.NOFRAMES, TAG_ID.NOFRAMES], [TAG_NAMES.NOEMBED, TAG_ID.NOEMBED], [TAG_NAMES.NOSCRIPT, TAG_ID.NOSCRIPT], [TAG_NAMES.OBJECT, TAG_ID.OBJECT], [TAG_NAMES.OL, TAG_ID.OL], [TAG_NAMES.OPTGROUP, TAG_ID.OPTGROUP], [TAG_NAMES.OPTION, TAG_ID.OPTION], [TAG_NAMES.P, TAG_ID.P], [TAG_NAMES.PARAM, TAG_ID.PARAM], [TAG_NAMES.PLAINTEXT, TAG_ID.PLAINTEXT], [TAG_NAMES.PRE, TAG_ID.PRE], [TAG_NAMES.RB, TAG_ID.RB], [TAG_NAMES.RP, TAG_ID.RP], [TAG_NAMES.RT, TAG_ID.RT], [TAG_NAMES.RTC, TAG_ID.RTC], [TAG_NAMES.RUBY, TAG_ID.RUBY], [TAG_NAMES.S, TAG_ID.S], [TAG_NAMES.SCRIPT, TAG_ID.SCRIPT], [TAG_NAMES.SECTION, TAG_ID.SECTION], [TAG_NAMES.SELECT, TAG_ID.SELECT], [TAG_NAMES.SOURCE, TAG_ID.SOURCE], [TAG_NAMES.SMALL, TAG_ID.SMALL], [TAG_NAMES.SPAN, TAG_ID.SPAN], [TAG_NAMES.STRIKE, TAG_ID.STRIKE], [TAG_NAMES.STRONG, TAG_ID.STRONG], [TAG_NAMES.STYLE, TAG_ID.STYLE], [TAG_NAMES.SUB, TAG_ID.SUB], [TAG_NAMES.SUMMARY, TAG_ID.SUMMARY], [TAG_NAMES.SUP, TAG_ID.SUP], [TAG_NAMES.TABLE, TAG_ID.TABLE], [TAG_NAMES.TBODY, TAG_ID.TBODY], [TAG_NAMES.TEMPLATE, TAG_ID.TEMPLATE], [TAG_NAMES.TEXTAREA, TAG_ID.TEXTAREA], [TAG_NAMES.TFOOT, TAG_ID.TFOOT], [TAG_NAMES.TD, TAG_ID.TD], [TAG_NAMES.TH, TAG_ID.TH], [TAG_NAMES.THEAD, TAG_ID.THEAD], [TAG_NAMES.TITLE, TAG_ID.TITLE], [TAG_NAMES.TR, TAG_ID.TR], [TAG_NAMES.TRACK, TAG_ID.TRACK], [TAG_NAMES.TT, TAG_ID.TT], [TAG_NAMES.U, TAG_ID.U], [TAG_NAMES.UL, TAG_ID.UL], [TAG_NAMES.SVG, TAG_ID.SVG], [TAG_NAMES.VAR, TAG_ID.VAR], [TAG_NAMES.WBR, TAG_ID.WBR], [TAG_NAMES.XMP, TAG_ID.XMP]]);
function getTagID(e) {
  var t;
  return (t = TAG_NAME_TO_ID.get(e)) !== null && t !== void 0 ? t : TAG_ID.UNKNOWN;
}
const $ = TAG_ID, SPECIAL_ELEMENTS = {
  [NS.HTML]: /* @__PURE__ */ new Set([$.ADDRESS, $.APPLET, $.AREA, $.ARTICLE, $.ASIDE, $.BASE, $.BASEFONT, $.BGSOUND, $.BLOCKQUOTE, $.BODY, $.BR, $.BUTTON, $.CAPTION, $.CENTER, $.COL, $.COLGROUP, $.DD, $.DETAILS, $.DIR, $.DIV, $.DL, $.DT, $.EMBED, $.FIELDSET, $.FIGCAPTION, $.FIGURE, $.FOOTER, $.FORM, $.FRAME, $.FRAMESET, $.H1, $.H2, $.H3, $.H4, $.H5, $.H6, $.HEAD, $.HEADER, $.HGROUP, $.HR, $.HTML, $.IFRAME, $.IMG, $.INPUT, $.LI, $.LINK, $.LISTING, $.MAIN, $.MARQUEE, $.MENU, $.META, $.NAV, $.NOEMBED, $.NOFRAMES, $.NOSCRIPT, $.OBJECT, $.OL, $.P, $.PARAM, $.PLAINTEXT, $.PRE, $.SCRIPT, $.SECTION, $.SELECT, $.SOURCE, $.STYLE, $.SUMMARY, $.TABLE, $.TBODY, $.TD, $.TEMPLATE, $.TEXTAREA, $.TFOOT, $.TH, $.THEAD, $.TITLE, $.TR, $.TRACK, $.UL, $.WBR, $.XMP]),
  [NS.MATHML]: /* @__PURE__ */ new Set([$.MI, $.MO, $.MN, $.MS, $.MTEXT, $.ANNOTATION_XML]),
  [NS.SVG]: /* @__PURE__ */ new Set([$.TITLE, $.FOREIGN_OBJECT, $.DESC]),
  [NS.XLINK]: /* @__PURE__ */ new Set(),
  [NS.XML]: /* @__PURE__ */ new Set(),
  [NS.XMLNS]: /* @__PURE__ */ new Set()
};
function isNumberedHeader(e) {
  return e === $.H1 || e === $.H2 || e === $.H3 || e === $.H4 || e === $.H5 || e === $.H6;
}
TAG_NAMES.STYLE, TAG_NAMES.SCRIPT, TAG_NAMES.XMP, TAG_NAMES.IFRAME, TAG_NAMES.NOEMBED, TAG_NAMES.NOFRAMES, TAG_NAMES.PLAINTEXT;
const C1_CONTROLS_REFERENCE_REPLACEMENTS = /* @__PURE__ */ new Map([[128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]);
var State;
(function(e) {
  e[e.DATA = 0] = "DATA", e[e.RCDATA = 1] = "RCDATA", e[e.RAWTEXT = 2] = "RAWTEXT", e[e.SCRIPT_DATA = 3] = "SCRIPT_DATA", e[e.PLAINTEXT = 4] = "PLAINTEXT", e[e.TAG_OPEN = 5] = "TAG_OPEN", e[e.END_TAG_OPEN = 6] = "END_TAG_OPEN", e[e.TAG_NAME = 7] = "TAG_NAME", e[e.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", e[e.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", e[e.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", e[e.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", e[e.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", e[e.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", e[e.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", e[e.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", e[e.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", e[e.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", e[e.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", e[e.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", e[e.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", e[e.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", e[e.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", e[e.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", e[e.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", e[e.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", e[e.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", e[e.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", e[e.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", e[e.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", e[e.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", e[e.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", e[e.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", e[e.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", e[e.COMMENT_START = 42] = "COMMENT_START", e[e.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", e[e.COMMENT = 44] = "COMMENT", e[e.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", e[e.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", e[e.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", e[e.COMMENT_END = 50] = "COMMENT_END", e[e.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", e[e.DOCTYPE = 52] = "DOCTYPE", e[e.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", e[e.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", e[e.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", e[e.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", e[e.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", e[e.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", e[e.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", e[e.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", e[e.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", e[e.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", e[e.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", e[e.CDATA_SECTION = 68] = "CDATA_SECTION", e[e.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", e[e.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", e[e.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", e[e.NAMED_CHARACTER_REFERENCE = 72] = "NAMED_CHARACTER_REFERENCE", e[e.AMBIGUOUS_AMPERSAND = 73] = "AMBIGUOUS_AMPERSAND", e[e.NUMERIC_CHARACTER_REFERENCE = 74] = "NUMERIC_CHARACTER_REFERENCE", e[e.HEXADEMICAL_CHARACTER_REFERENCE_START = 75] = "HEXADEMICAL_CHARACTER_REFERENCE_START", e[e.HEXADEMICAL_CHARACTER_REFERENCE = 76] = "HEXADEMICAL_CHARACTER_REFERENCE", e[e.DECIMAL_CHARACTER_REFERENCE = 77] = "DECIMAL_CHARACTER_REFERENCE", e[e.NUMERIC_CHARACTER_REFERENCE_END = 78] = "NUMERIC_CHARACTER_REFERENCE_END";
})(State || (State = {}));
const TokenizerMode = {
  DATA: State.DATA,
  RCDATA: State.RCDATA,
  RAWTEXT: State.RAWTEXT,
  SCRIPT_DATA: State.SCRIPT_DATA,
  PLAINTEXT: State.PLAINTEXT,
  CDATA_SECTION: State.CDATA_SECTION
};
function isAsciiDigit(e) {
  return e >= CODE_POINTS.DIGIT_0 && e <= CODE_POINTS.DIGIT_9;
}
function isAsciiUpper(e) {
  return e >= CODE_POINTS.LATIN_CAPITAL_A && e <= CODE_POINTS.LATIN_CAPITAL_Z;
}
function isAsciiLower(e) {
  return e >= CODE_POINTS.LATIN_SMALL_A && e <= CODE_POINTS.LATIN_SMALL_Z;
}
function isAsciiLetter(e) {
  return isAsciiLower(e) || isAsciiUpper(e);
}
function isAsciiAlphaNumeric(e) {
  return isAsciiLetter(e) || isAsciiDigit(e);
}
function isAsciiUpperHexDigit(e) {
  return e >= CODE_POINTS.LATIN_CAPITAL_A && e <= CODE_POINTS.LATIN_CAPITAL_F;
}
function isAsciiLowerHexDigit(e) {
  return e >= CODE_POINTS.LATIN_SMALL_A && e <= CODE_POINTS.LATIN_SMALL_F;
}
function isAsciiHexDigit(e) {
  return isAsciiDigit(e) || isAsciiUpperHexDigit(e) || isAsciiLowerHexDigit(e);
}
function toAsciiLower(e) {
  return e + 32;
}
function isWhitespace(e) {
  return e === CODE_POINTS.SPACE || e === CODE_POINTS.LINE_FEED || e === CODE_POINTS.TABULATION || e === CODE_POINTS.FORM_FEED;
}
function isEntityInAttributeInvalidEnd(e) {
  return e === CODE_POINTS.EQUALS_SIGN || isAsciiAlphaNumeric(e);
}
function isScriptDataDoubleEscapeSequenceEnd(e) {
  return isWhitespace(e) || e === CODE_POINTS.SOLIDUS || e === CODE_POINTS.GREATER_THAN_SIGN;
}
class Tokenizer {
  constructor(t, r) {
    this.options = t, this.handler = r, this.paused = !1, this.inLoop = !1, this.inForeignNode = !1, this.lastStartTagName = "", this.active = !1, this.state = State.DATA, this.returnState = State.DATA, this.charRefCode = -1, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = {
      name: "",
      value: ""
    }, this.preprocessor = new Preprocessor(r), this.currentLocation = this.getCurrentLocation(-1);
  }
  //Errors
  _err(t) {
    var r, a;
    (a = (r = this.handler).onParseError) === null || a === void 0 || a.call(r, this.preprocessor.getError(t));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(t) {
    return this.options.sourceCodeLocationInfo ? {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - t,
      startOffset: this.preprocessor.offset - t,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    } : null;
  }
  _runParsingLoop() {
    if (!this.inLoop) {
      for (this.inLoop = !0; this.active && !this.paused; ) {
        this.consumedAfterSnapshot = 0;
        const t = this._consume();
        this._ensureHibernation() || this._callState(t);
      }
      this.inLoop = !1;
    }
  }
  //API
  pause() {
    this.paused = !0;
  }
  resume(t) {
    if (!this.paused)
      throw new Error("Parser was already resumed");
    this.paused = !1, !this.inLoop && (this._runParsingLoop(), this.paused || t == null || t());
  }
  write(t, r, a) {
    this.active = !0, this.preprocessor.write(t, r), this._runParsingLoop(), this.paused || a == null || a();
  }
  insertHtmlAtCurrentPos(t) {
    this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(t), this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    return this.preprocessor.endOfChunkHit ? (this._unconsume(this.consumedAfterSnapshot), this.active = !1, !0) : !1;
  }
  //Consumption
  _consume() {
    return this.consumedAfterSnapshot++, this.preprocessor.advance();
  }
  _unconsume(t) {
    this.consumedAfterSnapshot -= t, this.preprocessor.retreat(t);
  }
  _reconsumeInState(t, r) {
    this.state = t, this._callState(r);
  }
  _advanceBy(t) {
    this.consumedAfterSnapshot += t;
    for (let r = 0; r < t; r++)
      this.preprocessor.advance();
  }
  _consumeSequenceIfMatch(t, r) {
    return this.preprocessor.startsWith(t, r) ? (this._advanceBy(t.length - 1), !0) : !1;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: TokenType.START_TAG,
      tagName: "",
      tagID: TAG_ID.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: TokenType.END_TAG,
      tagName: "",
      tagID: TAG_ID.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(t) {
    this.currentToken = {
      type: TokenType.COMMENT,
      data: "",
      location: this.getCurrentLocation(t)
    };
  }
  _createDoctypeToken(t) {
    this.currentToken = {
      type: TokenType.DOCTYPE,
      name: t,
      forceQuirks: !1,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(t, r) {
    this.currentCharacterToken = {
      type: t,
      chars: r,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(t) {
    this.currentAttr = {
      name: t,
      value: ""
    }, this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var t, r;
    const a = this.currentToken;
    if (getTokenAttr(a, this.currentAttr.name) === null) {
      if (a.attrs.push(this.currentAttr), a.location && this.currentLocation) {
        const o = (t = (r = a.location).attrs) !== null && t !== void 0 ? t : r.attrs = /* @__PURE__ */ Object.create(null);
        o[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue();
      }
    } else
      this._err(ERR.duplicateAttribute);
  }
  _leaveAttrValue() {
    this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset);
  }
  //Token emission
  prepareToken(t) {
    this._emitCurrentCharacterToken(t.location), this.currentToken = null, t.location && (t.location.endLine = this.preprocessor.line, t.location.endCol = this.preprocessor.col + 1, t.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const t = this.currentToken;
    this.prepareToken(t), t.tagID = getTagID(t.tagName), t.type === TokenType.START_TAG ? (this.lastStartTagName = t.tagName, this.handler.onStartTag(t)) : (t.attrs.length > 0 && this._err(ERR.endTagWithAttributes), t.selfClosing && this._err(ERR.endTagWithTrailingSolidus), this.handler.onEndTag(t)), this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(t) {
    this.prepareToken(t), this.handler.onComment(t), this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(t) {
    this.prepareToken(t), this.handler.onDoctype(t), this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(t) {
    if (this.currentCharacterToken) {
      switch (t && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = t.startLine, this.currentCharacterToken.location.endCol = t.startCol, this.currentCharacterToken.location.endOffset = t.startOffset), this.currentCharacterToken.type) {
        case TokenType.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case TokenType.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case TokenType.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const t = this.getCurrentLocation(0);
    t && (t.endLine = t.startLine, t.endCol = t.startCol, t.endOffset = t.startOffset), this._emitCurrentCharacterToken(t), this.handler.onEof({
      type: TokenType.EOF,
      location: t
    }), this.active = !1;
  }
  //Characters emission
  //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(t, r) {
    if (this.currentCharacterToken)
      if (this.currentCharacterToken.type !== t)
        this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk();
      else {
        this.currentCharacterToken.chars += r;
        return;
      }
    this._createCharacterToken(t, r);
  }
  _emitCodePoint(t) {
    const r = isWhitespace(t) ? TokenType.WHITESPACE_CHARACTER : t === CODE_POINTS.NULL ? TokenType.NULL_CHARACTER : TokenType.CHARACTER;
    this._appendCharToCurrentCharacterToken(r, String.fromCodePoint(t));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(t) {
    this._appendCharToCurrentCharacterToken(TokenType.CHARACTER, t);
  }
  // Character reference helpers
  _matchNamedCharacterReference(t) {
    let r = null, a = 0, o = !1;
    for (let u = 0, c = htmlDecodeTree[0]; u >= 0 && (u = determineBranch(htmlDecodeTree, c, u + 1, t), !(u < 0)); t = this._consume()) {
      a += 1, c = htmlDecodeTree[u];
      const d = c & BinTrieFlags.VALUE_LENGTH;
      if (d) {
        const g = (d >> 14) - 1;
        if (t !== CODE_POINTS.SEMICOLON && this._isCharacterReferenceInAttribute() && isEntityInAttributeInvalidEnd(this.preprocessor.peek(1)) ? (r = [CODE_POINTS.AMPERSAND], u += g) : (r = g === 0 ? [htmlDecodeTree[u] & ~BinTrieFlags.VALUE_LENGTH] : g === 1 ? [htmlDecodeTree[++u]] : [htmlDecodeTree[++u], htmlDecodeTree[++u]], a = 0, o = t !== CODE_POINTS.SEMICOLON), g === 0) {
          this._consume();
          break;
        }
      }
    }
    return this._unconsume(a), o && !this.preprocessor.endOfChunkHit && this._err(ERR.missingSemicolonAfterCharacterReference), this._unconsume(1), r;
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === State.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(t) {
    this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(t) : this._emitCodePoint(t);
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(t) {
    switch (this.state) {
      case State.DATA: {
        this._stateData(t);
        break;
      }
      case State.RCDATA: {
        this._stateRcdata(t);
        break;
      }
      case State.RAWTEXT: {
        this._stateRawtext(t);
        break;
      }
      case State.SCRIPT_DATA: {
        this._stateScriptData(t);
        break;
      }
      case State.PLAINTEXT: {
        this._statePlaintext(t);
        break;
      }
      case State.TAG_OPEN: {
        this._stateTagOpen(t);
        break;
      }
      case State.END_TAG_OPEN: {
        this._stateEndTagOpen(t);
        break;
      }
      case State.TAG_NAME: {
        this._stateTagName(t);
        break;
      }
      case State.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(t);
        break;
      }
      case State.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(t);
        break;
      }
      case State.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(t);
        break;
      }
      case State.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(t);
        break;
      }
      case State.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(t);
        break;
      }
      case State.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(t);
        break;
      }
      case State.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(t);
        break;
      }
      case State.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(t);
        break;
      }
      case State.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(t);
        break;
      }
      case State.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(t);
        break;
      }
      case State.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(t);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(t);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(t);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(t);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(t);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(t);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(t);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(t);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(t);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(t);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(t);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(t);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(t);
        break;
      }
      case State.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(t);
        break;
      }
      case State.ATTRIBUTE_NAME: {
        this._stateAttributeName(t);
        break;
      }
      case State.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(t);
        break;
      }
      case State.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(t);
        break;
      }
      case State.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(t);
        break;
      }
      case State.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(t);
        break;
      }
      case State.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(t);
        break;
      }
      case State.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(t);
        break;
      }
      case State.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(t);
        break;
      }
      case State.BOGUS_COMMENT: {
        this._stateBogusComment(t);
        break;
      }
      case State.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(t);
        break;
      }
      case State.COMMENT_START: {
        this._stateCommentStart(t);
        break;
      }
      case State.COMMENT_START_DASH: {
        this._stateCommentStartDash(t);
        break;
      }
      case State.COMMENT: {
        this._stateComment(t);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(t);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(t);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(t);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(t);
        break;
      }
      case State.COMMENT_END_DASH: {
        this._stateCommentEndDash(t);
        break;
      }
      case State.COMMENT_END: {
        this._stateCommentEnd(t);
        break;
      }
      case State.COMMENT_END_BANG: {
        this._stateCommentEndBang(t);
        break;
      }
      case State.DOCTYPE: {
        this._stateDoctype(t);
        break;
      }
      case State.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(t);
        break;
      }
      case State.DOCTYPE_NAME: {
        this._stateDoctypeName(t);
        break;
      }
      case State.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(t);
        break;
      }
      case State.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(t);
        break;
      }
      case State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(t);
        break;
      }
      case State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(t);
        break;
      }
      case State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(t);
        break;
      }
      case State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(t);
        break;
      }
      case State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(t);
        break;
      }
      case State.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(t);
        break;
      }
      case State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(t);
        break;
      }
      case State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(t);
        break;
      }
      case State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(t);
        break;
      }
      case State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(t);
        break;
      }
      case State.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(t);
        break;
      }
      case State.CDATA_SECTION: {
        this._stateCdataSection(t);
        break;
      }
      case State.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(t);
        break;
      }
      case State.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(t);
        break;
      }
      case State.CHARACTER_REFERENCE: {
        this._stateCharacterReference(t);
        break;
      }
      case State.NAMED_CHARACTER_REFERENCE: {
        this._stateNamedCharacterReference(t);
        break;
      }
      case State.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(t);
        break;
      }
      case State.NUMERIC_CHARACTER_REFERENCE: {
        this._stateNumericCharacterReference(t);
        break;
      }
      case State.HEXADEMICAL_CHARACTER_REFERENCE_START: {
        this._stateHexademicalCharacterReferenceStart(t);
        break;
      }
      case State.HEXADEMICAL_CHARACTER_REFERENCE: {
        this._stateHexademicalCharacterReference(t);
        break;
      }
      case State.DECIMAL_CHARACTER_REFERENCE: {
        this._stateDecimalCharacterReference(t);
        break;
      }
      case State.NUMERIC_CHARACTER_REFERENCE_END: {
        this._stateNumericCharacterReferenceEnd(t);
        break;
      }
      default:
        throw new Error("Unknown state");
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(t) {
    switch (t) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.TAG_OPEN;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State.DATA, this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), this._emitCodePoint(t);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(t) {
    switch (t) {
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State.RCDATA, this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(t) {
    switch (t) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(t) {
    switch (t) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(t) {
    switch (t) {
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(t) {
    if (isAsciiLetter(t))
      this._createStartTagToken(), this.state = State.TAG_NAME, this._stateTagName(t);
    else switch (t) {
      case CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State.MARKUP_DECLARATION_OPEN;
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this.state = State.END_TAG_OPEN;
        break;
      }
      case CODE_POINTS.QUESTION_MARK: {
        this._err(ERR.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = State.BOGUS_COMMENT, this._stateBogusComment(t);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken();
        break;
      }
      default:
        this._err(ERR.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = State.DATA, this._stateData(t);
    }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(t) {
    if (isAsciiLetter(t))
      this._createEndTagToken(), this.state = State.TAG_NAME, this._stateTagName(t);
    else switch (t) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingEndTagName), this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken();
        break;
      }
      default:
        this._err(ERR.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = State.BOGUS_COMMENT, this._stateBogusComment(t);
    }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(t) {
    const r = this.currentToken;
    switch (t) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA, this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), r.tagName += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        r.tagName += String.fromCodePoint(isAsciiUpper(t) ? toAsciiLower(t) : t);
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(t) {
    t === CODE_POINTS.SOLIDUS ? this.state = State.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = State.RCDATA, this._stateRcdata(t));
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(t) {
    isAsciiLetter(t) ? (this.state = State.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(t)) : (this._emitChars("</"), this.state = State.RCDATA, this._stateRcdata(t));
  }
  handleSpecialEndTag(t) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, !1))
      return !this._ensureHibernation();
    this._createEndTagToken();
    const r = this.currentToken;
    switch (r.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED:
        return this._advanceBy(this.lastStartTagName.length), this.state = State.BEFORE_ATTRIBUTE_NAME, !1;
      case CODE_POINTS.SOLIDUS:
        return this._advanceBy(this.lastStartTagName.length), this.state = State.SELF_CLOSING_START_TAG, !1;
      case CODE_POINTS.GREATER_THAN_SIGN:
        return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = State.DATA, !1;
      default:
        return !this._ensureHibernation();
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = State.RCDATA, this._stateRcdata(t));
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(t) {
    t === CODE_POINTS.SOLIDUS ? this.state = State.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = State.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(t) {
    isAsciiLetter(t) ? (this.state = State.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(t)) : (this._emitChars("</"), this.state = State.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = State.RAWTEXT, this._stateRawtext(t));
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(t) {
    switch (t) {
      case CODE_POINTS.SOLIDUS: {
        this.state = State.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!");
        break;
      }
      default:
        this._emitChars("<"), this.state = State.SCRIPT_DATA, this._stateScriptData(t);
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(t) {
    isAsciiLetter(t) ? (this.state = State.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(t)) : (this._emitChars("</"), this.state = State.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = State.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(t) {
    t === CODE_POINTS.HYPHEN_MINUS ? (this.state = State.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = State.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(t) {
    t === CODE_POINTS.HYPHEN_MINUS ? (this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = State.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(t) {
    switch (t) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(t) {
    switch (t) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), this.state = State.SCRIPT_DATA_ESCAPED, this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = State.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(t) {
    switch (t) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), this.state = State.SCRIPT_DATA_ESCAPED, this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = State.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(t) {
    t === CODE_POINTS.SOLIDUS ? this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : isAsciiLetter(t) ? (this._emitChars("<"), this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(t)) : (this._emitChars("<"), this.state = State.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(t) {
    isAsciiLetter(t) ? (this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(t)) : (this._emitChars("</"), this.state = State.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = State.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(t) {
    if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, !1) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let r = 0; r < SEQUENCES.SCRIPT.length; r++)
        this._emitCodePoint(this._consume());
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else this._ensureHibernation() || (this.state = State.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(t) {
    switch (t) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(t) {
    switch (t) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(t) {
    switch (t) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(t) {
    t === CODE_POINTS.SOLIDUS ? (this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(t) {
    if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, !1) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let r = 0; r < SEQUENCES.SCRIPT.length; r++)
        this._emitCodePoint(this._consume());
      this.state = State.SCRIPT_DATA_ESCAPED;
    } else this._ensureHibernation() || (this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(t) {
    switch (t) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED:
        break;
      case CODE_POINTS.SOLIDUS:
      case CODE_POINTS.GREATER_THAN_SIGN:
      case CODE_POINTS.EOF: {
        this.state = State.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this._err(ERR.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = State.ATTRIBUTE_NAME;
        break;
      }
      default:
        this._createAttr(""), this.state = State.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(t) {
    switch (t) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED:
      case CODE_POINTS.SOLIDUS:
      case CODE_POINTS.GREATER_THAN_SIGN:
      case CODE_POINTS.EOF: {
        this._leaveAttrName(), this.state = State.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this._leaveAttrName(), this.state = State.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK:
      case CODE_POINTS.APOSTROPHE:
      case CODE_POINTS.LESS_THAN_SIGN: {
        this._err(ERR.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(t);
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), this.currentAttr.name += REPLACEMENT_CHARACTER;
        break;
      }
      default:
        this.currentAttr.name += String.fromCodePoint(isAsciiUpper(t) ? toAsciiLower(t) : t);
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(t) {
    switch (t) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED:
        break;
      case CODE_POINTS.SOLIDUS: {
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this.state = State.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA, this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._createAttr(""), this.state = State.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(t) {
    switch (t) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED:
        break;
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingAttributeValue), this.state = State.DATA, this.emitCurrentTagToken();
        break;
      }
      default:
        this.state = State.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(t);
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(t) {
    switch (t) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED, this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(t) {
    switch (t) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State.ATTRIBUTE_VALUE_SINGLE_QUOTED, this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(t) {
    switch (t) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._leaveAttrValue(), this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State.ATTRIBUTE_VALUE_UNQUOTED, this.state = State.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = State.DATA, this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK:
      case CODE_POINTS.APOSTROPHE:
      case CODE_POINTS.LESS_THAN_SIGN:
      case CODE_POINTS.EQUALS_SIGN:
      case CODE_POINTS.GRAVE_ACCENT: {
        this._err(ERR.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(t);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(t) {
    switch (t) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._leaveAttrValue(), this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this._leaveAttrValue(), this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = State.DATA, this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(ERR.missingWhitespaceBetweenAttributes), this.state = State.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(t) {
    switch (t) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        const r = this.currentToken;
        r.selfClosing = !0, this.state = State.DATA, this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(ERR.unexpectedSolidusInTag), this.state = State.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(t) {
    const r = this.currentToken;
    switch (t) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA, this.emitCurrentComment(r);
        break;
      }
      case CODE_POINTS.EOF: {
        this.emitCurrentComment(r), this._emitEOFToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), r.data += REPLACEMENT_CHARACTER;
        break;
      }
      default:
        r.data += String.fromCodePoint(t);
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(t) {
    this._consumeSequenceIfMatch(SEQUENCES.DASH_DASH, !0) ? (this._createCommentToken(SEQUENCES.DASH_DASH.length + 1), this.state = State.COMMENT_START) : this._consumeSequenceIfMatch(SEQUENCES.DOCTYPE, !1) ? (this.currentLocation = this.getCurrentLocation(SEQUENCES.DOCTYPE.length + 1), this.state = State.DOCTYPE) : this._consumeSequenceIfMatch(SEQUENCES.CDATA_START, !0) ? this.inForeignNode ? this.state = State.CDATA_SECTION : (this._err(ERR.cdataInHtmlContent), this._createCommentToken(SEQUENCES.CDATA_START.length + 1), this.currentToken.data = "[CDATA[", this.state = State.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(ERR.incorrectlyOpenedComment), this._createCommentToken(2), this.state = State.BOGUS_COMMENT, this._stateBogusComment(t));
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(t) {
    switch (t) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_START_DASH;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptClosingOfEmptyComment), this.state = State.DATA;
        const r = this.currentToken;
        this.emitCurrentComment(r);
        break;
      }
      default:
        this.state = State.COMMENT, this._stateComment(t);
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(t) {
    const r = this.currentToken;
    switch (t) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptClosingOfEmptyComment), this.state = State.DATA, this.emitCurrentComment(r);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment), this.emitCurrentComment(r), this._emitEOFToken();
        break;
      }
      default:
        r.data += "-", this.state = State.COMMENT, this._stateComment(t);
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(t) {
    const r = this.currentToken;
    switch (t) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END_DASH;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        r.data += "<", this.state = State.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), r.data += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment), this.emitCurrentComment(r), this._emitEOFToken();
        break;
      }
      default:
        r.data += String.fromCodePoint(t);
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(t) {
    const r = this.currentToken;
    switch (t) {
      case CODE_POINTS.EXCLAMATION_MARK: {
        r.data += "!", this.state = State.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        r.data += "<";
        break;
      }
      default:
        this.state = State.COMMENT, this._stateComment(t);
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(t) {
    t === CODE_POINTS.HYPHEN_MINUS ? this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = State.COMMENT, this._stateComment(t));
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(t) {
    t === CODE_POINTS.HYPHEN_MINUS ? this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = State.COMMENT_END_DASH, this._stateCommentEndDash(t));
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(t) {
    t !== CODE_POINTS.GREATER_THAN_SIGN && t !== CODE_POINTS.EOF && this._err(ERR.nestedComment), this.state = State.COMMENT_END, this._stateCommentEnd(t);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(t) {
    const r = this.currentToken;
    switch (t) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment), this.emitCurrentComment(r), this._emitEOFToken();
        break;
      }
      default:
        r.data += "-", this.state = State.COMMENT, this._stateComment(t);
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(t) {
    const r = this.currentToken;
    switch (t) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA, this.emitCurrentComment(r);
        break;
      }
      case CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State.COMMENT_END_BANG;
        break;
      }
      case CODE_POINTS.HYPHEN_MINUS: {
        r.data += "-";
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment), this.emitCurrentComment(r), this._emitEOFToken();
        break;
      }
      default:
        r.data += "--", this.state = State.COMMENT, this._stateComment(t);
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(t) {
    const r = this.currentToken;
    switch (t) {
      case CODE_POINTS.HYPHEN_MINUS: {
        r.data += "--!", this.state = State.COMMENT_END_DASH;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.incorrectlyClosedComment), this.state = State.DATA, this.emitCurrentComment(r);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment), this.emitCurrentComment(r), this._emitEOFToken();
        break;
      }
      default:
        r.data += "--!", this.state = State.COMMENT, this._stateComment(t);
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(t) {
    switch (t) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_NAME;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype), this._createDoctypeToken(null);
        const r = this.currentToken;
        r.forceQuirks = !0, this.emitCurrentDoctype(r), this._emitEOFToken();
        break;
      }
      default:
        this._err(ERR.missingWhitespaceBeforeDoctypeName), this.state = State.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(t) {
    if (isAsciiUpper(t))
      this._createDoctypeToken(String.fromCharCode(toAsciiLower(t))), this.state = State.DOCTYPE_NAME;
    else switch (t) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED:
        break;
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), this._createDoctypeToken(REPLACEMENT_CHARACTER), this.state = State.DOCTYPE_NAME;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypeName), this._createDoctypeToken(null);
        const r = this.currentToken;
        r.forceQuirks = !0, this.emitCurrentDoctype(r), this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype), this._createDoctypeToken(null);
        const r = this.currentToken;
        r.forceQuirks = !0, this.emitCurrentDoctype(r), this._emitEOFToken();
        break;
      }
      default:
        this._createDoctypeToken(String.fromCodePoint(t)), this.state = State.DOCTYPE_NAME;
    }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(t) {
    const r = this.currentToken;
    switch (t) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.AFTER_DOCTYPE_NAME;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA, this.emitCurrentDoctype(r);
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), r.name += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype), r.forceQuirks = !0, this.emitCurrentDoctype(r), this._emitEOFToken();
        break;
      }
      default:
        r.name += String.fromCodePoint(isAsciiUpper(t) ? toAsciiLower(t) : t);
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(t) {
    const r = this.currentToken;
    switch (t) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED:
        break;
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA, this.emitCurrentDoctype(r);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype), r.forceQuirks = !0, this.emitCurrentDoctype(r), this._emitEOFToken();
        break;
      }
      default:
        this._consumeSequenceIfMatch(SEQUENCES.PUBLIC, !1) ? this.state = State.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch(SEQUENCES.SYSTEM, !1) ? this.state = State.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(ERR.invalidCharacterSequenceAfterDoctypeName), r.forceQuirks = !0, this.state = State.BOGUS_DOCTYPE, this._stateBogusDoctype(t));
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(t) {
    const r = this.currentToken;
    switch (t) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword), r.publicId = "", this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword), r.publicId = "", this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypePublicIdentifier), r.forceQuirks = !0, this.state = State.DATA, this.emitCurrentDoctype(r);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype), r.forceQuirks = !0, this.emitCurrentDoctype(r), this._emitEOFToken();
        break;
      }
      default:
        this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier), r.forceQuirks = !0, this.state = State.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(t) {
    const r = this.currentToken;
    switch (t) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED:
        break;
      case CODE_POINTS.QUOTATION_MARK: {
        r.publicId = "", this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        r.publicId = "", this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypePublicIdentifier), r.forceQuirks = !0, this.state = State.DATA, this.emitCurrentDoctype(r);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype), r.forceQuirks = !0, this.emitCurrentDoctype(r), this._emitEOFToken();
        break;
      }
      default:
        this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier), r.forceQuirks = !0, this.state = State.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(t) {
    const r = this.currentToken;
    switch (t) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), r.publicId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypePublicIdentifier), r.forceQuirks = !0, this.emitCurrentDoctype(r), this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype), r.forceQuirks = !0, this.emitCurrentDoctype(r), this._emitEOFToken();
        break;
      }
      default:
        r.publicId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(t) {
    const r = this.currentToken;
    switch (t) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), r.publicId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypePublicIdentifier), r.forceQuirks = !0, this.emitCurrentDoctype(r), this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype), r.forceQuirks = !0, this.emitCurrentDoctype(r), this._emitEOFToken();
        break;
      }
      default:
        r.publicId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(t) {
    const r = this.currentToken;
    switch (t) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA, this.emitCurrentDoctype(r);
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), r.systemId = "", this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), r.systemId = "", this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype), r.forceQuirks = !0, this.emitCurrentDoctype(r), this._emitEOFToken();
        break;
      }
      default:
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier), r.forceQuirks = !0, this.state = State.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(t) {
    const r = this.currentToken;
    switch (t) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED:
        break;
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(r), this.state = State.DATA;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        r.systemId = "", this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        r.systemId = "", this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype), r.forceQuirks = !0, this.emitCurrentDoctype(r), this._emitEOFToken();
        break;
      }
      default:
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier), r.forceQuirks = !0, this.state = State.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(t) {
    const r = this.currentToken;
    switch (t) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword), r.systemId = "", this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword), r.systemId = "", this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypeSystemIdentifier), r.forceQuirks = !0, this.state = State.DATA, this.emitCurrentDoctype(r);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype), r.forceQuirks = !0, this.emitCurrentDoctype(r), this._emitEOFToken();
        break;
      }
      default:
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier), r.forceQuirks = !0, this.state = State.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(t) {
    const r = this.currentToken;
    switch (t) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED:
        break;
      case CODE_POINTS.QUOTATION_MARK: {
        r.systemId = "", this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        r.systemId = "", this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypeSystemIdentifier), r.forceQuirks = !0, this.state = State.DATA, this.emitCurrentDoctype(r);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype), r.forceQuirks = !0, this.emitCurrentDoctype(r), this._emitEOFToken();
        break;
      }
      default:
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier), r.forceQuirks = !0, this.state = State.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(t) {
    const r = this.currentToken;
    switch (t) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), r.systemId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypeSystemIdentifier), r.forceQuirks = !0, this.emitCurrentDoctype(r), this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype), r.forceQuirks = !0, this.emitCurrentDoctype(r), this._emitEOFToken();
        break;
      }
      default:
        r.systemId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(t) {
    const r = this.currentToken;
    switch (t) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter), r.systemId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypeSystemIdentifier), r.forceQuirks = !0, this.emitCurrentDoctype(r), this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype), r.forceQuirks = !0, this.emitCurrentDoctype(r), this._emitEOFToken();
        break;
      }
      default:
        r.systemId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(t) {
    const r = this.currentToken;
    switch (t) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED:
        break;
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(r), this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype), r.forceQuirks = !0, this.emitCurrentDoctype(r), this._emitEOFToken();
        break;
      }
      default:
        this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = State.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(t) {
    const r = this.currentToken;
    switch (t) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(r), this.state = State.DATA;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        break;
      }
      case CODE_POINTS.EOF: {
        this.emitCurrentDoctype(r), this._emitEOFToken();
        break;
      }
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(t) {
    switch (t) {
      case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
        this.state = State.CDATA_SECTION_BRACKET;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInCdata), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(t) {
    t === CODE_POINTS.RIGHT_SQUARE_BRACKET ? this.state = State.CDATA_SECTION_END : (this._emitChars("]"), this.state = State.CDATA_SECTION, this._stateCdataSection(t));
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(t) {
    switch (t) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default:
        this._emitChars("]]"), this.state = State.CDATA_SECTION, this._stateCdataSection(t);
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference(t) {
    t === CODE_POINTS.NUMBER_SIGN ? this.state = State.NUMERIC_CHARACTER_REFERENCE : isAsciiAlphaNumeric(t) ? (this.state = State.NAMED_CHARACTER_REFERENCE, this._stateNamedCharacterReference(t)) : (this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND), this._reconsumeInState(this.returnState, t));
  }
  // Named character reference state
  //------------------------------------------------------------------
  _stateNamedCharacterReference(t) {
    const r = this._matchNamedCharacterReference(t);
    if (!this._ensureHibernation()) if (r) {
      for (let a = 0; a < r.length; a++)
        this._flushCodePointConsumedAsCharacterReference(r[a]);
      this.state = this.returnState;
    } else
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND), this.state = State.AMBIGUOUS_AMPERSAND;
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(t) {
    isAsciiAlphaNumeric(t) ? this._flushCodePointConsumedAsCharacterReference(t) : (t === CODE_POINTS.SEMICOLON && this._err(ERR.unknownNamedCharacterReference), this._reconsumeInState(this.returnState, t));
  }
  // Numeric character reference state
  //------------------------------------------------------------------
  _stateNumericCharacterReference(t) {
    this.charRefCode = 0, t === CODE_POINTS.LATIN_SMALL_X || t === CODE_POINTS.LATIN_CAPITAL_X ? this.state = State.HEXADEMICAL_CHARACTER_REFERENCE_START : isAsciiDigit(t) ? (this.state = State.DECIMAL_CHARACTER_REFERENCE, this._stateDecimalCharacterReference(t)) : (this._err(ERR.absenceOfDigitsInNumericCharacterReference), this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND), this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.NUMBER_SIGN), this._reconsumeInState(this.returnState, t));
  }
  // Hexademical character reference start state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReferenceStart(t) {
    isAsciiHexDigit(t) ? (this.state = State.HEXADEMICAL_CHARACTER_REFERENCE, this._stateHexademicalCharacterReference(t)) : (this._err(ERR.absenceOfDigitsInNumericCharacterReference), this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND), this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.NUMBER_SIGN), this._unconsume(2), this.state = this.returnState);
  }
  // Hexademical character reference state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReference(t) {
    isAsciiUpperHexDigit(t) ? this.charRefCode = this.charRefCode * 16 + t - 55 : isAsciiLowerHexDigit(t) ? this.charRefCode = this.charRefCode * 16 + t - 87 : isAsciiDigit(t) ? this.charRefCode = this.charRefCode * 16 + t - 48 : t === CODE_POINTS.SEMICOLON ? this.state = State.NUMERIC_CHARACTER_REFERENCE_END : (this._err(ERR.missingSemicolonAfterCharacterReference), this.state = State.NUMERIC_CHARACTER_REFERENCE_END, this._stateNumericCharacterReferenceEnd(t));
  }
  // Decimal character reference state
  //------------------------------------------------------------------
  _stateDecimalCharacterReference(t) {
    isAsciiDigit(t) ? this.charRefCode = this.charRefCode * 10 + t - 48 : t === CODE_POINTS.SEMICOLON ? this.state = State.NUMERIC_CHARACTER_REFERENCE_END : (this._err(ERR.missingSemicolonAfterCharacterReference), this.state = State.NUMERIC_CHARACTER_REFERENCE_END, this._stateNumericCharacterReferenceEnd(t));
  }
  // Numeric character reference end state
  //------------------------------------------------------------------
  _stateNumericCharacterReferenceEnd(t) {
    if (this.charRefCode === CODE_POINTS.NULL)
      this._err(ERR.nullCharacterReference), this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
    else if (this.charRefCode > 1114111)
      this._err(ERR.characterReferenceOutsideUnicodeRange), this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
    else if (isSurrogate(this.charRefCode))
      this._err(ERR.surrogateCharacterReference), this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
    else if (isUndefinedCodePoint(this.charRefCode))
      this._err(ERR.noncharacterCharacterReference);
    else if (isControlCodePoint(this.charRefCode) || this.charRefCode === CODE_POINTS.CARRIAGE_RETURN) {
      this._err(ERR.controlCharacterReference);
      const r = C1_CONTROLS_REFERENCE_REPLACEMENTS.get(this.charRefCode);
      r !== void 0 && (this.charRefCode = r);
    }
    this._flushCodePointConsumedAsCharacterReference(this.charRefCode), this._reconsumeInState(this.returnState, t);
  }
}
const IMPLICIT_END_TAG_REQUIRED = /* @__PURE__ */ new Set([TAG_ID.DD, TAG_ID.DT, TAG_ID.LI, TAG_ID.OPTGROUP, TAG_ID.OPTION, TAG_ID.P, TAG_ID.RB, TAG_ID.RP, TAG_ID.RT, TAG_ID.RTC]), IMPLICIT_END_TAG_REQUIRED_THOROUGHLY = /* @__PURE__ */ new Set([...IMPLICIT_END_TAG_REQUIRED, TAG_ID.CAPTION, TAG_ID.COLGROUP, TAG_ID.TBODY, TAG_ID.TD, TAG_ID.TFOOT, TAG_ID.TH, TAG_ID.THEAD, TAG_ID.TR]), SCOPING_ELEMENT_NS = /* @__PURE__ */ new Map([[TAG_ID.APPLET, NS.HTML], [TAG_ID.CAPTION, NS.HTML], [TAG_ID.HTML, NS.HTML], [TAG_ID.MARQUEE, NS.HTML], [TAG_ID.OBJECT, NS.HTML], [TAG_ID.TABLE, NS.HTML], [TAG_ID.TD, NS.HTML], [TAG_ID.TEMPLATE, NS.HTML], [TAG_ID.TH, NS.HTML], [TAG_ID.ANNOTATION_XML, NS.MATHML], [TAG_ID.MI, NS.MATHML], [TAG_ID.MN, NS.MATHML], [TAG_ID.MO, NS.MATHML], [TAG_ID.MS, NS.MATHML], [TAG_ID.MTEXT, NS.MATHML], [TAG_ID.DESC, NS.SVG], [TAG_ID.FOREIGN_OBJECT, NS.SVG], [TAG_ID.TITLE, NS.SVG]]), NAMED_HEADERS = [TAG_ID.H1, TAG_ID.H2, TAG_ID.H3, TAG_ID.H4, TAG_ID.H5, TAG_ID.H6], TABLE_ROW_CONTEXT = [TAG_ID.TR, TAG_ID.TEMPLATE, TAG_ID.HTML], TABLE_BODY_CONTEXT = [TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TEMPLATE, TAG_ID.HTML], TABLE_CONTEXT = [TAG_ID.TABLE, TAG_ID.TEMPLATE, TAG_ID.HTML], TABLE_CELLS = [TAG_ID.TD, TAG_ID.TH];
class OpenElementStack {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(t, r, a) {
    this.treeAdapter = r, this.handler = a, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = TAG_ID.UNKNOWN, this.current = t;
  }
  //Index of element
  _indexOf(t) {
    return this.items.lastIndexOf(t, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === TAG_ID.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(t, r) {
    this.stackTop++, this.items[this.stackTop] = t, this.current = t, this.tagIDs[this.stackTop] = r, this.currentTagId = r, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(t, r, !0);
  }
  pop() {
    const t = this.current;
    this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !0);
  }
  replace(t, r) {
    const a = this._indexOf(t);
    this.items[a] = r, a === this.stackTop && (this.current = r);
  }
  insertAfter(t, r, a) {
    const o = this._indexOf(t) + 1;
    this.items.splice(o, 0, r), this.tagIDs.splice(o, 0, a), this.stackTop++, o === this.stackTop && this._updateCurrentElement(), this.handler.onItemPush(this.current, this.currentTagId, o === this.stackTop);
  }
  popUntilTagNamePopped(t) {
    let r = this.stackTop + 1;
    do
      r = this.tagIDs.lastIndexOf(t, r - 1);
    while (r > 0 && this.treeAdapter.getNamespaceURI(this.items[r]) !== NS.HTML);
    this.shortenToLength(r < 0 ? 0 : r);
  }
  shortenToLength(t) {
    for (; this.stackTop >= t; ) {
      const r = this.current;
      this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(r, this.stackTop < t);
    }
  }
  popUntilElementPopped(t) {
    const r = this._indexOf(t);
    this.shortenToLength(r < 0 ? 0 : r);
  }
  popUntilPopped(t, r) {
    const a = this._indexOfTagNames(t, r);
    this.shortenToLength(a < 0 ? 0 : a);
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(NAMED_HEADERS, NS.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(TABLE_CELLS, NS.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0, this.shortenToLength(1);
  }
  _indexOfTagNames(t, r) {
    for (let a = this.stackTop; a >= 0; a--)
      if (t.includes(this.tagIDs[a]) && this.treeAdapter.getNamespaceURI(this.items[a]) === r)
        return a;
    return -1;
  }
  clearBackTo(t, r) {
    const a = this._indexOfTagNames(t, r);
    this.shortenToLength(a + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(TABLE_CONTEXT, NS.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(TABLE_BODY_CONTEXT, NS.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(TABLE_ROW_CONTEXT, NS.HTML);
  }
  remove(t) {
    const r = this._indexOf(t);
    r >= 0 && (r === this.stackTop ? this.pop() : (this.items.splice(r, 1), this.tagIDs.splice(r, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !1)));
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === TAG_ID.BODY ? this.items[1] : null;
  }
  contains(t) {
    return this._indexOf(t) > -1;
  }
  getCommonAncestor(t) {
    const r = this._indexOf(t) - 1;
    return r >= 0 ? this.items[r] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === TAG_ID.HTML;
  }
  //Element in scope
  hasInScope(t) {
    for (let r = this.stackTop; r >= 0; r--) {
      const a = this.tagIDs[r], o = this.treeAdapter.getNamespaceURI(this.items[r]);
      if (a === t && o === NS.HTML)
        return !0;
      if (SCOPING_ELEMENT_NS.get(a) === o)
        return !1;
    }
    return !0;
  }
  hasNumberedHeaderInScope() {
    for (let t = this.stackTop; t >= 0; t--) {
      const r = this.tagIDs[t], a = this.treeAdapter.getNamespaceURI(this.items[t]);
      if (isNumberedHeader(r) && a === NS.HTML)
        return !0;
      if (SCOPING_ELEMENT_NS.get(r) === a)
        return !1;
    }
    return !0;
  }
  hasInListItemScope(t) {
    for (let r = this.stackTop; r >= 0; r--) {
      const a = this.tagIDs[r], o = this.treeAdapter.getNamespaceURI(this.items[r]);
      if (a === t && o === NS.HTML)
        return !0;
      if ((a === TAG_ID.UL || a === TAG_ID.OL) && o === NS.HTML || SCOPING_ELEMENT_NS.get(a) === o)
        return !1;
    }
    return !0;
  }
  hasInButtonScope(t) {
    for (let r = this.stackTop; r >= 0; r--) {
      const a = this.tagIDs[r], o = this.treeAdapter.getNamespaceURI(this.items[r]);
      if (a === t && o === NS.HTML)
        return !0;
      if (a === TAG_ID.BUTTON && o === NS.HTML || SCOPING_ELEMENT_NS.get(a) === o)
        return !1;
    }
    return !0;
  }
  hasInTableScope(t) {
    for (let r = this.stackTop; r >= 0; r--) {
      const a = this.tagIDs[r];
      if (this.treeAdapter.getNamespaceURI(this.items[r]) === NS.HTML) {
        if (a === t)
          return !0;
        if (a === TAG_ID.TABLE || a === TAG_ID.TEMPLATE || a === TAG_ID.HTML)
          return !1;
      }
    }
    return !0;
  }
  hasTableBodyContextInTableScope() {
    for (let t = this.stackTop; t >= 0; t--) {
      const r = this.tagIDs[t];
      if (this.treeAdapter.getNamespaceURI(this.items[t]) === NS.HTML) {
        if (r === TAG_ID.TBODY || r === TAG_ID.THEAD || r === TAG_ID.TFOOT)
          return !0;
        if (r === TAG_ID.TABLE || r === TAG_ID.HTML)
          return !1;
      }
    }
    return !0;
  }
  hasInSelectScope(t) {
    for (let r = this.stackTop; r >= 0; r--) {
      const a = this.tagIDs[r];
      if (this.treeAdapter.getNamespaceURI(this.items[r]) === NS.HTML) {
        if (a === t)
          return !0;
        if (a !== TAG_ID.OPTION && a !== TAG_ID.OPTGROUP)
          return !1;
      }
    }
    return !0;
  }
  //Implied end tags
  generateImpliedEndTags() {
    for (; IMPLICIT_END_TAG_REQUIRED.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsThoroughly() {
    for (; IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsWithExclusion(t) {
    for (; this.currentTagId !== t && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId); )
      this.pop();
  }
}
const NOAH_ARK_CAPACITY = 3;
var EntryType;
(function(e) {
  e[e.Marker = 0] = "Marker", e[e.Element = 1] = "Element";
})(EntryType = EntryType || (EntryType = {}));
const MARKER = {
  type: EntryType.Marker
};
class FormattingElementList {
  constructor(t) {
    this.treeAdapter = t, this.entries = [], this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(t, r) {
    const a = [], o = r.length, u = this.treeAdapter.getTagName(t), c = this.treeAdapter.getNamespaceURI(t);
    for (let d = 0; d < this.entries.length; d++) {
      const g = this.entries[d];
      if (g.type === EntryType.Marker)
        break;
      const {
        element: b
      } = g;
      if (this.treeAdapter.getTagName(b) === u && this.treeAdapter.getNamespaceURI(b) === c) {
        const _ = this.treeAdapter.getAttrList(b);
        _.length === o && a.push({
          idx: d,
          attrs: _
        });
      }
    }
    return a;
  }
  _ensureNoahArkCondition(t) {
    if (this.entries.length < NOAH_ARK_CAPACITY) return;
    const r = this.treeAdapter.getAttrList(t), a = this._getNoahArkConditionCandidates(t, r);
    if (a.length < NOAH_ARK_CAPACITY) return;
    const o = new Map(r.map((c) => [c.name, c.value]));
    let u = 0;
    for (let c = 0; c < a.length; c++) {
      const d = a[c];
      d.attrs.every((g) => o.get(g.name) === g.value) && (u += 1, u >= NOAH_ARK_CAPACITY && this.entries.splice(d.idx, 1));
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(MARKER);
  }
  pushElement(t, r) {
    this._ensureNoahArkCondition(t), this.entries.unshift({
      type: EntryType.Element,
      element: t,
      token: r
    });
  }
  insertElementAfterBookmark(t, r) {
    const a = this.entries.indexOf(this.bookmark);
    this.entries.splice(a, 0, {
      type: EntryType.Element,
      element: t,
      token: r
    });
  }
  removeEntry(t) {
    const r = this.entries.indexOf(t);
    r >= 0 && this.entries.splice(r, 1);
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const t = this.entries.indexOf(MARKER);
    t >= 0 ? this.entries.splice(0, t + 1) : this.entries.length = 0;
  }
  //Search
  getElementEntryInScopeWithTagName(t) {
    const r = this.entries.find((a) => a.type === EntryType.Marker || this.treeAdapter.getTagName(a.element) === t);
    return r && r.type === EntryType.Element ? r : null;
  }
  getElementEntry(t) {
    return this.entries.find((r) => r.type === EntryType.Element && r.element === t);
  }
}
function createTextNode(e) {
  return {
    nodeName: "#text",
    value: e,
    parentNode: null
  };
}
const defaultTreeAdapter = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: DOCUMENT_MODE.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(e, t, r) {
    return {
      nodeName: e,
      tagName: e,
      attrs: r,
      namespaceURI: t,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(e) {
    return {
      nodeName: "#comment",
      data: e,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(e, t) {
    e.childNodes.push(t), t.parentNode = e;
  },
  insertBefore(e, t, r) {
    const a = e.childNodes.indexOf(r);
    e.childNodes.splice(a, 0, t), t.parentNode = e;
  },
  setTemplateContent(e, t) {
    e.content = t;
  },
  getTemplateContent(e) {
    return e.content;
  },
  setDocumentType(e, t, r, a) {
    const o = e.childNodes.find((u) => u.nodeName === "#documentType");
    if (o)
      o.name = t, o.publicId = r, o.systemId = a;
    else {
      const u = {
        nodeName: "#documentType",
        name: t,
        publicId: r,
        systemId: a,
        parentNode: null
      };
      defaultTreeAdapter.appendChild(e, u);
    }
  },
  setDocumentMode(e, t) {
    e.mode = t;
  },
  getDocumentMode(e) {
    return e.mode;
  },
  detachNode(e) {
    if (e.parentNode) {
      const t = e.parentNode.childNodes.indexOf(e);
      e.parentNode.childNodes.splice(t, 1), e.parentNode = null;
    }
  },
  insertText(e, t) {
    if (e.childNodes.length > 0) {
      const r = e.childNodes[e.childNodes.length - 1];
      if (defaultTreeAdapter.isTextNode(r)) {
        r.value += t;
        return;
      }
    }
    defaultTreeAdapter.appendChild(e, createTextNode(t));
  },
  insertTextBefore(e, t, r) {
    const a = e.childNodes[e.childNodes.indexOf(r) - 1];
    a && defaultTreeAdapter.isTextNode(a) ? a.value += t : defaultTreeAdapter.insertBefore(e, createTextNode(t), r);
  },
  adoptAttributes(e, t) {
    const r = new Set(e.attrs.map((a) => a.name));
    for (let a = 0; a < t.length; a++)
      r.has(t[a].name) || e.attrs.push(t[a]);
  },
  //Tree traversing
  getFirstChild(e) {
    return e.childNodes[0];
  },
  getChildNodes(e) {
    return e.childNodes;
  },
  getParentNode(e) {
    return e.parentNode;
  },
  getAttrList(e) {
    return e.attrs;
  },
  //Node data
  getTagName(e) {
    return e.tagName;
  },
  getNamespaceURI(e) {
    return e.namespaceURI;
  },
  getTextNodeContent(e) {
    return e.value;
  },
  getCommentNodeContent(e) {
    return e.data;
  },
  getDocumentTypeNodeName(e) {
    return e.name;
  },
  getDocumentTypeNodePublicId(e) {
    return e.publicId;
  },
  getDocumentTypeNodeSystemId(e) {
    return e.systemId;
  },
  //Node types
  isTextNode(e) {
    return e.nodeName === "#text";
  },
  isCommentNode(e) {
    return e.nodeName === "#comment";
  },
  isDocumentTypeNode(e) {
    return e.nodeName === "#documentType";
  },
  isElementNode(e) {
    return Object.prototype.hasOwnProperty.call(e, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = t;
  },
  getNodeSourceCodeLocation(e) {
    return e.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = {
      ...e.sourceCodeLocation,
      ...t
    };
  }
}, VALID_DOCTYPE_NAME = "html", VALID_SYSTEM_ID = "about:legacy-compat", QUIRKS_MODE_SYSTEM_ID = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", QUIRKS_MODE_PUBLIC_ID_PREFIXES = ["+//silmaril//dtd html pro v0r11 19970101//", "-//as//dtd html 3.0 aswedit + extensions//", "-//advasoft ltd//dtd html 3.0 aswedit + extensions//", "-//ietf//dtd html 2.0 level 1//", "-//ietf//dtd html 2.0 level 2//", "-//ietf//dtd html 2.0 strict level 1//", "-//ietf//dtd html 2.0 strict level 2//", "-//ietf//dtd html 2.0 strict//", "-//ietf//dtd html 2.0//", "-//ietf//dtd html 2.1e//", "-//ietf//dtd html 3.0//", "-//ietf//dtd html 3.2 final//", "-//ietf//dtd html 3.2//", "-//ietf//dtd html 3//", "-//ietf//dtd html level 0//", "-//ietf//dtd html level 1//", "-//ietf//dtd html level 2//", "-//ietf//dtd html level 3//", "-//ietf//dtd html strict level 0//", "-//ietf//dtd html strict level 1//", "-//ietf//dtd html strict level 2//", "-//ietf//dtd html strict level 3//", "-//ietf//dtd html strict//", "-//ietf//dtd html//", "-//metrius//dtd metrius presentational//", "-//microsoft//dtd internet explorer 2.0 html strict//", "-//microsoft//dtd internet explorer 2.0 html//", "-//microsoft//dtd internet explorer 2.0 tables//", "-//microsoft//dtd internet explorer 3.0 html strict//", "-//microsoft//dtd internet explorer 3.0 html//", "-//microsoft//dtd internet explorer 3.0 tables//", "-//netscape comm. corp.//dtd html//", "-//netscape comm. corp.//dtd strict html//", "-//o'reilly and associates//dtd html 2.0//", "-//o'reilly and associates//dtd html extended 1.0//", "-//o'reilly and associates//dtd html extended relaxed 1.0//", "-//sq//dtd html 2.0 hotmetal + extensions//", "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//", "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//", "-//spyglass//dtd html 2.0 extended//", "-//sun microsystems corp.//dtd hotjava html//", "-//sun microsystems corp.//dtd hotjava strict html//", "-//w3c//dtd html 3 1995-03-24//", "-//w3c//dtd html 3.2 draft//", "-//w3c//dtd html 3.2 final//", "-//w3c//dtd html 3.2//", "-//w3c//dtd html 3.2s draft//", "-//w3c//dtd html 4.0 frameset//", "-//w3c//dtd html 4.0 transitional//", "-//w3c//dtd html experimental 19960712//", "-//w3c//dtd html experimental 970421//", "-//w3c//dtd w3 html//", "-//w3o//dtd w3 html 3.0//", "-//webtechs//dtd mozilla html 2.0//", "-//webtechs//dtd mozilla html//"], QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = [...QUIRKS_MODE_PUBLIC_ID_PREFIXES, "-//w3c//dtd html 4.01 frameset//", "-//w3c//dtd html 4.01 transitional//"], QUIRKS_MODE_PUBLIC_IDS = /* @__PURE__ */ new Set(["-//w3o//dtd w3 html strict 3.0//en//", "-/w3c/dtd html 4.0 transitional/en", "html"]), LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = [...LIMITED_QUIRKS_PUBLIC_ID_PREFIXES, "-//w3c//dtd html 4.01 frameset//", "-//w3c//dtd html 4.01 transitional//"];
function hasPrefix(e, t) {
  return t.some((r) => e.startsWith(r));
}
function isConforming(e) {
  return e.name === VALID_DOCTYPE_NAME && e.publicId === null && (e.systemId === null || e.systemId === VALID_SYSTEM_ID);
}
function getDocumentMode(e) {
  if (e.name !== VALID_DOCTYPE_NAME)
    return DOCUMENT_MODE.QUIRKS;
  const {
    systemId: t
  } = e;
  if (t && t.toLowerCase() === QUIRKS_MODE_SYSTEM_ID)
    return DOCUMENT_MODE.QUIRKS;
  let {
    publicId: r
  } = e;
  if (r !== null) {
    if (r = r.toLowerCase(), QUIRKS_MODE_PUBLIC_IDS.has(r))
      return DOCUMENT_MODE.QUIRKS;
    let a = t === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
    if (hasPrefix(r, a))
      return DOCUMENT_MODE.QUIRKS;
    if (a = t === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES, hasPrefix(r, a))
      return DOCUMENT_MODE.LIMITED_QUIRKS;
  }
  return DOCUMENT_MODE.NO_QUIRKS;
}
const MIME_TYPES = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
}, DEFINITION_URL_ATTR = "definitionurl", ADJUSTED_DEFINITION_URL_ATTR = "definitionURL", SVG_ATTRS_ADJUSTMENT_MAP = new Map(["attributeName", "attributeType", "baseFrequency", "baseProfile", "calcMode", "clipPathUnits", "diffuseConstant", "edgeMode", "filterUnits", "glyphRef", "gradientTransform", "gradientUnits", "kernelMatrix", "kernelUnitLength", "keyPoints", "keySplines", "keyTimes", "lengthAdjust", "limitingConeAngle", "markerHeight", "markerUnits", "markerWidth", "maskContentUnits", "maskUnits", "numOctaves", "pathLength", "patternContentUnits", "patternTransform", "patternUnits", "pointsAtX", "pointsAtY", "pointsAtZ", "preserveAlpha", "preserveAspectRatio", "primitiveUnits", "refX", "refY", "repeatCount", "repeatDur", "requiredExtensions", "requiredFeatures", "specularConstant", "specularExponent", "spreadMethod", "startOffset", "stdDeviation", "stitchTiles", "surfaceScale", "systemLanguage", "tableValues", "targetX", "targetY", "textLength", "viewBox", "viewTarget", "xChannelSelector", "yChannelSelector", "zoomAndPan"].map((e) => [e.toLowerCase(), e])), XML_ATTRS_ADJUSTMENT_MAP = /* @__PURE__ */ new Map([["xlink:actuate", {
  prefix: "xlink",
  name: "actuate",
  namespace: NS.XLINK
}], ["xlink:arcrole", {
  prefix: "xlink",
  name: "arcrole",
  namespace: NS.XLINK
}], ["xlink:href", {
  prefix: "xlink",
  name: "href",
  namespace: NS.XLINK
}], ["xlink:role", {
  prefix: "xlink",
  name: "role",
  namespace: NS.XLINK
}], ["xlink:show", {
  prefix: "xlink",
  name: "show",
  namespace: NS.XLINK
}], ["xlink:title", {
  prefix: "xlink",
  name: "title",
  namespace: NS.XLINK
}], ["xlink:type", {
  prefix: "xlink",
  name: "type",
  namespace: NS.XLINK
}], ["xml:base", {
  prefix: "xml",
  name: "base",
  namespace: NS.XML
}], ["xml:lang", {
  prefix: "xml",
  name: "lang",
  namespace: NS.XML
}], ["xml:space", {
  prefix: "xml",
  name: "space",
  namespace: NS.XML
}], ["xmlns", {
  prefix: "",
  name: "xmlns",
  namespace: NS.XMLNS
}], ["xmlns:xlink", {
  prefix: "xmlns",
  name: "xlink",
  namespace: NS.XMLNS
}]]), SVG_TAG_NAMES_ADJUSTMENT_MAP = new Map(["altGlyph", "altGlyphDef", "altGlyphItem", "animateColor", "animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "glyphRef", "linearGradient", "radialGradient", "textPath"].map((e) => [e.toLowerCase(), e])), EXITS_FOREIGN_CONTENT = /* @__PURE__ */ new Set([TAG_ID.B, TAG_ID.BIG, TAG_ID.BLOCKQUOTE, TAG_ID.BODY, TAG_ID.BR, TAG_ID.CENTER, TAG_ID.CODE, TAG_ID.DD, TAG_ID.DIV, TAG_ID.DL, TAG_ID.DT, TAG_ID.EM, TAG_ID.EMBED, TAG_ID.H1, TAG_ID.H2, TAG_ID.H3, TAG_ID.H4, TAG_ID.H5, TAG_ID.H6, TAG_ID.HEAD, TAG_ID.HR, TAG_ID.I, TAG_ID.IMG, TAG_ID.LI, TAG_ID.LISTING, TAG_ID.MENU, TAG_ID.META, TAG_ID.NOBR, TAG_ID.OL, TAG_ID.P, TAG_ID.PRE, TAG_ID.RUBY, TAG_ID.S, TAG_ID.SMALL, TAG_ID.SPAN, TAG_ID.STRONG, TAG_ID.STRIKE, TAG_ID.SUB, TAG_ID.SUP, TAG_ID.TABLE, TAG_ID.TT, TAG_ID.U, TAG_ID.UL, TAG_ID.VAR]);
function causesExit(e) {
  const t = e.tagID;
  return t === TAG_ID.FONT && e.attrs.some(({
    name: a
  }) => a === ATTRS.COLOR || a === ATTRS.SIZE || a === ATTRS.FACE) || EXITS_FOREIGN_CONTENT.has(t);
}
function adjustTokenMathMLAttrs(e) {
  for (let t = 0; t < e.attrs.length; t++)
    if (e.attrs[t].name === DEFINITION_URL_ATTR) {
      e.attrs[t].name = ADJUSTED_DEFINITION_URL_ATTR;
      break;
    }
}
function adjustTokenSVGAttrs(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const r = SVG_ATTRS_ADJUSTMENT_MAP.get(e.attrs[t].name);
    r != null && (e.attrs[t].name = r);
  }
}
function adjustTokenXMLAttrs(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const r = XML_ATTRS_ADJUSTMENT_MAP.get(e.attrs[t].name);
    r && (e.attrs[t].prefix = r.prefix, e.attrs[t].name = r.name, e.attrs[t].namespace = r.namespace);
  }
}
function adjustTokenSVGTagName(e) {
  const t = SVG_TAG_NAMES_ADJUSTMENT_MAP.get(e.tagName);
  t != null && (e.tagName = t, e.tagID = getTagID(e.tagName));
}
function isMathMLTextIntegrationPoint(e, t) {
  return t === NS.MATHML && (e === TAG_ID.MI || e === TAG_ID.MO || e === TAG_ID.MN || e === TAG_ID.MS || e === TAG_ID.MTEXT);
}
function isHtmlIntegrationPoint(e, t, r) {
  if (t === NS.MATHML && e === TAG_ID.ANNOTATION_XML) {
    for (let a = 0; a < r.length; a++)
      if (r[a].name === ATTRS.ENCODING) {
        const o = r[a].value.toLowerCase();
        return o === MIME_TYPES.TEXT_HTML || o === MIME_TYPES.APPLICATION_XML;
      }
  }
  return t === NS.SVG && (e === TAG_ID.FOREIGN_OBJECT || e === TAG_ID.DESC || e === TAG_ID.TITLE);
}
function isIntegrationPoint(e, t, r, a) {
  return (!a || a === NS.HTML) && isHtmlIntegrationPoint(e, t, r) || (!a || a === NS.MATHML) && isMathMLTextIntegrationPoint(e, t);
}
const HIDDEN_INPUT_TYPE = "hidden", AA_OUTER_LOOP_ITER = 8, AA_INNER_LOOP_ITER = 3;
var InsertionMode;
(function(e) {
  e[e.INITIAL = 0] = "INITIAL", e[e.BEFORE_HTML = 1] = "BEFORE_HTML", e[e.BEFORE_HEAD = 2] = "BEFORE_HEAD", e[e.IN_HEAD = 3] = "IN_HEAD", e[e.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", e[e.AFTER_HEAD = 5] = "AFTER_HEAD", e[e.IN_BODY = 6] = "IN_BODY", e[e.TEXT = 7] = "TEXT", e[e.IN_TABLE = 8] = "IN_TABLE", e[e.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", e[e.IN_CAPTION = 10] = "IN_CAPTION", e[e.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", e[e.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", e[e.IN_ROW = 13] = "IN_ROW", e[e.IN_CELL = 14] = "IN_CELL", e[e.IN_SELECT = 15] = "IN_SELECT", e[e.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", e[e.IN_TEMPLATE = 17] = "IN_TEMPLATE", e[e.AFTER_BODY = 18] = "AFTER_BODY", e[e.IN_FRAMESET = 19] = "IN_FRAMESET", e[e.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", e[e.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", e[e.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET";
})(InsertionMode || (InsertionMode = {}));
const BASE_LOC = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
}, TABLE_STRUCTURE_TAGS = /* @__PURE__ */ new Set([TAG_ID.TABLE, TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TR]), defaultParserOptions = {
  scriptingEnabled: !0,
  sourceCodeLocationInfo: !1,
  treeAdapter: defaultTreeAdapter,
  onParseError: null
};
let Parser$1 = class {
  constructor(t, r, a = null, o = null) {
    this.fragmentContext = a, this.scriptHandler = o, this.currentToken = null, this.stopped = !1, this.insertionMode = InsertionMode.INITIAL, this.originalInsertionMode = InsertionMode.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = !1, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1, this.options = {
      ...defaultParserOptions,
      ...t
    }, this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = !0), this.document = r ?? this.treeAdapter.createDocument(), this.tokenizer = new Tokenizer(this.options, this), this.activeFormattingElements = new FormattingElementList(this.treeAdapter), this.fragmentContextID = a ? getTagID(this.treeAdapter.getTagName(a)) : TAG_ID.UNKNOWN, this._setContextModes(a ?? this.document, this.fragmentContextID), this.openElements = new OpenElementStack(this.document, this.treeAdapter, this);
  }
  // API
  static parse(t, r) {
    const a = new this(r);
    return a.tokenizer.write(t, !0), a.document;
  }
  static getFragmentParser(t, r) {
    const a = {
      ...defaultParserOptions,
      ...r
    };
    t ?? (t = a.treeAdapter.createElement(TAG_NAMES.TEMPLATE, NS.HTML, []));
    const o = a.treeAdapter.createElement("documentmock", NS.HTML, []), u = new this(a, o, t);
    return u.fragmentContextID === TAG_ID.TEMPLATE && u.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE), u._initTokenizerForFragmentParsing(), u._insertFakeRootElement(), u._resetInsertionMode(), u._findFormInFragmentContext(), u;
  }
  getFragment() {
    const t = this.treeAdapter.getFirstChild(this.document), r = this.treeAdapter.createDocumentFragment();
    return this._adoptNodes(t, r), r;
  }
  //Errors
  _err(t, r, a) {
    var o;
    if (!this.onParseError) return;
    const u = (o = t.location) !== null && o !== void 0 ? o : BASE_LOC, c = {
      code: r,
      startLine: u.startLine,
      startCol: u.startCol,
      startOffset: u.startOffset,
      endLine: a ? u.startLine : u.endLine,
      endCol: a ? u.startCol : u.endCol,
      endOffset: a ? u.startOffset : u.endOffset
    };
    this.onParseError(c);
  }
  //Stack events
  onItemPush(t, r, a) {
    var o, u;
    (u = (o = this.treeAdapter).onItemPush) === null || u === void 0 || u.call(o, t), a && this.openElements.stackTop > 0 && this._setContextModes(t, r);
  }
  onItemPop(t, r) {
    var a, o;
    if (this.options.sourceCodeLocationInfo && this._setEndLocation(t, this.currentToken), (o = (a = this.treeAdapter).onItemPop) === null || o === void 0 || o.call(a, t, this.openElements.current), r) {
      let u, c;
      this.openElements.stackTop === 0 && this.fragmentContext ? (u = this.fragmentContext, c = this.fragmentContextID) : {
        current: u,
        currentTagId: c
      } = this.openElements, this._setContextModes(u, c);
    }
  }
  _setContextModes(t, r) {
    const a = t === this.document || this.treeAdapter.getNamespaceURI(t) === NS.HTML;
    this.currentNotInHTML = !a, this.tokenizer.inForeignNode = !a && !this._isIntegrationPoint(r, t);
  }
  _switchToTextParsing(t, r) {
    this._insertElement(t, NS.HTML), this.tokenizer.state = r, this.originalInsertionMode = this.insertionMode, this.insertionMode = InsertionMode.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = InsertionMode.TEXT, this.originalInsertionMode = InsertionMode.IN_BODY, this.tokenizer.state = TokenizerMode.PLAINTEXT;
  }
  //Fragment parsing
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  _findFormInFragmentContext() {
    let t = this.fragmentContext;
    for (; t; ) {
      if (this.treeAdapter.getTagName(t) === TAG_NAMES.FORM) {
        this.formElement = t;
        break;
      }
      t = this.treeAdapter.getParentNode(t);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!(!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== NS.HTML))
      switch (this.fragmentContextID) {
        case TAG_ID.TITLE:
        case TAG_ID.TEXTAREA: {
          this.tokenizer.state = TokenizerMode.RCDATA;
          break;
        }
        case TAG_ID.STYLE:
        case TAG_ID.XMP:
        case TAG_ID.IFRAME:
        case TAG_ID.NOEMBED:
        case TAG_ID.NOFRAMES:
        case TAG_ID.NOSCRIPT: {
          this.tokenizer.state = TokenizerMode.RAWTEXT;
          break;
        }
        case TAG_ID.SCRIPT: {
          this.tokenizer.state = TokenizerMode.SCRIPT_DATA;
          break;
        }
        case TAG_ID.PLAINTEXT: {
          this.tokenizer.state = TokenizerMode.PLAINTEXT;
          break;
        }
      }
  }
  //Tree mutation
  _setDocumentType(t) {
    const r = t.name || "", a = t.publicId || "", o = t.systemId || "";
    if (this.treeAdapter.setDocumentType(this.document, r, a, o), t.location) {
      const c = this.treeAdapter.getChildNodes(this.document).find((d) => this.treeAdapter.isDocumentTypeNode(d));
      c && this.treeAdapter.setNodeSourceCodeLocation(c, t.location);
    }
  }
  _attachElementToTree(t, r) {
    if (this.options.sourceCodeLocationInfo) {
      const a = r && {
        ...r,
        startTag: r
      };
      this.treeAdapter.setNodeSourceCodeLocation(t, a);
    }
    if (this._shouldFosterParentOnInsertion())
      this._fosterParentElement(t);
    else {
      const a = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(a, t);
    }
  }
  _appendElement(t, r) {
    const a = this.treeAdapter.createElement(t.tagName, r, t.attrs);
    this._attachElementToTree(a, t.location);
  }
  _insertElement(t, r) {
    const a = this.treeAdapter.createElement(t.tagName, r, t.attrs);
    this._attachElementToTree(a, t.location), this.openElements.push(a, t.tagID);
  }
  _insertFakeElement(t, r) {
    const a = this.treeAdapter.createElement(t, NS.HTML, []);
    this._attachElementToTree(a, null), this.openElements.push(a, r);
  }
  _insertTemplate(t) {
    const r = this.treeAdapter.createElement(t.tagName, NS.HTML, t.attrs), a = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(r, a), this._attachElementToTree(r, t.location), this.openElements.push(r, t.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(a, null);
  }
  _insertFakeRootElement() {
    const t = this.treeAdapter.createElement(TAG_NAMES.HTML, NS.HTML, []);
    this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(t, null), this.treeAdapter.appendChild(this.openElements.current, t), this.openElements.push(t, TAG_ID.HTML);
  }
  _appendCommentNode(t, r) {
    const a = this.treeAdapter.createCommentNode(t.data);
    this.treeAdapter.appendChild(r, a), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(a, t.location);
  }
  _insertCharacters(t) {
    let r, a;
    if (this._shouldFosterParentOnInsertion() ? ({
      parent: r,
      beforeElement: a
    } = this._findFosterParentingLocation(), a ? this.treeAdapter.insertTextBefore(r, t.chars, a) : this.treeAdapter.insertText(r, t.chars)) : (r = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(r, t.chars)), !t.location) return;
    const o = this.treeAdapter.getChildNodes(r), u = a ? o.lastIndexOf(a) : o.length, c = o[u - 1];
    if (this.treeAdapter.getNodeSourceCodeLocation(c)) {
      const {
        endLine: g,
        endCol: b,
        endOffset: _
      } = t.location;
      this.treeAdapter.updateNodeSourceCodeLocation(c, {
        endLine: g,
        endCol: b,
        endOffset: _
      });
    } else this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(c, t.location);
  }
  _adoptNodes(t, r) {
    for (let a = this.treeAdapter.getFirstChild(t); a; a = this.treeAdapter.getFirstChild(t))
      this.treeAdapter.detachNode(a), this.treeAdapter.appendChild(r, a);
  }
  _setEndLocation(t, r) {
    if (this.treeAdapter.getNodeSourceCodeLocation(t) && r.location) {
      const a = r.location, o = this.treeAdapter.getTagName(t), u = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        r.type === TokenType.END_TAG && o === r.tagName ? {
          endTag: {
            ...a
          },
          endLine: a.endLine,
          endCol: a.endCol,
          endOffset: a.endOffset
        } : {
          endLine: a.startLine,
          endCol: a.startCol,
          endOffset: a.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(t, u);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(t) {
    if (!this.currentNotInHTML) return !1;
    let r, a;
    return this.openElements.stackTop === 0 && this.fragmentContext ? (r = this.fragmentContext, a = this.fragmentContextID) : {
      current: r,
      currentTagId: a
    } = this.openElements, t.tagID === TAG_ID.SVG && this.treeAdapter.getTagName(r) === TAG_NAMES.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(r) === NS.MATHML ? !1 : (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (t.tagID === TAG_ID.MGLYPH || t.tagID === TAG_ID.MALIGNMARK) && !this._isIntegrationPoint(a, r, NS.HTML)
    );
  }
  _processToken(t) {
    switch (t.type) {
      case TokenType.CHARACTER: {
        this.onCharacter(t);
        break;
      }
      case TokenType.NULL_CHARACTER: {
        this.onNullCharacter(t);
        break;
      }
      case TokenType.COMMENT: {
        this.onComment(t);
        break;
      }
      case TokenType.DOCTYPE: {
        this.onDoctype(t);
        break;
      }
      case TokenType.START_TAG: {
        this._processStartTag(t);
        break;
      }
      case TokenType.END_TAG: {
        this.onEndTag(t);
        break;
      }
      case TokenType.EOF: {
        this.onEof(t);
        break;
      }
      case TokenType.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(t);
        break;
      }
    }
  }
  //Integration points
  _isIntegrationPoint(t, r, a) {
    const o = this.treeAdapter.getNamespaceURI(r), u = this.treeAdapter.getAttrList(r);
    return isIntegrationPoint(t, o, u, a);
  }
  //Active formatting elements reconstruction
  _reconstructActiveFormattingElements() {
    const t = this.activeFormattingElements.entries.length;
    if (t) {
      const r = this.activeFormattingElements.entries.findIndex((o) => o.type === EntryType.Marker || this.openElements.contains(o.element)), a = r < 0 ? t - 1 : r - 1;
      for (let o = a; o >= 0; o--) {
        const u = this.activeFormattingElements.entries[o];
        this._insertElement(u.token, this.treeAdapter.getNamespaceURI(u.element)), u.element = this.openElements.current;
      }
    }
  }
  //Close elements
  _closeTableCell() {
    this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = InsertionMode.IN_ROW;
  }
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.P), this.openElements.popUntilTagNamePopped(TAG_ID.P);
  }
  //Insertion modes
  _resetInsertionMode() {
    for (let t = this.openElements.stackTop; t >= 0; t--)
      switch (t === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[t]) {
        case TAG_ID.TR: {
          this.insertionMode = InsertionMode.IN_ROW;
          return;
        }
        case TAG_ID.TBODY:
        case TAG_ID.THEAD:
        case TAG_ID.TFOOT: {
          this.insertionMode = InsertionMode.IN_TABLE_BODY;
          return;
        }
        case TAG_ID.CAPTION: {
          this.insertionMode = InsertionMode.IN_CAPTION;
          return;
        }
        case TAG_ID.COLGROUP: {
          this.insertionMode = InsertionMode.IN_COLUMN_GROUP;
          return;
        }
        case TAG_ID.TABLE: {
          this.insertionMode = InsertionMode.IN_TABLE;
          return;
        }
        case TAG_ID.BODY: {
          this.insertionMode = InsertionMode.IN_BODY;
          return;
        }
        case TAG_ID.FRAMESET: {
          this.insertionMode = InsertionMode.IN_FRAMESET;
          return;
        }
        case TAG_ID.SELECT: {
          this._resetInsertionModeForSelect(t);
          return;
        }
        case TAG_ID.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case TAG_ID.HTML: {
          this.insertionMode = this.headElement ? InsertionMode.AFTER_HEAD : InsertionMode.BEFORE_HEAD;
          return;
        }
        case TAG_ID.TD:
        case TAG_ID.TH: {
          if (t > 0) {
            this.insertionMode = InsertionMode.IN_CELL;
            return;
          }
          break;
        }
        case TAG_ID.HEAD: {
          if (t > 0) {
            this.insertionMode = InsertionMode.IN_HEAD;
            return;
          }
          break;
        }
      }
    this.insertionMode = InsertionMode.IN_BODY;
  }
  _resetInsertionModeForSelect(t) {
    if (t > 0)
      for (let r = t - 1; r > 0; r--) {
        const a = this.openElements.tagIDs[r];
        if (a === TAG_ID.TEMPLATE)
          break;
        if (a === TAG_ID.TABLE) {
          this.insertionMode = InsertionMode.IN_SELECT_IN_TABLE;
          return;
        }
      }
    this.insertionMode = InsertionMode.IN_SELECT;
  }
  //Foster parenting
  _isElementCausesFosterParenting(t) {
    return TABLE_STRUCTURE_TAGS.has(t);
  }
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  _findFosterParentingLocation() {
    for (let t = this.openElements.stackTop; t >= 0; t--) {
      const r = this.openElements.items[t];
      switch (this.openElements.tagIDs[t]) {
        case TAG_ID.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(r) === NS.HTML)
            return {
              parent: this.treeAdapter.getTemplateContent(r),
              beforeElement: null
            };
          break;
        }
        case TAG_ID.TABLE: {
          const a = this.treeAdapter.getParentNode(r);
          return a ? {
            parent: a,
            beforeElement: r
          } : {
            parent: this.openElements.items[t - 1],
            beforeElement: null
          };
        }
      }
    }
    return {
      parent: this.openElements.items[0],
      beforeElement: null
    };
  }
  _fosterParentElement(t) {
    const r = this._findFosterParentingLocation();
    r.beforeElement ? this.treeAdapter.insertBefore(r.parent, t, r.beforeElement) : this.treeAdapter.appendChild(r.parent, t);
  }
  //Special elements
  _isSpecialElement(t, r) {
    const a = this.treeAdapter.getNamespaceURI(t);
    return SPECIAL_ELEMENTS[a].has(r);
  }
  onCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      characterInForeignContent(this, t);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, t);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, t);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, t);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, t);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, t);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, t);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE: {
        characterInBody(this, t);
        break;
      }
      case InsertionMode.TEXT:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE: {
        this._insertCharacters(t);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, t);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        characterInTableText(this, t);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        tokenInColumnGroup(this, t);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        tokenAfterBody(this, t);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, t);
        break;
      }
    }
  }
  onNullCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      nullCharacterInForeignContent(this, t);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, t);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, t);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, t);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, t);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, t);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, t);
        break;
      }
      case InsertionMode.TEXT: {
        this._insertCharacters(t);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, t);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        tokenInColumnGroup(this, t);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        tokenAfterBody(this, t);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, t);
        break;
      }
    }
  }
  onComment(t) {
    if (this.skipNextNewLine = !1, this.currentNotInHTML) {
      appendComment(this, t);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL:
      case InsertionMode.BEFORE_HTML:
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET: {
        appendComment(this, t);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, t);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        appendCommentToRootHtmlElement(this, t);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        appendCommentToDocument(this, t);
        break;
      }
    }
  }
  onDoctype(t) {
    switch (this.skipNextNewLine = !1, this.insertionMode) {
      case InsertionMode.INITIAL: {
        doctypeInInitialMode(this, t);
        break;
      }
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD: {
        this._err(t, ERR.misplacedDoctype);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, t);
        break;
      }
    }
  }
  onStartTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this._processStartTag(t), t.selfClosing && !t.ackSelfClosing && this._err(t, ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   */
  _processStartTag(t) {
    this.shouldProcessStartTagTokenInForeignContent(t) ? startTagInForeignContent(this, t) : this._startTagOutsideForeignContent(t);
  }
  _startTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, t);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        startTagBeforeHtml(this, t);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        startTagBeforeHead(this, t);
        break;
      }
      case InsertionMode.IN_HEAD: {
        startTagInHead(this, t);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        startTagInHeadNoScript(this, t);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        startTagAfterHead(this, t);
        break;
      }
      case InsertionMode.IN_BODY: {
        startTagInBody(this, t);
        break;
      }
      case InsertionMode.IN_TABLE: {
        startTagInTable(this, t);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, t);
        break;
      }
      case InsertionMode.IN_CAPTION: {
        startTagInCaption(this, t);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        startTagInColumnGroup(this, t);
        break;
      }
      case InsertionMode.IN_TABLE_BODY: {
        startTagInTableBody(this, t);
        break;
      }
      case InsertionMode.IN_ROW: {
        startTagInRow(this, t);
        break;
      }
      case InsertionMode.IN_CELL: {
        startTagInCell(this, t);
        break;
      }
      case InsertionMode.IN_SELECT: {
        startTagInSelect(this, t);
        break;
      }
      case InsertionMode.IN_SELECT_IN_TABLE: {
        startTagInSelectInTable(this, t);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        startTagInTemplate(this, t);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        startTagAfterBody(this, t);
        break;
      }
      case InsertionMode.IN_FRAMESET: {
        startTagInFrameset(this, t);
        break;
      }
      case InsertionMode.AFTER_FRAMESET: {
        startTagAfterFrameset(this, t);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        startTagAfterAfterBody(this, t);
        break;
      }
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        startTagAfterAfterFrameset(this, t);
        break;
      }
    }
  }
  onEndTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this.currentNotInHTML ? endTagInForeignContent(this, t) : this._endTagOutsideForeignContent(t);
  }
  _endTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, t);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        endTagBeforeHtml(this, t);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        endTagBeforeHead(this, t);
        break;
      }
      case InsertionMode.IN_HEAD: {
        endTagInHead(this, t);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        endTagInHeadNoScript(this, t);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        endTagAfterHead(this, t);
        break;
      }
      case InsertionMode.IN_BODY: {
        endTagInBody(this, t);
        break;
      }
      case InsertionMode.TEXT: {
        endTagInText(this, t);
        break;
      }
      case InsertionMode.IN_TABLE: {
        endTagInTable(this, t);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, t);
        break;
      }
      case InsertionMode.IN_CAPTION: {
        endTagInCaption(this, t);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        endTagInColumnGroup(this, t);
        break;
      }
      case InsertionMode.IN_TABLE_BODY: {
        endTagInTableBody(this, t);
        break;
      }
      case InsertionMode.IN_ROW: {
        endTagInRow(this, t);
        break;
      }
      case InsertionMode.IN_CELL: {
        endTagInCell(this, t);
        break;
      }
      case InsertionMode.IN_SELECT: {
        endTagInSelect(this, t);
        break;
      }
      case InsertionMode.IN_SELECT_IN_TABLE: {
        endTagInSelectInTable(this, t);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        endTagInTemplate(this, t);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        endTagAfterBody(this, t);
        break;
      }
      case InsertionMode.IN_FRAMESET: {
        endTagInFrameset(this, t);
        break;
      }
      case InsertionMode.AFTER_FRAMESET: {
        endTagAfterFrameset(this, t);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, t);
        break;
      }
    }
  }
  onEof(t) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, t);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, t);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, t);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, t);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, t);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, t);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE: {
        eofInBody(this, t);
        break;
      }
      case InsertionMode.TEXT: {
        eofInText(this, t);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, t);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        eofInTemplate(this, t);
        break;
      }
      case InsertionMode.AFTER_BODY:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        stopParsing(this, t);
        break;
      }
    }
  }
  onWhitespaceCharacter(t) {
    if (this.skipNextNewLine && (this.skipNextNewLine = !1, t.chars.charCodeAt(0) === CODE_POINTS.LINE_FEED)) {
      if (t.chars.length === 1)
        return;
      t.chars = t.chars.substr(1);
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(t);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.TEXT:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET: {
        this._insertCharacters(t);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.AFTER_BODY:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        whitespaceCharacterInBody(this, t);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, t);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        whitespaceCharacterInTableText(this, t);
        break;
      }
    }
  }
};
function aaObtainFormattingElementEntry(e, t) {
  let r = e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName);
  return r ? e.openElements.contains(r.element) ? e.openElements.hasInScope(t.tagID) || (r = null) : (e.activeFormattingElements.removeEntry(r), r = null) : genericEndTagInBody(e, t), r;
}
function aaObtainFurthestBlock(e, t) {
  let r = null, a = e.openElements.stackTop;
  for (; a >= 0; a--) {
    const o = e.openElements.items[a];
    if (o === t.element)
      break;
    e._isSpecialElement(o, e.openElements.tagIDs[a]) && (r = o);
  }
  return r || (e.openElements.shortenToLength(a < 0 ? 0 : a), e.activeFormattingElements.removeEntry(t)), r;
}
function aaInnerLoop(e, t, r) {
  let a = t, o = e.openElements.getCommonAncestor(t);
  for (let u = 0, c = o; c !== r; u++, c = o) {
    o = e.openElements.getCommonAncestor(c);
    const d = e.activeFormattingElements.getElementEntry(c), g = d && u >= AA_INNER_LOOP_ITER;
    !d || g ? (g && e.activeFormattingElements.removeEntry(d), e.openElements.remove(c)) : (c = aaRecreateElementFromEntry(e, d), a === t && (e.activeFormattingElements.bookmark = d), e.treeAdapter.detachNode(a), e.treeAdapter.appendChild(c, a), a = c);
  }
  return a;
}
function aaRecreateElementFromEntry(e, t) {
  const r = e.treeAdapter.getNamespaceURI(t.element), a = e.treeAdapter.createElement(t.token.tagName, r, t.token.attrs);
  return e.openElements.replace(t.element, a), t.element = a, a;
}
function aaInsertLastNodeInCommonAncestor(e, t, r) {
  const a = e.treeAdapter.getTagName(t), o = getTagID(a);
  if (e._isElementCausesFosterParenting(o))
    e._fosterParentElement(r);
  else {
    const u = e.treeAdapter.getNamespaceURI(t);
    o === TAG_ID.TEMPLATE && u === NS.HTML && (t = e.treeAdapter.getTemplateContent(t)), e.treeAdapter.appendChild(t, r);
  }
}
function aaReplaceFormattingElement(e, t, r) {
  const a = e.treeAdapter.getNamespaceURI(r.element), {
    token: o
  } = r, u = e.treeAdapter.createElement(o.tagName, a, o.attrs);
  e._adoptNodes(t, u), e.treeAdapter.appendChild(t, u), e.activeFormattingElements.insertElementAfterBookmark(u, o), e.activeFormattingElements.removeEntry(r), e.openElements.remove(r.element), e.openElements.insertAfter(t, u, o.tagID);
}
function callAdoptionAgency(e, t) {
  for (let r = 0; r < AA_OUTER_LOOP_ITER; r++) {
    const a = aaObtainFormattingElementEntry(e, t);
    if (!a)
      break;
    const o = aaObtainFurthestBlock(e, a);
    if (!o)
      break;
    e.activeFormattingElements.bookmark = a;
    const u = aaInnerLoop(e, o, a.element), c = e.openElements.getCommonAncestor(a.element);
    e.treeAdapter.detachNode(u), c && aaInsertLastNodeInCommonAncestor(e, c, u), aaReplaceFormattingElement(e, o, a);
  }
}
function appendComment(e, t) {
  e._appendCommentNode(t, e.openElements.currentTmplContentOrNode);
}
function appendCommentToRootHtmlElement(e, t) {
  e._appendCommentNode(t, e.openElements.items[0]);
}
function appendCommentToDocument(e, t) {
  e._appendCommentNode(t, e.document);
}
function stopParsing(e, t) {
  if (e.stopped = !0, t.location) {
    const r = e.fragmentContext ? 0 : 2;
    for (let a = e.openElements.stackTop; a >= r; a--)
      e._setEndLocation(e.openElements.items[a], t);
    if (!e.fragmentContext && e.openElements.stackTop >= 0) {
      const a = e.openElements.items[0], o = e.treeAdapter.getNodeSourceCodeLocation(a);
      if (o && !o.endTag && (e._setEndLocation(a, t), e.openElements.stackTop >= 1)) {
        const u = e.openElements.items[1], c = e.treeAdapter.getNodeSourceCodeLocation(u);
        c && !c.endTag && e._setEndLocation(u, t);
      }
    }
  }
}
function doctypeInInitialMode(e, t) {
  e._setDocumentType(t);
  const r = t.forceQuirks ? DOCUMENT_MODE.QUIRKS : getDocumentMode(t);
  isConforming(t) || e._err(t, ERR.nonConformingDoctype), e.treeAdapter.setDocumentMode(e.document, r), e.insertionMode = InsertionMode.BEFORE_HTML;
}
function tokenInInitialMode(e, t) {
  e._err(t, ERR.missingDoctype, !0), e.treeAdapter.setDocumentMode(e.document, DOCUMENT_MODE.QUIRKS), e.insertionMode = InsertionMode.BEFORE_HTML, e._processToken(t);
}
function startTagBeforeHtml(e, t) {
  t.tagID === TAG_ID.HTML ? (e._insertElement(t, NS.HTML), e.insertionMode = InsertionMode.BEFORE_HEAD) : tokenBeforeHtml(e, t);
}
function endTagBeforeHtml(e, t) {
  const r = t.tagID;
  (r === TAG_ID.HTML || r === TAG_ID.HEAD || r === TAG_ID.BODY || r === TAG_ID.BR) && tokenBeforeHtml(e, t);
}
function tokenBeforeHtml(e, t) {
  e._insertFakeRootElement(), e.insertionMode = InsertionMode.BEFORE_HEAD, e._processToken(t);
}
function startTagBeforeHead(e, t) {
  switch (t.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(e, t);
      break;
    }
    case TAG_ID.HEAD: {
      e._insertElement(t, NS.HTML), e.headElement = e.openElements.current, e.insertionMode = InsertionMode.IN_HEAD;
      break;
    }
    default:
      tokenBeforeHead(e, t);
  }
}
function endTagBeforeHead(e, t) {
  const r = t.tagID;
  r === TAG_ID.HEAD || r === TAG_ID.BODY || r === TAG_ID.HTML || r === TAG_ID.BR ? tokenBeforeHead(e, t) : e._err(t, ERR.endTagWithoutMatchingOpenElement);
}
function tokenBeforeHead(e, t) {
  e._insertFakeElement(TAG_NAMES.HEAD, TAG_ID.HEAD), e.headElement = e.openElements.current, e.insertionMode = InsertionMode.IN_HEAD, e._processToken(t);
}
function startTagInHead(e, t) {
  switch (t.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(e, t);
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META: {
      e._appendElement(t, NS.HTML), t.ackSelfClosing = !0;
      break;
    }
    case TAG_ID.TITLE: {
      e._switchToTextParsing(t, TokenizerMode.RCDATA);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      e.options.scriptingEnabled ? e._switchToTextParsing(t, TokenizerMode.RAWTEXT) : (e._insertElement(t, NS.HTML), e.insertionMode = InsertionMode.IN_HEAD_NO_SCRIPT);
      break;
    }
    case TAG_ID.NOFRAMES:
    case TAG_ID.STYLE: {
      e._switchToTextParsing(t, TokenizerMode.RAWTEXT);
      break;
    }
    case TAG_ID.SCRIPT: {
      e._switchToTextParsing(t, TokenizerMode.SCRIPT_DATA);
      break;
    }
    case TAG_ID.TEMPLATE: {
      e._insertTemplate(t), e.activeFormattingElements.insertMarker(), e.framesetOk = !1, e.insertionMode = InsertionMode.IN_TEMPLATE, e.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
      break;
    }
    case TAG_ID.HEAD: {
      e._err(t, ERR.misplacedStartTagForHeadElement);
      break;
    }
    default:
      tokenInHead(e, t);
  }
}
function endTagInHead(e, t) {
  switch (t.tagID) {
    case TAG_ID.HEAD: {
      e.openElements.pop(), e.insertionMode = InsertionMode.AFTER_HEAD;
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.BR:
    case TAG_ID.HTML: {
      tokenInHead(e, t);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(e, t);
      break;
    }
    default:
      e._err(t, ERR.endTagWithoutMatchingOpenElement);
  }
}
function templateEndTagInHead(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.generateImpliedEndTagsThoroughly(), e.openElements.currentTagId !== TAG_ID.TEMPLATE && e._err(t, ERR.closingOfElementWithOpenChildElements), e.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode()) : e._err(t, ERR.endTagWithoutMatchingOpenElement);
}
function tokenInHead(e, t) {
  e.openElements.pop(), e.insertionMode = InsertionMode.AFTER_HEAD, e._processToken(t);
}
function startTagInHeadNoScript(e, t) {
  switch (t.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(e, t);
      break;
    }
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.HEAD:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.STYLE: {
      startTagInHead(e, t);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      e._err(t, ERR.nestedNoscriptInHead);
      break;
    }
    default:
      tokenInHeadNoScript(e, t);
  }
}
function endTagInHeadNoScript(e, t) {
  switch (t.tagID) {
    case TAG_ID.NOSCRIPT: {
      e.openElements.pop(), e.insertionMode = InsertionMode.IN_HEAD;
      break;
    }
    case TAG_ID.BR: {
      tokenInHeadNoScript(e, t);
      break;
    }
    default:
      e._err(t, ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenInHeadNoScript(e, t) {
  const r = t.type === TokenType.EOF ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;
  e._err(t, r), e.openElements.pop(), e.insertionMode = InsertionMode.IN_HEAD, e._processToken(t);
}
function startTagAfterHead(e, t) {
  switch (t.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(e, t);
      break;
    }
    case TAG_ID.BODY: {
      e._insertElement(t, NS.HTML), e.framesetOk = !1, e.insertionMode = InsertionMode.IN_BODY;
      break;
    }
    case TAG_ID.FRAMESET: {
      e._insertElement(t, NS.HTML), e.insertionMode = InsertionMode.IN_FRAMESET;
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.SCRIPT:
    case TAG_ID.STYLE:
    case TAG_ID.TEMPLATE:
    case TAG_ID.TITLE: {
      e._err(t, ERR.abandonedHeadElementChild), e.openElements.push(e.headElement, TAG_ID.HEAD), startTagInHead(e, t), e.openElements.remove(e.headElement);
      break;
    }
    case TAG_ID.HEAD: {
      e._err(t, ERR.misplacedStartTagForHeadElement);
      break;
    }
    default:
      tokenAfterHead(e, t);
  }
}
function endTagAfterHead(e, t) {
  switch (t.tagID) {
    case TAG_ID.BODY:
    case TAG_ID.HTML:
    case TAG_ID.BR: {
      tokenAfterHead(e, t);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(e, t);
      break;
    }
    default:
      e._err(t, ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenAfterHead(e, t) {
  e._insertFakeElement(TAG_NAMES.BODY, TAG_ID.BODY), e.insertionMode = InsertionMode.IN_BODY, modeInBody(e, t);
}
function modeInBody(e, t) {
  switch (t.type) {
    case TokenType.CHARACTER: {
      characterInBody(e, t);
      break;
    }
    case TokenType.WHITESPACE_CHARACTER: {
      whitespaceCharacterInBody(e, t);
      break;
    }
    case TokenType.COMMENT: {
      appendComment(e, t);
      break;
    }
    case TokenType.START_TAG: {
      startTagInBody(e, t);
      break;
    }
    case TokenType.END_TAG: {
      endTagInBody(e, t);
      break;
    }
    case TokenType.EOF: {
      eofInBody(e, t);
      break;
    }
  }
}
function whitespaceCharacterInBody(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t);
}
function characterInBody(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t), e.framesetOk = !1;
}
function htmlStartTagInBody(e, t) {
  e.openElements.tmplCount === 0 && e.treeAdapter.adoptAttributes(e.openElements.items[0], t.attrs);
}
function bodyStartTagInBody(e, t) {
  const r = e.openElements.tryPeekProperlyNestedBodyElement();
  r && e.openElements.tmplCount === 0 && (e.framesetOk = !1, e.treeAdapter.adoptAttributes(r, t.attrs));
}
function framesetStartTagInBody(e, t) {
  const r = e.openElements.tryPeekProperlyNestedBodyElement();
  e.framesetOk && r && (e.treeAdapter.detachNode(r), e.openElements.popAllUpToHtmlElement(), e._insertElement(t, NS.HTML), e.insertionMode = InsertionMode.IN_FRAMESET);
}
function addressStartTagInBody(e, t) {
  e.openElements.hasInButtonScope(TAG_ID.P) && e._closePElement(), e._insertElement(t, NS.HTML);
}
function numberedHeaderStartTagInBody(e, t) {
  e.openElements.hasInButtonScope(TAG_ID.P) && e._closePElement(), isNumberedHeader(e.openElements.currentTagId) && e.openElements.pop(), e._insertElement(t, NS.HTML);
}
function preStartTagInBody(e, t) {
  e.openElements.hasInButtonScope(TAG_ID.P) && e._closePElement(), e._insertElement(t, NS.HTML), e.skipNextNewLine = !0, e.framesetOk = !1;
}
function formStartTagInBody(e, t) {
  const r = e.openElements.tmplCount > 0;
  (!e.formElement || r) && (e.openElements.hasInButtonScope(TAG_ID.P) && e._closePElement(), e._insertElement(t, NS.HTML), r || (e.formElement = e.openElements.current));
}
function listItemStartTagInBody(e, t) {
  e.framesetOk = !1;
  const r = t.tagID;
  for (let a = e.openElements.stackTop; a >= 0; a--) {
    const o = e.openElements.tagIDs[a];
    if (r === TAG_ID.LI && o === TAG_ID.LI || (r === TAG_ID.DD || r === TAG_ID.DT) && (o === TAG_ID.DD || o === TAG_ID.DT)) {
      e.openElements.generateImpliedEndTagsWithExclusion(o), e.openElements.popUntilTagNamePopped(o);
      break;
    }
    if (o !== TAG_ID.ADDRESS && o !== TAG_ID.DIV && o !== TAG_ID.P && e._isSpecialElement(e.openElements.items[a], o))
      break;
  }
  e.openElements.hasInButtonScope(TAG_ID.P) && e._closePElement(), e._insertElement(t, NS.HTML);
}
function plaintextStartTagInBody(e, t) {
  e.openElements.hasInButtonScope(TAG_ID.P) && e._closePElement(), e._insertElement(t, NS.HTML), e.tokenizer.state = TokenizerMode.PLAINTEXT;
}
function buttonStartTagInBody(e, t) {
  e.openElements.hasInScope(TAG_ID.BUTTON) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(TAG_ID.BUTTON)), e._reconstructActiveFormattingElements(), e._insertElement(t, NS.HTML), e.framesetOk = !1;
}
function aStartTagInBody(e, t) {
  const r = e.activeFormattingElements.getElementEntryInScopeWithTagName(TAG_NAMES.A);
  r && (callAdoptionAgency(e, t), e.openElements.remove(r.element), e.activeFormattingElements.removeEntry(r)), e._reconstructActiveFormattingElements(), e._insertElement(t, NS.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function bStartTagInBody(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, NS.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function nobrStartTagInBody(e, t) {
  e._reconstructActiveFormattingElements(), e.openElements.hasInScope(TAG_ID.NOBR) && (callAdoptionAgency(e, t), e._reconstructActiveFormattingElements()), e._insertElement(t, NS.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function appletStartTagInBody(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, NS.HTML), e.activeFormattingElements.insertMarker(), e.framesetOk = !1;
}
function tableStartTagInBody(e, t) {
  e.treeAdapter.getDocumentMode(e.document) !== DOCUMENT_MODE.QUIRKS && e.openElements.hasInButtonScope(TAG_ID.P) && e._closePElement(), e._insertElement(t, NS.HTML), e.framesetOk = !1, e.insertionMode = InsertionMode.IN_TABLE;
}
function areaStartTagInBody(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, NS.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function isHiddenInput(e) {
  const t = getTokenAttr(e, ATTRS.TYPE);
  return t != null && t.toLowerCase() === HIDDEN_INPUT_TYPE;
}
function inputStartTagInBody(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, NS.HTML), isHiddenInput(t) || (e.framesetOk = !1), t.ackSelfClosing = !0;
}
function paramStartTagInBody(e, t) {
  e._appendElement(t, NS.HTML), t.ackSelfClosing = !0;
}
function hrStartTagInBody(e, t) {
  e.openElements.hasInButtonScope(TAG_ID.P) && e._closePElement(), e._appendElement(t, NS.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function imageStartTagInBody(e, t) {
  t.tagName = TAG_NAMES.IMG, t.tagID = TAG_ID.IMG, areaStartTagInBody(e, t);
}
function textareaStartTagInBody(e, t) {
  e._insertElement(t, NS.HTML), e.skipNextNewLine = !0, e.tokenizer.state = TokenizerMode.RCDATA, e.originalInsertionMode = e.insertionMode, e.framesetOk = !1, e.insertionMode = InsertionMode.TEXT;
}
function xmpStartTagInBody(e, t) {
  e.openElements.hasInButtonScope(TAG_ID.P) && e._closePElement(), e._reconstructActiveFormattingElements(), e.framesetOk = !1, e._switchToTextParsing(t, TokenizerMode.RAWTEXT);
}
function iframeStartTagInBody(e, t) {
  e.framesetOk = !1, e._switchToTextParsing(t, TokenizerMode.RAWTEXT);
}
function noembedStartTagInBody(e, t) {
  e._switchToTextParsing(t, TokenizerMode.RAWTEXT);
}
function selectStartTagInBody(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, NS.HTML), e.framesetOk = !1, e.insertionMode = e.insertionMode === InsertionMode.IN_TABLE || e.insertionMode === InsertionMode.IN_CAPTION || e.insertionMode === InsertionMode.IN_TABLE_BODY || e.insertionMode === InsertionMode.IN_ROW || e.insertionMode === InsertionMode.IN_CELL ? InsertionMode.IN_SELECT_IN_TABLE : InsertionMode.IN_SELECT;
}
function optgroupStartTagInBody(e, t) {
  e.openElements.currentTagId === TAG_ID.OPTION && e.openElements.pop(), e._reconstructActiveFormattingElements(), e._insertElement(t, NS.HTML);
}
function rbStartTagInBody(e, t) {
  e.openElements.hasInScope(TAG_ID.RUBY) && e.openElements.generateImpliedEndTags(), e._insertElement(t, NS.HTML);
}
function rtStartTagInBody(e, t) {
  e.openElements.hasInScope(TAG_ID.RUBY) && e.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.RTC), e._insertElement(t, NS.HTML);
}
function mathStartTagInBody(e, t) {
  e._reconstructActiveFormattingElements(), adjustTokenMathMLAttrs(t), adjustTokenXMLAttrs(t), t.selfClosing ? e._appendElement(t, NS.MATHML) : e._insertElement(t, NS.MATHML), t.ackSelfClosing = !0;
}
function svgStartTagInBody(e, t) {
  e._reconstructActiveFormattingElements(), adjustTokenSVGAttrs(t), adjustTokenXMLAttrs(t), t.selfClosing ? e._appendElement(t, NS.SVG) : e._insertElement(t, NS.SVG), t.ackSelfClosing = !0;
}
function genericStartTagInBody(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, NS.HTML);
}
function startTagInBody(e, t) {
  switch (t.tagID) {
    case TAG_ID.I:
    case TAG_ID.S:
    case TAG_ID.B:
    case TAG_ID.U:
    case TAG_ID.EM:
    case TAG_ID.TT:
    case TAG_ID.BIG:
    case TAG_ID.CODE:
    case TAG_ID.FONT:
    case TAG_ID.SMALL:
    case TAG_ID.STRIKE:
    case TAG_ID.STRONG: {
      bStartTagInBody(e, t);
      break;
    }
    case TAG_ID.A: {
      aStartTagInBody(e, t);
      break;
    }
    case TAG_ID.H1:
    case TAG_ID.H2:
    case TAG_ID.H3:
    case TAG_ID.H4:
    case TAG_ID.H5:
    case TAG_ID.H6: {
      numberedHeaderStartTagInBody(e, t);
      break;
    }
    case TAG_ID.P:
    case TAG_ID.DL:
    case TAG_ID.OL:
    case TAG_ID.UL:
    case TAG_ID.DIV:
    case TAG_ID.DIR:
    case TAG_ID.NAV:
    case TAG_ID.MAIN:
    case TAG_ID.MENU:
    case TAG_ID.ASIDE:
    case TAG_ID.CENTER:
    case TAG_ID.FIGURE:
    case TAG_ID.FOOTER:
    case TAG_ID.HEADER:
    case TAG_ID.HGROUP:
    case TAG_ID.DIALOG:
    case TAG_ID.DETAILS:
    case TAG_ID.ADDRESS:
    case TAG_ID.ARTICLE:
    case TAG_ID.SECTION:
    case TAG_ID.SUMMARY:
    case TAG_ID.FIELDSET:
    case TAG_ID.BLOCKQUOTE:
    case TAG_ID.FIGCAPTION: {
      addressStartTagInBody(e, t);
      break;
    }
    case TAG_ID.LI:
    case TAG_ID.DD:
    case TAG_ID.DT: {
      listItemStartTagInBody(e, t);
      break;
    }
    case TAG_ID.BR:
    case TAG_ID.IMG:
    case TAG_ID.WBR:
    case TAG_ID.AREA:
    case TAG_ID.EMBED:
    case TAG_ID.KEYGEN: {
      areaStartTagInBody(e, t);
      break;
    }
    case TAG_ID.HR: {
      hrStartTagInBody(e, t);
      break;
    }
    case TAG_ID.RB:
    case TAG_ID.RTC: {
      rbStartTagInBody(e, t);
      break;
    }
    case TAG_ID.RT:
    case TAG_ID.RP: {
      rtStartTagInBody(e, t);
      break;
    }
    case TAG_ID.PRE:
    case TAG_ID.LISTING: {
      preStartTagInBody(e, t);
      break;
    }
    case TAG_ID.XMP: {
      xmpStartTagInBody(e, t);
      break;
    }
    case TAG_ID.SVG: {
      svgStartTagInBody(e, t);
      break;
    }
    case TAG_ID.HTML: {
      htmlStartTagInBody(e, t);
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.STYLE:
    case TAG_ID.TITLE:
    case TAG_ID.SCRIPT:
    case TAG_ID.BGSOUND:
    case TAG_ID.BASEFONT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(e, t);
      break;
    }
    case TAG_ID.BODY: {
      bodyStartTagInBody(e, t);
      break;
    }
    case TAG_ID.FORM: {
      formStartTagInBody(e, t);
      break;
    }
    case TAG_ID.NOBR: {
      nobrStartTagInBody(e, t);
      break;
    }
    case TAG_ID.MATH: {
      mathStartTagInBody(e, t);
      break;
    }
    case TAG_ID.TABLE: {
      tableStartTagInBody(e, t);
      break;
    }
    case TAG_ID.INPUT: {
      inputStartTagInBody(e, t);
      break;
    }
    case TAG_ID.PARAM:
    case TAG_ID.TRACK:
    case TAG_ID.SOURCE: {
      paramStartTagInBody(e, t);
      break;
    }
    case TAG_ID.IMAGE: {
      imageStartTagInBody(e, t);
      break;
    }
    case TAG_ID.BUTTON: {
      buttonStartTagInBody(e, t);
      break;
    }
    case TAG_ID.APPLET:
    case TAG_ID.OBJECT:
    case TAG_ID.MARQUEE: {
      appletStartTagInBody(e, t);
      break;
    }
    case TAG_ID.IFRAME: {
      iframeStartTagInBody(e, t);
      break;
    }
    case TAG_ID.SELECT: {
      selectStartTagInBody(e, t);
      break;
    }
    case TAG_ID.OPTION:
    case TAG_ID.OPTGROUP: {
      optgroupStartTagInBody(e, t);
      break;
    }
    case TAG_ID.NOEMBED: {
      noembedStartTagInBody(e, t);
      break;
    }
    case TAG_ID.FRAMESET: {
      framesetStartTagInBody(e, t);
      break;
    }
    case TAG_ID.TEXTAREA: {
      textareaStartTagInBody(e, t);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      e.options.scriptingEnabled ? noembedStartTagInBody(e, t) : genericStartTagInBody(e, t);
      break;
    }
    case TAG_ID.PLAINTEXT: {
      plaintextStartTagInBody(e, t);
      break;
    }
    case TAG_ID.COL:
    case TAG_ID.TH:
    case TAG_ID.TD:
    case TAG_ID.TR:
    case TAG_ID.HEAD:
    case TAG_ID.FRAME:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.CAPTION:
    case TAG_ID.COLGROUP:
      break;
    default:
      genericStartTagInBody(e, t);
  }
}
function bodyEndTagInBody(e, t) {
  if (e.openElements.hasInScope(TAG_ID.BODY) && (e.insertionMode = InsertionMode.AFTER_BODY, e.options.sourceCodeLocationInfo)) {
    const r = e.openElements.tryPeekProperlyNestedBodyElement();
    r && e._setEndLocation(r, t);
  }
}
function htmlEndTagInBody(e, t) {
  e.openElements.hasInScope(TAG_ID.BODY) && (e.insertionMode = InsertionMode.AFTER_BODY, endTagAfterBody(e, t));
}
function addressEndTagInBody(e, t) {
  const r = t.tagID;
  e.openElements.hasInScope(r) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(r));
}
function formEndTagInBody(e) {
  const t = e.openElements.tmplCount > 0, {
    formElement: r
  } = e;
  t || (e.formElement = null), (r || t) && e.openElements.hasInScope(TAG_ID.FORM) && (e.openElements.generateImpliedEndTags(), t ? e.openElements.popUntilTagNamePopped(TAG_ID.FORM) : r && e.openElements.remove(r));
}
function pEndTagInBody(e) {
  e.openElements.hasInButtonScope(TAG_ID.P) || e._insertFakeElement(TAG_NAMES.P, TAG_ID.P), e._closePElement();
}
function liEndTagInBody(e) {
  e.openElements.hasInListItemScope(TAG_ID.LI) && (e.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.LI), e.openElements.popUntilTagNamePopped(TAG_ID.LI));
}
function ddEndTagInBody(e, t) {
  const r = t.tagID;
  e.openElements.hasInScope(r) && (e.openElements.generateImpliedEndTagsWithExclusion(r), e.openElements.popUntilTagNamePopped(r));
}
function numberedHeaderEndTagInBody(e) {
  e.openElements.hasNumberedHeaderInScope() && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilNumberedHeaderPopped());
}
function appletEndTagInBody(e, t) {
  const r = t.tagID;
  e.openElements.hasInScope(r) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(r), e.activeFormattingElements.clearToLastMarker());
}
function brEndTagInBody(e) {
  e._reconstructActiveFormattingElements(), e._insertFakeElement(TAG_NAMES.BR, TAG_ID.BR), e.openElements.pop(), e.framesetOk = !1;
}
function genericEndTagInBody(e, t) {
  const r = t.tagName, a = t.tagID;
  for (let o = e.openElements.stackTop; o > 0; o--) {
    const u = e.openElements.items[o], c = e.openElements.tagIDs[o];
    if (a === c && (a !== TAG_ID.UNKNOWN || e.treeAdapter.getTagName(u) === r)) {
      e.openElements.generateImpliedEndTagsWithExclusion(a), e.openElements.stackTop >= o && e.openElements.shortenToLength(o);
      break;
    }
    if (e._isSpecialElement(u, c))
      break;
  }
}
function endTagInBody(e, t) {
  switch (t.tagID) {
    case TAG_ID.A:
    case TAG_ID.B:
    case TAG_ID.I:
    case TAG_ID.S:
    case TAG_ID.U:
    case TAG_ID.EM:
    case TAG_ID.TT:
    case TAG_ID.BIG:
    case TAG_ID.CODE:
    case TAG_ID.FONT:
    case TAG_ID.NOBR:
    case TAG_ID.SMALL:
    case TAG_ID.STRIKE:
    case TAG_ID.STRONG: {
      callAdoptionAgency(e, t);
      break;
    }
    case TAG_ID.P: {
      pEndTagInBody(e);
      break;
    }
    case TAG_ID.DL:
    case TAG_ID.UL:
    case TAG_ID.OL:
    case TAG_ID.DIR:
    case TAG_ID.DIV:
    case TAG_ID.NAV:
    case TAG_ID.PRE:
    case TAG_ID.MAIN:
    case TAG_ID.MENU:
    case TAG_ID.ASIDE:
    case TAG_ID.BUTTON:
    case TAG_ID.CENTER:
    case TAG_ID.FIGURE:
    case TAG_ID.FOOTER:
    case TAG_ID.HEADER:
    case TAG_ID.HGROUP:
    case TAG_ID.DIALOG:
    case TAG_ID.ADDRESS:
    case TAG_ID.ARTICLE:
    case TAG_ID.DETAILS:
    case TAG_ID.SECTION:
    case TAG_ID.SUMMARY:
    case TAG_ID.LISTING:
    case TAG_ID.FIELDSET:
    case TAG_ID.BLOCKQUOTE:
    case TAG_ID.FIGCAPTION: {
      addressEndTagInBody(e, t);
      break;
    }
    case TAG_ID.LI: {
      liEndTagInBody(e);
      break;
    }
    case TAG_ID.DD:
    case TAG_ID.DT: {
      ddEndTagInBody(e, t);
      break;
    }
    case TAG_ID.H1:
    case TAG_ID.H2:
    case TAG_ID.H3:
    case TAG_ID.H4:
    case TAG_ID.H5:
    case TAG_ID.H6: {
      numberedHeaderEndTagInBody(e);
      break;
    }
    case TAG_ID.BR: {
      brEndTagInBody(e);
      break;
    }
    case TAG_ID.BODY: {
      bodyEndTagInBody(e, t);
      break;
    }
    case TAG_ID.HTML: {
      htmlEndTagInBody(e, t);
      break;
    }
    case TAG_ID.FORM: {
      formEndTagInBody(e);
      break;
    }
    case TAG_ID.APPLET:
    case TAG_ID.OBJECT:
    case TAG_ID.MARQUEE: {
      appletEndTagInBody(e, t);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(e, t);
      break;
    }
    default:
      genericEndTagInBody(e, t);
  }
}
function eofInBody(e, t) {
  e.tmplInsertionModeStack.length > 0 ? eofInTemplate(e, t) : stopParsing(e, t);
}
function endTagInText(e, t) {
  var r;
  t.tagID === TAG_ID.SCRIPT && ((r = e.scriptHandler) === null || r === void 0 || r.call(e, e.openElements.current)), e.openElements.pop(), e.insertionMode = e.originalInsertionMode;
}
function eofInText(e, t) {
  e._err(t, ERR.eofInElementThatCanContainOnlyText), e.openElements.pop(), e.insertionMode = e.originalInsertionMode, e.onEof(t);
}
function characterInTable(e, t) {
  if (TABLE_STRUCTURE_TAGS.has(e.openElements.currentTagId))
    switch (e.pendingCharacterTokens.length = 0, e.hasNonWhitespacePendingCharacterToken = !1, e.originalInsertionMode = e.insertionMode, e.insertionMode = InsertionMode.IN_TABLE_TEXT, t.type) {
      case TokenType.CHARACTER: {
        characterInTableText(e, t);
        break;
      }
      case TokenType.WHITESPACE_CHARACTER: {
        whitespaceCharacterInTableText(e, t);
        break;
      }
    }
  else
    tokenInTable(e, t);
}
function captionStartTagInTable(e, t) {
  e.openElements.clearBackToTableContext(), e.activeFormattingElements.insertMarker(), e._insertElement(t, NS.HTML), e.insertionMode = InsertionMode.IN_CAPTION;
}
function colgroupStartTagInTable(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, NS.HTML), e.insertionMode = InsertionMode.IN_COLUMN_GROUP;
}
function colStartTagInTable(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(TAG_NAMES.COLGROUP, TAG_ID.COLGROUP), e.insertionMode = InsertionMode.IN_COLUMN_GROUP, startTagInColumnGroup(e, t);
}
function tbodyStartTagInTable(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, NS.HTML), e.insertionMode = InsertionMode.IN_TABLE_BODY;
}
function tdStartTagInTable(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(TAG_NAMES.TBODY, TAG_ID.TBODY), e.insertionMode = InsertionMode.IN_TABLE_BODY, startTagInTableBody(e, t);
}
function tableStartTagInTable(e, t) {
  e.openElements.hasInTableScope(TAG_ID.TABLE) && (e.openElements.popUntilTagNamePopped(TAG_ID.TABLE), e._resetInsertionMode(), e._processStartTag(t));
}
function inputStartTagInTable(e, t) {
  isHiddenInput(t) ? e._appendElement(t, NS.HTML) : tokenInTable(e, t), t.ackSelfClosing = !0;
}
function formStartTagInTable(e, t) {
  !e.formElement && e.openElements.tmplCount === 0 && (e._insertElement(t, NS.HTML), e.formElement = e.openElements.current, e.openElements.pop());
}
function startTagInTable(e, t) {
  switch (t.tagID) {
    case TAG_ID.TD:
    case TAG_ID.TH:
    case TAG_ID.TR: {
      tdStartTagInTable(e, t);
      break;
    }
    case TAG_ID.STYLE:
    case TAG_ID.SCRIPT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(e, t);
      break;
    }
    case TAG_ID.COL: {
      colStartTagInTable(e, t);
      break;
    }
    case TAG_ID.FORM: {
      formStartTagInTable(e, t);
      break;
    }
    case TAG_ID.TABLE: {
      tableStartTagInTable(e, t);
      break;
    }
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      tbodyStartTagInTable(e, t);
      break;
    }
    case TAG_ID.INPUT: {
      inputStartTagInTable(e, t);
      break;
    }
    case TAG_ID.CAPTION: {
      captionStartTagInTable(e, t);
      break;
    }
    case TAG_ID.COLGROUP: {
      colgroupStartTagInTable(e, t);
      break;
    }
    default:
      tokenInTable(e, t);
  }
}
function endTagInTable(e, t) {
  switch (t.tagID) {
    case TAG_ID.TABLE: {
      e.openElements.hasInTableScope(TAG_ID.TABLE) && (e.openElements.popUntilTagNamePopped(TAG_ID.TABLE), e._resetInsertionMode());
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(e, t);
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TBODY:
    case TAG_ID.TD:
    case TAG_ID.TFOOT:
    case TAG_ID.TH:
    case TAG_ID.THEAD:
    case TAG_ID.TR:
      break;
    default:
      tokenInTable(e, t);
  }
}
function tokenInTable(e, t) {
  const r = e.fosterParentingEnabled;
  e.fosterParentingEnabled = !0, modeInBody(e, t), e.fosterParentingEnabled = r;
}
function whitespaceCharacterInTableText(e, t) {
  e.pendingCharacterTokens.push(t);
}
function characterInTableText(e, t) {
  e.pendingCharacterTokens.push(t), e.hasNonWhitespacePendingCharacterToken = !0;
}
function tokenInTableText(e, t) {
  let r = 0;
  if (e.hasNonWhitespacePendingCharacterToken)
    for (; r < e.pendingCharacterTokens.length; r++)
      tokenInTable(e, e.pendingCharacterTokens[r]);
  else
    for (; r < e.pendingCharacterTokens.length; r++)
      e._insertCharacters(e.pendingCharacterTokens[r]);
  e.insertionMode = e.originalInsertionMode, e._processToken(t);
}
const TABLE_VOID_ELEMENTS = /* @__PURE__ */ new Set([TAG_ID.CAPTION, TAG_ID.COL, TAG_ID.COLGROUP, TAG_ID.TBODY, TAG_ID.TD, TAG_ID.TFOOT, TAG_ID.TH, TAG_ID.THEAD, TAG_ID.TR]);
function startTagInCaption(e, t) {
  const r = t.tagID;
  TABLE_VOID_ELEMENTS.has(r) ? e.openElements.hasInTableScope(TAG_ID.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(TAG_ID.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = InsertionMode.IN_TABLE, startTagInTable(e, t)) : startTagInBody(e, t);
}
function endTagInCaption(e, t) {
  const r = t.tagID;
  switch (r) {
    case TAG_ID.CAPTION:
    case TAG_ID.TABLE: {
      e.openElements.hasInTableScope(TAG_ID.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(TAG_ID.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = InsertionMode.IN_TABLE, r === TAG_ID.TABLE && endTagInTable(e, t));
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TBODY:
    case TAG_ID.TD:
    case TAG_ID.TFOOT:
    case TAG_ID.TH:
    case TAG_ID.THEAD:
    case TAG_ID.TR:
      break;
    default:
      endTagInBody(e, t);
  }
}
function startTagInColumnGroup(e, t) {
  switch (t.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(e, t);
      break;
    }
    case TAG_ID.COL: {
      e._appendElement(t, NS.HTML), t.ackSelfClosing = !0;
      break;
    }
    case TAG_ID.TEMPLATE: {
      startTagInHead(e, t);
      break;
    }
    default:
      tokenInColumnGroup(e, t);
  }
}
function endTagInColumnGroup(e, t) {
  switch (t.tagID) {
    case TAG_ID.COLGROUP: {
      e.openElements.currentTagId === TAG_ID.COLGROUP && (e.openElements.pop(), e.insertionMode = InsertionMode.IN_TABLE);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(e, t);
      break;
    }
    case TAG_ID.COL:
      break;
    default:
      tokenInColumnGroup(e, t);
  }
}
function tokenInColumnGroup(e, t) {
  e.openElements.currentTagId === TAG_ID.COLGROUP && (e.openElements.pop(), e.insertionMode = InsertionMode.IN_TABLE, e._processToken(t));
}
function startTagInTableBody(e, t) {
  switch (t.tagID) {
    case TAG_ID.TR: {
      e.openElements.clearBackToTableBodyContext(), e._insertElement(t, NS.HTML), e.insertionMode = InsertionMode.IN_ROW;
      break;
    }
    case TAG_ID.TH:
    case TAG_ID.TD: {
      e.openElements.clearBackToTableBodyContext(), e._insertFakeElement(TAG_NAMES.TR, TAG_ID.TR), e.insertionMode = InsertionMode.IN_ROW, startTagInRow(e, t);
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = InsertionMode.IN_TABLE, startTagInTable(e, t));
      break;
    }
    default:
      startTagInTable(e, t);
  }
}
function endTagInTableBody(e, t) {
  const r = t.tagID;
  switch (t.tagID) {
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      e.openElements.hasInTableScope(r) && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = InsertionMode.IN_TABLE);
      break;
    }
    case TAG_ID.TABLE: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = InsertionMode.IN_TABLE, endTagInTable(e, t));
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TD:
    case TAG_ID.TH:
    case TAG_ID.TR:
      break;
    default:
      endTagInTable(e, t);
  }
}
function startTagInRow(e, t) {
  switch (t.tagID) {
    case TAG_ID.TH:
    case TAG_ID.TD: {
      e.openElements.clearBackToTableRowContext(), e._insertElement(t, NS.HTML), e.insertionMode = InsertionMode.IN_CELL, e.activeFormattingElements.insertMarker();
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      e.openElements.hasInTableScope(TAG_ID.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = InsertionMode.IN_TABLE_BODY, startTagInTableBody(e, t));
      break;
    }
    default:
      startTagInTable(e, t);
  }
}
function endTagInRow(e, t) {
  switch (t.tagID) {
    case TAG_ID.TR: {
      e.openElements.hasInTableScope(TAG_ID.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = InsertionMode.IN_TABLE_BODY);
      break;
    }
    case TAG_ID.TABLE: {
      e.openElements.hasInTableScope(TAG_ID.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = InsertionMode.IN_TABLE_BODY, endTagInTableBody(e, t));
      break;
    }
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      (e.openElements.hasInTableScope(t.tagID) || e.openElements.hasInTableScope(TAG_ID.TR)) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = InsertionMode.IN_TABLE_BODY, endTagInTableBody(e, t));
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TD:
    case TAG_ID.TH:
      break;
    default:
      endTagInTable(e, t);
  }
}
function startTagInCell(e, t) {
  const r = t.tagID;
  TABLE_VOID_ELEMENTS.has(r) ? (e.openElements.hasInTableScope(TAG_ID.TD) || e.openElements.hasInTableScope(TAG_ID.TH)) && (e._closeTableCell(), startTagInRow(e, t)) : startTagInBody(e, t);
}
function endTagInCell(e, t) {
  const r = t.tagID;
  switch (r) {
    case TAG_ID.TD:
    case TAG_ID.TH: {
      e.openElements.hasInTableScope(r) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(r), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = InsertionMode.IN_ROW);
      break;
    }
    case TAG_ID.TABLE:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      e.openElements.hasInTableScope(r) && (e._closeTableCell(), endTagInRow(e, t));
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
      break;
    default:
      endTagInBody(e, t);
  }
}
function startTagInSelect(e, t) {
  switch (t.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(e, t);
      break;
    }
    case TAG_ID.OPTION: {
      e.openElements.currentTagId === TAG_ID.OPTION && e.openElements.pop(), e._insertElement(t, NS.HTML);
      break;
    }
    case TAG_ID.OPTGROUP: {
      e.openElements.currentTagId === TAG_ID.OPTION && e.openElements.pop(), e.openElements.currentTagId === TAG_ID.OPTGROUP && e.openElements.pop(), e._insertElement(t, NS.HTML);
      break;
    }
    case TAG_ID.INPUT:
    case TAG_ID.KEYGEN:
    case TAG_ID.TEXTAREA:
    case TAG_ID.SELECT: {
      e.openElements.hasInSelectScope(TAG_ID.SELECT) && (e.openElements.popUntilTagNamePopped(TAG_ID.SELECT), e._resetInsertionMode(), t.tagID !== TAG_ID.SELECT && e._processStartTag(t));
      break;
    }
    case TAG_ID.SCRIPT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(e, t);
      break;
    }
  }
}
function endTagInSelect(e, t) {
  switch (t.tagID) {
    case TAG_ID.OPTGROUP: {
      e.openElements.stackTop > 0 && e.openElements.currentTagId === TAG_ID.OPTION && e.openElements.tagIDs[e.openElements.stackTop - 1] === TAG_ID.OPTGROUP && e.openElements.pop(), e.openElements.currentTagId === TAG_ID.OPTGROUP && e.openElements.pop();
      break;
    }
    case TAG_ID.OPTION: {
      e.openElements.currentTagId === TAG_ID.OPTION && e.openElements.pop();
      break;
    }
    case TAG_ID.SELECT: {
      e.openElements.hasInSelectScope(TAG_ID.SELECT) && (e.openElements.popUntilTagNamePopped(TAG_ID.SELECT), e._resetInsertionMode());
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(e, t);
      break;
    }
  }
}
function startTagInSelectInTable(e, t) {
  const r = t.tagID;
  r === TAG_ID.CAPTION || r === TAG_ID.TABLE || r === TAG_ID.TBODY || r === TAG_ID.TFOOT || r === TAG_ID.THEAD || r === TAG_ID.TR || r === TAG_ID.TD || r === TAG_ID.TH ? (e.openElements.popUntilTagNamePopped(TAG_ID.SELECT), e._resetInsertionMode(), e._processStartTag(t)) : startTagInSelect(e, t);
}
function endTagInSelectInTable(e, t) {
  const r = t.tagID;
  r === TAG_ID.CAPTION || r === TAG_ID.TABLE || r === TAG_ID.TBODY || r === TAG_ID.TFOOT || r === TAG_ID.THEAD || r === TAG_ID.TR || r === TAG_ID.TD || r === TAG_ID.TH ? e.openElements.hasInTableScope(r) && (e.openElements.popUntilTagNamePopped(TAG_ID.SELECT), e._resetInsertionMode(), e.onEndTag(t)) : endTagInSelect(e, t);
}
function startTagInTemplate(e, t) {
  switch (t.tagID) {
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.SCRIPT:
    case TAG_ID.STYLE:
    case TAG_ID.TEMPLATE:
    case TAG_ID.TITLE: {
      startTagInHead(e, t);
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      e.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE, e.insertionMode = InsertionMode.IN_TABLE, startTagInTable(e, t);
      break;
    }
    case TAG_ID.COL: {
      e.tmplInsertionModeStack[0] = InsertionMode.IN_COLUMN_GROUP, e.insertionMode = InsertionMode.IN_COLUMN_GROUP, startTagInColumnGroup(e, t);
      break;
    }
    case TAG_ID.TR: {
      e.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE_BODY, e.insertionMode = InsertionMode.IN_TABLE_BODY, startTagInTableBody(e, t);
      break;
    }
    case TAG_ID.TD:
    case TAG_ID.TH: {
      e.tmplInsertionModeStack[0] = InsertionMode.IN_ROW, e.insertionMode = InsertionMode.IN_ROW, startTagInRow(e, t);
      break;
    }
    default:
      e.tmplInsertionModeStack[0] = InsertionMode.IN_BODY, e.insertionMode = InsertionMode.IN_BODY, startTagInBody(e, t);
  }
}
function endTagInTemplate(e, t) {
  t.tagID === TAG_ID.TEMPLATE && templateEndTagInHead(e, t);
}
function eofInTemplate(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode(), e.onEof(t)) : stopParsing(e, t);
}
function startTagAfterBody(e, t) {
  t.tagID === TAG_ID.HTML ? startTagInBody(e, t) : tokenAfterBody(e, t);
}
function endTagAfterBody(e, t) {
  var r;
  if (t.tagID === TAG_ID.HTML) {
    if (e.fragmentContext || (e.insertionMode = InsertionMode.AFTER_AFTER_BODY), e.options.sourceCodeLocationInfo && e.openElements.tagIDs[0] === TAG_ID.HTML) {
      e._setEndLocation(e.openElements.items[0], t);
      const a = e.openElements.items[1];
      a && !(!((r = e.treeAdapter.getNodeSourceCodeLocation(a)) === null || r === void 0) && r.endTag) && e._setEndLocation(a, t);
    }
  } else
    tokenAfterBody(e, t);
}
function tokenAfterBody(e, t) {
  e.insertionMode = InsertionMode.IN_BODY, modeInBody(e, t);
}
function startTagInFrameset(e, t) {
  switch (t.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(e, t);
      break;
    }
    case TAG_ID.FRAMESET: {
      e._insertElement(t, NS.HTML);
      break;
    }
    case TAG_ID.FRAME: {
      e._appendElement(t, NS.HTML), t.ackSelfClosing = !0;
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(e, t);
      break;
    }
  }
}
function endTagInFrameset(e, t) {
  t.tagID === TAG_ID.FRAMESET && !e.openElements.isRootHtmlElementCurrent() && (e.openElements.pop(), !e.fragmentContext && e.openElements.currentTagId !== TAG_ID.FRAMESET && (e.insertionMode = InsertionMode.AFTER_FRAMESET));
}
function startTagAfterFrameset(e, t) {
  switch (t.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(e, t);
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(e, t);
      break;
    }
  }
}
function endTagAfterFrameset(e, t) {
  t.tagID === TAG_ID.HTML && (e.insertionMode = InsertionMode.AFTER_AFTER_FRAMESET);
}
function startTagAfterAfterBody(e, t) {
  t.tagID === TAG_ID.HTML ? startTagInBody(e, t) : tokenAfterAfterBody(e, t);
}
function tokenAfterAfterBody(e, t) {
  e.insertionMode = InsertionMode.IN_BODY, modeInBody(e, t);
}
function startTagAfterAfterFrameset(e, t) {
  switch (t.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(e, t);
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(e, t);
      break;
    }
  }
}
function nullCharacterInForeignContent(e, t) {
  t.chars = REPLACEMENT_CHARACTER, e._insertCharacters(t);
}
function characterInForeignContent(e, t) {
  e._insertCharacters(t), e.framesetOk = !1;
}
function popUntilHtmlOrIntegrationPoint(e) {
  for (; e.treeAdapter.getNamespaceURI(e.openElements.current) !== NS.HTML && !e._isIntegrationPoint(e.openElements.currentTagId, e.openElements.current); )
    e.openElements.pop();
}
function startTagInForeignContent(e, t) {
  if (causesExit(t))
    popUntilHtmlOrIntegrationPoint(e), e._startTagOutsideForeignContent(t);
  else {
    const r = e._getAdjustedCurrentElement(), a = e.treeAdapter.getNamespaceURI(r);
    a === NS.MATHML ? adjustTokenMathMLAttrs(t) : a === NS.SVG && (adjustTokenSVGTagName(t), adjustTokenSVGAttrs(t)), adjustTokenXMLAttrs(t), t.selfClosing ? e._appendElement(t, a) : e._insertElement(t, a), t.ackSelfClosing = !0;
  }
}
function endTagInForeignContent(e, t) {
  if (t.tagID === TAG_ID.P || t.tagID === TAG_ID.BR) {
    popUntilHtmlOrIntegrationPoint(e), e._endTagOutsideForeignContent(t);
    return;
  }
  for (let r = e.openElements.stackTop; r > 0; r--) {
    const a = e.openElements.items[r];
    if (e.treeAdapter.getNamespaceURI(a) === NS.HTML) {
      e._endTagOutsideForeignContent(t);
      break;
    }
    const o = e.treeAdapter.getTagName(a);
    if (o.toLowerCase() === t.tagName) {
      t.tagName = o, e.openElements.shortenToLength(r);
      break;
    }
  }
}
TAG_NAMES.AREA, TAG_NAMES.BASE, TAG_NAMES.BASEFONT, TAG_NAMES.BGSOUND, TAG_NAMES.BR, TAG_NAMES.COL, TAG_NAMES.EMBED, TAG_NAMES.FRAME, TAG_NAMES.HR, TAG_NAMES.IMG, TAG_NAMES.INPUT, TAG_NAMES.KEYGEN, TAG_NAMES.LINK, TAG_NAMES.META, TAG_NAMES.PARAM, TAG_NAMES.SOURCE, TAG_NAMES.TRACK, TAG_NAMES.WBR;
const knownMdxNames = /* @__PURE__ */ new Set(["mdxFlowExpression", "mdxJsxFlowElement", "mdxJsxTextElement", "mdxTextExpression", "mdxjsEsm"]), parseOptions = {
  sourceCodeLocationInfo: !0,
  scriptingEnabled: !1
};
function raw(e, t) {
  const r = documentMode(e), a = zwitch("type", {
    handlers: {
      root: root$2,
      element: element$7,
      text: text$4,
      comment: comment$1,
      doctype: doctype$1,
      raw: handleRaw
    },
    unknown
  }), o = {
    parser: r ? new Parser$1(parseOptions) : Parser$1.getFragmentParser(void 0, parseOptions),
    handle(d) {
      a(d, o);
    },
    stitches: !1,
    options: t || {}
  };
  a(e, o), resetTokenizer(o, pointStart());
  const u = r ? o.parser.document : o.parser.getFragment(), c = fromParse5(u, {
    // To do: support `space`?
    file: o.options.file
  });
  return o.stitches && visit(c, "comment", function(d, g, b) {
    const _ = (
      /** @type {Stitch} */
      /** @type {unknown} */
      d
    );
    if (_.value.stitch && b && g !== void 0) {
      const y = b.children;
      return y[g] = _.value.stitch, g;
    }
  }), c.type === "root" && c.children.length === 1 && c.children[0].type === e.type ? c.children[0] : c;
}
function all(e, t) {
  let r = -1;
  if (e)
    for (; ++r < e.length; )
      t.handle(e[r]);
}
function root$2(e, t) {
  all(e.children, t);
}
function element$7(e, t) {
  startTag(e, t), all(e.children, t), endTag(e, t);
}
function text$4(e, t) {
  const r = {
    type: TokenType.CHARACTER,
    chars: e.value,
    location: createParse5Location(e)
  };
  resetTokenizer(t, pointStart(e)), t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken);
}
function doctype$1(e, t) {
  const r = {
    type: TokenType.DOCTYPE,
    name: "html",
    forceQuirks: !1,
    publicId: "",
    systemId: "",
    location: createParse5Location(e)
  };
  resetTokenizer(t, pointStart(e)), t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken);
}
function stitch(e, t) {
  t.stitches = !0;
  const r = cloneWithoutChildren(e);
  if ("children" in e && "children" in r) {
    const a = (
      /** @type {Root} */
      raw({
        type: "root",
        children: e.children
      }, t.options)
    );
    r.children = a.children;
  }
  comment$1({
    type: "comment",
    value: {
      stitch: r
    }
  }, t);
}
function comment$1(e, t) {
  const r = e.value, a = {
    type: TokenType.COMMENT,
    data: r,
    location: createParse5Location(e)
  };
  resetTokenizer(t, pointStart(e)), t.parser.currentToken = a, t.parser._processToken(t.parser.currentToken);
}
function handleRaw(e, t) {
  if (t.parser.tokenizer.preprocessor.html = "", t.parser.tokenizer.preprocessor.pos = -1, t.parser.tokenizer.preprocessor.lastGapPos = -2, t.parser.tokenizer.preprocessor.gapStack = [], t.parser.tokenizer.preprocessor.skipNextNewLine = !1, t.parser.tokenizer.preprocessor.lastChunkWritten = !1, t.parser.tokenizer.preprocessor.endOfChunkHit = !1, t.parser.tokenizer.preprocessor.isEol = !1, setPoint(t, pointStart(e)), t.parser.tokenizer.write(e.value, !1), t.parser.tokenizer._runParsingLoop(), t.parser.tokenizer.state === 72 || t.parser.tokenizer.state === 78) {
    t.parser.tokenizer.preprocessor.lastChunkWritten = !0;
    const r = t.parser.tokenizer._consume();
    t.parser.tokenizer._callState(r);
  }
}
function unknown(e, t) {
  const r = (
    /** @type {Nodes} */
    e
  );
  if (t.options.passThrough && t.options.passThrough.includes(r.type))
    stitch(r, t);
  else {
    let a = "";
    throw knownMdxNames.has(r.type) && (a = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"), new Error("Cannot compile `" + r.type + "` node" + a);
  }
}
function resetTokenizer(e, t) {
  setPoint(e, t);
  const r = e.parser.tokenizer.currentCharacterToken;
  r && r.location && (r.location.endLine = e.parser.tokenizer.preprocessor.line, r.location.endCol = e.parser.tokenizer.preprocessor.col + 1, r.location.endOffset = e.parser.tokenizer.preprocessor.offset + 1, e.parser.currentToken = r, e.parser._processToken(e.parser.currentToken)), e.parser.tokenizer.paused = !1, e.parser.tokenizer.inLoop = !1, e.parser.tokenizer.active = !1, e.parser.tokenizer.returnState = TokenizerMode.DATA, e.parser.tokenizer.charRefCode = -1, e.parser.tokenizer.consumedAfterSnapshot = -1, e.parser.tokenizer.currentLocation = null, e.parser.tokenizer.currentCharacterToken = null, e.parser.tokenizer.currentToken = null, e.parser.tokenizer.currentAttr = {
    name: "",
    value: ""
  };
}
function setPoint(e, t) {
  if (t && t.offset !== void 0) {
    const r = {
      startLine: t.line,
      startCol: t.column,
      startOffset: t.offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
    e.parser.tokenizer.preprocessor.lineStartPos = -t.column + 1, e.parser.tokenizer.preprocessor.droppedBufferSize = t.offset, e.parser.tokenizer.preprocessor.line = t.line, e.parser.tokenizer.currentLocation = r;
  }
}
function startTag(e, t) {
  if (t.parser.tokenizer.state === TokenizerMode.PLAINTEXT) return;
  resetTokenizer(t, pointStart(e));
  const r = t.parser.openElements.current;
  let a = "namespaceURI" in r ? r.namespaceURI : webNamespaces.html;
  a === webNamespaces.html && e.tagName === "svg" && (a = webNamespaces.svg);
  const o = toParse5(
    // Shallow clone to not delve into `children`: we only need the attributes.
    {
      ...e,
      children: []
    },
    {
      space: a === webNamespaces.svg ? "svg" : "html"
    }
  ), u = "attrs" in o ? o.attrs : [], c = {
    type: TokenType.START_TAG,
    tagName: e.tagName,
    tagID: getTagID(e.tagName),
    // We always send start and end tags.
    selfClosing: !1,
    ackSelfClosing: !1,
    attrs: u,
    location: createParse5Location(e)
  };
  t.parser.currentToken = c, t.parser._processToken(t.parser.currentToken), t.parser.tokenizer.lastStartTagName = e.tagName;
}
function endTag(e, t) {
  if (!t.parser.tokenizer.inForeignNode && htmlVoidElements.includes(e.tagName) || t.parser.tokenizer.state === TokenizerMode.PLAINTEXT) return;
  resetTokenizer(t, pointEnd(e));
  const r = {
    type: TokenType.END_TAG,
    tagName: e.tagName,
    tagID: getTagID(e.tagName),
    selfClosing: !1,
    ackSelfClosing: !1,
    attrs: [],
    location: createParse5Location(e)
  };
  t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken), // Current element is closed.
  r.tagName === t.parser.tokenizer.lastStartTagName && // `<textarea>` and `<title>`
  (t.parser.tokenizer.state === TokenizerMode.RCDATA || // `<iframe>`, `<noembed>`, `<style>`, `<xmp>`
  t.parser.tokenizer.state === TokenizerMode.RAWTEXT || // `<script>`
  t.parser.tokenizer.state === TokenizerMode.SCRIPT_DATA) && (t.parser.tokenizer.state = TokenizerMode.DATA);
}
function documentMode(e) {
  const t = e.type === "root" ? e.children[0] : e;
  return !!(t && (t.type === "doctype" || t.type === "element" && t.tagName === "html"));
}
function createParse5Location(e) {
  const t = pointStart(e) || {
    line: void 0,
    column: void 0,
    offset: void 0
  }, r = pointEnd(e) || {
    line: void 0,
    column: void 0,
    offset: void 0
  };
  return {
    startLine: t.line,
    startCol: t.column,
    startOffset: t.offset,
    endLine: r.line,
    endCol: r.column,
    endOffset: r.offset
  };
}
function cloneWithoutChildren(e) {
  return "children" in e ? structuredClone$1({
    ...e,
    children: []
  }) : structuredClone$1(e);
}
function rehypeRaw(e) {
  return function(t, r) {
    return (
      /** @type {Root} */
      raw(t, {
        ...e,
        file: r
      })
    );
  };
}
function escapeStringRegexp(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function findAndReplace(e, t, r) {
  const o = convert((r || {}).ignore || []), u = toPairs(t);
  let c = -1;
  for (; ++c < u.length; )
    visitParents(e, "text", d);
  function d(b, _) {
    let y = -1, A;
    for (; ++y < _.length; ) {
      const E = _[y], v = A ? A.children : void 0;
      if (o(E, v ? v.indexOf(E) : void 0, A))
        return;
      A = E;
    }
    if (A)
      return g(b, _);
  }
  function g(b, _) {
    const y = _[_.length - 1], A = u[c][0], E = u[c][1];
    let v = 0;
    const R = y.children.indexOf(b);
    let I = !1, w = [];
    A.lastIndex = 0;
    let N = A.exec(b.value);
    for (; N; ) {
      const F = N.index, M = {
        index: N.index,
        input: N.input,
        stack: [..._, b]
      };
      let x = E(...N, M);
      if (typeof x == "string" && (x = x.length > 0 ? {
        type: "text",
        value: x
      } : void 0), x === !1 ? A.lastIndex = F + 1 : (v !== F && w.push({
        type: "text",
        value: b.value.slice(v, F)
      }), Array.isArray(x) ? w.push(...x) : x && w.push(x), v = F + N[0].length, I = !0), !A.global)
        break;
      N = A.exec(b.value);
    }
    return I ? (v < b.value.length && w.push({
      type: "text",
      value: b.value.slice(v)
    }), y.children.splice(R, 1, ...w)) : w = [b], R + w.length;
  }
}
function toPairs(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const r = !e[0] || Array.isArray(e[0]) ? e : [e];
  let a = -1;
  for (; ++a < r.length; ) {
    const o = r[a];
    t.push([toExpression(o[0]), toFunction(o[1])]);
  }
  return t;
}
function toExpression(e) {
  return typeof e == "string" ? new RegExp(escapeStringRegexp(e), "g") : e;
}
function toFunction(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
function newlineToBreak(e) {
  findAndReplace(e, [/\r?\n|\r/g, replace$1]);
}
function replace$1() {
  return {
    type: "break"
  };
}
function remarkBreaks() {
  return function(e) {
    newlineToBreak(e);
  };
}
function ccount(e, t) {
  const r = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let a = 0, o = r.indexOf(t);
  for (; o !== -1; )
    a++, o = r.indexOf(t, o + t.length);
  return a;
}
const characterEntitiesLegacy = ["AElig", "AMP", "Aacute", "Acirc", "Agrave", "Aring", "Atilde", "Auml", "COPY", "Ccedil", "ETH", "Eacute", "Ecirc", "Egrave", "Euml", "GT", "Iacute", "Icirc", "Igrave", "Iuml", "LT", "Ntilde", "Oacute", "Ocirc", "Ograve", "Oslash", "Otilde", "Ouml", "QUOT", "REG", "THORN", "Uacute", "Ucirc", "Ugrave", "Uuml", "Yacute", "aacute", "acirc", "acute", "aelig", "agrave", "amp", "aring", "atilde", "auml", "brvbar", "ccedil", "cedil", "cent", "copy", "curren", "deg", "divide", "eacute", "ecirc", "egrave", "eth", "euml", "frac12", "frac14", "frac34", "gt", "iacute", "icirc", "iexcl", "igrave", "iquest", "iuml", "laquo", "lt", "macr", "micro", "middot", "nbsp", "not", "ntilde", "oacute", "ocirc", "ograve", "ordf", "ordm", "oslash", "otilde", "ouml", "para", "plusmn", "pound", "quot", "raquo", "reg", "sect", "shy", "sup1", "sup2", "sup3", "szlig", "thorn", "times", "uacute", "ucirc", "ugrave", "uml", "uuml", "yacute", "yen", "yuml"], characterReferenceInvalid = {
  0: "",
  128: "",
  130: "",
  131: "",
  132: "",
  133: "",
  134: "",
  135: "",
  136: "",
  137: "",
  138: "",
  139: "",
  140: "",
  142: "",
  145: "",
  146: "",
  147: "",
  148: "",
  149: "",
  150: "",
  151: "",
  152: "",
  153: "",
  154: "",
  155: "",
  156: "",
  158: "",
  159: ""
};
function isDecimal$1(e) {
  const t = typeof e == "string" ? e.charCodeAt(0) : e;
  return t >= 48 && t <= 57;
}
function isHexadecimal$1(e) {
  const t = typeof e == "string" ? e.charCodeAt(0) : e;
  return t >= 97 && t <= 102 || t >= 65 && t <= 70 || t >= 48 && t <= 57;
}
function isAlphabetical$1(e) {
  const t = typeof e == "string" ? e.charCodeAt(0) : e;
  return t >= 97 && t <= 122 || t >= 65 && t <= 90;
}
function isAlphanumerical$1(e) {
  return isAlphabetical$1(e) || isDecimal$1(e);
}
const messages$1 = [
  "",
  /* 1: Non terminated (named) */
  "Named character references must be terminated by a semicolon",
  /* 2: Non terminated (numeric) */
  "Numeric character references must be terminated by a semicolon",
  /* 3: Empty (named) */
  "Named character references cannot be empty",
  /* 4: Empty (numeric) */
  "Numeric character references cannot be empty",
  /* 5: Unknown (named) */
  "Named character references must be known",
  /* 6: Disallowed (numeric) */
  "Numeric character references cannot be disallowed",
  /* 7: Prohibited (numeric) */
  "Numeric character references cannot be outside the permissible Unicode range"
];
function parseEntities$1(e, t) {
  const r = t || {}, a = typeof r.additional == "string" ? r.additional.charCodeAt(0) : r.additional, o = [];
  let u = 0, c = -1, d = "", g, b;
  r.position && ("start" in r.position || "indent" in r.position ? (b = r.position.indent, g = r.position.start) : g = r.position);
  let _ = (g ? g.line : 0) || 1, y = (g ? g.column : 0) || 1, A = v(), E;
  for (u--; ++u <= e.length; )
    if (E === 10 && (y = (b ? b[c] : 0) || 1), E = e.charCodeAt(u), E === 38) {
      const I = e.charCodeAt(u + 1);
      if (I === 9 || I === 10 || I === 12 || I === 32 || I === 38 || I === 60 || Number.isNaN(I) || a && I === a) {
        d += String.fromCharCode(E), y++;
        continue;
      }
      const w = u + 1;
      let N = w, F = w, M;
      if (I === 35) {
        F = ++N;
        const X = e.charCodeAt(F);
        X === 88 || X === 120 ? (M = "hexadecimal", F = ++N) : M = "decimal";
      } else
        M = "named";
      let x = "", P = "", U = "";
      const L = M === "named" ? isAlphanumerical$1 : M === "decimal" ? isDecimal$1 : isHexadecimal$1;
      for (F--; ++F <= e.length; ) {
        const X = e.charCodeAt(F);
        if (!L(X))
          break;
        U += String.fromCharCode(X), M === "named" && characterEntitiesLegacy.includes(U) && (x = U, P = decodeNamedCharacterReference(U));
      }
      let H = e.charCodeAt(F) === 59;
      if (H) {
        F++;
        const X = M === "named" ? decodeNamedCharacterReference(U) : !1;
        X && (x = U, P = X);
      }
      let B = 1 + F - w, V = "";
      if (!(!H && r.nonTerminated === !1)) if (!U)
        M !== "named" && C(4, B);
      else if (M === "named") {
        if (H && !P)
          C(5, 1);
        else if (x !== U && (F = N + x.length, B = 1 + F - N, H = !1), !H) {
          const X = x ? 1 : 3;
          if (r.attribute) {
            const de = e.charCodeAt(F);
            de === 61 ? (C(X, B), P = "") : isAlphanumerical$1(de) ? P = "" : C(X, B);
          } else
            C(X, B);
        }
        V = P;
      } else {
        H || C(2, B);
        let X = Number.parseInt(U, M === "hexadecimal" ? 16 : 10);
        if (prohibited$1(X))
          C(7, B), V = "";
        else if (X in characterReferenceInvalid)
          C(6, B), V = characterReferenceInvalid[X];
        else {
          let de = "";
          disallowed$1(X) && C(6, B), X > 65535 && (X -= 65536, de += String.fromCharCode(X >>> 10 | 55296), X = 56320 | X & 1023), V = de + String.fromCharCode(X);
        }
      }
      if (V) {
        R(), A = v(), u = F - 1, y += F - w + 1, o.push(V);
        const X = v();
        X.offset++, r.reference && r.reference.call(r.referenceContext || void 0, V, {
          start: A,
          end: X
        }, e.slice(w - 1, F)), A = X;
      } else
        U = e.slice(w - 1, F), d += U, y += U.length, u = F - 1;
    } else
      E === 10 && (_++, c++, y = 0), Number.isNaN(E) ? R() : (d += String.fromCharCode(E), y++);
  return o.join("");
  function v() {
    return {
      line: _,
      column: y,
      offset: u + ((g ? g.offset : 0) || 0)
    };
  }
  function C(I, w) {
    let N;
    r.warning && (N = v(), N.column += w, N.offset += w, r.warning.call(r.warningContext || void 0, messages$1[I], N, I));
  }
  function R() {
    d && (o.push(d), r.text && r.text.call(r.textContext || void 0, d, {
      start: A,
      end: v()
    }), d = "");
  }
}
function prohibited$1(e) {
  return e >= 55296 && e <= 57343 || e > 1114111;
}
function disallowed$1(e) {
  return e >= 1 && e <= 8 || e === 11 || e >= 13 && e <= 31 || e >= 127 && e <= 159 || e >= 64976 && e <= 65007 || (e & 65535) === 65535 || (e & 65535) === 65534;
}
const defaultSubsetRegex = /["&'<>`]/g, surrogatePairsRegex = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, controlCharactersRegex = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
), regexEscapeRegex = /[|\\{}()[\]^$+*?.]/g, subsetToRegexCache = /* @__PURE__ */ new WeakMap();
function core$1(e, t) {
  if (e = e.replace(t.subset ? charactersToExpressionCached(t.subset) : defaultSubsetRegex, a), t.subset || t.escapeOnly)
    return e;
  return e.replace(surrogatePairsRegex, r).replace(controlCharactersRegex, a);
  function r(o, u, c) {
    return t.format((o.charCodeAt(0) - 55296) * 1024 + o.charCodeAt(1) - 56320 + 65536, c.charCodeAt(u + 2), t);
  }
  function a(o, u, c) {
    return t.format(o.charCodeAt(0), c.charCodeAt(u + 1), t);
  }
}
function charactersToExpressionCached(e) {
  let t = subsetToRegexCache.get(e);
  return t || (t = charactersToExpression(e), subsetToRegexCache.set(e, t)), t;
}
function charactersToExpression(e) {
  const t = [];
  let r = -1;
  for (; ++r < e.length; )
    t.push(e[r].replace(regexEscapeRegex, "\\$&"));
  return new RegExp("(?:" + t.join("|") + ")", "g");
}
function formatBasic(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function stringifyEntitiesLight(e, t) {
  return core$1(e, Object.assign({
    format: formatBasic
  }, t));
}
const own$6 = {}.hasOwnProperty, emptyOptions$2 = {}, shortcut = /^[^\t\n\r "#'.<=>`}]+$/, unquoted = /^[^\t\n\r "'<=>`}]+$/;
function directiveFromMarkdown() {
  return {
    canContainEols: ["textDirective"],
    enter: {
      directiveContainer: enterContainer,
      directiveContainerAttributes: enterAttributes,
      directiveContainerLabel: enterContainerLabel,
      directiveLeaf: enterLeaf,
      directiveLeafAttributes: enterAttributes,
      directiveText: enterText,
      directiveTextAttributes: enterAttributes
    },
    exit: {
      directiveContainer: exit$1,
      directiveContainerAttributeClassValue: exitAttributeClassValue,
      directiveContainerAttributeIdValue: exitAttributeIdValue,
      directiveContainerAttributeName: exitAttributeName,
      directiveContainerAttributeValue: exitAttributeValue,
      directiveContainerAttributes: exitAttributes,
      directiveContainerLabel: exitContainerLabel,
      directiveContainerName: exitName,
      directiveLeaf: exit$1,
      directiveLeafAttributeClassValue: exitAttributeClassValue,
      directiveLeafAttributeIdValue: exitAttributeIdValue,
      directiveLeafAttributeName: exitAttributeName,
      directiveLeafAttributeValue: exitAttributeValue,
      directiveLeafAttributes: exitAttributes,
      directiveLeafName: exitName,
      directiveText: exit$1,
      directiveTextAttributeClassValue: exitAttributeClassValue,
      directiveTextAttributeIdValue: exitAttributeIdValue,
      directiveTextAttributeName: exitAttributeName,
      directiveTextAttributeValue: exitAttributeValue,
      directiveTextAttributes: exitAttributes,
      directiveTextName: exitName
    }
  };
}
function directiveToMarkdown(e) {
  const t = emptyOptions$2;
  if (t.quote !== '"' && t.quote !== "'" && t.quote !== null && t.quote !== void 0)
    throw new Error("Invalid quote `" + t.quote + "`, expected `'` or `\"`");
  return r.peek = peekDirective, {
    handlers: {
      containerDirective: r,
      leafDirective: r,
      textDirective: r
    },
    unsafe: [{
      character: "\r",
      inConstruct: ["leafDirectiveLabel", "containerDirectiveLabel"]
    }, {
      character: `
`,
      inConstruct: ["leafDirectiveLabel", "containerDirectiveLabel"]
    }, {
      before: "[^:]",
      character: ":",
      after: "[A-Za-z]",
      inConstruct: ["phrasing"]
    }, {
      atBreak: !0,
      character: ":",
      after: ":"
    }]
  };
  function r(u, c, d, g) {
    const b = d.createTracker(g), _ = fence(u), y = d.enter(u.type);
    let A = b.move(_ + (u.name || "")), E;
    if (u.type === "containerDirective") {
      const v = (u.children || [])[0];
      E = inlineDirectiveLabel(v) ? v : void 0;
    } else
      E = u;
    if (E && E.children && E.children.length > 0) {
      const v = d.enter("label"), C = `${u.type}Label`, R = d.enter(C);
      A += b.move("["), A += b.move(d.containerPhrasing(E, {
        ...b.current(),
        before: A,
        after: "]"
      })), A += b.move("]"), R(), v();
    }
    if (A += b.move(a(u, d)), u.type === "containerDirective") {
      const v = (u.children || [])[0];
      let C = u;
      inlineDirectiveLabel(v) && (C = Object.assign({}, u, {
        children: u.children.slice(1)
      })), C && C.children && C.children.length > 0 && (A += b.move(`
`), A += b.move(d.containerFlow(C, b.current()))), A += b.move(`
` + _);
    }
    return y(), A;
  }
  function a(u, c) {
    const d = u.attributes || {}, g = [];
    let b, _, y, A;
    for (A in d)
      if (own$6.call(d, A) && d[A] !== void 0 && d[A] !== null) {
        const E = String(d[A]);
        if (A === "id")
          y = t.preferShortcut !== !1 && shortcut.test(E) ? "#" + E : o("id", E, u, c);
        else if (A === "class") {
          const v = E.split(/[\t\n\r ]+/g), C = [], R = [];
          let I = -1;
          for (; ++I < v.length; )
            (t.preferShortcut !== !1 && shortcut.test(v[I]) ? R : C).push(v[I]);
          b = C.length > 0 ? o("class", C.join(" "), u, c) : "", _ = R.length > 0 ? "." + R.join(".") : "";
        } else
          g.push(o(A, E, u, c));
      }
    return b && g.unshift(b), _ && g.unshift(_), y && g.unshift(y), g.length > 0 ? "{" + g.join(" ") + "}" : "";
  }
  function o(u, c, d, g) {
    if (t.collapseEmptyAttributes !== !1 && !c) return u;
    if (t.preferUnquoted && unquoted.test(c))
      return u + "=" + c;
    const b = t.quote || g.options.quote || '"', _ = b === '"' ? "'" : '"', y = t.quoteSmart && ccount(c, b) > ccount(c, _) ? _ : b, A = d.type === "textDirective" ? [y] : [y, `
`, "\r"];
    return u + "=" + y + stringifyEntitiesLight(c, {
      subset: A
    }) + y;
  }
}
function enterContainer(e) {
  enter.call(this, "containerDirective", e);
}
function enterLeaf(e) {
  enter.call(this, "leafDirective", e);
}
function enterText(e) {
  enter.call(this, "textDirective", e);
}
function enter(e, t) {
  this.enter({
    type: e,
    name: "",
    attributes: {},
    children: []
  }, t);
}
function exitName(e) {
  const t = this.stack[this.stack.length - 1];
  t.type === "containerDirective" || t.type === "leafDirective" || t.type, t.name = this.sliceSerialize(e);
}
function enterContainerLabel(e) {
  this.enter({
    type: "paragraph",
    data: {
      directiveLabel: !0
    },
    children: []
  }, e);
}
function exitContainerLabel(e) {
  this.exit(e);
}
function enterAttributes() {
  this.data.directiveAttributes = [], this.buffer();
}
function exitAttributeIdValue(e) {
  this.data.directiveAttributes.push(["id", parseEntities$1(this.sliceSerialize(e), {
    attribute: !0
  })]);
}
function exitAttributeClassValue(e) {
  this.data.directiveAttributes.push(["class", parseEntities$1(this.sliceSerialize(e), {
    attribute: !0
  })]);
}
function exitAttributeValue(e) {
  const t = this.data.directiveAttributes;
  t[t.length - 1][1] = parseEntities$1(this.sliceSerialize(e), {
    attribute: !0
  });
}
function exitAttributeName(e) {
  this.data.directiveAttributes.push([this.sliceSerialize(e), ""]);
}
function exitAttributes() {
  const e = this.data.directiveAttributes, t = {};
  let r = -1;
  for (; ++r < e.length; ) {
    const o = e[r];
    o[0] === "class" && t.class ? t.class += " " + o[1] : t[o[0]] = o[1];
  }
  this.data.directiveAttributes = void 0, this.resume();
  const a = this.stack[this.stack.length - 1];
  a.type === "containerDirective" || a.type === "leafDirective" || a.type, a.attributes = t;
}
function exit$1(e) {
  this.exit(e);
}
function peekDirective() {
  return ":";
}
function inlineDirectiveLabel(e) {
  return !!(e && e.type === "paragraph" && e.data && e.data.directiveLabel);
}
function fence(e) {
  let t = 0;
  return e.type === "containerDirective" ? (visitParents(e, function(r, a) {
    if (r.type === "containerDirective") {
      let o = a.length, u = 0;
      for (; o--; )
        a[o].type === "containerDirective" && u++;
      u > t && (t = u);
    }
  }), t += 3) : e.type === "leafDirective" ? t = 2 : t = 1, ":".repeat(t);
}
function factoryAttributes(e, t, r, a, o, u, c, d, g, b, _, y, A, E, v) {
  let C, R;
  return I;
  function I(Y) {
    return e.enter(a), e.enter(o), e.consume(Y), e.exit(o), w;
  }
  function w(Y) {
    return Y === 35 ? (C = c, N(Y)) : Y === 46 ? (C = d, N(Y)) : Y === 58 || Y === 95 || asciiAlpha(Y) ? (e.enter(u), e.enter(g), e.consume(Y), x) : v && markdownSpace(Y) ? factorySpace(e, w, "whitespace")(Y) : !v && markdownLineEndingOrSpace(Y) ? factoryWhitespace(e, w)(Y) : de(Y);
  }
  function N(Y) {
    const se = (
      /** @type {TokenType} */
      C + "Marker"
    );
    return e.enter(u), e.enter(C), e.enter(se), e.consume(Y), e.exit(se), F;
  }
  function F(Y) {
    if (Y === null || Y === 34 || Y === 35 || Y === 39 || Y === 46 || Y === 60 || Y === 61 || Y === 62 || Y === 96 || Y === 125 || markdownLineEndingOrSpace(Y))
      return r(Y);
    const se = (
      /** @type {TokenType} */
      C + "Value"
    );
    return e.enter(se), e.consume(Y), M;
  }
  function M(Y) {
    if (Y === null || Y === 34 || Y === 39 || Y === 60 || Y === 61 || Y === 62 || Y === 96)
      return r(Y);
    if (Y === 35 || Y === 46 || Y === 125 || markdownLineEndingOrSpace(Y)) {
      const se = (
        /** @type {TokenType} */
        C + "Value"
      );
      return e.exit(se), e.exit(C), e.exit(u), w(Y);
    }
    return e.consume(Y), M;
  }
  function x(Y) {
    return Y === 45 || Y === 46 || Y === 58 || Y === 95 || asciiAlphanumeric(Y) ? (e.consume(Y), x) : (e.exit(g), v && markdownSpace(Y) ? factorySpace(e, P, "whitespace")(Y) : !v && markdownLineEndingOrSpace(Y) ? factoryWhitespace(e, P)(Y) : P(Y));
  }
  function P(Y) {
    return Y === 61 ? (e.enter(b), e.consume(Y), e.exit(b), U) : (e.exit(u), w(Y));
  }
  function U(Y) {
    return Y === null || Y === 60 || Y === 61 || Y === 62 || Y === 96 || Y === 125 || v && markdownLineEnding(Y) ? r(Y) : Y === 34 || Y === 39 ? (e.enter(_), e.enter(A), e.consume(Y), e.exit(A), R = Y, H) : v && markdownSpace(Y) ? factorySpace(e, U, "whitespace")(Y) : !v && markdownLineEndingOrSpace(Y) ? factoryWhitespace(e, U)(Y) : (e.enter(y), e.enter(E), e.consume(Y), R = void 0, L);
  }
  function L(Y) {
    return Y === null || Y === 34 || Y === 39 || Y === 60 || Y === 61 || Y === 62 || Y === 96 ? r(Y) : Y === 125 || markdownLineEndingOrSpace(Y) ? (e.exit(E), e.exit(y), e.exit(u), w(Y)) : (e.consume(Y), L);
  }
  function H(Y) {
    return Y === R ? (e.enter(A), e.consume(Y), e.exit(A), e.exit(_), e.exit(u), X) : (e.enter(y), B(Y));
  }
  function B(Y) {
    return Y === R ? (e.exit(y), H(Y)) : Y === null ? r(Y) : markdownLineEnding(Y) ? v ? r(Y) : factoryWhitespace(e, B)(Y) : (e.enter(E), e.consume(Y), V);
  }
  function V(Y) {
    return Y === R || Y === null || markdownLineEnding(Y) ? (e.exit(E), B(Y)) : (e.consume(Y), V);
  }
  function X(Y) {
    return Y === 125 || markdownLineEndingOrSpace(Y) ? w(Y) : de(Y);
  }
  function de(Y) {
    return Y === 125 ? (e.enter(o), e.consume(Y), e.exit(o), e.exit(a), t) : r(Y);
  }
}
function factoryLabel(e, t, r, a, o, u, c) {
  let d = 0, g = 0, b;
  return _;
  function _(R) {
    return e.enter(a), e.enter(o), e.consume(R), e.exit(o), y;
  }
  function y(R) {
    return R === 93 ? (e.enter(o), e.consume(R), e.exit(o), e.exit(a), t) : (e.enter(u), A(R));
  }
  function A(R) {
    if (R === 93 && !g)
      return C(R);
    const I = e.enter("chunkText", {
      contentType: "text",
      previous: b
    });
    return b && (b.next = I), b = I, E(R);
  }
  function E(R) {
    return R === null || d > 999 || R === 91 && ++g > 32 ? r(R) : R === 93 && !g-- ? (e.exit("chunkText"), C(R)) : markdownLineEnding(R) ? c ? r(R) : (e.consume(R), e.exit("chunkText"), A) : (e.consume(R), R === 92 ? v : E);
  }
  function v(R) {
    return R === 91 || R === 92 || R === 93 ? (e.consume(R), d++, E) : E(R);
  }
  function C(R) {
    return e.exit(u), e.enter(o), e.consume(R), e.exit(o), e.exit(a), t;
  }
}
function factoryName(e, t, r, a) {
  const o = this;
  return u;
  function u(d) {
    return asciiAlpha(d) ? (e.enter(a), e.consume(d), c) : r(d);
  }
  function c(d) {
    return d === 45 || d === 95 || asciiAlphanumeric(d) ? (e.consume(d), c) : (e.exit(a), o.previous === 45 || o.previous === 95 ? r(d) : t(d));
  }
}
const directiveContainer = {
  tokenize: tokenizeDirectiveContainer,
  concrete: !0
}, label$2 = {
  tokenize: tokenizeLabel$2,
  partial: !0
}, attributes$3 = {
  tokenize: tokenizeAttributes$2,
  partial: !0
}, nonLazyLine = {
  tokenize: tokenizeNonLazyLine,
  partial: !0
};
function tokenizeDirectiveContainer(e, t, r) {
  const a = this, o = a.events[a.events.length - 1], u = o && o[1].type === "linePrefix" ? o[2].sliceSerialize(o[1], !0).length : 0;
  let c = 0, d;
  return g;
  function g(L) {
    return e.enter("directiveContainer"), e.enter("directiveContainerFence"), e.enter("directiveContainerSequence"), b(L);
  }
  function b(L) {
    return L === 58 ? (e.consume(L), c++, b) : c < 3 ? r(L) : (e.exit("directiveContainerSequence"), factoryName.call(a, e, _, r, "directiveContainerName")(L));
  }
  function _(L) {
    return L === 91 ? e.attempt(label$2, y, y)(L) : y(L);
  }
  function y(L) {
    return L === 123 ? e.attempt(attributes$3, A, A)(L) : A(L);
  }
  function A(L) {
    return factorySpace(e, E, "whitespace")(L);
  }
  function E(L) {
    return e.exit("directiveContainerFence"), L === null ? P(L) : markdownLineEnding(L) ? a.interrupt ? t(L) : e.attempt(nonLazyLine, v, P)(L) : r(L);
  }
  function v(L) {
    return L === null ? P(L) : markdownLineEnding(L) ? e.check(nonLazyLine, N, P)(L) : (e.enter("directiveContainerContent"), C(L));
  }
  function C(L) {
    return e.attempt({
      tokenize: U,
      partial: !0
    }, x, u ? factorySpace(e, R, "linePrefix", u + 1) : R)(L);
  }
  function R(L) {
    return L === null ? x(L) : markdownLineEnding(L) ? e.check(nonLazyLine, w, x)(L) : w(L);
  }
  function I(L) {
    if (L === null) {
      const H = e.exit("chunkDocument");
      return a.parser.lazy[H.start.line] = !1, x(L);
    }
    return markdownLineEnding(L) ? e.check(nonLazyLine, F, M)(L) : (e.consume(L), I);
  }
  function w(L) {
    const H = e.enter("chunkDocument", {
      contentType: "document",
      previous: d
    });
    return d && (d.next = H), d = H, I(L);
  }
  function N(L) {
    return e.enter("directiveContainerContent"), C(L);
  }
  function F(L) {
    e.consume(L);
    const H = e.exit("chunkDocument");
    return a.parser.lazy[H.start.line] = !1, C;
  }
  function M(L) {
    const H = e.exit("chunkDocument");
    return a.parser.lazy[H.start.line] = !1, x(L);
  }
  function x(L) {
    return e.exit("directiveContainerContent"), P(L);
  }
  function P(L) {
    return e.exit("directiveContainer"), t(L);
  }
  function U(L, H, B) {
    let V = 0;
    return factorySpace(L, X, "linePrefix", a.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
    function X(se) {
      return L.enter("directiveContainerFence"), L.enter("directiveContainerSequence"), de(se);
    }
    function de(se) {
      return se === 58 ? (L.consume(se), V++, de) : V < c ? B(se) : (L.exit("directiveContainerSequence"), factorySpace(L, Y, "whitespace")(se));
    }
    function Y(se) {
      return se === null || markdownLineEnding(se) ? (L.exit("directiveContainerFence"), H(se)) : B(se);
    }
  }
}
function tokenizeLabel$2(e, t, r) {
  return factoryLabel(e, t, r, "directiveContainerLabel", "directiveContainerLabelMarker", "directiveContainerLabelString", !0);
}
function tokenizeAttributes$2(e, t, r) {
  return factoryAttributes(e, t, r, "directiveContainerAttributes", "directiveContainerAttributesMarker", "directiveContainerAttribute", "directiveContainerAttributeId", "directiveContainerAttributeClass", "directiveContainerAttributeName", "directiveContainerAttributeInitializerMarker", "directiveContainerAttributeValueLiteral", "directiveContainerAttributeValue", "directiveContainerAttributeValueMarker", "directiveContainerAttributeValueData", !0);
}
function tokenizeNonLazyLine(e, t, r) {
  const a = this;
  return o;
  function o(c) {
    return e.enter("lineEnding"), e.consume(c), e.exit("lineEnding"), u;
  }
  function u(c) {
    return a.parser.lazy[a.now().line] ? r(c) : t(c);
  }
}
const directiveLeaf = {
  tokenize: tokenizeDirectiveLeaf
}, label$1 = {
  tokenize: tokenizeLabel$1,
  partial: !0
}, attributes$2 = {
  tokenize: tokenizeAttributes$1,
  partial: !0
};
function tokenizeDirectiveLeaf(e, t, r) {
  const a = this;
  return o;
  function o(_) {
    return e.enter("directiveLeaf"), e.enter("directiveLeafSequence"), e.consume(_), u;
  }
  function u(_) {
    return _ === 58 ? (e.consume(_), e.exit("directiveLeafSequence"), factoryName.call(a, e, c, r, "directiveLeafName")) : r(_);
  }
  function c(_) {
    return _ === 91 ? e.attempt(label$1, d, d)(_) : d(_);
  }
  function d(_) {
    return _ === 123 ? e.attempt(attributes$2, g, g)(_) : g(_);
  }
  function g(_) {
    return factorySpace(e, b, "whitespace")(_);
  }
  function b(_) {
    return _ === null || markdownLineEnding(_) ? (e.exit("directiveLeaf"), t(_)) : r(_);
  }
}
function tokenizeLabel$1(e, t, r) {
  return factoryLabel(e, t, r, "directiveLeafLabel", "directiveLeafLabelMarker", "directiveLeafLabelString", !0);
}
function tokenizeAttributes$1(e, t, r) {
  return factoryAttributes(e, t, r, "directiveLeafAttributes", "directiveLeafAttributesMarker", "directiveLeafAttribute", "directiveLeafAttributeId", "directiveLeafAttributeClass", "directiveLeafAttributeName", "directiveLeafAttributeInitializerMarker", "directiveLeafAttributeValueLiteral", "directiveLeafAttributeValue", "directiveLeafAttributeValueMarker", "directiveLeafAttributeValueData", !0);
}
const directiveText = {
  tokenize: tokenizeDirectiveText,
  previous: previous$2
}, label = {
  tokenize: tokenizeLabel,
  partial: !0
}, attributes$1 = {
  tokenize: tokenizeAttributes,
  partial: !0
};
function previous$2(e) {
  return e !== 58 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeDirectiveText(e, t, r) {
  const a = this;
  return o;
  function o(g) {
    return e.enter("directiveText"), e.enter("directiveTextMarker"), e.consume(g), e.exit("directiveTextMarker"), factoryName.call(a, e, u, r, "directiveTextName");
  }
  function u(g) {
    return g === 58 ? r(g) : g === 91 ? e.attempt(label, c, c)(g) : c(g);
  }
  function c(g) {
    return g === 123 ? e.attempt(attributes$1, d, d)(g) : d(g);
  }
  function d(g) {
    return e.exit("directiveText"), t(g);
  }
}
function tokenizeLabel(e, t, r) {
  return factoryLabel(e, t, r, "directiveTextLabel", "directiveTextLabelMarker", "directiveTextLabelString");
}
function tokenizeAttributes(e, t, r) {
  return factoryAttributes(e, t, r, "directiveTextAttributes", "directiveTextAttributesMarker", "directiveTextAttribute", "directiveTextAttributeId", "directiveTextAttributeClass", "directiveTextAttributeName", "directiveTextAttributeInitializerMarker", "directiveTextAttributeValueLiteral", "directiveTextAttributeValue", "directiveTextAttributeValueMarker", "directiveTextAttributeValueData");
}
function directive() {
  return {
    text: {
      58: directiveText
    },
    flow: {
      58: [directiveContainer, directiveLeaf]
    }
  };
}
function remarkDirective() {
  const t = /** @type {Processor<Root>} */ this.data(), r = t.micromarkExtensions || (t.micromarkExtensions = []), a = t.fromMarkdownExtensions || (t.fromMarkdownExtensions = []), o = t.toMarkdownExtensions || (t.toMarkdownExtensions = []);
  r.push(directive()), a.push(directiveFromMarkdown()), o.push(directiveToMarkdown());
}
const inConstruct = "phrasing", notInConstruct = ["autolink", "link", "image", "label"];
function gfmAutolinkLiteralFromMarkdown() {
  return {
    transforms: [transformGfmAutolinkLiterals],
    enter: {
      literalAutolink: enterLiteralAutolink,
      literalAutolinkEmail: enterLiteralAutolinkValue,
      literalAutolinkHttp: enterLiteralAutolinkValue,
      literalAutolinkWww: enterLiteralAutolinkValue
    },
    exit: {
      literalAutolink: exitLiteralAutolink,
      literalAutolinkEmail: exitLiteralAutolinkEmail,
      literalAutolinkHttp: exitLiteralAutolinkHttp,
      literalAutolinkWww: exitLiteralAutolinkWww
    }
  };
}
function gfmAutolinkLiteralToMarkdown() {
  return {
    unsafe: [{
      character: "@",
      before: "[+\\-.\\w]",
      after: "[\\-.\\w]",
      inConstruct,
      notInConstruct
    }, {
      character: ".",
      before: "[Ww]",
      after: "[\\-.\\w]",
      inConstruct,
      notInConstruct
    }, {
      character: ":",
      before: "[ps]",
      after: "\\/",
      inConstruct,
      notInConstruct
    }]
  };
}
function enterLiteralAutolink(e) {
  this.enter({
    type: "link",
    title: null,
    url: "",
    children: []
  }, e);
}
function enterLiteralAutolinkValue(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function exitLiteralAutolinkHttp(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function exitLiteralAutolinkWww(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function exitLiteralAutolinkEmail(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function exitLiteralAutolink(e) {
  this.exit(e);
}
function transformGfmAutolinkLiterals(e) {
  findAndReplace(e, [[/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl], [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), findEmail]], {
    ignore: ["link", "linkReference"]
  });
}
function findUrl(e, t, r, a, o) {
  let u = "";
  if (!previous$1(o) || (/^w/i.test(t) && (r = t + r, t = "", u = "http://"), !isCorrectDomain(r)))
    return !1;
  const c = splitUrl(r + a);
  if (!c[0]) return !1;
  const d = {
    type: "link",
    title: null,
    url: u + t + c[0],
    children: [{
      type: "text",
      value: t + c[0]
    }]
  };
  return c[1] ? [d, {
    type: "text",
    value: c[1]
  }] : d;
}
function findEmail(e, t, r, a) {
  return (
    // Not an expected previous character.
    !previous$1(a, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(r) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + r,
      children: [{
        type: "text",
        value: t + "@" + r
      }]
    }
  );
}
function isCorrectDomain(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function splitUrl(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let r = t[0], a = r.indexOf(")");
  const o = ccount(e, "(");
  let u = ccount(e, ")");
  for (; a !== -1 && o > u; )
    e += r.slice(0, a + 1), r = r.slice(a + 1), a = r.indexOf(")"), u++;
  return [e, r];
}
function previous$1(e, t) {
  const r = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || unicodeWhitespace(r) || unicodePunctuation(r)) && // If its an email, the previous character should not be a slash.
  (!t || r !== 47);
}
footnoteReference.peek = footnoteReferencePeek;
function enterFootnoteCallString() {
  this.buffer();
}
function enterFootnoteCall(e) {
  this.enter({
    type: "footnoteReference",
    identifier: "",
    label: ""
  }, e);
}
function enterFootnoteDefinitionLabelString() {
  this.buffer();
}
function enterFootnoteDefinition(e) {
  this.enter({
    type: "footnoteDefinition",
    identifier: "",
    label: "",
    children: []
  }, e);
}
function exitFootnoteCallString(e) {
  const t = this.resume(), r = this.stack[this.stack.length - 1];
  r.type, r.identifier = normalizeIdentifier(this.sliceSerialize(e)).toLowerCase(), r.label = t;
}
function exitFootnoteCall(e) {
  this.exit(e);
}
function exitFootnoteDefinitionLabelString(e) {
  const t = this.resume(), r = this.stack[this.stack.length - 1];
  r.type, r.identifier = normalizeIdentifier(this.sliceSerialize(e)).toLowerCase(), r.label = t;
}
function exitFootnoteDefinition(e) {
  this.exit(e);
}
function footnoteReferencePeek() {
  return "[";
}
function footnoteReference(e, t, r, a) {
  const o = r.createTracker(a);
  let u = o.move("[^");
  const c = r.enter("footnoteReference"), d = r.enter("reference");
  return u += o.move(r.safe(r.associationId(e), {
    after: "]",
    before: u
  })), d(), c(), u += o.move("]"), u;
}
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteCallString: enterFootnoteCallString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteDefinition: enterFootnoteDefinition
    },
    exit: {
      gfmFootnoteCallString: exitFootnoteCallString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteDefinition: exitFootnoteDefinition
    }
  };
}
function gfmFootnoteToMarkdown(e) {
  let t = !1;
  return e && e.firstLineBlank && (t = !0), {
    handlers: {
      footnoteDefinition: r,
      footnoteReference
    },
    // This is on by default already.
    unsafe: [{
      character: "[",
      inConstruct: ["label", "phrasing", "reference"]
    }]
  };
  function r(a, o, u, c) {
    const d = u.createTracker(c);
    let g = d.move("[^");
    const b = u.enter("footnoteDefinition"), _ = u.enter("label");
    return g += d.move(u.safe(u.associationId(a), {
      before: g,
      after: "]"
    })), _(), g += d.move("]:"), a.children && a.children.length > 0 && (d.shift(4), g += d.move((t ? `
` : " ") + u.indentLines(u.containerFlow(a, d.current()), t ? mapAll : mapExceptFirst))), b(), g;
  }
}
function mapExceptFirst(e, t, r) {
  return t === 0 ? e : mapAll(e, t, r);
}
function mapAll(e, t, r) {
  return (r ? "" : "    ") + e;
}
const constructsWithoutStrikethrough = ["autolink", "destinationLiteral", "destinationRaw", "reference", "titleQuote", "titleApostrophe"];
handleDelete.peek = peekDelete;
function gfmStrikethroughFromMarkdown() {
  return {
    canContainEols: ["delete"],
    enter: {
      strikethrough: enterStrikethrough
    },
    exit: {
      strikethrough: exitStrikethrough
    }
  };
}
function gfmStrikethroughToMarkdown() {
  return {
    unsafe: [{
      character: "~",
      inConstruct: "phrasing",
      notInConstruct: constructsWithoutStrikethrough
    }],
    handlers: {
      delete: handleDelete
    }
  };
}
function enterStrikethrough(e) {
  this.enter({
    type: "delete",
    children: []
  }, e);
}
function exitStrikethrough(e) {
  this.exit(e);
}
function handleDelete(e, t, r, a) {
  const o = r.createTracker(a), u = r.enter("strikethrough");
  let c = o.move("~~");
  return c += r.containerPhrasing(e, {
    ...o.current(),
    before: c,
    after: "~"
  }), c += o.move("~~"), u(), c;
}
function peekDelete() {
  return "~";
}
function defaultStringLength(e) {
  return e.length;
}
function markdownTable(e, t) {
  const r = t || {}, a = (r.align || []).concat(), o = r.stringLength || defaultStringLength, u = [], c = [], d = [], g = [];
  let b = 0, _ = -1;
  for (; ++_ < e.length; ) {
    const C = [], R = [];
    let I = -1;
    for (e[_].length > b && (b = e[_].length); ++I < e[_].length; ) {
      const w = serialize(e[_][I]);
      if (r.alignDelimiters !== !1) {
        const N = o(w);
        R[I] = N, (g[I] === void 0 || N > g[I]) && (g[I] = N);
      }
      C.push(w);
    }
    c[_] = C, d[_] = R;
  }
  let y = -1;
  if (typeof a == "object" && "length" in a)
    for (; ++y < b; )
      u[y] = toAlignment(a[y]);
  else {
    const C = toAlignment(a);
    for (; ++y < b; )
      u[y] = C;
  }
  y = -1;
  const A = [], E = [];
  for (; ++y < b; ) {
    const C = u[y];
    let R = "", I = "";
    C === 99 ? (R = ":", I = ":") : C === 108 ? R = ":" : C === 114 && (I = ":");
    let w = r.alignDelimiters === !1 ? 1 : Math.max(1, g[y] - R.length - I.length);
    const N = R + "-".repeat(w) + I;
    r.alignDelimiters !== !1 && (w = R.length + w + I.length, w > g[y] && (g[y] = w), E[y] = w), A[y] = N;
  }
  c.splice(1, 0, A), d.splice(1, 0, E), _ = -1;
  const v = [];
  for (; ++_ < c.length; ) {
    const C = c[_], R = d[_];
    y = -1;
    const I = [];
    for (; ++y < b; ) {
      const w = C[y] || "";
      let N = "", F = "";
      if (r.alignDelimiters !== !1) {
        const M = g[y] - (R[y] || 0), x = u[y];
        x === 114 ? N = " ".repeat(M) : x === 99 ? M % 2 ? (N = " ".repeat(M / 2 + 0.5), F = " ".repeat(M / 2 - 0.5)) : (N = " ".repeat(M / 2), F = N) : F = " ".repeat(M);
      }
      r.delimiterStart !== !1 && !y && I.push("|"), r.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(r.alignDelimiters === !1 && w === "") && (r.delimiterStart !== !1 || y) && I.push(" "), r.alignDelimiters !== !1 && I.push(N), I.push(w), r.alignDelimiters !== !1 && I.push(F), r.padding !== !1 && I.push(" "), (r.delimiterEnd !== !1 || y !== b - 1) && I.push("|");
    }
    v.push(r.delimiterEnd === !1 ? I.join("").replace(/ +$/, "") : I.join(""));
  }
  return v.join(`
`);
}
function serialize(e) {
  return e == null ? "" : String(e);
}
function toAlignment(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function blockquote(e, t, r, a) {
  const o = r.enter("blockquote"), u = r.createTracker(a);
  u.move("> "), u.shift(2);
  const c = r.indentLines(r.containerFlow(e, u.current()), map$1);
  return o(), c;
}
function map$1(e, t, r) {
  return ">" + (r ? "" : " ") + e;
}
function patternInScope(e, t) {
  return listInScope(e, t.inConstruct, !0) && !listInScope(e, t.notInConstruct, !1);
}
function listInScope(e, t, r) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return r;
  let a = -1;
  for (; ++a < t.length; )
    if (e.includes(t[a]))
      return !0;
  return !1;
}
function hardBreak(e, t, r, a) {
  let o = -1;
  for (; ++o < r.unsafe.length; )
    if (r.unsafe[o].character === `
` && patternInScope(r.stack, r.unsafe[o]))
      return /[ \t]/.test(a.before) ? "" : " ";
  return `\\
`;
}
function longestStreak(e, t) {
  const r = String(e);
  let a = r.indexOf(t), o = a, u = 0, c = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; a !== -1; )
    a === o ? ++u > c && (c = u) : u = 1, o = a + t.length, a = r.indexOf(t, o);
  return c;
}
function formatCodeAsIndented(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function checkFence(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error("Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`");
  return t;
}
function code$1(e, t, r, a) {
  const o = checkFence(r), u = e.value || "", c = o === "`" ? "GraveAccent" : "Tilde";
  if (formatCodeAsIndented(e, r)) {
    const y = r.enter("codeIndented"), A = r.indentLines(u, map);
    return y(), A;
  }
  const d = r.createTracker(a), g = o.repeat(Math.max(longestStreak(u, o) + 1, 3)), b = r.enter("codeFenced");
  let _ = d.move(g);
  if (e.lang) {
    const y = r.enter(`codeFencedLang${c}`);
    _ += d.move(r.safe(e.lang, {
      before: _,
      after: " ",
      encode: ["`"],
      ...d.current()
    })), y();
  }
  if (e.lang && e.meta) {
    const y = r.enter(`codeFencedMeta${c}`);
    _ += d.move(" "), _ += d.move(r.safe(e.meta, {
      before: _,
      after: `
`,
      encode: ["`"],
      ...d.current()
    })), y();
  }
  return _ += d.move(`
`), u && (_ += d.move(u + `
`)), _ += d.move(g), b(), _;
}
function map(e, t, r) {
  return (r ? "" : "    ") + e;
}
function checkQuote(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error("Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`");
  return t;
}
function definition(e, t, r, a) {
  const o = checkQuote(r), u = o === '"' ? "Quote" : "Apostrophe", c = r.enter("definition");
  let d = r.enter("label");
  const g = r.createTracker(a);
  let b = g.move("[");
  return b += g.move(r.safe(r.associationId(e), {
    before: b,
    after: "]",
    ...g.current()
  })), b += g.move("]: "), d(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (d = r.enter("destinationLiteral"), b += g.move("<"), b += g.move(r.safe(e.url, {
    before: b,
    after: ">",
    ...g.current()
  })), b += g.move(">")) : (d = r.enter("destinationRaw"), b += g.move(r.safe(e.url, {
    before: b,
    after: e.title ? " " : `
`,
    ...g.current()
  }))), d(), e.title && (d = r.enter(`title${u}`), b += g.move(" " + o), b += g.move(r.safe(e.title, {
    before: b,
    after: o,
    ...g.current()
  })), b += g.move(o), d()), c(), b;
}
function checkEmphasis(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error("Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`");
  return t;
}
function encodeCharacterReference(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function encodeInfo(e, t, r) {
  const a = classifyCharacter(e), o = classifyCharacter(t);
  return a === void 0 ? o === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    r === "_" ? {
      inside: !0,
      outside: !0
    } : {
      inside: !1,
      outside: !1
    }
  ) : o === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    {
      inside: !0,
      outside: !0
    }
  ) : (
    // Punctuation inside: encode outer (letter)
    {
      inside: !1,
      outside: !0
    }
  ) : a === 1 ? o === void 0 ? (
    // Letter inside: already forms.
    {
      inside: !1,
      outside: !1
    }
  ) : o === 1 ? (
    // Whitespace inside: encode both (whitespace).
    {
      inside: !0,
      outside: !0
    }
  ) : (
    // Punctuation inside: already forms.
    {
      inside: !1,
      outside: !1
    }
  ) : o === void 0 ? (
    // Letter inside: already forms.
    {
      inside: !1,
      outside: !1
    }
  ) : o === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    {
      inside: !0,
      outside: !1
    }
  ) : (
    // Punctuation inside: already forms.
    {
      inside: !1,
      outside: !1
    }
  );
}
emphasis.peek = emphasisPeek;
function emphasis(e, t, r, a) {
  const o = checkEmphasis(r), u = r.enter("emphasis"), c = r.createTracker(a), d = c.move(o);
  let g = c.move(r.containerPhrasing(e, {
    after: o,
    before: d,
    ...c.current()
  }));
  const b = g.charCodeAt(0), _ = encodeInfo(a.before.charCodeAt(a.before.length - 1), b, o);
  _.inside && (g = encodeCharacterReference(b) + g.slice(1));
  const y = g.charCodeAt(g.length - 1), A = encodeInfo(a.after.charCodeAt(0), y, o);
  A.inside && (g = g.slice(0, -1) + encodeCharacterReference(y));
  const E = c.move(o);
  return u(), r.attentionEncodeSurroundingInfo = {
    after: A.outside,
    before: _.outside
  }, d + g + E;
}
function emphasisPeek(e, t, r) {
  return r.options.emphasis || "*";
}
function formatHeadingAsSetext(e, t) {
  let r = !1;
  return visit(e, function(a) {
    if ("value" in a && /\r?\n|\r/.test(a.value) || a.type === "break")
      return r = !0, EXIT;
  }), !!((!e.depth || e.depth < 3) && toString$1(e) && (t.options.setext || r));
}
function heading(e, t, r, a) {
  const o = Math.max(Math.min(6, e.depth || 1), 1), u = r.createTracker(a);
  if (formatHeadingAsSetext(e, r)) {
    const _ = r.enter("headingSetext"), y = r.enter("phrasing"), A = r.containerPhrasing(e, {
      ...u.current(),
      before: `
`,
      after: `
`
    });
    return y(), _(), A + `
` + (o === 1 ? "=" : "-").repeat(
      // The whole size
      A.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(A.lastIndexOf("\r"), A.lastIndexOf(`
`)) + 1)
    );
  }
  const c = "#".repeat(o), d = r.enter("headingAtx"), g = r.enter("phrasing");
  u.move(c + " ");
  let b = r.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...u.current()
  });
  return /^[\t ]/.test(b) && (b = encodeCharacterReference(b.charCodeAt(0)) + b.slice(1)), b = b ? c + " " + b : c, r.options.closeAtx && (b += " " + c), g(), d(), b;
}
html$3.peek = htmlPeek;
function html$3(e) {
  return e.value || "";
}
function htmlPeek() {
  return "<";
}
image.peek = imagePeek;
function image(e, t, r, a) {
  const o = checkQuote(r), u = o === '"' ? "Quote" : "Apostrophe", c = r.enter("image");
  let d = r.enter("label");
  const g = r.createTracker(a);
  let b = g.move("![");
  return b += g.move(r.safe(e.alt, {
    before: b,
    after: "]",
    ...g.current()
  })), b += g.move("]("), d(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (d = r.enter("destinationLiteral"), b += g.move("<"), b += g.move(r.safe(e.url, {
    before: b,
    after: ">",
    ...g.current()
  })), b += g.move(">")) : (d = r.enter("destinationRaw"), b += g.move(r.safe(e.url, {
    before: b,
    after: e.title ? " " : ")",
    ...g.current()
  }))), d(), e.title && (d = r.enter(`title${u}`), b += g.move(" " + o), b += g.move(r.safe(e.title, {
    before: b,
    after: o,
    ...g.current()
  })), b += g.move(o), d()), b += g.move(")"), c(), b;
}
function imagePeek() {
  return "!";
}
imageReference.peek = imageReferencePeek;
function imageReference(e, t, r, a) {
  const o = e.referenceType, u = r.enter("imageReference");
  let c = r.enter("label");
  const d = r.createTracker(a);
  let g = d.move("![");
  const b = r.safe(e.alt, {
    before: g,
    after: "]",
    ...d.current()
  });
  g += d.move(b + "]["), c();
  const _ = r.stack;
  r.stack = [], c = r.enter("reference");
  const y = r.safe(r.associationId(e), {
    before: g,
    after: "]",
    ...d.current()
  });
  return c(), r.stack = _, u(), o === "full" || !b || b !== y ? g += d.move(y + "]") : o === "shortcut" ? g = g.slice(0, -1) : g += d.move("]"), g;
}
function imageReferencePeek() {
  return "!";
}
inlineCode.peek = inlineCodePeek;
function inlineCode(e, t, r) {
  let a = e.value || "", o = "`", u = -1;
  for (; new RegExp("(^|[^`])" + o + "([^`]|$)").test(a); )
    o += "`";
  for (/[^ \r\n]/.test(a) && (/^[ \r\n]/.test(a) && /[ \r\n]$/.test(a) || /^`|`$/.test(a)) && (a = " " + a + " "); ++u < r.unsafe.length; ) {
    const c = r.unsafe[u], d = r.compilePattern(c);
    let g;
    if (c.atBreak)
      for (; g = d.exec(a); ) {
        let b = g.index;
        a.charCodeAt(b) === 10 && a.charCodeAt(b - 1) === 13 && b--, a = a.slice(0, b) + " " + a.slice(g.index + 1);
      }
  }
  return o + a + o;
}
function inlineCodePeek() {
  return "`";
}
function formatLinkAsAutolink(e, t) {
  const r = toString$1(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (r === e.url || "mailto:" + r === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
link.peek = linkPeek;
function link(e, t, r, a) {
  const o = checkQuote(r), u = o === '"' ? "Quote" : "Apostrophe", c = r.createTracker(a);
  let d, g;
  if (formatLinkAsAutolink(e, r)) {
    const _ = r.stack;
    r.stack = [], d = r.enter("autolink");
    let y = c.move("<");
    return y += c.move(r.containerPhrasing(e, {
      before: y,
      after: ">",
      ...c.current()
    })), y += c.move(">"), d(), r.stack = _, y;
  }
  d = r.enter("link"), g = r.enter("label");
  let b = c.move("[");
  return b += c.move(r.containerPhrasing(e, {
    before: b,
    after: "](",
    ...c.current()
  })), b += c.move("]("), g(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (g = r.enter("destinationLiteral"), b += c.move("<"), b += c.move(r.safe(e.url, {
    before: b,
    after: ">",
    ...c.current()
  })), b += c.move(">")) : (g = r.enter("destinationRaw"), b += c.move(r.safe(e.url, {
    before: b,
    after: e.title ? " " : ")",
    ...c.current()
  }))), g(), e.title && (g = r.enter(`title${u}`), b += c.move(" " + o), b += c.move(r.safe(e.title, {
    before: b,
    after: o,
    ...c.current()
  })), b += c.move(o), g()), b += c.move(")"), d(), b;
}
function linkPeek(e, t, r) {
  return formatLinkAsAutolink(e, r) ? "<" : "[";
}
linkReference.peek = linkReferencePeek;
function linkReference(e, t, r, a) {
  const o = e.referenceType, u = r.enter("linkReference");
  let c = r.enter("label");
  const d = r.createTracker(a);
  let g = d.move("[");
  const b = r.containerPhrasing(e, {
    before: g,
    after: "]",
    ...d.current()
  });
  g += d.move(b + "]["), c();
  const _ = r.stack;
  r.stack = [], c = r.enter("reference");
  const y = r.safe(r.associationId(e), {
    before: g,
    after: "]",
    ...d.current()
  });
  return c(), r.stack = _, u(), o === "full" || !b || b !== y ? g += d.move(y + "]") : o === "shortcut" ? g = g.slice(0, -1) : g += d.move("]"), g;
}
function linkReferencePeek() {
  return "[";
}
function checkBullet(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error("Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`");
  return t;
}
function checkBulletOther(e) {
  const t = checkBullet(e), r = e.options.bulletOther;
  if (!r)
    return t === "*" ? "-" : "*";
  if (r !== "*" && r !== "+" && r !== "-")
    throw new Error("Cannot serialize items with `" + r + "` for `options.bulletOther`, expected `*`, `+`, or `-`");
  if (r === t)
    throw new Error("Expected `bullet` (`" + t + "`) and `bulletOther` (`" + r + "`) to be different");
  return r;
}
function checkBulletOrdered(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error("Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`");
  return t;
}
function checkRule(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error("Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`");
  return t;
}
function list(e, t, r, a) {
  const o = r.enter("list"), u = r.bulletCurrent;
  let c = e.ordered ? checkBulletOrdered(r) : checkBullet(r);
  const d = e.ordered ? c === "." ? ")" : "." : checkBulletOther(r);
  let g = t && r.bulletLastUsed ? c === r.bulletLastUsed : !1;
  if (!e.ordered) {
    const _ = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (c === "*" || c === "-") && // Empty first list item:
      _ && (!_.children || !_.children[0]) && // Directly in two other list items:
      r.stack[r.stack.length - 1] === "list" && r.stack[r.stack.length - 2] === "listItem" && r.stack[r.stack.length - 3] === "list" && r.stack[r.stack.length - 4] === "listItem" && // That are each the first child.
      r.indexStack[r.indexStack.length - 1] === 0 && r.indexStack[r.indexStack.length - 2] === 0 && r.indexStack[r.indexStack.length - 3] === 0 && (g = !0), checkRule(r) === c && _
    ) {
      let y = -1;
      for (; ++y < e.children.length; ) {
        const A = e.children[y];
        if (A && A.type === "listItem" && A.children && A.children[0] && A.children[0].type === "thematicBreak") {
          g = !0;
          break;
        }
      }
    }
  }
  g && (c = d), r.bulletCurrent = c;
  const b = r.containerFlow(e, a);
  return r.bulletLastUsed = c, r.bulletCurrent = u, o(), b;
}
function checkListItemIndent(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error("Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`");
  return t;
}
function listItem(e, t, r, a) {
  const o = checkListItemIndent(r);
  let u = r.bulletCurrent || checkBullet(r);
  t && t.type === "list" && t.ordered && (u = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (r.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + u);
  let c = u.length + 1;
  (o === "tab" || o === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (c = Math.ceil(c / 4) * 4);
  const d = r.createTracker(a);
  d.move(u + " ".repeat(c - u.length)), d.shift(c);
  const g = r.enter("listItem"), b = r.indentLines(r.containerFlow(e, d.current()), _);
  return g(), b;
  function _(y, A, E) {
    return A ? (E ? "" : " ".repeat(c)) + y : (E ? u : u + " ".repeat(c - u.length)) + y;
  }
}
function paragraph(e, t, r, a) {
  const o = r.enter("paragraph"), u = r.enter("phrasing"), c = r.containerPhrasing(e, a);
  return u(), o(), c;
}
const phrasing = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  convert([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function root$1(e, t, r, a) {
  return (e.children.some(function(c) {
    return phrasing(c);
  }) ? r.containerPhrasing : r.containerFlow).call(r, e, a);
}
function checkStrong(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error("Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`");
  return t;
}
strong.peek = strongPeek;
function strong(e, t, r, a) {
  const o = checkStrong(r), u = r.enter("strong"), c = r.createTracker(a), d = c.move(o + o);
  let g = c.move(r.containerPhrasing(e, {
    after: o,
    before: d,
    ...c.current()
  }));
  const b = g.charCodeAt(0), _ = encodeInfo(a.before.charCodeAt(a.before.length - 1), b, o);
  _.inside && (g = encodeCharacterReference(b) + g.slice(1));
  const y = g.charCodeAt(g.length - 1), A = encodeInfo(a.after.charCodeAt(0), y, o);
  A.inside && (g = g.slice(0, -1) + encodeCharacterReference(y));
  const E = c.move(o + o);
  return u(), r.attentionEncodeSurroundingInfo = {
    after: A.outside,
    before: _.outside
  }, d + g + E;
}
function strongPeek(e, t, r) {
  return r.options.strong || "*";
}
function text$3(e, t, r, a) {
  return r.safe(e.value, a);
}
function checkRuleRepetition(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error("Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more");
  return t;
}
function thematicBreak(e, t, r) {
  const a = (checkRule(r) + (r.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(r));
  return r.options.ruleSpaces ? a.slice(0, -1) : a;
}
const handle = {
  blockquote,
  break: hardBreak,
  code: code$1,
  definition,
  emphasis,
  hardBreak,
  heading,
  html: html$3,
  image,
  imageReference,
  inlineCode,
  link,
  linkReference,
  list,
  listItem,
  paragraph,
  root: root$1,
  strong,
  text: text$3,
  thematicBreak
};
function gfmTableFromMarkdown() {
  return {
    enter: {
      table: enterTable,
      tableData: enterCell,
      tableHeader: enterCell,
      tableRow: enterRow
    },
    exit: {
      codeText: exitCodeText,
      table: exitTable,
      tableData: exit,
      tableHeader: exit,
      tableRow: exit
    }
  };
}
function enterTable(e) {
  const t = e._align;
  this.enter({
    type: "table",
    align: t.map(function(r) {
      return r === "none" ? null : r;
    }),
    children: []
  }, e), this.data.inTable = !0;
}
function exitTable(e) {
  this.exit(e), this.data.inTable = void 0;
}
function enterRow(e) {
  this.enter({
    type: "tableRow",
    children: []
  }, e);
}
function exit(e) {
  this.exit(e);
}
function enterCell(e) {
  this.enter({
    type: "tableCell",
    children: []
  }, e);
}
function exitCodeText(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, replace));
  const r = this.stack[this.stack.length - 1];
  r.type, r.value = t, this.exit(e);
}
function replace(e, t) {
  return t === "|" ? t : e;
}
function gfmTableToMarkdown(e) {
  const t = e || {}, r = t.tableCellPadding, a = t.tablePipeAlign, o = t.stringLength, u = r ? " " : "|";
  return {
    unsafe: [
      {
        character: "\r",
        inConstruct: "tableCell"
      },
      {
        character: `
`,
        inConstruct: "tableCell"
      },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      {
        atBreak: !0,
        character: "|",
        after: "[	 :-]"
      },
      // A pipe in a cell must be encoded.
      {
        character: "|",
        inConstruct: "tableCell"
      },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      {
        atBreak: !0,
        character: ":",
        after: "-"
      },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      {
        atBreak: !0,
        character: "-",
        after: "[:|-]"
      }
    ],
    handlers: {
      inlineCode: A,
      table: c,
      tableCell: g,
      tableRow: d
    }
  };
  function c(E, v, C, R) {
    return b(_(E, C, R), E.align);
  }
  function d(E, v, C, R) {
    const I = y(E, C, R), w = b([I]);
    return w.slice(0, w.indexOf(`
`));
  }
  function g(E, v, C, R) {
    const I = C.enter("tableCell"), w = C.enter("phrasing"), N = C.containerPhrasing(E, {
      ...R,
      before: u,
      after: u
    });
    return w(), I(), N;
  }
  function b(E, v) {
    return markdownTable(E, {
      align: v,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: a,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: o
    });
  }
  function _(E, v, C) {
    const R = E.children;
    let I = -1;
    const w = [], N = v.enter("table");
    for (; ++I < R.length; )
      w[I] = y(R[I], v, C);
    return N(), w;
  }
  function y(E, v, C) {
    const R = E.children;
    let I = -1;
    const w = [], N = v.enter("tableRow");
    for (; ++I < R.length; )
      w[I] = g(R[I], E, v, C);
    return N(), w;
  }
  function A(E, v, C) {
    let R = handle.inlineCode(E, v, C);
    return C.stack.includes("tableCell") && (R = R.replace(/\|/g, "\\$&")), R;
  }
}
function gfmTaskListItemFromMarkdown() {
  return {
    exit: {
      taskListCheckValueChecked: exitCheck,
      taskListCheckValueUnchecked: exitCheck,
      paragraph: exitParagraphWithTaskListItem
    }
  };
}
function gfmTaskListItemToMarkdown() {
  return {
    unsafe: [{
      atBreak: !0,
      character: "-",
      after: "[:|-]"
    }],
    handlers: {
      listItem: listItemWithTaskListItem
    }
  };
}
function exitCheck(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const r = this.stack[this.stack.length - 1];
    r.type;
    const a = r.children[0];
    if (a && a.type === "text") {
      const o = t.children;
      let u = -1, c;
      for (; ++u < o.length; ) {
        const d = o[u];
        if (d.type === "paragraph") {
          c = d;
          break;
        }
      }
      c === r && (a.value = a.value.slice(1), a.value.length === 0 ? r.children.shift() : r.position && a.position && typeof a.position.start.offset == "number" && (a.position.start.column++, a.position.start.offset++, r.position.start = Object.assign({}, a.position.start)));
    }
  }
  this.exit(e);
}
function listItemWithTaskListItem(e, t, r, a) {
  const o = e.children[0], u = typeof e.checked == "boolean" && o && o.type === "paragraph", c = "[" + (e.checked ? "x" : " ") + "] ", d = r.createTracker(a);
  u && d.move(c);
  let g = handle.listItem(e, t, r, {
    ...a,
    ...d.current()
  });
  return u && (g = g.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, b)), g;
  function b(_) {
    return _ + c;
  }
}
function gfmFromMarkdown() {
  return [gfmAutolinkLiteralFromMarkdown(), gfmFootnoteFromMarkdown(), gfmStrikethroughFromMarkdown(), gfmTableFromMarkdown(), gfmTaskListItemFromMarkdown()];
}
function gfmToMarkdown(e) {
  return {
    extensions: [gfmAutolinkLiteralToMarkdown(), gfmFootnoteToMarkdown(e), gfmStrikethroughToMarkdown(), gfmTableToMarkdown(e), gfmTaskListItemToMarkdown()]
  };
}
const wwwPrefix = {
  tokenize: tokenizeWwwPrefix,
  partial: !0
}, domain = {
  tokenize: tokenizeDomain,
  partial: !0
}, path = {
  tokenize: tokenizePath,
  partial: !0
}, trail = {
  tokenize: tokenizeTrail,
  partial: !0
}, emailDomainDotTrail = {
  tokenize: tokenizeEmailDomainDotTrail,
  partial: !0
}, wwwAutolink = {
  name: "wwwAutolink",
  tokenize: tokenizeWwwAutolink,
  previous: previousWww
}, protocolAutolink = {
  name: "protocolAutolink",
  tokenize: tokenizeProtocolAutolink,
  previous: previousProtocol
}, emailAutolink = {
  name: "emailAutolink",
  tokenize: tokenizeEmailAutolink,
  previous: previousEmail
}, text$2 = {};
function gfmAutolinkLiteral() {
  return {
    text: text$2
  };
}
let code = 48;
for (; code < 123; )
  text$2[code] = emailAutolink, code++, code === 58 ? code = 65 : code === 91 && (code = 97);
text$2[43] = emailAutolink;
text$2[45] = emailAutolink;
text$2[46] = emailAutolink;
text$2[95] = emailAutolink;
text$2[72] = [emailAutolink, protocolAutolink];
text$2[104] = [emailAutolink, protocolAutolink];
text$2[87] = [emailAutolink, wwwAutolink];
text$2[119] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(e, t, r) {
  const a = this;
  let o, u;
  return c;
  function c(y) {
    return !gfmAtext(y) || !previousEmail.call(a, a.previous) || previousUnbalanced(a.events) ? r(y) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), d(y));
  }
  function d(y) {
    return gfmAtext(y) ? (e.consume(y), d) : y === 64 ? (e.consume(y), g) : r(y);
  }
  function g(y) {
    return y === 46 ? e.check(emailDomainDotTrail, _, b)(y) : y === 45 || y === 95 || asciiAlphanumeric(y) ? (u = !0, e.consume(y), g) : _(y);
  }
  function b(y) {
    return e.consume(y), o = !0, g;
  }
  function _(y) {
    return u && o && asciiAlpha(a.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(y)) : r(y);
  }
}
function tokenizeWwwAutolink(e, t, r) {
  const a = this;
  return o;
  function o(c) {
    return c !== 87 && c !== 119 || !previousWww.call(a, a.previous) || previousUnbalanced(a.events) ? r(c) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(wwwPrefix, e.attempt(domain, e.attempt(path, u), r), r)(c));
  }
  function u(c) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(c);
  }
}
function tokenizeProtocolAutolink(e, t, r) {
  const a = this;
  let o = "", u = !1;
  return c;
  function c(y) {
    return (y === 72 || y === 104) && previousProtocol.call(a, a.previous) && !previousUnbalanced(a.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), o += String.fromCodePoint(y), e.consume(y), d) : r(y);
  }
  function d(y) {
    if (asciiAlpha(y) && o.length < 5)
      return o += String.fromCodePoint(y), e.consume(y), d;
    if (y === 58) {
      const A = o.toLowerCase();
      if (A === "http" || A === "https")
        return e.consume(y), g;
    }
    return r(y);
  }
  function g(y) {
    return y === 47 ? (e.consume(y), u ? b : (u = !0, g)) : r(y);
  }
  function b(y) {
    return y === null || asciiControl(y) || markdownLineEndingOrSpace(y) || unicodeWhitespace(y) || unicodePunctuation(y) ? r(y) : e.attempt(domain, e.attempt(path, _), r)(y);
  }
  function _(y) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(y);
  }
}
function tokenizeWwwPrefix(e, t, r) {
  let a = 0;
  return o;
  function o(c) {
    return (c === 87 || c === 119) && a < 3 ? (a++, e.consume(c), o) : c === 46 && a === 3 ? (e.consume(c), u) : r(c);
  }
  function u(c) {
    return c === null ? r(c) : t(c);
  }
}
function tokenizeDomain(e, t, r) {
  let a, o, u;
  return c;
  function c(b) {
    return b === 46 || b === 95 ? e.check(trail, g, d)(b) : b === null || markdownLineEndingOrSpace(b) || unicodeWhitespace(b) || b !== 45 && unicodePunctuation(b) ? g(b) : (u = !0, e.consume(b), c);
  }
  function d(b) {
    return b === 95 ? a = !0 : (o = a, a = void 0), e.consume(b), c;
  }
  function g(b) {
    return o || a || !u ? r(b) : t(b);
  }
}
function tokenizePath(e, t) {
  let r = 0, a = 0;
  return o;
  function o(c) {
    return c === 40 ? (r++, e.consume(c), o) : c === 41 && a < r ? u(c) : c === 33 || c === 34 || c === 38 || c === 39 || c === 41 || c === 42 || c === 44 || c === 46 || c === 58 || c === 59 || c === 60 || c === 63 || c === 93 || c === 95 || c === 126 ? e.check(trail, t, u)(c) : c === null || markdownLineEndingOrSpace(c) || unicodeWhitespace(c) ? t(c) : (e.consume(c), o);
  }
  function u(c) {
    return c === 41 && a++, e.consume(c), o;
  }
}
function tokenizeTrail(e, t, r) {
  return a;
  function a(d) {
    return d === 33 || d === 34 || d === 39 || d === 41 || d === 42 || d === 44 || d === 46 || d === 58 || d === 59 || d === 63 || d === 95 || d === 126 ? (e.consume(d), a) : d === 38 ? (e.consume(d), u) : d === 93 ? (e.consume(d), o) : (
      // `<` is an end.
      d === 60 || // So is whitespace.
      d === null || markdownLineEndingOrSpace(d) || unicodeWhitespace(d) ? t(d) : r(d)
    );
  }
  function o(d) {
    return d === null || d === 40 || d === 91 || markdownLineEndingOrSpace(d) || unicodeWhitespace(d) ? t(d) : a(d);
  }
  function u(d) {
    return asciiAlpha(d) ? c(d) : r(d);
  }
  function c(d) {
    return d === 59 ? (e.consume(d), a) : asciiAlpha(d) ? (e.consume(d), c) : r(d);
  }
}
function tokenizeEmailDomainDotTrail(e, t, r) {
  return a;
  function a(u) {
    return e.consume(u), o;
  }
  function o(u) {
    return asciiAlphanumeric(u) ? r(u) : t(u);
  }
}
function previousWww(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || markdownLineEndingOrSpace(e);
}
function previousProtocol(e) {
  return !asciiAlpha(e);
}
function previousEmail(e) {
  return !(e === 47 || gfmAtext(e));
}
function gfmAtext(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || asciiAlphanumeric(e);
}
function previousUnbalanced(e) {
  let t = e.length, r = !1;
  for (; t--; ) {
    const a = e[t][1];
    if ((a.type === "labelLink" || a.type === "labelImage") && !a._balanced) {
      r = !0;
      break;
    }
    if (a._gfmAutolinkLiteralWalkedInto) {
      r = !1;
      break;
    }
  }
  return e.length > 0 && !r && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), r;
}
const indent = {
  tokenize: tokenizeIndent,
  partial: !0
};
function gfmFootnote() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: tokenizeDefinitionStart,
        continuation: {
          tokenize: tokenizeDefinitionContinuation
        },
        exit: gfmFootnoteDefinitionEnd
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: tokenizeGfmFootnoteCall
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: tokenizePotentialGfmFootnoteCall,
        resolveTo: resolveToPotentialGfmFootnoteCall
      }
    }
  };
}
function tokenizePotentialGfmFootnoteCall(e, t, r) {
  const a = this;
  let o = a.events.length;
  const u = a.parser.gfmFootnotes || (a.parser.gfmFootnotes = []);
  let c;
  for (; o--; ) {
    const g = a.events[o][1];
    if (g.type === "labelImage") {
      c = g;
      break;
    }
    if (g.type === "gfmFootnoteCall" || g.type === "labelLink" || g.type === "label" || g.type === "image" || g.type === "link")
      break;
  }
  return d;
  function d(g) {
    if (!c || !c._balanced)
      return r(g);
    const b = normalizeIdentifier(a.sliceSerialize({
      start: c.end,
      end: a.now()
    }));
    return b.codePointAt(0) !== 94 || !u.includes(b.slice(1)) ? r(g) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(g), e.exit("gfmFootnoteCallLabelMarker"), t(g));
  }
}
function resolveToPotentialGfmFootnoteCall(e, t) {
  let r = e.length;
  for (; r--; )
    if (e[r][1].type === "labelImage" && e[r][0] === "enter") {
      e[r][1];
      break;
    }
  e[r + 1][1].type = "data", e[r + 3][1].type = "gfmFootnoteCallLabelMarker";
  const a = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[r + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, o = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[r + 3][1].end),
    end: Object.assign({}, e[r + 3][1].end)
  };
  o.end.column++, o.end.offset++, o.end._bufferIndex++;
  const u = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, o.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, c = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, u.start),
    end: Object.assign({}, u.end)
  }, d = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[r + 1],
    e[r + 2],
    ["enter", a, t],
    // The `[`
    e[r + 3],
    e[r + 4],
    // The `^`.
    ["enter", o, t],
    ["exit", o, t],
    // Everything in between.
    ["enter", u, t],
    ["enter", c, t],
    ["exit", c, t],
    ["exit", u, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", a, t]
  ];
  return e.splice(r, e.length - r + 1, ...d), e;
}
function tokenizeGfmFootnoteCall(e, t, r) {
  const a = this, o = a.parser.gfmFootnotes || (a.parser.gfmFootnotes = []);
  let u = 0, c;
  return d;
  function d(y) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(y), e.exit("gfmFootnoteCallLabelMarker"), g;
  }
  function g(y) {
    return y !== 94 ? r(y) : (e.enter("gfmFootnoteCallMarker"), e.consume(y), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", b);
  }
  function b(y) {
    if (
      // Too long.
      u > 999 || // Closing brace with nothing.
      y === 93 && !c || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      y === null || y === 91 || markdownLineEndingOrSpace(y)
    )
      return r(y);
    if (y === 93) {
      e.exit("chunkString");
      const A = e.exit("gfmFootnoteCallString");
      return o.includes(normalizeIdentifier(a.sliceSerialize(A))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(y), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : r(y);
    }
    return markdownLineEndingOrSpace(y) || (c = !0), u++, e.consume(y), y === 92 ? _ : b;
  }
  function _(y) {
    return y === 91 || y === 92 || y === 93 ? (e.consume(y), u++, b) : b(y);
  }
}
function tokenizeDefinitionStart(e, t, r) {
  const a = this, o = a.parser.gfmFootnotes || (a.parser.gfmFootnotes = []);
  let u, c = 0, d;
  return g;
  function g(v) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(v), e.exit("gfmFootnoteDefinitionLabelMarker"), b;
  }
  function b(v) {
    return v === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(v), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", _) : r(v);
  }
  function _(v) {
    if (
      // Too long.
      c > 999 || // Closing brace with nothing.
      v === 93 && !d || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      v === null || v === 91 || markdownLineEndingOrSpace(v)
    )
      return r(v);
    if (v === 93) {
      e.exit("chunkString");
      const C = e.exit("gfmFootnoteDefinitionLabelString");
      return u = normalizeIdentifier(a.sliceSerialize(C)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(v), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), A;
    }
    return markdownLineEndingOrSpace(v) || (d = !0), c++, e.consume(v), v === 92 ? y : _;
  }
  function y(v) {
    return v === 91 || v === 92 || v === 93 ? (e.consume(v), c++, _) : _(v);
  }
  function A(v) {
    return v === 58 ? (e.enter("definitionMarker"), e.consume(v), e.exit("definitionMarker"), o.includes(u) || o.push(u), factorySpace(e, E, "gfmFootnoteDefinitionWhitespace")) : r(v);
  }
  function E(v) {
    return t(v);
  }
}
function tokenizeDefinitionContinuation(e, t, r) {
  return e.check(blankLine, t, e.attempt(indent, t, r));
}
function gfmFootnoteDefinitionEnd(e) {
  e.exit("gfmFootnoteDefinition");
}
function tokenizeIndent(e, t, r) {
  const a = this;
  return factorySpace(e, o, "gfmFootnoteDefinitionIndent", 5);
  function o(u) {
    const c = a.events[a.events.length - 1];
    return c && c[1].type === "gfmFootnoteDefinitionIndent" && c[2].sliceSerialize(c[1], !0).length === 4 ? t(u) : r(u);
  }
}
function gfmStrikethrough(e) {
  let r = (e || {}).singleTilde;
  const a = {
    name: "strikethrough",
    tokenize: u,
    resolveAll: o
  };
  return r == null && (r = !0), {
    text: {
      126: a
    },
    insideSpan: {
      null: [a]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function o(c, d) {
    let g = -1;
    for (; ++g < c.length; )
      if (c[g][0] === "enter" && c[g][1].type === "strikethroughSequenceTemporary" && c[g][1]._close) {
        let b = g;
        for (; b--; )
          if (c[b][0] === "exit" && c[b][1].type === "strikethroughSequenceTemporary" && c[b][1]._open && // If the sizes are the same:
          c[g][1].end.offset - c[g][1].start.offset === c[b][1].end.offset - c[b][1].start.offset) {
            c[g][1].type = "strikethroughSequence", c[b][1].type = "strikethroughSequence";
            const _ = {
              type: "strikethrough",
              start: Object.assign({}, c[b][1].start),
              end: Object.assign({}, c[g][1].end)
            }, y = {
              type: "strikethroughText",
              start: Object.assign({}, c[b][1].end),
              end: Object.assign({}, c[g][1].start)
            }, A = [["enter", _, d], ["enter", c[b][1], d], ["exit", c[b][1], d], ["enter", y, d]], E = d.parser.constructs.insideSpan.null;
            E && splice(A, A.length, 0, resolveAll(E, c.slice(b + 1, g), d)), splice(A, A.length, 0, [["exit", y, d], ["enter", c[g][1], d], ["exit", c[g][1], d], ["exit", _, d]]), splice(c, b - 1, g - b + 3, A), g = b + A.length - 2;
            break;
          }
      }
    for (g = -1; ++g < c.length; )
      c[g][1].type === "strikethroughSequenceTemporary" && (c[g][1].type = "data");
    return c;
  }
  function u(c, d, g) {
    const b = this.previous, _ = this.events;
    let y = 0;
    return A;
    function A(v) {
      return b === 126 && _[_.length - 1][1].type !== "characterEscape" ? g(v) : (c.enter("strikethroughSequenceTemporary"), E(v));
    }
    function E(v) {
      const C = classifyCharacter(b);
      if (v === 126)
        return y > 1 ? g(v) : (c.consume(v), y++, E);
      if (y < 2 && !r) return g(v);
      const R = c.exit("strikethroughSequenceTemporary"), I = classifyCharacter(v);
      return R._open = !I || I === 2 && !!C, R._close = !C || C === 2 && !!I, d(v);
    }
  }
}
class EditMap {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, r, a) {
    addImplementation(this, t, r, a);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(u, c) {
      return u[0] - c[0];
    }), this.map.length === 0)
      return;
    let r = this.map.length;
    const a = [];
    for (; r > 0; )
      r -= 1, a.push(t.slice(this.map[r][0] + this.map[r][1]), this.map[r][2]), t.length = this.map[r][0];
    a.push(t.slice()), t.length = 0;
    let o = a.pop();
    for (; o; ) {
      for (const u of o)
        t.push(u);
      o = a.pop();
    }
    this.map.length = 0;
  }
}
function addImplementation(e, t, r, a) {
  let o = 0;
  if (!(r === 0 && a.length === 0)) {
    for (; o < e.map.length; ) {
      if (e.map[o][0] === t) {
        e.map[o][1] += r, e.map[o][2].push(...a);
        return;
      }
      o += 1;
    }
    e.map.push([t, r, a]);
  }
}
function gfmTableAlign(e, t) {
  let r = !1;
  const a = [];
  for (; t < e.length; ) {
    const o = e[t];
    if (r) {
      if (o[0] === "enter")
        o[1].type === "tableContent" && a.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (o[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const u = a.length - 1;
          a[u] = a[u] === "left" ? "center" : "right";
        }
      } else if (o[1].type === "tableDelimiterRow")
        break;
    } else o[0] === "enter" && o[1].type === "tableDelimiterRow" && (r = !0);
    t += 1;
  }
  return a;
}
function gfmTable() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: tokenizeTable,
        resolveAll: resolveTable
      }
    }
  };
}
function tokenizeTable(e, t, r) {
  const a = this;
  let o = 0, u = 0, c;
  return d;
  function d(H) {
    let B = a.events.length - 1;
    for (; B > -1; ) {
      const de = a.events[B][1].type;
      if (de === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      de === "linePrefix") B--;
      else break;
    }
    const V = B > -1 ? a.events[B][1].type : null, X = V === "tableHead" || V === "tableRow" ? x : g;
    return X === x && a.parser.lazy[a.now().line] ? r(H) : X(H);
  }
  function g(H) {
    return e.enter("tableHead"), e.enter("tableRow"), b(H);
  }
  function b(H) {
    return H === 124 || (c = !0, u += 1), _(H);
  }
  function _(H) {
    return H === null ? r(H) : markdownLineEnding(H) ? u > 1 ? (u = 0, a.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(H), e.exit("lineEnding"), E) : r(H) : markdownSpace(H) ? factorySpace(e, _, "whitespace")(H) : (u += 1, c && (c = !1, o += 1), H === 124 ? (e.enter("tableCellDivider"), e.consume(H), e.exit("tableCellDivider"), c = !0, _) : (e.enter("data"), y(H)));
  }
  function y(H) {
    return H === null || H === 124 || markdownLineEndingOrSpace(H) ? (e.exit("data"), _(H)) : (e.consume(H), H === 92 ? A : y);
  }
  function A(H) {
    return H === 92 || H === 124 ? (e.consume(H), y) : y(H);
  }
  function E(H) {
    return a.interrupt = !1, a.parser.lazy[a.now().line] ? r(H) : (e.enter("tableDelimiterRow"), c = !1, markdownSpace(H) ? factorySpace(e, v, "linePrefix", a.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(H) : v(H));
  }
  function v(H) {
    return H === 45 || H === 58 ? R(H) : H === 124 ? (c = !0, e.enter("tableCellDivider"), e.consume(H), e.exit("tableCellDivider"), C) : M(H);
  }
  function C(H) {
    return markdownSpace(H) ? factorySpace(e, R, "whitespace")(H) : R(H);
  }
  function R(H) {
    return H === 58 ? (u += 1, c = !0, e.enter("tableDelimiterMarker"), e.consume(H), e.exit("tableDelimiterMarker"), I) : H === 45 ? (u += 1, I(H)) : H === null || markdownLineEnding(H) ? F(H) : M(H);
  }
  function I(H) {
    return H === 45 ? (e.enter("tableDelimiterFiller"), w(H)) : M(H);
  }
  function w(H) {
    return H === 45 ? (e.consume(H), w) : H === 58 ? (c = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(H), e.exit("tableDelimiterMarker"), N) : (e.exit("tableDelimiterFiller"), N(H));
  }
  function N(H) {
    return markdownSpace(H) ? factorySpace(e, F, "whitespace")(H) : F(H);
  }
  function F(H) {
    return H === 124 ? v(H) : H === null || markdownLineEnding(H) ? !c || o !== u ? M(H) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(H)) : M(H);
  }
  function M(H) {
    return r(H);
  }
  function x(H) {
    return e.enter("tableRow"), P(H);
  }
  function P(H) {
    return H === 124 ? (e.enter("tableCellDivider"), e.consume(H), e.exit("tableCellDivider"), P) : H === null || markdownLineEnding(H) ? (e.exit("tableRow"), t(H)) : markdownSpace(H) ? factorySpace(e, P, "whitespace")(H) : (e.enter("data"), U(H));
  }
  function U(H) {
    return H === null || H === 124 || markdownLineEndingOrSpace(H) ? (e.exit("data"), P(H)) : (e.consume(H), H === 92 ? L : U);
  }
  function L(H) {
    return H === 92 || H === 124 ? (e.consume(H), U) : U(H);
  }
}
function resolveTable(e, t) {
  let r = -1, a = !0, o = 0, u = [0, 0, 0, 0], c = [0, 0, 0, 0], d = !1, g = 0, b, _, y;
  const A = new EditMap();
  for (; ++r < e.length; ) {
    const E = e[r], v = E[1];
    E[0] === "enter" ? v.type === "tableHead" ? (d = !1, g !== 0 && (flushTableEnd(A, t, g, b, _), _ = void 0, g = 0), b = {
      type: "table",
      start: Object.assign({}, v.start),
      // Note: correct end is set later.
      end: Object.assign({}, v.end)
    }, A.add(r, 0, [["enter", b, t]])) : v.type === "tableRow" || v.type === "tableDelimiterRow" ? (a = !0, y = void 0, u = [0, 0, 0, 0], c = [0, r + 1, 0, 0], d && (d = !1, _ = {
      type: "tableBody",
      start: Object.assign({}, v.start),
      // Note: correct end is set later.
      end: Object.assign({}, v.end)
    }, A.add(r, 0, [["enter", _, t]])), o = v.type === "tableDelimiterRow" ? 2 : _ ? 3 : 1) : o && (v.type === "data" || v.type === "tableDelimiterMarker" || v.type === "tableDelimiterFiller") ? (a = !1, c[2] === 0 && (u[1] !== 0 && (c[0] = c[1], y = flushCell(A, t, u, o, void 0, y), u = [0, 0, 0, 0]), c[2] = r)) : v.type === "tableCellDivider" && (a ? a = !1 : (u[1] !== 0 && (c[0] = c[1], y = flushCell(A, t, u, o, void 0, y)), u = c, c = [u[1], r, 0, 0])) : v.type === "tableHead" ? (d = !0, g = r) : v.type === "tableRow" || v.type === "tableDelimiterRow" ? (g = r, u[1] !== 0 ? (c[0] = c[1], y = flushCell(A, t, u, o, r, y)) : c[1] !== 0 && (y = flushCell(A, t, c, o, r, y)), o = 0) : o && (v.type === "data" || v.type === "tableDelimiterMarker" || v.type === "tableDelimiterFiller") && (c[3] = r);
  }
  for (g !== 0 && flushTableEnd(A, t, g, b, _), A.consume(t.events), r = -1; ++r < t.events.length; ) {
    const E = t.events[r];
    E[0] === "enter" && E[1].type === "table" && (E[1]._align = gfmTableAlign(t.events, r));
  }
  return e;
}
function flushCell(e, t, r, a, o, u) {
  const c = a === 1 ? "tableHeader" : a === 2 ? "tableDelimiter" : "tableData", d = "tableContent";
  r[0] !== 0 && (u.end = Object.assign({}, getPoint(t.events, r[0])), e.add(r[0], 0, [["exit", u, t]]));
  const g = getPoint(t.events, r[1]);
  if (u = {
    type: c,
    start: Object.assign({}, g),
    // Note: correct end is set later.
    end: Object.assign({}, g)
  }, e.add(r[1], 0, [["enter", u, t]]), r[2] !== 0) {
    const b = getPoint(t.events, r[2]), _ = getPoint(t.events, r[3]), y = {
      type: d,
      start: Object.assign({}, b),
      end: Object.assign({}, _)
    };
    if (e.add(r[2], 0, [["enter", y, t]]), a !== 2) {
      const A = t.events[r[2]], E = t.events[r[3]];
      if (A[1].end = Object.assign({}, E[1].end), A[1].type = "chunkText", A[1].contentType = "text", r[3] > r[2] + 1) {
        const v = r[2] + 1, C = r[3] - r[2] - 1;
        e.add(v, C, []);
      }
    }
    e.add(r[3] + 1, 0, [["exit", y, t]]);
  }
  return o !== void 0 && (u.end = Object.assign({}, getPoint(t.events, o)), e.add(o, 0, [["exit", u, t]]), u = void 0), u;
}
function flushTableEnd(e, t, r, a, o) {
  const u = [], c = getPoint(t.events, r);
  o && (o.end = Object.assign({}, c), u.push(["exit", o, t])), a.end = Object.assign({}, c), u.push(["exit", a, t]), e.add(r + 1, 0, u);
}
function getPoint(e, t) {
  const r = e[t], a = r[0] === "enter" ? "start" : "end";
  return r[1][a];
}
const tasklistCheck = {
  name: "tasklistCheck",
  tokenize: tokenizeTasklistCheck
};
function gfmTaskListItem() {
  return {
    text: {
      91: tasklistCheck
    }
  };
}
function tokenizeTasklistCheck(e, t, r) {
  const a = this;
  return o;
  function o(g) {
    return (
      // Exit if theres stuff before.
      a.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !a._gfmTasklistFirstContentOfListItem ? r(g) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(g), e.exit("taskListCheckMarker"), u)
    );
  }
  function u(g) {
    return markdownLineEndingOrSpace(g) ? (e.enter("taskListCheckValueUnchecked"), e.consume(g), e.exit("taskListCheckValueUnchecked"), c) : g === 88 || g === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(g), e.exit("taskListCheckValueChecked"), c) : r(g);
  }
  function c(g) {
    return g === 93 ? (e.enter("taskListCheckMarker"), e.consume(g), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), d) : r(g);
  }
  function d(g) {
    return markdownLineEnding(g) ? t(g) : markdownSpace(g) ? e.check({
      tokenize: spaceThenNonSpace
    }, t, r)(g) : r(g);
  }
}
function spaceThenNonSpace(e, t, r) {
  return factorySpace(e, a, "whitespace");
  function a(o) {
    return o === null ? r(o) : t(o);
  }
}
function gfm(e) {
  return combineExtensions([gfmAutolinkLiteral(), gfmFootnote(), gfmStrikethrough(e), gfmTable(), gfmTaskListItem()]);
}
const emptyOptions$1 = {};
function remarkGfm(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), r = e || emptyOptions$1, a = t.data(), o = a.micromarkExtensions || (a.micromarkExtensions = []), u = a.fromMarkdownExtensions || (a.fromMarkdownExtensions = []), c = a.toMarkdownExtensions || (a.toMarkdownExtensions = []);
  o.push(gfm(r)), u.push(gfmFromMarkdown()), c.push(gfmToMarkdown(r));
}
function mathFromMarkdown() {
  return {
    enter: {
      mathFlow: e,
      mathFlowFenceMeta: t,
      mathText: u
    },
    exit: {
      mathFlow: o,
      mathFlowFence: a,
      mathFlowFenceMeta: r,
      mathFlowValue: d,
      mathText: c,
      mathTextData: d
    }
  };
  function e(g) {
    const b = {
      type: "element",
      tagName: "code",
      properties: {
        className: ["language-math", "math-display"]
      },
      children: []
    };
    this.enter({
      type: "math",
      meta: null,
      value: "",
      data: {
        hName: "pre",
        hChildren: [b]
      }
    }, g);
  }
  function t() {
    this.buffer();
  }
  function r() {
    const g = this.resume(), b = this.stack[this.stack.length - 1];
    b.type, b.meta = g;
  }
  function a() {
    this.data.mathFlowInside || (this.buffer(), this.data.mathFlowInside = !0);
  }
  function o(g) {
    const b = this.resume().replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), _ = this.stack[this.stack.length - 1];
    _.type, this.exit(g), _.value = b;
    const y = (
      /** @type {HastElement} */
      _.data.hChildren[0]
    );
    y.type, y.tagName, y.children.push({
      type: "text",
      value: b
    }), this.data.mathFlowInside = void 0;
  }
  function u(g) {
    this.enter({
      type: "inlineMath",
      value: "",
      data: {
        hName: "code",
        hProperties: {
          className: ["language-math", "math-inline"]
        },
        hChildren: []
      }
    }, g), this.buffer();
  }
  function c(g) {
    const b = this.resume(), _ = this.stack[this.stack.length - 1];
    _.type, this.exit(g), _.value = b, /** @type {Array<HastElementContent>} */
    // @ts-expect-error: we defined it in `enterMathFlow`.
    _.data.hChildren.push({
      type: "text",
      value: b
    });
  }
  function d(g) {
    this.config.enter.data.call(this, g), this.config.exit.data.call(this, g);
  }
}
function mathToMarkdown(e) {
  let t = (e || {}).singleDollarTextMath;
  return t == null && (t = !0), a.peek = o, {
    unsafe: [{
      character: "\r",
      inConstruct: "mathFlowMeta"
    }, {
      character: `
`,
      inConstruct: "mathFlowMeta"
    }, {
      character: "$",
      after: t ? void 0 : "\\$",
      inConstruct: "phrasing"
    }, {
      character: "$",
      inConstruct: "mathFlowMeta"
    }, {
      atBreak: !0,
      character: "$",
      after: "\\$"
    }],
    handlers: {
      math: r,
      inlineMath: a
    }
  };
  function r(u, c, d, g) {
    const b = u.value || "", _ = d.createTracker(g), y = "$".repeat(Math.max(longestStreak(b, "$") + 1, 2)), A = d.enter("mathFlow");
    let E = _.move(y);
    if (u.meta) {
      const v = d.enter("mathFlowMeta");
      E += _.move(d.safe(u.meta, {
        after: `
`,
        before: E,
        encode: ["$"],
        ..._.current()
      })), v();
    }
    return E += _.move(`
`), b && (E += _.move(b + `
`)), E += _.move(y), A(), E;
  }
  function a(u, c, d) {
    let g = u.value || "", b = 1;
    for (t || b++; new RegExp("(^|[^$])" + "\\$".repeat(b) + "([^$]|$)").test(g); )
      b++;
    const _ = "$".repeat(b);
    // Contains non-space.
    /[^ \r\n]/.test(g) && // Starts with space and ends with space.
    (/^[ \r\n]/.test(g) && /[ \r\n]$/.test(g) || // Starts or ends with dollar.
    /^\$|\$$/.test(g)) && (g = " " + g + " ");
    let y = -1;
    for (; ++y < d.unsafe.length; ) {
      const A = d.unsafe[y];
      if (!A.atBreak) continue;
      const E = d.compilePattern(A);
      let v;
      for (; v = E.exec(g); ) {
        let C = v.index;
        g.codePointAt(C) === 10 && g.codePointAt(C - 1) === 13 && C--, g = g.slice(0, C) + " " + g.slice(v.index + 1);
      }
    }
    return _ + g + _;
  }
  function o() {
    return "$";
  }
}
const mathFlow = {
  tokenize: tokenizeMathFenced,
  concrete: !0
}, nonLazyContinuation = {
  tokenize: tokenizeNonLazyContinuation,
  partial: !0
};
function tokenizeMathFenced(e, t, r) {
  const a = this, o = a.events[a.events.length - 1], u = o && o[1].type === "linePrefix" ? o[2].sliceSerialize(o[1], !0).length : 0;
  let c = 0;
  return d;
  function d(w) {
    return e.enter("mathFlow"), e.enter("mathFlowFence"), e.enter("mathFlowFenceSequence"), g(w);
  }
  function g(w) {
    return w === 36 ? (e.consume(w), c++, g) : c < 2 ? r(w) : (e.exit("mathFlowFenceSequence"), factorySpace(e, b, "whitespace")(w));
  }
  function b(w) {
    return w === null || markdownLineEnding(w) ? y(w) : (e.enter("mathFlowFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), _(w));
  }
  function _(w) {
    return w === null || markdownLineEnding(w) ? (e.exit("chunkString"), e.exit("mathFlowFenceMeta"), y(w)) : w === 36 ? r(w) : (e.consume(w), _);
  }
  function y(w) {
    return e.exit("mathFlowFence"), a.interrupt ? t(w) : e.attempt(nonLazyContinuation, A, R)(w);
  }
  function A(w) {
    return e.attempt({
      tokenize: I,
      partial: !0
    }, R, E)(w);
  }
  function E(w) {
    return (u ? factorySpace(e, v, "linePrefix", u + 1) : v)(w);
  }
  function v(w) {
    return w === null ? R(w) : markdownLineEnding(w) ? e.attempt(nonLazyContinuation, A, R)(w) : (e.enter("mathFlowValue"), C(w));
  }
  function C(w) {
    return w === null || markdownLineEnding(w) ? (e.exit("mathFlowValue"), v(w)) : (e.consume(w), C);
  }
  function R(w) {
    return e.exit("mathFlow"), t(w);
  }
  function I(w, N, F) {
    let M = 0;
    return factorySpace(w, x, "linePrefix", a.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
    function x(L) {
      return w.enter("mathFlowFence"), w.enter("mathFlowFenceSequence"), P(L);
    }
    function P(L) {
      return L === 36 ? (M++, w.consume(L), P) : M < c ? F(L) : (w.exit("mathFlowFenceSequence"), factorySpace(w, U, "whitespace")(L));
    }
    function U(L) {
      return L === null || markdownLineEnding(L) ? (w.exit("mathFlowFence"), N(L)) : F(L);
    }
  }
}
function tokenizeNonLazyContinuation(e, t, r) {
  const a = this;
  return o;
  function o(c) {
    return c === null ? t(c) : (e.enter("lineEnding"), e.consume(c), e.exit("lineEnding"), u);
  }
  function u(c) {
    return a.parser.lazy[a.now().line] ? r(c) : t(c);
  }
}
function mathText(e) {
  let r = (e || {}).singleDollarTextMath;
  return r == null && (r = !0), {
    tokenize: a,
    resolve: resolveMathText,
    previous
  };
  function a(o, u, c) {
    let d = 0, g, b;
    return _;
    function _(C) {
      return o.enter("mathText"), o.enter("mathTextSequence"), y(C);
    }
    function y(C) {
      return C === 36 ? (o.consume(C), d++, y) : d < 2 && !r ? c(C) : (o.exit("mathTextSequence"), A(C));
    }
    function A(C) {
      return C === null ? c(C) : C === 36 ? (b = o.enter("mathTextSequence"), g = 0, v(C)) : C === 32 ? (o.enter("space"), o.consume(C), o.exit("space"), A) : markdownLineEnding(C) ? (o.enter("lineEnding"), o.consume(C), o.exit("lineEnding"), A) : (o.enter("mathTextData"), E(C));
    }
    function E(C) {
      return C === null || C === 32 || C === 36 || markdownLineEnding(C) ? (o.exit("mathTextData"), A(C)) : (o.consume(C), E);
    }
    function v(C) {
      return C === 36 ? (o.consume(C), g++, v) : g === d ? (o.exit("mathTextSequence"), o.exit("mathText"), u(C)) : (b.type = "mathTextData", E(C));
    }
  }
}
function resolveMathText(e) {
  let t = e.length - 4, r = 3, a, o;
  if ((e[r][1].type === "lineEnding" || e[r][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (a = r; ++a < t; )
      if (e[a][1].type === "mathTextData") {
        e[t][1].type = "mathTextPadding", e[r][1].type = "mathTextPadding", r += 2, t -= 2;
        break;
      }
  }
  for (a = r - 1, t++; ++a <= t; )
    o === void 0 ? a !== t && e[a][1].type !== "lineEnding" && (o = a) : (a === t || e[a][1].type === "lineEnding") && (e[o][1].type = "mathTextData", a !== o + 2 && (e[o][1].end = e[a - 1][1].end, e.splice(o + 2, a - o - 2), t -= a - o - 2, a = o + 2), o = void 0);
  return e;
}
function previous(e) {
  return e !== 36 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function math(e) {
  return {
    flow: {
      36: mathFlow
    },
    text: {
      36: mathText(e)
    }
  };
}
const emptyOptions = {};
function remarkMath(e) {
  const t = (
    /** @type {Processor} */
    this
  ), r = e || emptyOptions, a = t.data(), o = a.micromarkExtensions || (a.micromarkExtensions = []), u = a.fromMarkdownExtensions || (a.fromMarkdownExtensions = []), c = a.toMarkdownExtensions || (a.toMarkdownExtensions = []);
  o.push(math(r)), u.push(mathFromMarkdown()), c.push(mathToMarkdown(r));
}
const Anchor = ({
  children: e,
  href: t
}) => e ? /* @__PURE__ */ jsxRuntimeExports.jsx("a", {
  target: "_blank",
  href: t,
  onMouseDown: (r) => r.stopPropagation(),
  rel: "noreferrer",
  children: React.Children.toArray(e)[0]
}) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
  children: "[](" + t + ")"
}), Audio = (e) => /* @__PURE__ */ jsxRuntimeExports.jsx(FileView, {
  type: "audio",
  ...e,
  url: e.src
});
function _objectWithoutPropertiesLoose(e, t) {
  if (e == null) return {};
  var r = {};
  for (var a in e) if ({}.hasOwnProperty.call(e, a)) {
    if (t.includes(a)) continue;
    r[a] = e[a];
  }
  return r;
}
function _objectWithoutProperties(e, t) {
  if (e == null) return {};
  var r, a, o = _objectWithoutPropertiesLoose(e, t);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(e);
    for (a = 0; a < u.length; a++) r = u[a], t.includes(r) || {}.propertyIsEnumerable.call(e, r) && (o[r] = e[r]);
  }
  return o;
}
function _arrayLikeToArray(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, a = Array(t); r < t; r++) a[r] = e[r];
  return a;
}
function _arrayWithoutHoles(e) {
  if (Array.isArray(e)) return _arrayLikeToArray(e);
}
function _iterableToArray(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function _unsupportedIterableToArray(e, t) {
  if (e) {
    if (typeof e == "string") return _arrayLikeToArray(e, t);
    var r = {}.toString.call(e).slice(8, -1);
    return r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set" ? Array.from(e) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? _arrayLikeToArray(e, t) : void 0;
  }
}
function _nonIterableSpread() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _toConsumableArray(e) {
  return _arrayWithoutHoles(e) || _iterableToArray(e) || _unsupportedIterableToArray(e) || _nonIterableSpread();
}
function _typeof$1(e) {
  "@babel/helpers - typeof";
  return _typeof$1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, _typeof$1(e);
}
function toPrimitive$1(e, t) {
  if (_typeof$1(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var a = r.call(e, t);
    if (_typeof$1(a) != "object") return a;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function toPropertyKey$1(e) {
  var t = toPrimitive$1(e, "string");
  return _typeof$1(t) == "symbol" ? t : t + "";
}
function _defineProperty(e, t, r) {
  return (t = toPropertyKey$1(t)) in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r) ({}).hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, _extends.apply(null, arguments);
}
function ownKeys$1(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    t && (a = a.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), r.push.apply(r, a);
  }
  return r;
}
function _objectSpread$1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ownKeys$1(Object(r), !0).forEach(function(a) {
      _defineProperty(e, a, r[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : ownKeys$1(Object(r)).forEach(function(a) {
      Object.defineProperty(e, a, Object.getOwnPropertyDescriptor(r, a));
    });
  }
  return e;
}
function powerSetPermutations(e) {
  var t = e.length;
  if (t === 0 || t === 1) return e;
  if (t === 2)
    return [e[0], e[1], "".concat(e[0], ".").concat(e[1]), "".concat(e[1], ".").concat(e[0])];
  if (t === 3)
    return [e[0], e[1], e[2], "".concat(e[0], ".").concat(e[1]), "".concat(e[0], ".").concat(e[2]), "".concat(e[1], ".").concat(e[0]), "".concat(e[1], ".").concat(e[2]), "".concat(e[2], ".").concat(e[0]), "".concat(e[2], ".").concat(e[1]), "".concat(e[0], ".").concat(e[1], ".").concat(e[2]), "".concat(e[0], ".").concat(e[2], ".").concat(e[1]), "".concat(e[1], ".").concat(e[0], ".").concat(e[2]), "".concat(e[1], ".").concat(e[2], ".").concat(e[0]), "".concat(e[2], ".").concat(e[0], ".").concat(e[1]), "".concat(e[2], ".").concat(e[1], ".").concat(e[0])];
  if (t >= 4)
    return [e[0], e[1], e[2], e[3], "".concat(e[0], ".").concat(e[1]), "".concat(e[0], ".").concat(e[2]), "".concat(e[0], ".").concat(e[3]), "".concat(e[1], ".").concat(e[0]), "".concat(e[1], ".").concat(e[2]), "".concat(e[1], ".").concat(e[3]), "".concat(e[2], ".").concat(e[0]), "".concat(e[2], ".").concat(e[1]), "".concat(e[2], ".").concat(e[3]), "".concat(e[3], ".").concat(e[0]), "".concat(e[3], ".").concat(e[1]), "".concat(e[3], ".").concat(e[2]), "".concat(e[0], ".").concat(e[1], ".").concat(e[2]), "".concat(e[0], ".").concat(e[1], ".").concat(e[3]), "".concat(e[0], ".").concat(e[2], ".").concat(e[1]), "".concat(e[0], ".").concat(e[2], ".").concat(e[3]), "".concat(e[0], ".").concat(e[3], ".").concat(e[1]), "".concat(e[0], ".").concat(e[3], ".").concat(e[2]), "".concat(e[1], ".").concat(e[0], ".").concat(e[2]), "".concat(e[1], ".").concat(e[0], ".").concat(e[3]), "".concat(e[1], ".").concat(e[2], ".").concat(e[0]), "".concat(e[1], ".").concat(e[2], ".").concat(e[3]), "".concat(e[1], ".").concat(e[3], ".").concat(e[0]), "".concat(e[1], ".").concat(e[3], ".").concat(e[2]), "".concat(e[2], ".").concat(e[0], ".").concat(e[1]), "".concat(e[2], ".").concat(e[0], ".").concat(e[3]), "".concat(e[2], ".").concat(e[1], ".").concat(e[0]), "".concat(e[2], ".").concat(e[1], ".").concat(e[3]), "".concat(e[2], ".").concat(e[3], ".").concat(e[0]), "".concat(e[2], ".").concat(e[3], ".").concat(e[1]), "".concat(e[3], ".").concat(e[0], ".").concat(e[1]), "".concat(e[3], ".").concat(e[0], ".").concat(e[2]), "".concat(e[3], ".").concat(e[1], ".").concat(e[0]), "".concat(e[3], ".").concat(e[1], ".").concat(e[2]), "".concat(e[3], ".").concat(e[2], ".").concat(e[0]), "".concat(e[3], ".").concat(e[2], ".").concat(e[1]), "".concat(e[0], ".").concat(e[1], ".").concat(e[2], ".").concat(e[3]), "".concat(e[0], ".").concat(e[1], ".").concat(e[3], ".").concat(e[2]), "".concat(e[0], ".").concat(e[2], ".").concat(e[1], ".").concat(e[3]), "".concat(e[0], ".").concat(e[2], ".").concat(e[3], ".").concat(e[1]), "".concat(e[0], ".").concat(e[3], ".").concat(e[1], ".").concat(e[2]), "".concat(e[0], ".").concat(e[3], ".").concat(e[2], ".").concat(e[1]), "".concat(e[1], ".").concat(e[0], ".").concat(e[2], ".").concat(e[3]), "".concat(e[1], ".").concat(e[0], ".").concat(e[3], ".").concat(e[2]), "".concat(e[1], ".").concat(e[2], ".").concat(e[0], ".").concat(e[3]), "".concat(e[1], ".").concat(e[2], ".").concat(e[3], ".").concat(e[0]), "".concat(e[1], ".").concat(e[3], ".").concat(e[0], ".").concat(e[2]), "".concat(e[1], ".").concat(e[3], ".").concat(e[2], ".").concat(e[0]), "".concat(e[2], ".").concat(e[0], ".").concat(e[1], ".").concat(e[3]), "".concat(e[2], ".").concat(e[0], ".").concat(e[3], ".").concat(e[1]), "".concat(e[2], ".").concat(e[1], ".").concat(e[0], ".").concat(e[3]), "".concat(e[2], ".").concat(e[1], ".").concat(e[3], ".").concat(e[0]), "".concat(e[2], ".").concat(e[3], ".").concat(e[0], ".").concat(e[1]), "".concat(e[2], ".").concat(e[3], ".").concat(e[1], ".").concat(e[0]), "".concat(e[3], ".").concat(e[0], ".").concat(e[1], ".").concat(e[2]), "".concat(e[3], ".").concat(e[0], ".").concat(e[2], ".").concat(e[1]), "".concat(e[3], ".").concat(e[1], ".").concat(e[0], ".").concat(e[2]), "".concat(e[3], ".").concat(e[1], ".").concat(e[2], ".").concat(e[0]), "".concat(e[3], ".").concat(e[2], ".").concat(e[0], ".").concat(e[1]), "".concat(e[3], ".").concat(e[2], ".").concat(e[1], ".").concat(e[0])];
}
var classNameCombinations = {};
function getClassNameCombinations(e) {
  if (e.length === 0 || e.length === 1) return e;
  var t = e.join(".");
  return classNameCombinations[t] || (classNameCombinations[t] = powerSetPermutations(e)), classNameCombinations[t];
}
function createStyleObject(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 ? arguments[2] : void 0, a = e.filter(function(u) {
    return u !== "token";
  }), o = getClassNameCombinations(a);
  return o.reduce(function(u, c) {
    return _objectSpread$1(_objectSpread$1({}, u), r[c]);
  }, t);
}
function createClassNameString(e) {
  return e.join(" ");
}
function createChildren(e, t) {
  var r = 0;
  return function(a) {
    return r += 1, a.map(function(o, u) {
      return createElement({
        node: o,
        stylesheet: e,
        useInlineStyles: t,
        key: "code-segment-".concat(r, "-").concat(u)
      });
    });
  };
}
function createElement(e) {
  var t = e.node, r = e.stylesheet, a = e.style, o = a === void 0 ? {} : a, u = e.useInlineStyles, c = e.key, d = t.properties, g = t.type, b = t.tagName, _ = t.value;
  if (g === "text")
    return _;
  if (b) {
    var y = createChildren(r, u), A;
    if (!u)
      A = _objectSpread$1(_objectSpread$1({}, d), {}, {
        className: createClassNameString(d.className)
      });
    else {
      var E = Object.keys(r).reduce(function(I, w) {
        return w.split(".").forEach(function(N) {
          I.includes(N) || I.push(N);
        }), I;
      }, []), v = d.className && d.className.includes("token") ? ["token"] : [], C = d.className && v.concat(d.className.filter(function(I) {
        return !E.includes(I);
      }));
      A = _objectSpread$1(_objectSpread$1({}, d), {}, {
        className: createClassNameString(C) || void 0,
        style: createStyleObject(d.className, Object.assign({}, d.style, o), r)
      });
    }
    var R = y(t.children);
    return /* @__PURE__ */ React.createElement(b, _extends({
      key: c
    }, A), R);
  }
}
const checkForListedLanguage = function(e, t) {
  var r = e.listLanguages();
  return r.indexOf(t) !== -1;
};
var _excluded = ["language", "children", "style", "customStyle", "codeTagProps", "useInlineStyles", "showLineNumbers", "showInlineLineNumbers", "startingLineNumber", "lineNumberContainerStyle", "lineNumberStyle", "wrapLines", "wrapLongLines", "lineProps", "renderer", "PreTag", "CodeTag", "code", "astGenerator"];
function ownKeys(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    t && (a = a.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), r.push.apply(r, a);
  }
  return r;
}
function _objectSpread(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ownKeys(Object(r), !0).forEach(function(a) {
      _defineProperty(e, a, r[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : ownKeys(Object(r)).forEach(function(a) {
      Object.defineProperty(e, a, Object.getOwnPropertyDescriptor(r, a));
    });
  }
  return e;
}
var newLineRegex = /\n/g;
function getNewLines(e) {
  return e.match(newLineRegex);
}
function getAllLineNumbers(e) {
  var t = e.lines, r = e.startingLineNumber, a = e.style;
  return t.map(function(o, u) {
    var c = u + r;
    return /* @__PURE__ */ React.createElement("span", {
      key: "line-".concat(u),
      className: "react-syntax-highlighter-line-number",
      style: typeof a == "function" ? a(c) : a
    }, "".concat(c, `
`));
  });
}
function AllLineNumbers(e) {
  var t = e.codeString, r = e.codeStyle, a = e.containerStyle, o = a === void 0 ? {
    float: "left",
    paddingRight: "10px"
  } : a, u = e.numberStyle, c = u === void 0 ? {} : u, d = e.startingLineNumber;
  return /* @__PURE__ */ React.createElement("code", {
    style: Object.assign({}, r, o)
  }, getAllLineNumbers({
    lines: t.replace(/\n$/, "").split(`
`),
    style: c,
    startingLineNumber: d
  }));
}
function getEmWidthOfNumber(e) {
  return "".concat(e.toString().length, ".25em");
}
function getInlineLineNumber(e, t) {
  return {
    type: "element",
    tagName: "span",
    properties: {
      key: "line-number--".concat(e),
      className: ["comment", "linenumber", "react-syntax-highlighter-line-number"],
      style: t
    },
    children: [{
      type: "text",
      value: e
    }]
  };
}
function assembleLineNumberStyles(e, t, r) {
  var a = {
    display: "inline-block",
    minWidth: getEmWidthOfNumber(r),
    paddingRight: "1em",
    textAlign: "right",
    userSelect: "none"
  }, o = typeof e == "function" ? e(t) : e, u = _objectSpread(_objectSpread({}, a), o);
  return u;
}
function createLineElement(e) {
  var t = e.children, r = e.lineNumber, a = e.lineNumberStyle, o = e.largestLineNumber, u = e.showInlineLineNumbers, c = e.lineProps, d = c === void 0 ? {} : c, g = e.className, b = g === void 0 ? [] : g, _ = e.showLineNumbers, y = e.wrapLongLines, A = e.wrapLines, E = A === void 0 ? !1 : A, v = E ? _objectSpread({}, typeof d == "function" ? d(r) : d) : {};
  if (v.className = v.className ? [].concat(_toConsumableArray(v.className.trim().split(/\s+/)), _toConsumableArray(b)) : b, r && u) {
    var C = assembleLineNumberStyles(a, r, o);
    t.unshift(getInlineLineNumber(r, C));
  }
  return y & _ && (v.style = _objectSpread({
    display: "flex"
  }, v.style)), {
    type: "element",
    tagName: "span",
    properties: v,
    children: t
  };
}
function flattenCodeTree(e) {
  for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], a = 0; a < e.length; a++) {
    var o = e[a];
    if (o.type === "text")
      r.push(createLineElement({
        children: [o],
        className: _toConsumableArray(new Set(t))
      }));
    else if (o.children) {
      var u = t.concat(o.properties.className);
      flattenCodeTree(o.children, u).forEach(function(c) {
        return r.push(c);
      });
    }
  }
  return r;
}
function processLines(e, t, r, a, o, u, c, d, g) {
  var b, _ = flattenCodeTree(e.value), y = [], A = -1, E = 0;
  function v(M, x) {
    var P = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return createLineElement({
      children: M,
      lineNumber: x,
      lineNumberStyle: d,
      largestLineNumber: c,
      showInlineLineNumbers: o,
      lineProps: r,
      className: P,
      showLineNumbers: a,
      wrapLongLines: g,
      wrapLines: t
    });
  }
  function C(M, x) {
    if (a && x && o) {
      var P = assembleLineNumberStyles(d, x, c);
      M.unshift(getInlineLineNumber(x, P));
    }
    return M;
  }
  function R(M, x) {
    var P = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return t || P.length > 0 ? v(M, x, P) : C(M, x);
  }
  for (var I = function() {
    var x = _[E], P = x.children[0].value, U = getNewLines(P);
    if (U) {
      var L = P.split(`
`);
      L.forEach(function(H, B) {
        var V = a && y.length + u, X = {
          type: "text",
          value: "".concat(H, `
`)
        };
        if (B === 0) {
          var de = _.slice(A + 1, E).concat(createLineElement({
            children: [X],
            className: x.properties.className
          })), Y = R(de, V);
          y.push(Y);
        } else if (B === L.length - 1) {
          var se = _[E + 1] && _[E + 1].children && _[E + 1].children[0], ue = {
            type: "text",
            value: "".concat(H)
          };
          if (se) {
            var pe = createLineElement({
              children: [ue],
              className: x.properties.className
            });
            _.splice(E + 1, 0, pe);
          } else {
            var J = [ue], j = R(J, V, x.properties.className);
            y.push(j);
          }
        } else {
          var le = [X], Z = R(le, V, x.properties.className);
          y.push(Z);
        }
      }), A = E;
    }
    E++;
  }; E < _.length; )
    I();
  if (A !== _.length - 1) {
    var w = _.slice(A + 1, _.length);
    if (w && w.length) {
      var N = a && y.length + u, F = R(w, N);
      y.push(F);
    }
  }
  return t ? y : (b = []).concat.apply(b, y);
}
function defaultRenderer(e) {
  var t = e.rows, r = e.stylesheet, a = e.useInlineStyles;
  return t.map(function(o, u) {
    return createElement({
      node: o,
      stylesheet: r,
      useInlineStyles: a,
      key: "code-segement".concat(u)
    });
  });
}
function isHighlightJs(e) {
  return e && typeof e.highlightAuto < "u";
}
function getCodeTree(e) {
  var t = e.astGenerator, r = e.language, a = e.code, o = e.defaultCodeValue;
  if (isHighlightJs(t)) {
    var u = checkForListedLanguage(t, r);
    return r === "text" ? {
      value: o,
      language: "text"
    } : u ? t.highlight(r, a) : t.highlightAuto(a);
  }
  try {
    return r && r !== "text" ? {
      value: t.highlight(a, r)
    } : {
      value: o
    };
  } catch {
    return {
      value: o
    };
  }
}
function highlight$1(e, t) {
  return function(a) {
    var o = a.language, u = a.children, c = a.style, d = c === void 0 ? t : c, g = a.customStyle, b = g === void 0 ? {} : g, _ = a.codeTagProps, y = _ === void 0 ? {
      className: o ? "language-".concat(o) : void 0,
      style: _objectSpread(_objectSpread({}, d['code[class*="language-"]']), d['code[class*="language-'.concat(o, '"]')])
    } : _, A = a.useInlineStyles, E = A === void 0 ? !0 : A, v = a.showLineNumbers, C = v === void 0 ? !1 : v, R = a.showInlineLineNumbers, I = R === void 0 ? !0 : R, w = a.startingLineNumber, N = w === void 0 ? 1 : w, F = a.lineNumberContainerStyle, M = a.lineNumberStyle, x = M === void 0 ? {} : M, P = a.wrapLines, U = a.wrapLongLines, L = U === void 0 ? !1 : U, H = a.lineProps, B = H === void 0 ? {} : H, V = a.renderer, X = a.PreTag, de = X === void 0 ? "pre" : X, Y = a.CodeTag, se = Y === void 0 ? "code" : Y, ue = a.code, pe = ue === void 0 ? (Array.isArray(u) ? u[0] : u) || "" : ue, J = a.astGenerator, j = _objectWithoutProperties(a, _excluded);
    J = J || e;
    var le = C ? /* @__PURE__ */ React.createElement(AllLineNumbers, {
      containerStyle: F,
      codeStyle: y.style || {},
      numberStyle: x,
      startingLineNumber: N,
      codeString: pe
    }) : null, Z = d.hljs || d['pre[class*="language-"]'] || {
      backgroundColor: "#fff"
    }, O = isHighlightJs(J) ? "hljs" : "prismjs", z = E ? Object.assign({}, j, {
      style: Object.assign({}, Z, b)
    }) : Object.assign({}, j, {
      className: j.className ? "".concat(O, " ").concat(j.className) : O,
      style: Object.assign({}, b)
    });
    if (L ? y.style = _objectSpread({
      whiteSpace: "pre-wrap"
    }, y.style) : y.style = _objectSpread({
      whiteSpace: "pre"
    }, y.style), !J)
      return /* @__PURE__ */ React.createElement(de, z, le, /* @__PURE__ */ React.createElement(se, y, pe));
    (P === void 0 && V || L) && (P = !0), V = V || defaultRenderer;
    var W = [{
      type: "text",
      value: pe
    }], ee = getCodeTree({
      astGenerator: J,
      language: o,
      code: pe,
      defaultCodeValue: W
    });
    ee.language === null && (ee.value = W);
    var ae = ee.value.length;
    ae === 1 && ee.value[0].type === "text" && (ae = ee.value[0].value.split(`
`).length);
    var ie = ae + N, me = processLines(ee, P, B, C, I, N, ie, x, L);
    return /* @__PURE__ */ React.createElement(de, z, /* @__PURE__ */ React.createElement(se, y, !I && le, V({
      rows: me,
      stylesheet: d,
      useInlineStyles: E
    })));
  };
}
const supportedLanguages = ["abap", "abnf", "actionscript", "ada", "agda", "al", "antlr4", "apacheconf", "apex", "apl", "applescript", "aql", "arduino", "arff", "asciidoc", "asm6502", "asmatmel", "aspnet", "autohotkey", "autoit", "avisynth", "avro-idl", "bash", "basic", "batch", "bbcode", "bicep", "birb", "bison", "bnf", "brainfuck", "brightscript", "bro", "bsl", "c", "cfscript", "chaiscript", "cil", "clike", "clojure", "cmake", "cobol", "coffeescript", "concurnas", "coq", "cpp", "crystal", "csharp", "cshtml", "csp", "css-extras", "css", "csv", "cypher", "d", "dart", "dataweave", "dax", "dhall", "diff", "django", "dns-zone-file", "docker", "dot", "ebnf", "editorconfig", "eiffel", "ejs", "elixir", "elm", "erb", "erlang", "etlua", "excel-formula", "factor", "false", "firestore-security-rules", "flow", "fortran", "fsharp", "ftl", "gap", "gcode", "gdscript", "gedcom", "gherkin", "git", "glsl", "gml", "gn", "go-module", "go", "graphql", "groovy", "haml", "handlebars", "haskell", "haxe", "hcl", "hlsl", "hoon", "hpkp", "hsts", "http", "ichigojam", "icon", "icu-message-format", "idris", "iecst", "ignore", "inform7", "ini", "io", "j", "java", "javadoc", "javadoclike", "javascript", "javastacktrace", "jexl", "jolie", "jq", "js-extras", "js-templates", "jsdoc", "json", "json5", "jsonp", "jsstacktrace", "jsx", "julia", "keepalived", "keyman", "kotlin", "kumir", "kusto", "latex", "latte", "less", "lilypond", "liquid", "lisp", "livescript", "llvm", "log", "lolcode", "lua", "magma", "makefile", "markdown", "markup-templating", "markup", "matlab", "maxscript", "mel", "mermaid", "mizar", "mongodb", "monkey", "moonscript", "n1ql", "n4js", "nand2tetris-hdl", "naniscript", "nasm", "neon", "nevod", "nginx", "nim", "nix", "nsis", "objectivec", "ocaml", "opencl", "openqasm", "oz", "parigp", "parser", "pascal", "pascaligo", "pcaxis", "peoplecode", "perl", "php-extras", "php", "phpdoc", "plsql", "powerquery", "powershell", "processing", "prolog", "promql", "properties", "protobuf", "psl", "pug", "puppet", "pure", "purebasic", "purescript", "python", "q", "qml", "qore", "qsharp", "r", "racket", "reason", "regex", "rego", "renpy", "rest", "rip", "roboconf", "robotframework", "ruby", "rust", "sas", "sass", "scala", "scheme", "scss", "shell-session", "smali", "smalltalk", "smarty", "sml", "solidity", "solution-file", "soy", "sparql", "splunk-spl", "sqf", "sql", "squirrel", "stan", "stylus", "swift", "systemd", "t4-cs", "t4-templating", "t4-vb", "tap", "tcl", "textile", "toml", "tremor", "tsx", "tt2", "turtle", "twig", "typescript", "typoscript", "unrealscript", "uorazor", "uri", "v", "vala", "vbnet", "velocity", "verilog", "vhdl", "vim", "visual-basic", "warpscript", "wasm", "web-idl", "wiki", "wolfram", "wren", "xeora", "xml-doc", "xojo", "xquery", "yaml", "yang", "zig"];
var immutable = extend, hasOwnProperty = Object.prototype.hasOwnProperty;
function extend() {
  for (var e = {}, t = 0; t < arguments.length; t++) {
    var r = arguments[t];
    for (var a in r)
      hasOwnProperty.call(r, a) && (e[a] = r[a]);
  }
  return e;
}
var schema$1 = Schema$2, proto$1 = Schema$2.prototype;
proto$1.space = null;
proto$1.normal = {};
proto$1.property = {};
function Schema$2(e, t, r) {
  this.property = e, this.normal = t, r && (this.space = r);
}
var xtend = immutable, Schema$1 = schema$1, merge_1 = merge$1;
function merge$1(e) {
  for (var t = e.length, r = [], a = [], o = -1, u, c; ++o < t; )
    u = e[o], r.push(u.property), a.push(u.normal), c = u.space;
  return new Schema$1(xtend.apply(null, r), xtend.apply(null, a), c);
}
var normalize_1 = normalize$3;
function normalize$3(e) {
  return e.toLowerCase();
}
var info = Info$2, proto = Info$2.prototype;
proto.space = null;
proto.attribute = null;
proto.property = null;
proto.boolean = !1;
proto.booleanish = !1;
proto.overloadedBoolean = !1;
proto.number = !1;
proto.commaSeparated = !1;
proto.spaceSeparated = !1;
proto.commaOrSpaceSeparated = !1;
proto.mustUseProperty = !1;
proto.defined = !1;
function Info$2(e, t) {
  this.property = e, this.attribute = t;
}
var types$3 = {}, powers = 0;
types$3.boolean = increment();
types$3.booleanish = increment();
types$3.overloadedBoolean = increment();
types$3.number = increment();
types$3.spaceSeparated = increment();
types$3.commaSeparated = increment();
types$3.commaOrSpaceSeparated = increment();
function increment() {
  return Math.pow(2, ++powers);
}
var Info$1 = info, types$2 = types$3, definedInfo = DefinedInfo$2;
DefinedInfo$2.prototype = new Info$1();
DefinedInfo$2.prototype.defined = !0;
var checks = ["boolean", "booleanish", "overloadedBoolean", "number", "commaSeparated", "spaceSeparated", "commaOrSpaceSeparated"], checksLength = checks.length;
function DefinedInfo$2(e, t, r, a) {
  var o = -1, u;
  for (mark(this, "space", a), Info$1.call(this, e, t); ++o < checksLength; )
    u = checks[o], mark(this, u, (r & types$2[u]) === types$2[u]);
}
function mark(e, t, r) {
  r && (e[t] = r);
}
var normalize$2 = normalize_1, Schema = schema$1, DefinedInfo$1 = definedInfo, create_1 = create$5;
function create$5(e) {
  var t = e.space, r = e.mustUseProperty || [], a = e.attributes || {}, o = e.properties, u = e.transform, c = {}, d = {}, g, b;
  for (g in o)
    b = new DefinedInfo$1(g, u(a, g), o[g], t), r.indexOf(g) !== -1 && (b.mustUseProperty = !0), c[g] = b, d[normalize$2(g)] = g, d[normalize$2(b.attribute)] = g;
  return new Schema(c, d, t);
}
var create$4 = create_1, xlink$1 = create$4({
  space: "xlink",
  transform: xlinkTransform,
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});
function xlinkTransform(e, t) {
  return "xlink:" + t.slice(5).toLowerCase();
}
var create$3 = create_1, xml$1 = create$3({
  space: "xml",
  transform: xmlTransform,
  properties: {
    xmlLang: null,
    xmlBase: null,
    xmlSpace: null
  }
});
function xmlTransform(e, t) {
  return "xml:" + t.slice(3).toLowerCase();
}
var caseSensitiveTransform_1 = caseSensitiveTransform$1;
function caseSensitiveTransform$1(e, t) {
  return t in e ? e[t] : t;
}
var caseSensitiveTransform = caseSensitiveTransform_1, caseInsensitiveTransform_1 = caseInsensitiveTransform$2;
function caseInsensitiveTransform$2(e, t) {
  return caseSensitiveTransform(e, t.toLowerCase());
}
var create$2 = create_1, caseInsensitiveTransform$1 = caseInsensitiveTransform_1, xmlns$1 = create$2({
  space: "xmlns",
  attributes: {
    xmlnsxlink: "xmlns:xlink"
  },
  transform: caseInsensitiveTransform$1,
  properties: {
    xmlns: null,
    xmlnsXLink: null
  }
}), types$1 = types$3, create$1 = create_1, booleanish$1 = types$1.booleanish, number$1 = types$1.number, spaceSeparated$1 = types$1.spaceSeparated, aria$2 = create$1({
  transform: ariaTransform,
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish$1,
    ariaAutoComplete: null,
    ariaBusy: booleanish$1,
    ariaChecked: booleanish$1,
    ariaColCount: number$1,
    ariaColIndex: number$1,
    ariaColSpan: number$1,
    ariaControls: spaceSeparated$1,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated$1,
    ariaDetails: null,
    ariaDisabled: booleanish$1,
    ariaDropEffect: spaceSeparated$1,
    ariaErrorMessage: null,
    ariaExpanded: booleanish$1,
    ariaFlowTo: spaceSeparated$1,
    ariaGrabbed: booleanish$1,
    ariaHasPopup: null,
    ariaHidden: booleanish$1,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated$1,
    ariaLevel: number$1,
    ariaLive: null,
    ariaModal: booleanish$1,
    ariaMultiLine: booleanish$1,
    ariaMultiSelectable: booleanish$1,
    ariaOrientation: null,
    ariaOwns: spaceSeparated$1,
    ariaPlaceholder: null,
    ariaPosInSet: number$1,
    ariaPressed: booleanish$1,
    ariaReadOnly: booleanish$1,
    ariaRelevant: null,
    ariaRequired: booleanish$1,
    ariaRoleDescription: spaceSeparated$1,
    ariaRowCount: number$1,
    ariaRowIndex: number$1,
    ariaRowSpan: number$1,
    ariaSelected: booleanish$1,
    ariaSetSize: number$1,
    ariaSort: null,
    ariaValueMax: number$1,
    ariaValueMin: number$1,
    ariaValueNow: number$1,
    ariaValueText: null,
    role: null
  }
});
function ariaTransform(e, t) {
  return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
}
var types = types$3, create = create_1, caseInsensitiveTransform = caseInsensitiveTransform_1, boolean = types.boolean, overloadedBoolean = types.overloadedBoolean, booleanish = types.booleanish, number = types.number, spaceSeparated = types.spaceSeparated, commaSeparated = types.commaSeparated, html$2 = create({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    capture: boolean,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: boolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: commaSeparated,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextMenu: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: commaSeparated,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number,
    // `<img>` and `<object>`
    leftMargin: number,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number,
    // `<body>`
    marginWidth: number,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  }
}), merge = merge_1, xlink = xlink$1, xml = xml$1, xmlns = xmlns$1, aria$1 = aria$2, html$1 = html$2, html_1$1 = merge([xml, xlink, xmlns, aria$1, html$1]), normalize$1 = normalize_1, DefinedInfo = definedInfo, Info = info, data = "data", find_1 = find$1, valid = /^data[-\w.:]+$/i, dash = /-[a-z]/g, cap = /[A-Z]/g;
function find$1(e, t) {
  var r = normalize$1(t), a = t, o = Info;
  return r in e.normal ? e.property[e.normal[r]] : (r.length > 4 && r.slice(0, 4) === data && valid.test(t) && (t.charAt(4) === "-" ? a = datasetToProperty(t) : t = datasetToAttribute(t), o = DefinedInfo), new o(a, t));
}
function datasetToProperty(e) {
  var t = e.slice(5).replace(dash, camelcase);
  return data + t.charAt(0).toUpperCase() + t.slice(1);
}
function datasetToAttribute(e) {
  var t = e.slice(4);
  return dash.test(t) ? e : (t = t.replace(cap, kebab), t.charAt(0) !== "-" && (t = "-" + t), data + t);
}
function kebab(e) {
  return "-" + e.toLowerCase();
}
function camelcase(e) {
  return e.charAt(1).toUpperCase();
}
var hastUtilParseSelector = parse$4, search = /[#.]/g;
function parse$4(e, t) {
  for (var r = e || "", a = t || "div", o = {}, u = 0, c, d, g; u < r.length; )
    search.lastIndex = u, g = search.exec(r), c = r.slice(u, g ? g.index : r.length), c && (d ? d === "#" ? o.id = c : o.className ? o.className.push(c) : o.className = [c] : a = c, u += c.length), g && (d = g[0], u++);
  return {
    type: "element",
    tagName: a,
    properties: o,
    children: []
  };
}
var spaceSeparatedTokens = {};
spaceSeparatedTokens.parse = parse$3;
spaceSeparatedTokens.stringify = stringify$2;
var empty$2 = "", space$5 = " ", whiteSpace = /[ \t\n\r\f]+/g;
function parse$3(e) {
  var t = String(e || empty$2).trim();
  return t === empty$2 ? [] : t.split(whiteSpace);
}
function stringify$2(e) {
  return e.join(space$5).trim();
}
var commaSeparatedTokens = {};
commaSeparatedTokens.parse = parse$2;
commaSeparatedTokens.stringify = stringify$1;
var comma = ",", space$4 = " ", empty$1 = "";
function parse$2(e) {
  for (var t = [], r = String(e || empty$1), a = r.indexOf(comma), o = 0, u = !1, c; !u; )
    a === -1 && (a = r.length, u = !0), c = r.slice(o, a).trim(), (c || !u) && t.push(c), o = a + 1, a = r.indexOf(comma, o);
  return t;
}
function stringify$1(e, t) {
  var r = t || {}, a = r.padLeft === !1 ? empty$1 : space$4, o = r.padRight ? space$4 : empty$1;
  return e[e.length - 1] === empty$1 && (e = e.concat(empty$1)), e.join(o + comma + a).trim();
}
var find = find_1, normalize = normalize_1, parseSelector = hastUtilParseSelector, spaces = spaceSeparatedTokens.parse, commas = commaSeparatedTokens.parse, factory_1 = factory$1, own$5 = {}.hasOwnProperty;
function factory$1(e, t, r) {
  var a = r ? createAdjustMap$1(r) : null;
  return o;
  function o(c, d) {
    var g = parseSelector(c, t), b = Array.prototype.slice.call(arguments, 2), _ = g.tagName.toLowerCase(), y;
    if (g.tagName = a && own$5.call(a, _) ? a[_] : _, d && isChildren(d, g) && (b.unshift(d), d = null), d)
      for (y in d)
        u(g.properties, y, d[y]);
    return addChild$1(g.children, b), g.tagName === "template" && (g.content = {
      type: "root",
      children: g.children
    }, g.children = []), g;
  }
  function u(c, d, g) {
    var b, _, y;
    g == null || g !== g || (b = find(e, d), _ = b.property, y = g, typeof y == "string" && (b.spaceSeparated ? y = spaces(y) : b.commaSeparated ? y = commas(y) : b.commaOrSpaceSeparated && (y = spaces(commas(y).join(" ")))), _ === "style" && typeof g != "string" && (y = style$1(y)), _ === "className" && c.className && (y = c.className.concat(y)), c[_] = parsePrimitives(b, _, y));
  }
}
function isChildren(e, t) {
  return typeof e == "string" || "length" in e || isNode(t.tagName, e);
}
function isNode(e, t) {
  var r = t.type;
  return e === "input" || !r || typeof r != "string" ? !1 : typeof t.children == "object" && "length" in t.children ? !0 : (r = r.toLowerCase(), e === "button" ? r !== "menu" && r !== "submit" && r !== "reset" && r !== "button" : "value" in t);
}
function addChild$1(e, t) {
  var r, a;
  if (typeof t == "string" || typeof t == "number") {
    e.push({
      type: "text",
      value: String(t)
    });
    return;
  }
  if (typeof t == "object" && "length" in t) {
    for (r = -1, a = t.length; ++r < a; )
      addChild$1(e, t[r]);
    return;
  }
  if (typeof t != "object" || !("type" in t))
    throw new Error("Expected node, nodes, or string, got `" + t + "`");
  e.push(t);
}
function parsePrimitives(e, t, r) {
  var a, o, u;
  if (typeof r != "object" || !("length" in r))
    return parsePrimitive$1(e, t, r);
  for (o = r.length, a = -1, u = []; ++a < o; )
    u[a] = parsePrimitive$1(e, t, r[a]);
  return u;
}
function parsePrimitive$1(e, t, r) {
  var a = r;
  return e.number || e.positiveNumber ? !isNaN(a) && a !== "" && (a = Number(a)) : (e.boolean || e.overloadedBoolean) && typeof a == "string" && (a === "" || normalize(r) === normalize(t)) && (a = !0), a;
}
function style$1(e) {
  var t = [], r;
  for (r in e)
    t.push([r, e[r]].join(": "));
  return t.join("; ");
}
function createAdjustMap$1(e) {
  for (var t = e.length, r = -1, a = {}, o; ++r < t; )
    o = e[r], a[o.toLowerCase()] = o;
  return a;
}
var schema = html_1$1, factory = factory_1, html = factory(schema, "div");
html.displayName = "html";
var html_1 = html, hastscript = html_1;
const AElig = "", AMP = "&", Aacute = "", Acirc = "", Agrave = "", Aring = "", Atilde = "", Auml = "", COPY = "", Ccedil = "", ETH = "", Eacute = "", Ecirc = "", Egrave = "", Euml = "", GT = ">", Iacute = "", Icirc = "", Igrave = "", Iuml = "", LT = "<", Ntilde = "", Oacute = "", Ocirc = "", Ograve = "", Oslash = "", Otilde = "", Ouml = "", QUOT = '"', REG = "", THORN = "", Uacute = "", Ucirc = "", Ugrave = "", Uuml = "", Yacute = "", aacute = "", acirc = "", acute = "", aelig = "", agrave = "", amp = "&", aring = "", atilde = "", auml = "", brvbar = "", ccedil = "", cedil = "", cent = "", copy = "", curren = "", deg = "", divide = "", eacute = "", ecirc = "", egrave = "", eth = "", euml = "", frac12 = "", frac14 = "", frac34 = "", gt = ">", iacute = "", icirc = "", iexcl = "", igrave = "", iquest = "", iuml = "", laquo = "", lt = "<", macr = "", micro = "", middot = "", nbsp = "", not = "", ntilde = "", oacute = "", ocirc = "", ograve = "", ordf = "", ordm = "", oslash = "", otilde = "", ouml = "", para = "", plusmn = "", pound = "", quot = '"', raquo = "", reg = "", sect = "", shy = "", sup1 = "", sup2 = "", sup3 = "", szlig = "", thorn = "", times = "", uacute = "", ucirc = "", ugrave = "", uml = "", uuml = "", yacute = "", yen = "", yuml = "", require$$0 = {
  AElig,
  AMP,
  Aacute,
  Acirc,
  Agrave,
  Aring,
  Atilde,
  Auml,
  COPY,
  Ccedil,
  ETH,
  Eacute,
  Ecirc,
  Egrave,
  Euml,
  GT,
  Iacute,
  Icirc,
  Igrave,
  Iuml,
  LT,
  Ntilde,
  Oacute,
  Ocirc,
  Ograve,
  Oslash,
  Otilde,
  Ouml,
  QUOT,
  REG,
  THORN,
  Uacute,
  Ucirc,
  Ugrave,
  Uuml,
  Yacute,
  aacute,
  acirc,
  acute,
  aelig,
  agrave,
  amp,
  aring,
  atilde,
  auml,
  brvbar,
  ccedil,
  cedil,
  cent,
  copy,
  curren,
  deg,
  divide,
  eacute,
  ecirc,
  egrave,
  eth,
  euml,
  frac12,
  frac14,
  frac34,
  gt,
  iacute,
  icirc,
  iexcl,
  igrave,
  iquest,
  iuml,
  laquo,
  lt,
  macr,
  micro,
  middot,
  nbsp,
  not,
  ntilde,
  oacute,
  ocirc,
  ograve,
  ordf,
  ordm,
  oslash,
  otilde,
  ouml,
  para,
  plusmn,
  pound,
  quot,
  raquo,
  reg,
  sect,
  shy,
  sup1,
  sup2,
  sup3,
  szlig,
  thorn,
  times,
  uacute,
  ucirc,
  ugrave,
  uml,
  uuml,
  yacute,
  yen,
  yuml
}, require$$1 = {
  0: "",
  128: "",
  130: "",
  131: "",
  132: "",
  133: "",
  134: "",
  135: "",
  136: "",
  137: "",
  138: "",
  139: "",
  140: "",
  142: "",
  145: "",
  146: "",
  147: "",
  148: "",
  149: "",
  150: "",
  151: "",
  152: "",
  153: "",
  154: "",
  155: "",
  156: "",
  158: "",
  159: ""
};
var isDecimal = decimal$2;
function decimal$2(e) {
  var t = typeof e == "string" ? e.charCodeAt(0) : e;
  return t >= 48 && t <= 57;
}
var isHexadecimal = hexadecimal$1;
function hexadecimal$1(e) {
  var t = typeof e == "string" ? e.charCodeAt(0) : e;
  return t >= 97 && t <= 102 || t >= 65 && t <= 70 || t >= 48 && t <= 57;
}
var isAlphabetical = alphabetical$1;
function alphabetical$1(e) {
  var t = typeof e == "string" ? e.charCodeAt(0) : e;
  return t >= 97 && t <= 122 || t >= 65 && t <= 90;
}
var alphabetical = isAlphabetical, decimal$1 = isDecimal, isAlphanumerical = alphanumerical$1;
function alphanumerical$1(e) {
  return alphabetical(e) || decimal$1(e);
}
var el, semicolon$1 = 59, decodeEntity_browser = decodeEntity$1;
function decodeEntity$1(e) {
  var t = "&" + e + ";", r;
  return el = el || document.createElement("i"), el.innerHTML = t, r = el.textContent, r.charCodeAt(r.length - 1) === semicolon$1 && e !== "semi" || r === t ? !1 : r;
}
var legacy = require$$0, invalid = require$$1, decimal = isDecimal, hexadecimal = isHexadecimal, alphanumerical = isAlphanumerical, decodeEntity = decodeEntity_browser, parseEntities_1 = parseEntities, own$4 = {}.hasOwnProperty, fromCharCode = String.fromCharCode, noop$2 = Function.prototype, defaults = {
  warning: null,
  reference: null,
  text: null,
  warningContext: null,
  referenceContext: null,
  textContext: null,
  position: {},
  additional: null,
  attribute: !1,
  nonTerminated: !0
}, tab = 9, lineFeed = 10, formFeed = 12, space$3 = 32, ampersand = 38, semicolon = 59, lessThan = 60, equalsTo = 61, numberSign = 35, uppercaseX = 88, lowercaseX = 120, replacementCharacter = 65533, name = "named", hexa = "hexadecimal", deci = "decimal", bases = {};
bases[hexa] = 16;
bases[deci] = 10;
var tests = {};
tests[name] = alphanumerical;
tests[deci] = decimal;
tests[hexa] = hexadecimal;
var namedNotTerminated = 1, numericNotTerminated = 2, namedEmpty = 3, numericEmpty = 4, namedUnknown = 5, numericDisallowed = 6, numericProhibited = 7, messages = {};
messages[namedNotTerminated] = "Named character references must be terminated by a semicolon";
messages[numericNotTerminated] = "Numeric character references must be terminated by a semicolon";
messages[namedEmpty] = "Named character references cannot be empty";
messages[numericEmpty] = "Numeric character references cannot be empty";
messages[namedUnknown] = "Named character references must be known";
messages[numericDisallowed] = "Numeric character references cannot be disallowed";
messages[numericProhibited] = "Numeric character references cannot be outside the permissible Unicode range";
function parseEntities(e, t) {
  var r = {}, a, o;
  t || (t = {});
  for (o in defaults)
    a = t[o], r[o] = a ?? defaults[o];
  return (r.position.indent || r.position.start) && (r.indent = r.position.indent || [], r.position = r.position.start), parse$1(e, r);
}
function parse$1(e, t) {
  var r = t.additional, a = t.nonTerminated, o = t.text, u = t.reference, c = t.warning, d = t.textContext, g = t.referenceContext, b = t.warningContext, _ = t.position, y = t.indent || [], A = e.length, E = 0, v = -1, C = _.column || 1, R = _.line || 1, I = "", w = [], N, F, M, x, P, U, L, H, B, V, X, de, Y, se, ue, pe, J, j, le;
  for (typeof r == "string" && (r = r.charCodeAt(0)), pe = Z(), H = c ? O : noop$2, E--, A++; ++E < A; )
    if (P === lineFeed && (C = y[v] || 1), P = e.charCodeAt(E), P === ampersand) {
      if (L = e.charCodeAt(E + 1), L === tab || L === lineFeed || L === formFeed || L === space$3 || L === ampersand || L === lessThan || L !== L || r && L === r) {
        I += fromCharCode(P), C++;
        continue;
      }
      for (Y = E + 1, de = Y, le = Y, L === numberSign ? (le = ++de, L = e.charCodeAt(le), L === uppercaseX || L === lowercaseX ? (se = hexa, le = ++de) : se = deci) : se = name, N = "", X = "", x = "", ue = tests[se], le--; ++le < A && (L = e.charCodeAt(le), !!ue(L)); )
        x += fromCharCode(L), se === name && own$4.call(legacy, x) && (N = x, X = legacy[x]);
      M = e.charCodeAt(le) === semicolon, M && (le++, F = se === name ? decodeEntity(x) : !1, F && (N = x, X = F)), j = 1 + le - Y, !M && !a || (x ? se === name ? (M && !X ? H(namedUnknown, 1) : (N !== x && (le = de + N.length, j = 1 + le - de, M = !1), M || (B = N ? namedNotTerminated : namedEmpty, t.attribute ? (L = e.charCodeAt(le), L === equalsTo ? (H(B, j), X = null) : alphanumerical(L) ? X = null : H(B, j)) : H(B, j))), U = X) : (M || H(numericNotTerminated, j), U = parseInt(x, bases[se]), prohibited(U) ? (H(numericProhibited, j), U = fromCharCode(replacementCharacter)) : U in invalid ? (H(numericDisallowed, j), U = invalid[U]) : (V = "", disallowed(U) && H(numericDisallowed, j), U > 65535 && (U -= 65536, V += fromCharCode(U >>> 10 | 55296), U = 56320 | U & 1023), U = V + fromCharCode(U))) : se !== name && H(numericEmpty, j)), U ? (z(), pe = Z(), E = le - 1, C += le - Y + 1, w.push(U), J = Z(), J.offset++, u && u.call(g, U, {
        start: pe,
        end: J
      }, e.slice(Y - 1, le)), pe = J) : (x = e.slice(Y - 1, le), I += x, C += x.length, E = le - 1);
    } else
      P === 10 && (R++, v++, C = 0), P === P ? (I += fromCharCode(P), C++) : z();
  return w.join("");
  function Z() {
    return {
      line: R,
      column: C,
      offset: E + (_.offset || 0)
    };
  }
  function O(W, ee) {
    var ae = Z();
    ae.column += ee, ae.offset += ee, c.call(b, messages[W], ae, W);
  }
  function z() {
    I && (w.push(I), o && o.call(d, I, {
      start: pe,
      end: Z()
    }), I = "");
  }
}
function prohibited(e) {
  return e >= 55296 && e <= 57343 || e > 1114111;
}
function disallowed(e) {
  return e >= 1 && e <= 8 || e === 11 || e >= 13 && e <= 31 || e >= 127 && e <= 159 || e >= 64976 && e <= 65007 || (e & 65535) === 65535 || (e & 65535) === 65534;
}
var prismCore = {
  exports: {}
};
(function(e) {
  var t = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};
  /**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   */
  var r = function(a) {
    var o = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, u = 0, c = {}, d = {
      /**
       * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
       * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
       * additional languages or plugins yourself.
       *
       * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
       *
       * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.manual = true;
       * // add a new <script> to load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      manual: a.Prism && a.Prism.manual,
      /**
       * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
       * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
       * own worker, you don't want it to do this.
       *
       * By setting this value to `true`, Prism will not add its own listeners to the worker.
       *
       * You obviously have to change this value before Prism executes. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.disableWorkerMessageHandler = true;
       * // Load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      disableWorkerMessageHandler: a.Prism && a.Prism.disableWorkerMessageHandler,
      /**
       * A namespace for utility methods.
       *
       * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
       * change or disappear at any time.
       *
       * @namespace
       * @memberof Prism
       */
      util: {
        encode: function w(N) {
          return N instanceof g ? new g(N.type, w(N.content), N.alias) : Array.isArray(N) ? N.map(w) : N.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
        },
        /**
         * Returns the name of the type of the given value.
         *
         * @param {any} o
         * @returns {string}
         * @example
         * type(null)      === 'Null'
         * type(undefined) === 'Undefined'
         * type(123)       === 'Number'
         * type('foo')     === 'String'
         * type(true)      === 'Boolean'
         * type([1, 2])    === 'Array'
         * type({})        === 'Object'
         * type(String)    === 'Function'
         * type(/abc+/)    === 'RegExp'
         */
        type: function(w) {
          return Object.prototype.toString.call(w).slice(8, -1);
        },
        /**
         * Returns a unique number for the given object. Later calls will still return the same number.
         *
         * @param {Object} obj
         * @returns {number}
         */
        objId: function(w) {
          return w.__id || Object.defineProperty(w, "__id", {
            value: ++u
          }), w.__id;
        },
        /**
         * Creates a deep clone of the given object.
         *
         * The main intended use of this function is to clone language definitions.
         *
         * @param {T} o
         * @param {Record<number, any>} [visited]
         * @returns {T}
         * @template T
         */
        clone: function w(N, F) {
          F = F || {};
          var M, x;
          switch (d.util.type(N)) {
            case "Object":
              if (x = d.util.objId(N), F[x])
                return F[x];
              M = /** @type {Record<string, any>} */
              {}, F[x] = M;
              for (var P in N)
                N.hasOwnProperty(P) && (M[P] = w(N[P], F));
              return (
                /** @type {any} */
                M
              );
            case "Array":
              return x = d.util.objId(N), F[x] ? F[x] : (M = [], F[x] = M, /** @type {Array} */
              /** @type {any} */
              N.forEach(function(U, L) {
                M[L] = w(U, F);
              }), /** @type {any} */
              M);
            default:
              return N;
          }
        },
        /**
         * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
         *
         * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
         *
         * @param {Element} element
         * @returns {string}
         */
        getLanguage: function(w) {
          for (; w; ) {
            var N = o.exec(w.className);
            if (N)
              return N[1].toLowerCase();
            w = w.parentElement;
          }
          return "none";
        },
        /**
         * Sets the Prism `language-xxxx` class of the given element.
         *
         * @param {Element} element
         * @param {string} language
         * @returns {void}
         */
        setLanguage: function(w, N) {
          w.className = w.className.replace(RegExp(o, "gi"), ""), w.classList.add("language-" + N);
        },
        /**
         * Returns the script element that is currently executing.
         *
         * This does __not__ work for line script element.
         *
         * @returns {HTMLScriptElement | null}
         */
        currentScript: function() {
          if (typeof document > "u")
            return null;
          if ("currentScript" in document)
            return (
              /** @type {any} */
              document.currentScript
            );
          try {
            throw new Error();
          } catch (M) {
            var w = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(M.stack) || [])[1];
            if (w) {
              var N = document.getElementsByTagName("script");
              for (var F in N)
                if (N[F].src == w)
                  return N[F];
            }
            return null;
          }
        },
        /**
         * Returns whether a given class is active for `element`.
         *
         * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
         * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
         * given class is just the given class with a `no-` prefix.
         *
         * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
         * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
         * ancestors have the given class or the negated version of it, then the default activation will be returned.
         *
         * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
         * version of it, the class is considered active.
         *
         * @param {Element} element
         * @param {string} className
         * @param {boolean} [defaultActivation=false]
         * @returns {boolean}
         */
        isActive: function(w, N, F) {
          for (var M = "no-" + N; w; ) {
            var x = w.classList;
            if (x.contains(N))
              return !0;
            if (x.contains(M))
              return !1;
            w = w.parentElement;
          }
          return !!F;
        }
      },
      /**
       * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
       *
       * @namespace
       * @memberof Prism
       * @public
       */
      languages: {
        /**
         * The grammar for plain, unformatted text.
         */
        plain: c,
        plaintext: c,
        text: c,
        txt: c,
        /**
         * Creates a deep copy of the language with the given id and appends the given tokens.
         *
         * If a token in `redef` also appears in the copied language, then the existing token in the copied language
         * will be overwritten at its original position.
         *
         * ## Best practices
         *
         * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
         * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
         * understand the language definition because, normally, the order of tokens matters in Prism grammars.
         *
         * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
         * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
         *
         * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
         * @param {Grammar} redef The new tokens to append.
         * @returns {Grammar} The new language created.
         * @public
         * @example
         * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
         *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
         *     // at its original position
         *     'comment': { ... },
         *     // CSS doesn't have a 'color' token, so this token will be appended
         *     'color': /\b(?:red|green|blue)\b/
         * });
         */
        extend: function(w, N) {
          var F = d.util.clone(d.languages[w]);
          for (var M in N)
            F[M] = N[M];
          return F;
        },
        /**
         * Inserts tokens _before_ another token in a language definition or any other grammar.
         *
         * ## Usage
         *
         * This helper method makes it easy to modify existing languages. For example, the CSS language definition
         * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
         * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
         * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
         * this:
         *
         * ```js
         * Prism.languages.markup.style = {
         *     // token
         * };
         * ```
         *
         * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
         * before existing tokens. For the CSS example above, you would use it like this:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'cdata', {
         *     'style': {
         *         // token
         *     }
         * });
         * ```
         *
         * ## Special cases
         *
         * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
         * will be ignored.
         *
         * This behavior can be used to insert tokens after `before`:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'comment', {
         *     'comment': Prism.languages.markup.comment,
         *     // tokens after 'comment'
         * });
         * ```
         *
         * ## Limitations
         *
         * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
         * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
         * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
         * deleting properties which is necessary to insert at arbitrary positions.
         *
         * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
         * Instead, it will create a new object and replace all references to the target object with the new one. This
         * can be done without temporarily deleting properties, so the iteration order is well-defined.
         *
         * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
         * you hold the target object in a variable, then the value of the variable will not change.
         *
         * ```js
         * var oldMarkup = Prism.languages.markup;
         * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
         *
         * assert(oldMarkup !== Prism.languages.markup);
         * assert(newMarkup === Prism.languages.markup);
         * ```
         *
         * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
         * object to be modified.
         * @param {string} before The key to insert before.
         * @param {Grammar} insert An object containing the key-value pairs to be inserted.
         * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
         * object to be modified.
         *
         * Defaults to `Prism.languages`.
         * @returns {Grammar} The new grammar object.
         * @public
         */
        insertBefore: function(w, N, F, M) {
          M = M || /** @type {any} */
          d.languages;
          var x = M[w], P = {};
          for (var U in x)
            if (x.hasOwnProperty(U)) {
              if (U == N)
                for (var L in F)
                  F.hasOwnProperty(L) && (P[L] = F[L]);
              F.hasOwnProperty(U) || (P[U] = x[U]);
            }
          var H = M[w];
          return M[w] = P, d.languages.DFS(d.languages, function(B, V) {
            V === H && B != w && (this[B] = P);
          }), P;
        },
        // Traverse a language definition with Depth First Search
        DFS: function w(N, F, M, x) {
          x = x || {};
          var P = d.util.objId;
          for (var U in N)
            if (N.hasOwnProperty(U)) {
              F.call(N, U, N[U], M || U);
              var L = N[U], H = d.util.type(L);
              H === "Object" && !x[P(L)] ? (x[P(L)] = !0, w(L, F, null, x)) : H === "Array" && !x[P(L)] && (x[P(L)] = !0, w(L, F, U, x));
            }
        }
      },
      plugins: {},
      /**
       * This is the most high-level function in Prisms API.
       * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
       * each one of them.
       *
       * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
       *
       * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
       * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
       * @memberof Prism
       * @public
       */
      highlightAll: function(w, N) {
        d.highlightAllUnder(document, w, N);
      },
      /**
       * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
       * {@link Prism.highlightElement} on each one of them.
       *
       * The following hooks will be run:
       * 1. `before-highlightall`
       * 2. `before-all-elements-highlight`
       * 3. All hooks of {@link Prism.highlightElement} for each element.
       *
       * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
       * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
       * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
       * @memberof Prism
       * @public
       */
      highlightAllUnder: function(w, N, F) {
        var M = {
          callback: F,
          container: w,
          selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
        };
        d.hooks.run("before-highlightall", M), M.elements = Array.prototype.slice.apply(M.container.querySelectorAll(M.selector)), d.hooks.run("before-all-elements-highlight", M);
        for (var x = 0, P; P = M.elements[x++]; )
          d.highlightElement(P, N === !0, M.callback);
      },
      /**
       * Highlights the code inside a single element.
       *
       * The following hooks will be run:
       * 1. `before-sanity-check`
       * 2. `before-highlight`
       * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
       * 4. `before-insert`
       * 5. `after-highlight`
       * 6. `complete`
       *
       * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
       * the element's language.
       *
       * @param {Element} element The element containing the code.
       * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
       * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
       * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
       * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
       *
       * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
       * asynchronous highlighting to work. You can build your own bundle on the
       * [Download page](https://prismjs.com/download.html).
       * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
       * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
       * @memberof Prism
       * @public
       */
      highlightElement: function(w, N, F) {
        var M = d.util.getLanguage(w), x = d.languages[M];
        d.util.setLanguage(w, M);
        var P = w.parentElement;
        P && P.nodeName.toLowerCase() === "pre" && d.util.setLanguage(P, M);
        var U = w.textContent, L = {
          element: w,
          language: M,
          grammar: x,
          code: U
        };
        function H(V) {
          L.highlightedCode = V, d.hooks.run("before-insert", L), L.element.innerHTML = L.highlightedCode, d.hooks.run("after-highlight", L), d.hooks.run("complete", L), F && F.call(L.element);
        }
        if (d.hooks.run("before-sanity-check", L), P = L.element.parentElement, P && P.nodeName.toLowerCase() === "pre" && !P.hasAttribute("tabindex") && P.setAttribute("tabindex", "0"), !L.code) {
          d.hooks.run("complete", L), F && F.call(L.element);
          return;
        }
        if (d.hooks.run("before-highlight", L), !L.grammar) {
          H(d.util.encode(L.code));
          return;
        }
        if (N && a.Worker) {
          var B = new Worker(d.filename);
          B.onmessage = function(V) {
            H(V.data);
          }, B.postMessage(JSON.stringify({
            language: L.language,
            code: L.code,
            immediateClose: !0
          }));
        } else
          H(d.highlight(L.code, L.grammar, L.language));
      },
      /**
       * Low-level function, only use if you know what youre doing. It accepts a string of text as input
       * and the language definitions to use, and returns a string with the HTML produced.
       *
       * The following hooks will be run:
       * 1. `before-tokenize`
       * 2. `after-tokenize`
       * 3. `wrap`: On each {@link Token}.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @param {string} language The name of the language definition passed to `grammar`.
       * @returns {string} The highlighted HTML.
       * @memberof Prism
       * @public
       * @example
       * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
       */
      highlight: function(w, N, F) {
        var M = {
          code: w,
          grammar: N,
          language: F
        };
        if (d.hooks.run("before-tokenize", M), !M.grammar)
          throw new Error('The language "' + M.language + '" has no grammar.');
        return M.tokens = d.tokenize(M.code, M.grammar), d.hooks.run("after-tokenize", M), g.stringify(d.util.encode(M.tokens), M.language);
      },
      /**
       * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
       * and the language definitions to use, and returns an array with the tokenized code.
       *
       * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
       *
       * This method could be useful in other contexts as well, as a very crude parser.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @returns {TokenStream} An array of strings and tokens, a token stream.
       * @memberof Prism
       * @public
       * @example
       * let code = `var foo = 0;`;
       * let tokens = Prism.tokenize(code, Prism.languages.javascript);
       * tokens.forEach(token => {
       *     if (token instanceof Prism.Token && token.type === 'number') {
       *         console.log(`Found numeric literal: ${token.content}`);
       *     }
       * });
       */
      tokenize: function(w, N) {
        var F = N.rest;
        if (F) {
          for (var M in F)
            N[M] = F[M];
          delete N.rest;
        }
        var x = new y();
        return A(x, x.head, w), _(w, x, N, x.head, 0), v(x);
      },
      /**
       * @namespace
       * @memberof Prism
       * @public
       */
      hooks: {
        all: {},
        /**
         * Adds the given callback to the list of callbacks for the given hook.
         *
         * The callback will be invoked when the hook it is registered for is run.
         * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
         *
         * One callback function can be registered to multiple hooks and the same hook multiple times.
         *
         * @param {string} name The name of the hook.
         * @param {HookCallback} callback The callback function which is given environment variables.
         * @public
         */
        add: function(w, N) {
          var F = d.hooks.all;
          F[w] = F[w] || [], F[w].push(N);
        },
        /**
         * Runs a hook invoking all registered callbacks with the given environment variables.
         *
         * Callbacks will be invoked synchronously and in the order in which they were registered.
         *
         * @param {string} name The name of the hook.
         * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
         * @public
         */
        run: function(w, N) {
          var F = d.hooks.all[w];
          if (!(!F || !F.length))
            for (var M = 0, x; x = F[M++]; )
              x(N);
        }
      },
      Token: g
    };
    a.Prism = d;
    function g(w, N, F, M) {
      this.type = w, this.content = N, this.alias = F, this.length = (M || "").length | 0;
    }
    g.stringify = function w(N, F) {
      if (typeof N == "string")
        return N;
      if (Array.isArray(N)) {
        var M = "";
        return N.forEach(function(H) {
          M += w(H, F);
        }), M;
      }
      var x = {
        type: N.type,
        content: w(N.content, F),
        tag: "span",
        classes: ["token", N.type],
        attributes: {},
        language: F
      }, P = N.alias;
      P && (Array.isArray(P) ? Array.prototype.push.apply(x.classes, P) : x.classes.push(P)), d.hooks.run("wrap", x);
      var U = "";
      for (var L in x.attributes)
        U += " " + L + '="' + (x.attributes[L] || "").replace(/"/g, "&quot;") + '"';
      return "<" + x.tag + ' class="' + x.classes.join(" ") + '"' + U + ">" + x.content + "</" + x.tag + ">";
    };
    function b(w, N, F, M) {
      w.lastIndex = N;
      var x = w.exec(F);
      if (x && M && x[1]) {
        var P = x[1].length;
        x.index += P, x[0] = x[0].slice(P);
      }
      return x;
    }
    function _(w, N, F, M, x, P) {
      for (var U in F)
        if (!(!F.hasOwnProperty(U) || !F[U])) {
          var L = F[U];
          L = Array.isArray(L) ? L : [L];
          for (var H = 0; H < L.length; ++H) {
            if (P && P.cause == U + "," + H)
              return;
            var B = L[H], V = B.inside, X = !!B.lookbehind, de = !!B.greedy, Y = B.alias;
            if (de && !B.pattern.global) {
              var se = B.pattern.toString().match(/[imsuy]*$/)[0];
              B.pattern = RegExp(B.pattern.source, se + "g");
            }
            for (var ue = B.pattern || B, pe = M.next, J = x; pe !== N.tail && !(P && J >= P.reach); J += pe.value.length, pe = pe.next) {
              var j = pe.value;
              if (N.length > w.length)
                return;
              if (!(j instanceof g)) {
                var le = 1, Z;
                if (de) {
                  if (Z = b(ue, J, w, X), !Z || Z.index >= w.length)
                    break;
                  var ee = Z.index, O = Z.index + Z[0].length, z = J;
                  for (z += pe.value.length; ee >= z; )
                    pe = pe.next, z += pe.value.length;
                  if (z -= pe.value.length, J = z, pe.value instanceof g)
                    continue;
                  for (var W = pe; W !== N.tail && (z < O || typeof W.value == "string"); W = W.next)
                    le++, z += W.value.length;
                  le--, j = w.slice(J, z), Z.index -= J;
                } else if (Z = b(ue, 0, j, X), !Z)
                  continue;
                var ee = Z.index, ae = Z[0], ie = j.slice(0, ee), me = j.slice(ee + ae.length), ye = J + j.length;
                P && ye > P.reach && (P.reach = ye);
                var Re = pe.prev;
                ie && (Re = A(N, Re, ie), J += ie.length), E(N, Re, le);
                var De = new g(U, V ? d.tokenize(ae, V) : ae, Y, ae);
                if (pe = A(N, Re, De), me && A(N, pe, me), le > 1) {
                  var Pe = {
                    cause: U + "," + H,
                    reach: ye
                  };
                  _(w, N, F, pe.prev, J, Pe), P && Pe.reach > P.reach && (P.reach = Pe.reach);
                }
              }
            }
          }
        }
    }
    function y() {
      var w = {
        value: null,
        prev: null,
        next: null
      }, N = {
        value: null,
        prev: w,
        next: null
      };
      w.next = N, this.head = w, this.tail = N, this.length = 0;
    }
    function A(w, N, F) {
      var M = N.next, x = {
        value: F,
        prev: N,
        next: M
      };
      return N.next = x, M.prev = x, w.length++, x;
    }
    function E(w, N, F) {
      for (var M = N.next, x = 0; x < F && M !== w.tail; x++)
        M = M.next;
      N.next = M, M.prev = N, w.length -= x;
    }
    function v(w) {
      for (var N = [], F = w.head.next; F !== w.tail; )
        N.push(F.value), F = F.next;
      return N;
    }
    if (!a.document)
      return a.addEventListener && (d.disableWorkerMessageHandler || a.addEventListener("message", function(w) {
        var N = JSON.parse(w.data), F = N.language, M = N.code, x = N.immediateClose;
        a.postMessage(d.highlight(M, d.languages[F], F)), x && a.close();
      }, !1)), d;
    var C = d.util.currentScript();
    C && (d.filename = C.src, C.hasAttribute("data-manual") && (d.manual = !0));
    function R() {
      d.manual || d.highlightAll();
    }
    if (!d.manual) {
      var I = document.readyState;
      I === "loading" || I === "interactive" && C && C.defer ? document.addEventListener("DOMContentLoaded", R) : window.requestAnimationFrame ? window.requestAnimationFrame(R) : window.setTimeout(R, 16);
    }
    return d;
  }(t);
  e.exports && (e.exports = r), typeof commonjsGlobal < "u" && (commonjsGlobal.Prism = r);
})(prismCore);
var prismCoreExports = prismCore.exports, markup_1 = markup$1;
markup$1.displayName = "markup";
markup$1.aliases = ["html", "mathml", "svg", "xml", "ssml", "atom", "rss"];
function markup$1(e) {
  e.languages.markup = {
    comment: {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: !0
    },
    prolog: {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: !0
    },
    doctype: {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: !0,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: !0,
          greedy: !0,
          inside: null
          // see below
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: !0
        },
        punctuation: /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        name: /[^\s<>'"]+/
      }
    },
    cdata: {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: !0
    },
    tag: {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: !0,
      inside: {
        tag: {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            punctuation: /^<\/?/,
            namespace: /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            punctuation: [{
              pattern: /^=/,
              alias: "attr-equals"
            }, /"|'/]
          }
        },
        punctuation: /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            namespace: /^[^\s>\/:]+:/
          }
        }
      }
    },
    entity: [{
      pattern: /&[\da-z]{1,8};/i,
      alias: "named-entity"
    }, /&#x?[\da-f]{1,8};/i]
  }, e.languages.markup.tag.inside["attr-value"].inside.entity = e.languages.markup.entity, e.languages.markup.doctype.inside["internal-subset"].inside = e.languages.markup, e.hooks.add("wrap", function(t) {
    t.type === "entity" && (t.attributes.title = t.content.value.replace(/&amp;/, "&"));
  }), Object.defineProperty(e.languages.markup.tag, "addInlined", {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function(r, a) {
      var o = {};
      o["language-" + a] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: !0,
        inside: e.languages[a]
      }, o.cdata = /^<!\[CDATA\[|\]\]>$/i;
      var u = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: o
        }
      };
      u["language-" + a] = {
        pattern: /[\s\S]+/,
        inside: e.languages[a]
      };
      var c = {};
      c[r] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return r;
        }), "i"),
        lookbehind: !0,
        greedy: !0,
        inside: u
      }, e.languages.insertBefore("markup", "cdata", c);
    }
  }), Object.defineProperty(e.languages.markup.tag, "addAttribute", {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: function(t, r) {
      e.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(/(^|["'\s])/.source + "(?:" + t + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
        lookbehind: !0,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              value: {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: !0,
                alias: [r, "language-" + r],
                inside: e.languages[r]
              },
              punctuation: [{
                pattern: /^=/,
                alias: "attr-equals"
              }, /"|'/]
            }
          }
        }
      });
    }
  }), e.languages.html = e.languages.markup, e.languages.mathml = e.languages.markup, e.languages.svg = e.languages.markup, e.languages.xml = e.languages.extend("markup", {}), e.languages.ssml = e.languages.xml, e.languages.atom = e.languages.xml, e.languages.rss = e.languages.xml;
}
var css_1 = css$1;
css$1.displayName = "css";
css$1.aliases = [];
function css$1(e) {
  (function(t) {
    var r = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    t.languages.css = {
      comment: /\/\*[\s\S]*?\*\//,
      atrule: {
        pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
        inside: {
          rule: /^@[\w-]+/,
          "selector-function-argument": {
            pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
            lookbehind: !0,
            alias: "selector"
          },
          keyword: {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: !0
          }
          // See rest below
        }
      },
      url: {
        // https://drafts.csswg.org/css-values-3/#urls
        pattern: RegExp("\\burl\\((?:" + r.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
        greedy: !0,
        inside: {
          function: /^url/i,
          punctuation: /^\(|\)$/,
          string: {
            pattern: RegExp("^" + r.source + "$"),
            alias: "url"
          }
        }
      },
      selector: {
        pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + r.source + ")*(?=\\s*\\{)"),
        lookbehind: !0
      },
      string: {
        pattern: r,
        greedy: !0
      },
      property: {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: !0
      },
      important: /!important\b/i,
      function: {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: !0
      },
      punctuation: /[(){};:,]/
    }, t.languages.css.atrule.inside.rest = t.languages.css;
    var a = t.languages.markup;
    a && (a.tag.addInlined("style", "css"), a.tag.addAttribute("style", "css"));
  })(e);
}
var clike_1 = clike$1;
clike$1.displayName = "clike";
clike$1.aliases = [];
function clike$1(e) {
  e.languages.clike = {
    comment: [{
      pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
      lookbehind: !0,
      greedy: !0
    }, {
      pattern: /(^|[^\\:])\/\/.*/,
      lookbehind: !0,
      greedy: !0
    }],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: !0,
      inside: {
        punctuation: /[.\\]/
      }
    },
    keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
  };
}
var javascript_1 = javascript;
javascript.displayName = "javascript";
javascript.aliases = ["js"];
function javascript(e) {
  e.languages.javascript = e.languages.extend("clike", {
    "class-name": [e.languages.clike["class-name"], {
      pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
      lookbehind: !0
    }],
    keyword: [{
      pattern: /((?:^|\})\s*)catch\b/,
      lookbehind: !0
    }, {
      pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
      lookbehind: !0
    }],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    number: {
      pattern: RegExp(/(^|[^\w$])/.source + "(?:" + // constant
      (/NaN|Infinity/.source + "|" + // binary integer
      /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
      /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
      /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
      /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
      /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
      lookbehind: !0
    },
    operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  }), e.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, e.languages.insertBefore("javascript", "keyword", {
    regex: {
      // eslint-disable-next-line regexp/no-dupe-characters-character-class
      pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
      lookbehind: !0,
      greedy: !0,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: !0,
          alias: "language-regex",
          inside: e.languages.regex
        },
        "regex-delimiter": /^\/|\/$/,
        "regex-flags": /^[a-z]+$/
      }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    },
    parameter: [{
      pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
      lookbehind: !0,
      inside: e.languages.javascript
    }, {
      pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
      lookbehind: !0,
      inside: e.languages.javascript
    }, {
      pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
      lookbehind: !0,
      inside: e.languages.javascript
    }, {
      pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
      lookbehind: !0,
      inside: e.languages.javascript
    }],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  }), e.languages.insertBefore("javascript", "string", {
    hashbang: {
      pattern: /^#!.*/,
      greedy: !0,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: !0,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: !0,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            rest: e.languages.javascript
          }
        },
        string: /[\s\S]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: !0,
      greedy: !0,
      alias: "property"
    }
  }), e.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: !0,
      alias: "property"
    }
  }), e.languages.markup && (e.languages.markup.tag.addInlined("script", "javascript"), e.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript")), e.languages.js = e.languages.javascript;
}
var ctx = typeof globalThis == "object" ? globalThis : typeof self == "object" ? self : typeof window == "object" ? window : typeof commonjsGlobal == "object" ? commonjsGlobal : {}, restore = capture();
ctx.Prism = {
  manual: !0,
  disableWorkerMessageHandler: !0
};
var h$1 = hastscript, decode = parseEntities_1, Prism = prismCoreExports, markup = markup_1, css = css_1, clike = clike_1, js = javascript_1;
restore();
var own$3 = {}.hasOwnProperty;
function Refractor() {
}
Refractor.prototype = Prism;
var refract = new Refractor(), core = refract;
refract.highlight = highlight;
refract.register = register;
refract.alias = alias;
refract.registered = registered;
refract.listLanguages = listLanguages;
register(markup);
register(css);
register(clike);
register(js);
refract.util.encode = encode;
refract.Token.stringify = stringify;
function register(e) {
  if (typeof e != "function" || !e.displayName)
    throw new Error("Expected `function` for `grammar`, got `" + e + "`");
  refract.languages[e.displayName] === void 0 && e(refract);
}
function alias(e, t) {
  var r = refract.languages, a = e, o, u, c, d;
  t && (a = {}, a[e] = t);
  for (o in a)
    for (u = a[o], u = typeof u == "string" ? [u] : u, c = u.length, d = -1; ++d < c; )
      r[u[d]] = r[o];
}
function highlight(e, t) {
  var r = Prism.highlight, a;
  if (typeof e != "string")
    throw new Error("Expected `string` for `value`, got `" + e + "`");
  if (refract.util.type(t) === "Object")
    a = t, t = null;
  else {
    if (typeof t != "string")
      throw new Error("Expected `string` for `name`, got `" + t + "`");
    if (own$3.call(refract.languages, t))
      a = refract.languages[t];
    else
      throw new Error("Unknown language: `" + t + "` is not registered");
  }
  return r.call(this, e, a, t);
}
function registered(e) {
  if (typeof e != "string")
    throw new Error("Expected `string` for `language`, got `" + e + "`");
  return own$3.call(refract.languages, e);
}
function listLanguages() {
  var e = refract.languages, t = [], r;
  for (r in e)
    own$3.call(e, r) && typeof e[r] == "object" && t.push(r);
  return t;
}
function stringify(e, t, r) {
  var a;
  return typeof e == "string" ? {
    type: "text",
    value: e
  } : refract.util.type(e) === "Array" ? stringifyAll(e, t) : (a = {
    type: e.type,
    content: refract.Token.stringify(e.content, t, r),
    tag: "span",
    classes: ["token", e.type],
    attributes: {},
    language: t,
    parent: r
  }, e.alias && (a.classes = a.classes.concat(e.alias)), refract.hooks.run("wrap", a), h$1(a.tag + "." + a.classes.join("."), attributes(a.attributes), a.content));
}
function stringifyAll(e, t) {
  for (var r = [], a = e.length, o = -1, u; ++o < a; )
    u = e[o], u !== "" && u !== null && u !== void 0 && r.push(u);
  for (o = -1, a = r.length; ++o < a; )
    u = r[o], r[o] = refract.Token.stringify(u, t, r);
  return r;
}
function encode(e) {
  return e;
}
function attributes(e) {
  var t;
  for (t in e)
    e[t] = decode(e[t]);
  return e;
}
function capture() {
  var e = "Prism" in ctx, t = e ? ctx.Prism : void 0;
  return r;
  function r() {
    e ? ctx.Prism = t : delete ctx.Prism, e = void 0, t = void 0;
  }
}
const defaultStyle = {
  'code[class*="language-"]': {
    color: "black",
    background: "none",
    textShadow: "0 1px white",
    fontFamily: "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
    fontSize: "1em",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    wordWrap: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    msHyphens: "none",
    hyphens: "none"
  },
  'pre[class*="language-"]': {
    color: "black",
    background: "#f5f2f0",
    textShadow: "0 1px white",
    fontFamily: "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
    fontSize: "1em",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    wordWrap: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    msHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto"
  },
  'pre[class*="language-"]::-moz-selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'pre[class*="language-"] ::-moz-selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'code[class*="language-"]::-moz-selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'code[class*="language-"] ::-moz-selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'pre[class*="language-"]::selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'pre[class*="language-"] ::selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'code[class*="language-"]::selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  'code[class*="language-"] ::selection': {
    textShadow: "none",
    background: "#b3d4fc"
  },
  ':not(pre) > code[class*="language-"]': {
    background: "#f5f2f0",
    padding: ".1em",
    borderRadius: ".3em",
    whiteSpace: "normal"
  },
  comment: {
    color: "slategray"
  },
  prolog: {
    color: "slategray"
  },
  doctype: {
    color: "slategray"
  },
  cdata: {
    color: "slategray"
  },
  punctuation: {
    color: "#999"
  },
  namespace: {
    Opacity: ".7"
  },
  property: {
    color: "#905"
  },
  tag: {
    color: "#905"
  },
  boolean: {
    color: "#905"
  },
  number: {
    color: "#905"
  },
  constant: {
    color: "#905"
  },
  symbol: {
    color: "#905"
  },
  deleted: {
    color: "#905"
  },
  selector: {
    color: "#690"
  },
  "attr-name": {
    color: "#690"
  },
  string: {
    color: "#690"
  },
  char: {
    color: "#690"
  },
  builtin: {
    color: "#690"
  },
  inserted: {
    color: "#690"
  },
  operator: {
    color: "#9a6e3a",
    background: "hsla(0, 0%, 100%, .5)"
  },
  entity: {
    color: "#9a6e3a",
    background: "hsla(0, 0%, 100%, .5)",
    cursor: "help"
  },
  url: {
    color: "#9a6e3a",
    background: "hsla(0, 0%, 100%, .5)"
  },
  ".language-css .token.string": {
    color: "#9a6e3a",
    background: "hsla(0, 0%, 100%, .5)"
  },
  ".style .token.string": {
    color: "#9a6e3a",
    background: "hsla(0, 0%, 100%, .5)"
  },
  atrule: {
    color: "#07a"
  },
  "attr-value": {
    color: "#07a"
  },
  keyword: {
    color: "#07a"
  },
  function: {
    color: "#DD4A68"
  },
  "class-name": {
    color: "#DD4A68"
  },
  regex: {
    color: "#e90"
  },
  important: {
    color: "#e90",
    fontWeight: "bold"
  },
  variable: {
    color: "#e90"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  }
};
var abap_1, hasRequiredAbap;
function requireAbap() {
  if (hasRequiredAbap) return abap_1;
  hasRequiredAbap = 1, abap_1 = e, e.displayName = "abap", e.aliases = [];
  function e(t) {
    t.languages.abap = {
      comment: /^\*.*/m,
      string: /(`|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
      "string-template": {
        pattern: /([|}])(?:\\.|[^\\|{\r\n])*(?=[|{])/,
        lookbehind: !0,
        alias: "string"
      },
      /* End Of Line comments should not interfere with strings when the
      quote character occurs within them. We assume a string being highlighted
      inside an EOL comment is more acceptable than the opposite.
      */
      "eol-comment": {
        pattern: /(^|\s)".*/m,
        lookbehind: !0,
        alias: "comment"
      },
      keyword: {
        pattern: /(\s|\.|^)(?:SCIENTIFIC_WITH_LEADING_ZERO|SCALE_PRESERVING_SCIENTIFIC|RMC_COMMUNICATION_FAILURE|END-ENHANCEMENT-SECTION|MULTIPLY-CORRESPONDING|SUBTRACT-CORRESPONDING|VERIFICATION-MESSAGE|DIVIDE-CORRESPONDING|ENHANCEMENT-SECTION|CURRENCY_CONVERSION|RMC_SYSTEM_FAILURE|START-OF-SELECTION|MOVE-CORRESPONDING|RMC_INVALID_STATUS|CUSTOMER-FUNCTION|END-OF-DEFINITION|ENHANCEMENT-POINT|SYSTEM-EXCEPTIONS|ADD-CORRESPONDING|SCALE_PRESERVING|SELECTION-SCREEN|CURSOR-SELECTION|END-OF-SELECTION|LOAD-OF-PROGRAM|SCROLL-BOUNDARY|SELECTION-TABLE|EXCEPTION-TABLE|IMPLEMENTATIONS|PARAMETER-TABLE|RIGHT-JUSTIFIED|UNIT_CONVERSION|AUTHORITY-CHECK|LIST-PROCESSING|SIGN_AS_POSTFIX|COL_BACKGROUND|IMPLEMENTATION|INTERFACE-POOL|TRANSFORMATION|IDENTIFICATION|ENDENHANCEMENT|LINE-SELECTION|INITIALIZATION|LEFT-JUSTIFIED|SELECT-OPTIONS|SELECTION-SETS|COMMUNICATION|CORRESPONDING|DECIMAL_SHIFT|PRINT-CONTROL|VALUE-REQUEST|CHAIN-REQUEST|FUNCTION-POOL|FIELD-SYMBOLS|FUNCTIONALITY|INVERTED-DATE|SELECTION-SET|CLASS-METHODS|OUTPUT-LENGTH|CLASS-CODING|COL_NEGATIVE|ERRORMESSAGE|FIELD-GROUPS|HELP-REQUEST|NO-EXTENSION|NO-TOPOFPAGE|REDEFINITION|DISPLAY-MODE|ENDINTERFACE|EXIT-COMMAND|FIELD-SYMBOL|NO-SCROLLING|SHORTDUMP-ID|ACCESSPOLICY|CLASS-EVENTS|COL_POSITIVE|DECLARATIONS|ENHANCEMENTS|FILTER-TABLE|SWITCHSTATES|SYNTAX-CHECK|TRANSPORTING|ASYNCHRONOUS|SYNTAX-TRACE|TOKENIZATION|USER-COMMAND|WITH-HEADING|ABAP-SOURCE|BREAK-POINT|CHAIN-INPUT|COMPRESSION|FIXED-POINT|NEW-SECTION|NON-UNICODE|OCCURRENCES|RESPONSIBLE|SYSTEM-CALL|TRACE-TABLE|ABBREVIATED|CHAR-TO-HEX|END-OF-FILE|ENDFUNCTION|ENVIRONMENT|ASSOCIATION|COL_HEADING|EDITOR-CALL|END-OF-PAGE|ENGINEERING|IMPLEMENTED|INTENSIFIED|RADIOBUTTON|SYSTEM-EXIT|TOP-OF-PAGE|TRANSACTION|APPLICATION|CONCATENATE|DESTINATION|ENHANCEMENT|IMMEDIATELY|NO-GROUPING|PRECOMPILED|REPLACEMENT|TITLE-LINES|ACTIVATION|BYTE-ORDER|CLASS-POOL|CONNECTION|CONVERSION|DEFINITION|DEPARTMENT|EXPIRATION|INHERITING|MESSAGE-ID|NO-HEADING|PERFORMING|QUEUE-ONLY|RIGHTSPACE|SCIENTIFIC|STATUSINFO|STRUCTURES|SYNCPOINTS|WITH-TITLE|ATTRIBUTES|BOUNDARIES|CLASS-DATA|COL_NORMAL|DD\/MM\/YYYY|DESCENDING|INTERFACES|LINE-COUNT|MM\/DD\/YYYY|NON-UNIQUE|PRESERVING|SELECTIONS|STATEMENTS|SUBROUTINE|TRUNCATION|TYPE-POOLS|ARITHMETIC|BACKGROUND|ENDPROVIDE|EXCEPTIONS|IDENTIFIER|INDEX-LINE|OBLIGATORY|PARAMETERS|PERCENTAGE|PUSHBUTTON|RESOLUTION|COMPONENTS|DEALLOCATE|DISCONNECT|DUPLICATES|FIRST-LINE|HEAD-LINES|NO-DISPLAY|OCCURRENCE|RESPECTING|RETURNCODE|SUBMATCHES|TRACE-FILE|ASCENDING|BYPASSING|ENDMODULE|EXCEPTION|EXCLUDING|EXPORTING|INCREMENT|MATCHCODE|PARAMETER|PARTIALLY|PREFERRED|REFERENCE|REPLACING|RETURNING|SELECTION|SEPARATED|SPECIFIED|STATEMENT|TIMESTAMP|TYPE-POOL|ACCEPTING|APPENDAGE|ASSIGNING|COL_GROUP|COMPARING|CONSTANTS|DANGEROUS|IMPORTING|INSTANCES|LEFTSPACE|LOG-POINT|QUICKINFO|READ-ONLY|SCROLLING|SQLSCRIPT|STEP-LOOP|TOP-LINES|TRANSLATE|APPENDING|AUTHORITY|CHARACTER|COMPONENT|CONDITION|DIRECTORY|DUPLICATE|MESSAGING|RECEIVING|SUBSCREEN|ACCORDING|COL_TOTAL|END-LINES|ENDMETHOD|ENDSELECT|EXPANDING|EXTENSION|INCLUDING|INFOTYPES|INTERFACE|INTERVALS|LINE-SIZE|PF-STATUS|PROCEDURE|PROTECTED|REQUESTED|RESUMABLE|RIGHTPLUS|SAP-SPOOL|SECONDARY|STRUCTURE|SUBSTRING|TABLEVIEW|NUMOFCHAR|ADJACENT|ANALYSIS|ASSIGNED|BACKWARD|CHANNELS|CHECKBOX|CONTINUE|CRITICAL|DATAINFO|DD\/MM\/YY|DURATION|ENCODING|ENDCLASS|FUNCTION|LEFTPLUS|LINEFEED|MM\/DD\/YY|OVERFLOW|RECEIVED|SKIPPING|SORTABLE|STANDARD|SUBTRACT|SUPPRESS|TABSTRIP|TITLEBAR|TRUNCATE|UNASSIGN|WHENEVER|ANALYZER|COALESCE|COMMENTS|CONDENSE|DECIMALS|DEFERRED|ENDWHILE|EXPLICIT|KEYWORDS|MESSAGES|POSITION|PRIORITY|RECEIVER|RENAMING|TIMEZONE|TRAILING|ALLOCATE|CENTERED|CIRCULAR|CONTROLS|CURRENCY|DELETING|DESCRIBE|DISTANCE|ENDCATCH|EXPONENT|EXTENDED|GENERATE|IGNORING|INCLUDES|INTERNAL|MAJOR-ID|MODIFIER|NEW-LINE|OPTIONAL|PROPERTY|ROLLBACK|STARTING|SUPPLIED|ABSTRACT|CHANGING|CONTEXTS|CREATING|CUSTOMER|DATABASE|DAYLIGHT|DEFINING|DISTINCT|DIVISION|ENABLING|ENDCHAIN|ESCAPING|HARMLESS|IMPLICIT|INACTIVE|LANGUAGE|MINOR-ID|MULTIPLY|NEW-PAGE|NO-TITLE|POS_HIGH|SEPARATE|TEXTPOOL|TRANSFER|SELECTOR|DBMAXLEN|ITERATOR|ARCHIVE|BIT-XOR|BYTE-CO|COLLECT|COMMENT|CURRENT|DEFAULT|DISPLAY|ENDFORM|EXTRACT|LEADING|LISTBOX|LOCATOR|MEMBERS|METHODS|NESTING|POS_LOW|PROCESS|PROVIDE|RAISING|RESERVE|SECONDS|SUMMARY|VISIBLE|BETWEEN|BIT-AND|BYTE-CS|CLEANUP|COMPUTE|CONTROL|CONVERT|DATASET|ENDCASE|FORWARD|HEADERS|HOTSPOT|INCLUDE|INVERSE|KEEPING|NO-ZERO|OBJECTS|OVERLAY|PADDING|PATTERN|PROGRAM|REFRESH|SECTION|SUMMING|TESTING|VERSION|WINDOWS|WITHOUT|BIT-NOT|BYTE-CA|BYTE-NA|CASTING|CONTEXT|COUNTRY|DYNAMIC|ENABLED|ENDLOOP|EXECUTE|FRIENDS|HANDLER|HEADING|INITIAL|\*-INPUT|LOGFILE|MAXIMUM|MINIMUM|NO-GAPS|NO-SIGN|PRAGMAS|PRIMARY|PRIVATE|REDUCED|REPLACE|REQUEST|RESULTS|UNICODE|WARNING|ALIASES|BYTE-CN|BYTE-NS|CALLING|COL_KEY|COLUMNS|CONNECT|ENDEXEC|ENTRIES|EXCLUDE|FILTERS|FURTHER|HELP-ID|LOGICAL|MAPPING|MESSAGE|NAMETAB|OPTIONS|PACKAGE|PERFORM|RECEIVE|STATICS|VARYING|BINDING|CHARLEN|GREATER|XSTRLEN|ACCEPT|APPEND|DETAIL|ELSEIF|ENDING|ENDTRY|FORMAT|FRAMES|GIVING|HASHED|HEADER|IMPORT|INSERT|MARGIN|MODULE|NATIVE|OBJECT|OFFSET|REMOTE|RESUME|SAVING|SIMPLE|SUBMIT|TABBED|TOKENS|UNIQUE|UNPACK|UPDATE|WINDOW|YELLOW|ACTUAL|ASPECT|CENTER|CURSOR|DELETE|DIALOG|DIVIDE|DURING|ERRORS|EVENTS|EXTEND|FILTER|HANDLE|HAVING|IGNORE|LITTLE|MEMORY|NO-GAP|OCCURS|OPTION|PERSON|PLACES|PUBLIC|REDUCE|REPORT|RESULT|SINGLE|SORTED|SWITCH|SYNTAX|TARGET|VALUES|WRITER|ASSERT|BLOCKS|BOUNDS|BUFFER|CHANGE|COLUMN|COMMIT|CONCAT|COPIES|CREATE|DDMMYY|DEFINE|ENDIAN|ESCAPE|EXPAND|KERNEL|LAYOUT|LEGACY|LEVELS|MMDDYY|NUMBER|OUTPUT|RANGES|READER|RETURN|SCREEN|SEARCH|SELECT|SHARED|SOURCE|STABLE|STATIC|SUBKEY|SUFFIX|TABLES|UNWIND|YYMMDD|ASSIGN|BACKUP|BEFORE|BINARY|BIT-OR|BLANKS|CLIENT|CODING|COMMON|DEMAND|DYNPRO|EXCEPT|EXISTS|EXPORT|FIELDS|GLOBAL|GROUPS|LENGTH|LOCALE|MEDIUM|METHOD|MODIFY|NESTED|OTHERS|REJECT|SCROLL|SUPPLY|SYMBOL|ENDFOR|STRLEN|ALIGN|BEGIN|BOUND|ENDAT|ENTRY|EVENT|FINAL|FLUSH|GRANT|INNER|SHORT|USING|WRITE|AFTER|BLACK|BLOCK|CLOCK|COLOR|COUNT|DUMMY|EMPTY|ENDDO|ENDON|GREEN|INDEX|INOUT|LEAVE|LEVEL|LINES|MODIF|ORDER|OUTER|RANGE|RESET|RETRY|RIGHT|SMART|SPLIT|STYLE|TABLE|THROW|UNDER|UNTIL|UPPER|UTF-8|WHERE|ALIAS|BLANK|CLEAR|CLOSE|EXACT|FETCH|FIRST|FOUND|GROUP|LLANG|LOCAL|OTHER|REGEX|SPOOL|TITLE|TYPES|VALID|WHILE|ALPHA|BOXED|CATCH|CHAIN|CHECK|CLASS|COVER|ENDIF|EQUIV|FIELD|FLOOR|FRAME|INPUT|LOWER|MATCH|NODES|PAGES|PRINT|RAISE|ROUND|SHIFT|SPACE|SPOTS|STAMP|STATE|TASKS|TIMES|TRMAC|ULINE|UNION|VALUE|WIDTH|EQUAL|LOG10|TRUNC|BLOB|CASE|CEIL|CLOB|COND|EXIT|FILE|GAPS|HOLD|INCL|INTO|KEEP|KEYS|LAST|LINE|LONG|LPAD|MAIL|MODE|OPEN|PINK|READ|ROWS|TEST|THEN|ZERO|AREA|BACK|BADI|BYTE|CAST|EDIT|EXEC|FAIL|FIND|FKEQ|FONT|FREE|GKEQ|HIDE|INIT|ITNO|LATE|LOOP|MAIN|MARK|MOVE|NEXT|NULL|RISK|ROLE|UNIT|WAIT|ZONE|BASE|CALL|CODE|DATA|DATE|FKGE|GKGE|HIGH|KIND|LEFT|LIST|MASK|MESH|NAME|NODE|PACK|PAGE|POOL|SEND|SIGN|SIZE|SOME|STOP|TASK|TEXT|TIME|USER|VARY|WITH|WORD|BLUE|CONV|COPY|DEEP|ELSE|FORM|FROM|HINT|ICON|JOIN|LIKE|LOAD|ONLY|PART|SCAN|SKIP|SORT|TYPE|UNIX|VIEW|WHEN|WORK|ACOS|ASIN|ATAN|COSH|EACH|FRAC|LESS|RTTI|SINH|SQRT|TANH|AVG|BIT|DIV|ISO|LET|OUT|PAD|SQL|ALL|CI_|CPI|END|LOB|LPI|MAX|MIN|NEW|OLE|RUN|SET|\?TO|YES|ABS|ADD|AND|BIG|FOR|HDB|JOB|LOW|NOT|SAP|TRY|VIA|XML|ANY|GET|IDS|KEY|MOD|OFF|PUT|RAW|RED|REF|SUM|TAB|XSD|CNT|COS|EXP|LOG|SIN|TAN|XOR|AT|CO|CP|DO|GT|ID|IF|NS|OR|BT|CA|CS|GE|NA|NB|EQ|IN|LT|NE|NO|OF|ON|PF|TO|AS|BY|CN|IS|LE|NP|UP|E|I|M|O|Z|C|X)\b/i,
        lookbehind: !0
      },
      /* Numbers can be only integers. Decimal or Hex appear only as strings */
      number: /\b\d+\b/,
      /* Operators must always be surrounded by whitespace, they cannot be put
      adjacent to operands.
      */
      operator: {
        pattern: /(\s)(?:\*\*?|<[=>]?|>=?|\?=|[-+\/=])(?=\s)/,
        lookbehind: !0
      },
      "string-operator": {
        pattern: /(\s)&&?(?=\s)/,
        lookbehind: !0,
        /* The official editor highlights */
        alias: "keyword"
      },
      "token-operator": [{
        /* Special operators used to access structure components, class methods/attributes, etc. */
        pattern: /(\w)(?:->?|=>|[~|{}])(?=\w)/,
        lookbehind: !0,
        alias: "punctuation"
      }, {
        /* Special tokens used do delimit string templates */
        pattern: /[|{}]/,
        alias: "punctuation"
      }],
      punctuation: /[,.:()]/
    };
  }
  return abap_1;
}
var abnf_1, hasRequiredAbnf;
function requireAbnf() {
  if (hasRequiredAbnf) return abnf_1;
  hasRequiredAbnf = 1, abnf_1 = e, e.displayName = "abnf", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = "(?:ALPHA|BIT|CHAR|CR|CRLF|CTL|DIGIT|DQUOTE|HEXDIG|HTAB|LF|LWSP|OCTET|SP|VCHAR|WSP)";
      r.languages.abnf = {
        comment: /;.*/,
        string: {
          pattern: /(?:%[is])?"[^"\n\r]*"/,
          greedy: !0,
          inside: {
            punctuation: /^%[is]/
          }
        },
        range: {
          pattern: /%(?:b[01]+-[01]+|d\d+-\d+|x[A-F\d]+-[A-F\d]+)/i,
          alias: "number"
        },
        terminal: {
          pattern: /%(?:b[01]+(?:\.[01]+)*|d\d+(?:\.\d+)*|x[A-F\d]+(?:\.[A-F\d]+)*)/i,
          alias: "number"
        },
        repetition: {
          pattern: /(^|[^\w-])(?:\d*\*\d*|\d+)/,
          lookbehind: !0,
          alias: "operator"
        },
        definition: {
          pattern: /(^[ \t]*)(?:[a-z][\w-]*|<[^<>\r\n]*>)(?=\s*=)/m,
          lookbehind: !0,
          alias: "keyword",
          inside: {
            punctuation: /<|>/
          }
        },
        "core-rule": {
          pattern: RegExp("(?:(^|[^<\\w-])" + a + "|<" + a + ">)(?![\\w-])", "i"),
          lookbehind: !0,
          alias: ["rule", "constant"],
          inside: {
            punctuation: /<|>/
          }
        },
        rule: {
          pattern: /(^|[^<\w-])[a-z][\w-]*|<[^<>\r\n]*>/i,
          lookbehind: !0,
          inside: {
            punctuation: /<|>/
          }
        },
        operator: /=\/?|\//,
        punctuation: /[()\[\]]/
      };
    })(t);
  }
  return abnf_1;
}
var actionscript_1, hasRequiredActionscript;
function requireActionscript() {
  if (hasRequiredActionscript) return actionscript_1;
  hasRequiredActionscript = 1, actionscript_1 = e, e.displayName = "actionscript", e.aliases = [];
  function e(t) {
    t.languages.actionscript = t.languages.extend("javascript", {
      keyword: /\b(?:as|break|case|catch|class|const|default|delete|do|dynamic|each|else|extends|final|finally|for|function|get|if|implements|import|in|include|instanceof|interface|internal|is|namespace|native|new|null|override|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|use|var|void|while|with)\b/,
      operator: /\+\+|--|(?:[+\-*\/%^]|&&?|\|\|?|<<?|>>?>?|[!=]=?)=?|[~?@]/
    }), t.languages.actionscript["class-name"].alias = "function", delete t.languages.actionscript.parameter, delete t.languages.actionscript["literal-property"], t.languages.markup && t.languages.insertBefore("actionscript", "string", {
      xml: {
        pattern: /(^|[^.])<\/?\w+(?:\s+[^\s>\/=]+=("|')(?:\\[\s\S]|(?!\2)[^\\])*\2)*\s*\/?>/,
        lookbehind: !0,
        inside: t.languages.markup
      }
    });
  }
  return actionscript_1;
}
var ada_1, hasRequiredAda;
function requireAda() {
  if (hasRequiredAda) return ada_1;
  hasRequiredAda = 1, ada_1 = e, e.displayName = "ada", e.aliases = [];
  function e(t) {
    t.languages.ada = {
      comment: /--.*/,
      string: /"(?:""|[^"\r\f\n])*"/,
      number: [{
        pattern: /\b\d(?:_?\d)*#[\dA-F](?:_?[\dA-F])*(?:\.[\dA-F](?:_?[\dA-F])*)?#(?:E[+-]?\d(?:_?\d)*)?/i
      }, {
        pattern: /\b\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:E[+-]?\d(?:_?\d)*)?\b/i
      }],
      "attr-name": /\b'\w+/,
      keyword: /\b(?:abort|abs|abstract|accept|access|aliased|all|and|array|at|begin|body|case|constant|declare|delay|delta|digits|do|else|elsif|end|entry|exception|exit|for|function|generic|goto|if|in|interface|is|limited|loop|mod|new|not|null|of|others|out|overriding|package|pragma|private|procedure|protected|raise|range|record|rem|renames|requeue|return|reverse|select|separate|some|subtype|synchronized|tagged|task|terminate|then|type|until|use|when|while|with|xor)\b/i,
      boolean: /\b(?:false|true)\b/i,
      operator: /<[=>]?|>=?|=>?|:=|\/=?|\*\*?|[&+-]/,
      punctuation: /\.\.?|[,;():]/,
      char: /'.'/,
      variable: /\b[a-z](?:\w)*\b/i
    };
  }
  return ada_1;
}
var agda_1, hasRequiredAgda;
function requireAgda() {
  if (hasRequiredAgda) return agda_1;
  hasRequiredAgda = 1, agda_1 = e, e.displayName = "agda", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.agda = {
        comment: /\{-[\s\S]*?(?:-\}|$)|--.*/,
        string: {
          pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
          greedy: !0
        },
        punctuation: /[(){}.;@]/,
        "class-name": {
          pattern: /((?:data|record) +)\S+/,
          lookbehind: !0
        },
        function: {
          pattern: /(^[ \t]*)(?!\s)[^:\r\n]+(?=:)/m,
          lookbehind: !0
        },
        operator: {
          pattern: /(^\s*|\s)(?:[=|:\\?_]|->)(?=\s)/,
          lookbehind: !0
        },
        keyword: /\b(?:Set|abstract|constructor|data|eta-equality|field|forall|hiding|import|in|inductive|infix|infixl|infixr|instance|let|macro|module|mutual|no-eta-equality|open|overlap|pattern|postulate|primitive|private|public|quote|quoteContext|quoteGoal|quoteTerm|record|renaming|rewrite|syntax|tactic|unquote|unquoteDecl|unquoteDef|using|variable|where|with)\b/
      };
    })(t);
  }
  return agda_1;
}
var al_1, hasRequiredAl;
function requireAl() {
  if (hasRequiredAl) return al_1;
  hasRequiredAl = 1, al_1 = e, e.displayName = "al", e.aliases = [];
  function e(t) {
    t.languages.al = {
      comment: /\/\/.*|\/\*[\s\S]*?\*\//,
      string: {
        pattern: /'(?:''|[^'\r\n])*'(?!')|"(?:""|[^"\r\n])*"(?!")/,
        greedy: !0
      },
      function: {
        pattern: /(\b(?:event|procedure|trigger)\s+|(?:^|[^.])\.\s*)[a-z_]\w*(?=\s*\()/i,
        lookbehind: !0
      },
      keyword: [
        // keywords
        /\b(?:array|asserterror|begin|break|case|do|downto|else|end|event|exit|for|foreach|function|if|implements|in|indataset|interface|internal|local|of|procedure|program|protected|repeat|runonclient|securityfiltering|suppressdispose|temporary|then|to|trigger|until|var|while|with|withevents)\b/i,
        // objects and metadata that are used like keywords
        /\b(?:action|actions|addafter|addbefore|addfirst|addlast|area|assembly|chartpart|codeunit|column|controladdin|cuegroup|customizes|dataitem|dataset|dotnet|elements|enum|enumextension|extends|field|fieldattribute|fieldelement|fieldgroup|fieldgroups|fields|filter|fixed|grid|group|key|keys|label|labels|layout|modify|moveafter|movebefore|movefirst|movelast|page|pagecustomization|pageextension|part|profile|query|repeater|report|requestpage|schema|separator|systempart|table|tableelement|tableextension|textattribute|textelement|type|usercontrol|value|xmlport)\b/i
      ],
      number: /\b(?:0x[\da-f]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)(?:F|LL?|U(?:LL?)?)?\b/i,
      boolean: /\b(?:false|true)\b/i,
      variable: /\b(?:Curr(?:FieldNo|Page|Report)|x?Rec|RequestOptionsPage)\b/,
      "class-name": /\b(?:automation|biginteger|bigtext|blob|boolean|byte|char|clienttype|code|completiontriggererrorlevel|connectiontype|database|dataclassification|datascope|date|dateformula|datetime|decimal|defaultlayout|dialog|dictionary|dotnetassembly|dotnettypedeclaration|duration|errorinfo|errortype|executioncontext|executionmode|fieldclass|fieldref|fieldtype|file|filterpagebuilder|guid|httpclient|httpcontent|httpheaders|httprequestmessage|httpresponsemessage|instream|integer|joker|jsonarray|jsonobject|jsontoken|jsonvalue|keyref|list|moduledependencyinfo|moduleinfo|none|notification|notificationscope|objecttype|option|outstream|pageresult|record|recordid|recordref|reportformat|securityfilter|sessionsettings|tableconnectiontype|tablefilter|testaction|testfield|testfilterfield|testpage|testpermissions|testrequestpage|text|textbuilder|textconst|textencoding|time|transactionmodel|transactiontype|variant|verbosity|version|view|views|webserviceactioncontext|webserviceactionresultcode|xmlattribute|xmlattributecollection|xmlcdata|xmlcomment|xmldeclaration|xmldocument|xmldocumenttype|xmlelement|xmlnamespacemanager|xmlnametable|xmlnode|xmlnodelist|xmlprocessinginstruction|xmlreadoptions|xmltext|xmlwriteoptions)\b/i,
      operator: /\.\.|:[=:]|[-+*/]=?|<>|[<>]=?|=|\b(?:and|div|mod|not|or|xor)\b/i,
      punctuation: /[()\[\]{}:.;,]/
    };
  }
  return al_1;
}
var antlr4_1, hasRequiredAntlr4;
function requireAntlr4() {
  if (hasRequiredAntlr4) return antlr4_1;
  hasRequiredAntlr4 = 1, antlr4_1 = e, e.displayName = "antlr4", e.aliases = ["g4"];
  function e(t) {
    t.languages.antlr4 = {
      comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
      string: {
        pattern: /'(?:\\.|[^\\'\r\n])*'/,
        greedy: !0
      },
      "character-class": {
        pattern: /\[(?:\\.|[^\\\]\r\n])*\]/,
        greedy: !0,
        alias: "regex",
        inside: {
          range: {
            pattern: /([^[]|(?:^|[^\\])(?:\\\\)*\\\[)-(?!\])/,
            lookbehind: !0,
            alias: "punctuation"
          },
          escape: /\\(?:u(?:[a-fA-F\d]{4}|\{[a-fA-F\d]+\})|[pP]\{[=\w-]+\}|[^\r\nupP])/,
          punctuation: /[\[\]]/
        }
      },
      action: {
        pattern: /\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\}/,
        greedy: !0,
        inside: {
          content: {
            // this might be C, C++, Python, Java, C#, or any other language ANTLR4 compiles to
            pattern: /(\{)[\s\S]+(?=\})/,
            lookbehind: !0
          },
          punctuation: /[{}]/
        }
      },
      command: {
        pattern: /(->\s*(?!\s))(?:\s*(?:,\s*)?\b[a-z]\w*(?:\s*\([^()\r\n]*\))?)+(?=\s*;)/i,
        lookbehind: !0,
        inside: {
          function: /\b\w+(?=\s*(?:[,(]|$))/,
          punctuation: /[,()]/
        }
      },
      annotation: {
        pattern: /@\w+(?:::\w+)*/,
        alias: "keyword"
      },
      label: {
        pattern: /#[ \t]*\w+/,
        alias: "punctuation"
      },
      keyword: /\b(?:catch|channels|finally|fragment|grammar|import|lexer|locals|mode|options|parser|returns|throws|tokens)\b/,
      definition: [{
        pattern: /\b[a-z]\w*(?=\s*:)/,
        alias: ["rule", "class-name"]
      }, {
        pattern: /\b[A-Z]\w*(?=\s*:)/,
        alias: ["token", "constant"]
      }],
      constant: /\b[A-Z][A-Z_]*\b/,
      operator: /\.\.|->|[|~]|[*+?]\??/,
      punctuation: /[;:()=]/
    }, t.languages.g4 = t.languages.antlr4;
  }
  return antlr4_1;
}
var apacheconf_1, hasRequiredApacheconf;
function requireApacheconf() {
  if (hasRequiredApacheconf) return apacheconf_1;
  hasRequiredApacheconf = 1, apacheconf_1 = e, e.displayName = "apacheconf", e.aliases = [];
  function e(t) {
    t.languages.apacheconf = {
      comment: /#.*/,
      "directive-inline": {
        pattern: /(^[\t ]*)\b(?:AcceptFilter|AcceptPathInfo|AccessFileName|Action|Add(?:Alt|AltByEncoding|AltByType|Charset|DefaultCharset|Description|Encoding|Handler|Icon|IconByEncoding|IconByType|InputFilter|Language|ModuleInfo|OutputFilter|OutputFilterByType|Type)|Alias|AliasMatch|Allow(?:CONNECT|EncodedSlashes|Methods|Override|OverrideList)?|Anonymous(?:_LogEmail|_MustGiveEmail|_NoUserID|_VerifyEmail)?|AsyncRequestWorkerFactor|Auth(?:BasicAuthoritative|BasicFake|BasicProvider|BasicUseDigestAlgorithm|DBDUserPWQuery|DBDUserRealmQuery|DBMGroupFile|DBMType|DBMUserFile|Digest(?:Algorithm|Domain|NonceLifetime|Provider|Qop|ShmemSize)|Form(?:Authoritative|Body|DisableNoStore|FakeBasicAuth|Location|LoginRequiredLocation|LoginSuccessLocation|LogoutLocation|Method|Mimetype|Password|Provider|SitePassphrase|Size|Username)|GroupFile|LDAP(?:AuthorizePrefix|BindAuthoritative|BindDN|BindPassword|CharsetConfig|CompareAsUser|CompareDNOnServer|DereferenceAliases|GroupAttribute|GroupAttributeIsDN|InitialBindAsUser|InitialBindPattern|MaxSubGroupDepth|RemoteUserAttribute|RemoteUserIsDN|SearchAsUser|SubGroupAttribute|SubGroupClass|Url)|Merging|Name|nCache(?:Context|Enable|ProvideFor|SOCache|Timeout)|nzFcgiCheckAuthnProvider|nzFcgiDefineProvider|Type|UserFile|zDBDLoginToReferer|zDBDQuery|zDBDRedirectQuery|zDBMType|zSendForbiddenOnFailure)|BalancerGrowth|BalancerInherit|BalancerMember|BalancerPersist|BrowserMatch|BrowserMatchNoCase|BufferedLogs|BufferSize|Cache(?:DefaultExpire|DetailHeader|DirLength|DirLevels|Disable|Enable|File|Header|IgnoreCacheControl|IgnoreHeaders|IgnoreNoLastMod|IgnoreQueryString|IgnoreURLSessionIdentifiers|KeyBaseURL|LastModifiedFactor|Lock|LockMaxAge|LockPath|MaxExpire|MaxFileSize|MinExpire|MinFileSize|NegotiatedDocs|QuickHandler|ReadSize|ReadTime|Root|Socache(?:MaxSize|MaxTime|MinTime|ReadSize|ReadTime)?|StaleOnError|StoreExpired|StoreNoStore|StorePrivate)|CGIDScriptTimeout|CGIMapExtension|CharsetDefault|CharsetOptions|CharsetSourceEnc|CheckCaseOnly|CheckSpelling|ChrootDir|ContentDigest|CookieDomain|CookieExpires|CookieName|CookieStyle|CookieTracking|CoreDumpDirectory|CustomLog|Dav|DavDepthInfinity|DavGenericLockDB|DavLockDB|DavMinTimeout|DBDExptime|DBDInitSQL|DBDKeep|DBDMax|DBDMin|DBDParams|DBDPersist|DBDPrepareSQL|DBDriver|DefaultIcon|DefaultLanguage|DefaultRuntimeDir|DefaultType|Define|Deflate(?:BufferSize|CompressionLevel|FilterNote|InflateLimitRequestBody|InflateRatio(?:Burst|Limit)|MemLevel|WindowSize)|Deny|DirectoryCheckHandler|DirectoryIndex|DirectoryIndexRedirect|DirectorySlash|DocumentRoot|DTracePrivileges|DumpIOInput|DumpIOOutput|EnableExceptionHook|EnableMMAP|EnableSendfile|Error|ErrorDocument|ErrorLog|ErrorLogFormat|Example|ExpiresActive|ExpiresByType|ExpiresDefault|ExtendedStatus|ExtFilterDefine|ExtFilterOptions|FallbackResource|FileETag|FilterChain|FilterDeclare|FilterProtocol|FilterProvider|FilterTrace|ForceLanguagePriority|ForceType|ForensicLog|GprofDir|GracefulShutdownTimeout|Group|Header|HeaderName|Heartbeat(?:Address|Listen|MaxServers|Storage)|HostnameLookups|IdentityCheck|IdentityCheckTimeout|ImapBase|ImapDefault|ImapMenu|Include|IncludeOptional|Index(?:HeadInsert|Ignore|IgnoreReset|Options|OrderDefault|StyleSheet)|InputSed|ISAPI(?:AppendLogToErrors|AppendLogToQuery|CacheFile|FakeAsync|LogNotSupported|ReadAheadBuffer)|KeepAlive|KeepAliveTimeout|KeptBodySize|LanguagePriority|LDAP(?:CacheEntries|CacheTTL|ConnectionPoolTTL|ConnectionTimeout|LibraryDebug|OpCacheEntries|OpCacheTTL|ReferralHopLimit|Referrals|Retries|RetryDelay|SharedCacheFile|SharedCacheSize|Timeout|TrustedClientCert|TrustedGlobalCert|TrustedMode|VerifyServerCert)|Limit(?:InternalRecursion|Request(?:Body|Fields|FieldSize|Line)|XMLRequestBody)|Listen|ListenBackLog|LoadFile|LoadModule|LogFormat|LogLevel|LogMessage|LuaAuthzProvider|LuaCodeCache|Lua(?:Hook(?:AccessChecker|AuthChecker|CheckUserID|Fixups|InsertFilter|Log|MapToStorage|TranslateName|TypeChecker)|Inherit|InputFilter|MapHandler|OutputFilter|PackageCPath|PackagePath|QuickHandler|Root|Scope)|Max(?:ConnectionsPerChild|KeepAliveRequests|MemFree|RangeOverlaps|RangeReversals|Ranges|RequestWorkers|SpareServers|SpareThreads|Threads)|MergeTrailers|MetaDir|MetaFiles|MetaSuffix|MimeMagicFile|MinSpareServers|MinSpareThreads|MMapFile|ModemStandard|ModMimeUsePathInfo|MultiviewsMatch|Mutex|NameVirtualHost|NoProxy|NWSSLTrustedCerts|NWSSLUpgradeable|Options|Order|OutputSed|PassEnv|PidFile|PrivilegesMode|Protocol|ProtocolEcho|Proxy(?:AddHeaders|BadHeader|Block|Domain|ErrorOverride|ExpressDBMFile|ExpressDBMType|ExpressEnable|FtpDirCharset|FtpEscapeWildcards|FtpListOnWildcard|HTML(?:BufSize|CharsetOut|DocType|Enable|Events|Extended|Fixups|Interp|Links|Meta|StripComments|URLMap)|IOBufferSize|MaxForwards|Pass(?:Inherit|InterpolateEnv|Match|Reverse|ReverseCookieDomain|ReverseCookiePath)?|PreserveHost|ReceiveBufferSize|Remote|RemoteMatch|Requests|SCGIInternalRedirect|SCGISendfile|Set|SourceAddress|Status|Timeout|Via)|ReadmeName|ReceiveBufferSize|Redirect|RedirectMatch|RedirectPermanent|RedirectTemp|ReflectorHeader|RemoteIP(?:Header|InternalProxy|InternalProxyList|ProxiesHeader|TrustedProxy|TrustedProxyList)|RemoveCharset|RemoveEncoding|RemoveHandler|RemoveInputFilter|RemoveLanguage|RemoveOutputFilter|RemoveType|RequestHeader|RequestReadTimeout|Require|Rewrite(?:Base|Cond|Engine|Map|Options|Rule)|RLimitCPU|RLimitMEM|RLimitNPROC|Satisfy|ScoreBoardFile|Script(?:Alias|AliasMatch|InterpreterSource|Log|LogBuffer|LogLength|Sock)?|SecureListen|SeeRequestTail|SendBufferSize|Server(?:Admin|Alias|Limit|Name|Path|Root|Signature|Tokens)|Session(?:Cookie(?:Name|Name2|Remove)|Crypto(?:Cipher|Driver|Passphrase|PassphraseFile)|DBD(?:CookieName|CookieName2|CookieRemove|DeleteLabel|InsertLabel|PerUser|SelectLabel|UpdateLabel)|Env|Exclude|Header|Include|MaxAge)?|SetEnv|SetEnvIf|SetEnvIfExpr|SetEnvIfNoCase|SetHandler|SetInputFilter|SetOutputFilter|SSIEndTag|SSIErrorMsg|SSIETag|SSILastModified|SSILegacyExprParser|SSIStartTag|SSITimeFormat|SSIUndefinedEcho|SSL(?:CACertificateFile|CACertificatePath|CADNRequestFile|CADNRequestPath|CARevocationCheck|CARevocationFile|CARevocationPath|CertificateChainFile|CertificateFile|CertificateKeyFile|CipherSuite|Compression|CryptoDevice|Engine|FIPS|HonorCipherOrder|InsecureRenegotiation|OCSP(?:DefaultResponder|Enable|OverrideResponder|ResponderTimeout|ResponseMaxAge|ResponseTimeSkew|UseRequestNonce)|OpenSSLConfCmd|Options|PassPhraseDialog|Protocol|Proxy(?:CACertificateFile|CACertificatePath|CARevocation(?:Check|File|Path)|CheckPeer(?:CN|Expire|Name)|CipherSuite|Engine|MachineCertificate(?:ChainFile|File|Path)|Protocol|Verify|VerifyDepth)|RandomSeed|RenegBufferSize|Require|RequireSSL|Session(?:Cache|CacheTimeout|TicketKeyFile|Tickets)|SRPUnknownUserSeed|SRPVerifierFile|Stapling(?:Cache|ErrorCacheTimeout|FakeTryLater|ForceURL|ResponderTimeout|ResponseMaxAge|ResponseTimeSkew|ReturnResponderErrors|StandardCacheTimeout)|StrictSNIVHostCheck|UserName|UseStapling|VerifyClient|VerifyDepth)|StartServers|StartThreads|Substitute|Suexec|SuexecUserGroup|ThreadLimit|ThreadsPerChild|ThreadStackSize|TimeOut|TraceEnable|TransferLog|TypesConfig|UnDefine|UndefMacro|UnsetEnv|Use|UseCanonicalName|UseCanonicalPhysicalPort|User|UserDir|VHostCGIMode|VHostCGIPrivs|VHostGroup|VHostPrivs|VHostSecure|VHostUser|Virtual(?:DocumentRoot|ScriptAlias)(?:IP)?|WatchdogInterval|XBitHack|xml2EncAlias|xml2EncDefault|xml2StartParse)\b/im,
        lookbehind: !0,
        alias: "property"
      },
      "directive-block": {
        pattern: /<\/?\b(?:Auth[nz]ProviderAlias|Directory|DirectoryMatch|Else|ElseIf|Files|FilesMatch|If|IfDefine|IfModule|IfVersion|Limit|LimitExcept|Location|LocationMatch|Macro|Proxy|Require(?:All|Any|None)|VirtualHost)\b.*>/i,
        inside: {
          "directive-block": {
            pattern: /^<\/?\w+/,
            inside: {
              punctuation: /^<\/?/
            },
            alias: "tag"
          },
          "directive-block-parameter": {
            pattern: /.*[^>]/,
            inside: {
              punctuation: /:/,
              string: {
                pattern: /("|').*\1/,
                inside: {
                  variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/
                }
              }
            },
            alias: "attr-value"
          },
          punctuation: />/
        },
        alias: "tag"
      },
      "directive-flags": {
        pattern: /\[(?:[\w=],?)+\]/,
        alias: "keyword"
      },
      string: {
        pattern: /("|').*\1/,
        inside: {
          variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/
        }
      },
      variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/,
      regex: /\^?.*\$|\^.*\$?/
    };
  }
  return apacheconf_1;
}
var sql_1, hasRequiredSql;
function requireSql() {
  if (hasRequiredSql) return sql_1;
  hasRequiredSql = 1, sql_1 = e, e.displayName = "sql", e.aliases = [];
  function e(t) {
    t.languages.sql = {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
        lookbehind: !0
      },
      variable: [{
        pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
        greedy: !0
      }, /@[\w.$]+/],
      string: {
        pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
        greedy: !0,
        lookbehind: !0
      },
      identifier: {
        pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
        greedy: !0,
        lookbehind: !0,
        inside: {
          punctuation: /^`|`$/
        }
      },
      function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
      // Should we highlight user defined functions too?
      keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
      boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
      number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
      operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
      punctuation: /[;[\]()`,.]/
    };
  }
  return sql_1;
}
var apex_1, hasRequiredApex;
function requireApex() {
  if (hasRequiredApex) return apex_1;
  hasRequiredApex = 1;
  var e = requireSql();
  apex_1 = t, t.displayName = "apex", t.aliases = [];
  function t(r) {
    r.register(e), function(a) {
      var o = /\b(?:(?:after|before)(?=\s+[a-z])|abstract|activate|and|any|array|as|asc|autonomous|begin|bigdecimal|blob|boolean|break|bulk|by|byte|case|cast|catch|char|class|collect|commit|const|continue|currency|date|datetime|decimal|default|delete|desc|do|double|else|end|enum|exception|exit|export|extends|final|finally|float|for|from|get(?=\s*[{};])|global|goto|group|having|hint|if|implements|import|in|inner|insert|instanceof|int|integer|interface|into|join|like|limit|list|long|loop|map|merge|new|not|null|nulls|number|object|of|on|or|outer|override|package|parallel|pragma|private|protected|public|retrieve|return|rollback|select|set|short|sObject|sort|static|string|super|switch|synchronized|system|testmethod|then|this|throw|time|transaction|transient|trigger|try|undelete|update|upsert|using|virtual|void|webservice|when|where|while|(?:inherited|with|without)\s+sharing)\b/i, u = /\b(?:(?=[a-z_]\w*\s*[<\[])|(?!<keyword>))[A-Z_]\w*(?:\s*\.\s*[A-Z_]\w*)*\b(?:\s*(?:\[\s*\]|<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>))*/.source.replace(/<keyword>/g, function() {
        return o.source;
      });
      function c(g) {
        return RegExp(g.replace(/<CLASS-NAME>/g, function() {
          return u;
        }), "i");
      }
      var d = {
        keyword: o,
        punctuation: /[()\[\]{};,:.<>]/
      };
      a.languages.apex = {
        comment: a.languages.clike.comment,
        string: a.languages.clike.string,
        sql: {
          pattern: /((?:[=,({:]|\breturn)\s*)\[[^\[\]]*\]/i,
          lookbehind: !0,
          greedy: !0,
          alias: "language-sql",
          inside: a.languages.sql
        },
        annotation: {
          pattern: /@\w+\b/,
          alias: "punctuation"
        },
        "class-name": [{
          pattern: c(/(\b(?:class|enum|extends|implements|instanceof|interface|new|trigger\s+\w+\s+on)\s+)<CLASS-NAME>/.source),
          lookbehind: !0,
          inside: d
        }, {
          // cast
          pattern: c(/(\(\s*)<CLASS-NAME>(?=\s*\)\s*[\w(])/.source),
          lookbehind: !0,
          inside: d
        }, {
          // variable/parameter declaration and return types
          pattern: c(/<CLASS-NAME>(?=\s*\w+\s*[;=,(){:])/.source),
          inside: d
        }],
        trigger: {
          pattern: /(\btrigger\s+)\w+\b/i,
          lookbehind: !0,
          alias: "class-name"
        },
        keyword: o,
        function: /\b[a-z_]\w*(?=\s*\()/i,
        boolean: /\b(?:false|true)\b/i,
        number: /(?:\B\.\d+|\b\d+(?:\.\d+|L)?)\b/i,
        operator: /[!=](?:==?)?|\?\.?|&&|\|\||--|\+\+|[-+*/^&|]=?|:|<<?=?|>{1,3}=?/,
        punctuation: /[()\[\]{};,.]/
      };
    }(r);
  }
  return apex_1;
}
var apl_1, hasRequiredApl;
function requireApl() {
  if (hasRequiredApl) return apl_1;
  hasRequiredApl = 1, apl_1 = e, e.displayName = "apl", e.aliases = [];
  function e(t) {
    t.languages.apl = {
      comment: /(?:|#[! ]).*$/m,
      string: {
        pattern: /'(?:[^'\r\n]|'')*'/,
        greedy: !0
      },
      number: /?(?:\d*\.?\b\d+(?:e[+]?\d+)?||)(?:j?(?:(?:\d+(?:\.\d+)?|\.\d+)(?:e[+]?\d+)?||))?/i,
      statement: /:[A-Z][a-z][A-Za-z]*\b/,
      "system-function": {
        pattern: /[A-Z]+/i,
        alias: "function"
      },
      constant: /[#]/,
      function: /[-+|?*!<=>~,]/,
      "monadic-operator": {
        pattern: /[\\\/&]/,
        alias: "operator"
      },
      "dyadic-operator": {
        pattern: /[.@]/,
        alias: "operator"
      },
      assignment: {
        pattern: //,
        alias: "keyword"
      },
      punctuation: /[\[;\]()]/,
      dfn: {
        pattern: /[{}:]/,
        alias: "builtin"
      }
    };
  }
  return apl_1;
}
var applescript_1, hasRequiredApplescript;
function requireApplescript() {
  if (hasRequiredApplescript) return applescript_1;
  hasRequiredApplescript = 1, applescript_1 = e, e.displayName = "applescript", e.aliases = [];
  function e(t) {
    t.languages.applescript = {
      comment: [
        // Allow one level of nesting
        /\(\*(?:\(\*(?:[^*]|\*(?!\)))*\*\)|(?!\(\*)[\s\S])*?\*\)/,
        /--.+/,
        /#.+/
      ],
      string: /"(?:\\.|[^"\\\r\n])*"/,
      number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e-?\d+)?\b/i,
      operator: [/[&=*+\-\/^]|[<>]=?/, /\b(?:(?:begin|end|start)s? with|(?:contains?|(?:does not|doesn't) contain)|(?:is|isn't|is not) (?:contained by|in)|(?:(?:is|isn't|is not) )?(?:greater|less) than(?: or equal)?(?: to)?|(?:comes|(?:does not|doesn't) come) (?:after|before)|(?:is|isn't|is not) equal(?: to)?|(?:(?:does not|doesn't) equal|equal to|equals|is not|isn't)|(?:a )?(?:ref(?: to)?|reference to)|(?:and|as|div|mod|not|or))\b/],
      keyword: /\b(?:about|above|after|against|apart from|around|aside from|at|back|before|beginning|behind|below|beneath|beside|between|but|by|considering|continue|copy|does|eighth|else|end|equal|error|every|exit|false|fifth|first|for|fourth|from|front|get|given|global|if|ignoring|in|instead of|into|is|it|its|last|local|me|middle|my|ninth|of|on|onto|out of|over|prop|property|put|repeat|return|returning|second|set|seventh|since|sixth|some|tell|tenth|that|the|then|third|through|thru|timeout|times|to|transaction|true|try|until|where|while|whose|with|without)\b/,
      "class-name": /\b(?:POSIX file|RGB color|alias|application|boolean|centimeters|centimetres|class|constant|cubic centimeters|cubic centimetres|cubic feet|cubic inches|cubic meters|cubic metres|cubic yards|date|degrees Celsius|degrees Fahrenheit|degrees Kelvin|feet|file|gallons|grams|inches|integer|kilograms|kilometers|kilometres|list|liters|litres|meters|metres|miles|number|ounces|pounds|quarts|real|record|reference|script|square feet|square kilometers|square kilometres|square meters|square metres|square miles|square yards|text|yards)\b/,
      punctuation: /[{}():,]/
    };
  }
  return applescript_1;
}
var aql_1, hasRequiredAql;
function requireAql() {
  if (hasRequiredAql) return aql_1;
  hasRequiredAql = 1, aql_1 = e, e.displayName = "aql", e.aliases = [];
  function e(t) {
    t.languages.aql = {
      comment: /\/\/.*|\/\*[\s\S]*?\*\//,
      property: {
        pattern: /([{,]\s*)(?:(?!\d)\w+|(["'`])(?:(?!\2)[^\\\r\n]|\\.)*\2)(?=\s*:)/,
        lookbehind: !0,
        greedy: !0
      },
      string: {
        pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\.)*\1/,
        greedy: !0
      },
      identifier: {
        pattern: /([`])(?:(?!\1)[^\\\r\n]|\\.)*\1/,
        greedy: !0
      },
      variable: /@@?\w+/,
      keyword: [
        {
          pattern: /(\bWITH\s+)COUNT(?=\s+INTO\b)/i,
          lookbehind: !0
        },
        /\b(?:AGGREGATE|ALL|AND|ANY|ASC|COLLECT|DESC|DISTINCT|FILTER|FOR|GRAPH|IN|INBOUND|INSERT|INTO|K_PATHS|K_SHORTEST_PATHS|LET|LIKE|LIMIT|NONE|NOT|NULL|OR|OUTBOUND|REMOVE|REPLACE|RETURN|SHORTEST_PATH|SORT|UPDATE|UPSERT|WINDOW|WITH)\b/i,
        // pseudo keywords get a lookbehind to avoid false positives
        {
          pattern: /(^|[^\w.[])(?:KEEP|PRUNE|SEARCH|TO)\b/i,
          lookbehind: !0
        },
        {
          pattern: /(^|[^\w.[])(?:CURRENT|NEW|OLD)\b/,
          lookbehind: !0
        },
        {
          pattern: /\bOPTIONS(?=\s*\{)/i
        }
      ],
      function: /\b(?!\d)\w+(?=\s*\()/,
      boolean: /\b(?:false|true)\b/i,
      range: {
        pattern: /\.\./,
        alias: "operator"
      },
      number: [/\b0b[01]+/i, /\b0x[0-9a-f]+/i, /(?:\B\.\d+|\b(?:0|[1-9]\d*)(?:\.\d+)?)(?:e[+-]?\d+)?/i],
      operator: /\*{2,}|[=!]~|[!=<>]=?|&&|\|\||[-+*/%]/,
      punctuation: /::|[?.:,;()[\]{}]/
    };
  }
  return aql_1;
}
var c_1, hasRequiredC;
function requireC() {
  if (hasRequiredC) return c_1;
  hasRequiredC = 1, c_1 = e, e.displayName = "c", e.aliases = [];
  function e(t) {
    t.languages.c = t.languages.extend("clike", {
      comment: {
        pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
        greedy: !0
      },
      string: {
        // https://en.cppreference.com/w/c/language/string_literal
        pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
        lookbehind: !0
      },
      keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
      operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
    }), t.languages.insertBefore("c", "string", {
      char: {
        // https://en.cppreference.com/w/c/language/character_constant
        pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
        greedy: !0
      }
    }), t.languages.insertBefore("c", "string", {
      macro: {
        // allow for multiline macro definitions
        // spaces after the # character compile fine with gcc
        pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
        lookbehind: !0,
        greedy: !0,
        alias: "property",
        inside: {
          string: [{
            // highlight the path of the include statement as a string
            pattern: /^(#\s*include\s*)<[^>]+>/,
            lookbehind: !0
          }, t.languages.c.string],
          char: t.languages.c.char,
          comment: t.languages.c.comment,
          "macro-name": [{
            pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
            lookbehind: !0
          }, {
            pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
            lookbehind: !0,
            alias: "function"
          }],
          // highlight macro directives as keywords
          directive: {
            pattern: /^(#\s*)[a-z]+/,
            lookbehind: !0,
            alias: "keyword"
          },
          "directive-hash": /^#/,
          punctuation: /##|\\(?=[\r\n])/,
          expression: {
            pattern: /\S[\s\S]*/,
            inside: t.languages.c
          }
        }
      }
    }), t.languages.insertBefore("c", "function", {
      // highlight predefined macros as constants
      constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
    }), delete t.languages.c.boolean;
  }
  return c_1;
}
var cpp_1, hasRequiredCpp;
function requireCpp() {
  if (hasRequiredCpp) return cpp_1;
  hasRequiredCpp = 1;
  var e = requireC();
  cpp_1 = t, t.displayName = "cpp", t.aliases = [];
  function t(r) {
    r.register(e), function(a) {
      var o = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, u = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
        return o.source;
      });
      a.languages.cpp = a.languages.extend("c", {
        "class-name": [
          {
            pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
              return o.source;
            })),
            lookbehind: !0
          },
          // This is intended to capture the class name of method implementations like:
          //   void foo::bar() const {}
          // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
          // it starts with an uppercase letter. This approximation should give decent results.
          /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
          // This will capture the class name before destructors like:
          //   Foo::~Foo() {}
          /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
          // This also intends to capture the class name of method implementations but here the class has template
          // parameters, so it can't be a namespace (until C++ adds generic namespaces).
          /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
        ],
        keyword: o,
        number: {
          pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
          greedy: !0
        },
        operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
        boolean: /\b(?:false|true)\b/
      }), a.languages.insertBefore("cpp", "string", {
        module: {
          // https://en.cppreference.com/w/cpp/language/modules
          pattern: RegExp(/(\b(?:import|module)\s+)/.source + "(?:" + // header-name
          /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
          /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
            return u;
          }) + ")"),
          lookbehind: !0,
          greedy: !0,
          inside: {
            string: /^[<"][\s\S]+/,
            operator: /:/,
            punctuation: /\./
          }
        },
        "raw-string": {
          pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
          alias: "string",
          greedy: !0
        }
      }), a.languages.insertBefore("cpp", "keyword", {
        "generic-function": {
          pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
          inside: {
            function: /^\w+/,
            generic: {
              pattern: /<[\s\S]+/,
              alias: "class-name",
              inside: a.languages.cpp
            }
          }
        }
      }), a.languages.insertBefore("cpp", "operator", {
        "double-colon": {
          pattern: /::/,
          alias: "punctuation"
        }
      }), a.languages.insertBefore("cpp", "class-name", {
        // the base clause is an optional list of parent classes
        // https://en.cppreference.com/w/cpp/language/class
        "base-clause": {
          pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
          lookbehind: !0,
          greedy: !0,
          inside: a.languages.extend("cpp", {})
        }
      }), a.languages.insertBefore("inside", "double-colon", {
        // All untokenized words that are not namespaces should be class names
        "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
      }, a.languages.cpp["base-clause"]);
    }(r);
  }
  return cpp_1;
}
var arduino_1, hasRequiredArduino;
function requireArduino() {
  if (hasRequiredArduino) return arduino_1;
  hasRequiredArduino = 1;
  var e = requireCpp();
  arduino_1 = t, t.displayName = "arduino", t.aliases = ["ino"];
  function t(r) {
    r.register(e), r.languages.arduino = r.languages.extend("cpp", {
      keyword: /\b(?:String|array|bool|boolean|break|byte|case|catch|continue|default|do|double|else|finally|for|function|goto|if|in|instanceof|int|integer|long|loop|new|null|return|setup|string|switch|throw|try|void|while|word)\b/,
      constant: /\b(?:ANALOG_MESSAGE|DEFAULT|DIGITAL_MESSAGE|EXTERNAL|FIRMATA_STRING|HIGH|INPUT|INPUT_PULLUP|INTERNAL|INTERNAL1V1|INTERNAL2V56|LED_BUILTIN|LOW|OUTPUT|REPORT_ANALOG|REPORT_DIGITAL|SET_PIN_MODE|SYSEX_START|SYSTEM_RESET)\b/,
      builtin: /\b(?:Audio|BSSID|Bridge|Client|Console|EEPROM|Esplora|EsploraTFT|Ethernet|EthernetClient|EthernetServer|EthernetUDP|File|FileIO|FileSystem|Firmata|GPRS|GSM|GSMBand|GSMClient|GSMModem|GSMPIN|GSMScanner|GSMServer|GSMVoiceCall|GSM_SMS|HttpClient|IPAddress|IRread|Keyboard|KeyboardController|LiquidCrystal|LiquidCrystal_I2C|Mailbox|Mouse|MouseController|PImage|Process|RSSI|RobotControl|RobotMotor|SD|SPI|SSID|Scheduler|Serial|Server|Servo|SoftwareSerial|Stepper|Stream|TFT|Task|USBHost|WiFi|WiFiClient|WiFiServer|WiFiUDP|Wire|YunClient|YunServer|abs|addParameter|analogRead|analogReadResolution|analogReference|analogWrite|analogWriteResolution|answerCall|attach|attachGPRS|attachInterrupt|attached|autoscroll|available|background|beep|begin|beginPacket|beginSD|beginSMS|beginSpeaker|beginTFT|beginTransmission|beginWrite|bit|bitClear|bitRead|bitSet|bitWrite|blink|blinkVersion|buffer|changePIN|checkPIN|checkPUK|checkReg|circle|cityNameRead|cityNameWrite|clear|clearScreen|click|close|compassRead|config|connect|connected|constrain|cos|countryNameRead|countryNameWrite|createChar|cursor|debugPrint|delay|delayMicroseconds|detach|detachInterrupt|digitalRead|digitalWrite|disconnect|display|displayLogos|drawBMP|drawCompass|encryptionType|end|endPacket|endSMS|endTransmission|endWrite|exists|exitValue|fill|find|findUntil|flush|gatewayIP|get|getAsynchronously|getBand|getButton|getCurrentCarrier|getIMEI|getKey|getModifiers|getOemKey|getPINUsed|getResult|getSignalStrength|getSocket|getVoiceCallStatus|getXChange|getYChange|hangCall|height|highByte|home|image|interrupts|isActionDone|isDirectory|isListening|isPIN|isPressed|isValid|keyPressed|keyReleased|keyboardRead|knobRead|leftToRight|line|lineFollowConfig|listen|listenOnLocalhost|loadImage|localIP|lowByte|macAddress|maintain|map|max|messageAvailable|micros|millis|min|mkdir|motorsStop|motorsWrite|mouseDragged|mouseMoved|mousePressed|mouseReleased|move|noAutoscroll|noBlink|noBuffer|noCursor|noDisplay|noFill|noInterrupts|noListenOnLocalhost|noStroke|noTone|onReceive|onRequest|open|openNextFile|overflow|parseCommand|parseFloat|parseInt|parsePacket|pauseMode|peek|pinMode|playFile|playMelody|point|pointTo|position|pow|prepare|press|print|printFirmwareVersion|printVersion|println|process|processInput|pulseIn|put|random|randomSeed|read|readAccelerometer|readBlue|readButton|readBytes|readBytesUntil|readGreen|readJoystickButton|readJoystickSwitch|readJoystickX|readJoystickY|readLightSensor|readMessage|readMicrophone|readNetworks|readRed|readSlider|readString|readStringUntil|readTemperature|ready|rect|release|releaseAll|remoteIP|remoteNumber|remotePort|remove|requestFrom|retrieveCallingNumber|rewindDirectory|rightToLeft|rmdir|robotNameRead|robotNameWrite|run|runAsynchronously|runShellCommand|runShellCommandAsynchronously|running|scanNetworks|scrollDisplayLeft|scrollDisplayRight|seek|sendAnalog|sendDigitalPortPair|sendDigitalPorts|sendString|sendSysex|serialEvent|setBand|setBitOrder|setClockDivider|setCursor|setDNS|setDataMode|setFirmwareVersion|setMode|setPINUsed|setSpeed|setTextSize|setTimeout|shiftIn|shiftOut|shutdown|sin|size|sqrt|startLoop|step|stop|stroke|subnetMask|switchPIN|tan|tempoWrite|text|tone|transfer|tuneWrite|turn|updateIR|userNameRead|userNameWrite|voiceCall|waitContinue|width|write|writeBlue|writeGreen|writeJSON|writeMessage|writeMicroseconds|writeRGB|writeRed|yield)\b/
    }), r.languages.ino = r.languages.arduino;
  }
  return arduino_1;
}
var arff_1, hasRequiredArff;
function requireArff() {
  if (hasRequiredArff) return arff_1;
  hasRequiredArff = 1, arff_1 = e, e.displayName = "arff", e.aliases = [];
  function e(t) {
    t.languages.arff = {
      comment: /%.*/,
      string: {
        pattern: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      keyword: /@(?:attribute|data|end|relation)\b/i,
      number: /\b\d+(?:\.\d+)?\b/,
      punctuation: /[{},]/
    };
  }
  return arff_1;
}
var asciidoc_1, hasRequiredAsciidoc;
function requireAsciidoc() {
  if (hasRequiredAsciidoc) return asciidoc_1;
  hasRequiredAsciidoc = 1, asciidoc_1 = e, e.displayName = "asciidoc", e.aliases = ["adoc"];
  function e(t) {
    (function(r) {
      var a = {
        pattern: /(^[ \t]*)\[(?!\[)(?:(["'$`])(?:(?!\2)[^\\]|\\.)*\2|\[(?:[^\[\]\\]|\\.)*\]|[^\[\]\\"'$`]|\\.)*\]/m,
        lookbehind: !0,
        inside: {
          quoted: {
            pattern: /([$`])(?:(?!\1)[^\\]|\\.)*\1/,
            inside: {
              punctuation: /^[$`]|[$`]$/
            }
          },
          interpreted: {
            pattern: /'(?:[^'\\]|\\.)*'/,
            inside: {
              punctuation: /^'|'$/
              // See rest below
            }
          },
          string: /"(?:[^"\\]|\\.)*"/,
          variable: /\w+(?==)/,
          punctuation: /^\[|\]$|,/,
          operator: /=/,
          // The negative look-ahead prevents blank matches
          "attr-value": /(?!^\s+$).+/
        }
      }, o = r.languages.asciidoc = {
        "comment-block": {
          pattern: /^(\/{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1/m,
          alias: "comment"
        },
        table: {
          pattern: /^\|={3,}(?:(?:\r?\n|\r(?!\n)).*)*?(?:\r?\n|\r)\|={3,}$/m,
          inside: {
            specifiers: {
              pattern: /(?:(?:(?:\d+(?:\.\d+)?|\.\d+)[+*](?:[<^>](?:\.[<^>])?|\.[<^>])?|[<^>](?:\.[<^>])?|\.[<^>])[a-z]*|[a-z]+)(?=\|)/,
              alias: "attr-value"
            },
            punctuation: {
              pattern: /(^|[^\\])[|!]=*/,
              lookbehind: !0
            }
            // See rest below
          }
        },
        "passthrough-block": {
          pattern: /^(\+{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
          inside: {
            punctuation: /^\++|\++$/
            // See rest below
          }
        },
        // Literal blocks and listing blocks
        "literal-block": {
          pattern: /^(-{4,}|\.{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
          inside: {
            punctuation: /^(?:-+|\.+)|(?:-+|\.+)$/
            // See rest below
          }
        },
        // Sidebar blocks, quote blocks, example blocks and open blocks
        "other-block": {
          pattern: /^(--|\*{4,}|_{4,}|={4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
          inside: {
            punctuation: /^(?:-+|\*+|_+|=+)|(?:-+|\*+|_+|=+)$/
            // See rest below
          }
        },
        // list-punctuation and list-label must appear before indented-block
        "list-punctuation": {
          pattern: /(^[ \t]*)(?:-|\*{1,5}|\.{1,5}|(?:[a-z]|\d+)\.|[xvi]+\))(?= )/im,
          lookbehind: !0,
          alias: "punctuation"
        },
        "list-label": {
          pattern: /(^[ \t]*)[a-z\d].+(?::{2,4}|;;)(?=\s)/im,
          lookbehind: !0,
          alias: "symbol"
        },
        "indented-block": {
          pattern: /((\r?\n|\r)\2)([ \t]+)\S.*(?:(?:\r?\n|\r)\3.+)*(?=\2{2}|$)/,
          lookbehind: !0
        },
        comment: /^\/\/.*/m,
        title: {
          pattern: /^.+(?:\r?\n|\r)(?:={3,}|-{3,}|~{3,}|\^{3,}|\+{3,})$|^={1,5} .+|^\.(?![\s.]).*/m,
          alias: "important",
          inside: {
            punctuation: /^(?:\.|=+)|(?:=+|-+|~+|\^+|\++)$/
            // See rest below
          }
        },
        "attribute-entry": {
          pattern: /^:[^:\r\n]+:(?: .*?(?: \+(?:\r?\n|\r).*?)*)?$/m,
          alias: "tag"
        },
        attributes: a,
        hr: {
          pattern: /^'{3,}$/m,
          alias: "punctuation"
        },
        "page-break": {
          pattern: /^<{3,}$/m,
          alias: "punctuation"
        },
        admonition: {
          pattern: /^(?:CAUTION|IMPORTANT|NOTE|TIP|WARNING):/m,
          alias: "keyword"
        },
        callout: [{
          pattern: /(^[ \t]*)<?\d*>/m,
          lookbehind: !0,
          alias: "symbol"
        }, {
          pattern: /<\d+>/,
          alias: "symbol"
        }],
        macro: {
          pattern: /\b[a-z\d][a-z\d-]*::?(?:[^\s\[\]]*\[(?:[^\]\\"']|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,
          inside: {
            function: /^[a-z\d-]+(?=:)/,
            punctuation: /^::?/,
            attributes: {
              pattern: /(?:\[(?:[^\]\\"']|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,
              inside: a.inside
            }
          }
        },
        inline: {
          /*
          The initial look-behind prevents the highlighting of escaped quoted text.
          Quoted text can be multi-line but cannot span an empty line.
          All quoted text can have attributes before [foobar, 'foobar', baz="bar"].
          First, we handle the constrained quotes.
          Those must be bounded by non-word chars and cannot have spaces between the delimiter and the first char.
          They are, in order: _emphasis_, ``double quotes'', `single quotes', `monospace`, 'emphasis', *strong*, +monospace+ and #unquoted#
          Then we handle the unconstrained quotes.
          Those do not have the restrictions of the constrained quotes.
          They are, in order: __emphasis__, **strong**, ++monospace++, +++passthrough+++, ##unquoted##, $$passthrough$$, ~subscript~, ^superscript^, {attribute-reference}, [[anchor]], [[[bibliography anchor]]], <<xref>>, (((indexes))) and ((indexes))
          */
          pattern: /(^|[^\\])(?:(?:\B\[(?:[^\]\\"']|(["'])(?:(?!\2)[^\\]|\\.)*\2|\\.)*\])?(?:\b_(?!\s)(?: _|[^_\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: _|[^_\\\r\n]|\\.)+)*_\b|\B``(?!\s).+?(?:(?:\r?\n|\r).+?)*''\B|\B`(?!\s)(?:[^`'\s]|\s+\S)+['`]\B|\B(['*+#])(?!\s)(?: \3|(?!\3)[^\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: \3|(?!\3)[^\\\r\n]|\\.)+)*\3\B)|(?:\[(?:[^\]\\"']|(["'])(?:(?!\4)[^\\]|\\.)*\4|\\.)*\])?(?:(__|\*\*|\+\+\+?|##|\$\$|[~^]).+?(?:(?:\r?\n|\r).+?)*\5|\{[^}\r\n]+\}|\[\[\[?.+?(?:(?:\r?\n|\r).+?)*\]?\]\]|<<.+?(?:(?:\r?\n|\r).+?)*>>|\(\(\(?.+?(?:(?:\r?\n|\r).+?)*\)?\)\)))/m,
          lookbehind: !0,
          inside: {
            attributes: a,
            url: {
              pattern: /^(?:\[\[\[?.+?\]?\]\]|<<.+?>>)$/,
              inside: {
                punctuation: /^(?:\[\[\[?|<<)|(?:\]\]\]?|>>)$/
              }
            },
            "attribute-ref": {
              pattern: /^\{.+\}$/,
              inside: {
                variable: {
                  pattern: /(^\{)[a-z\d,+_-]+/,
                  lookbehind: !0
                },
                operator: /^[=?!#%@$]|!(?=[:}])/,
                punctuation: /^\{|\}$|::?/
              }
            },
            italic: {
              pattern: /^(['_])[\s\S]+\1$/,
              inside: {
                punctuation: /^(?:''?|__?)|(?:''?|__?)$/
              }
            },
            bold: {
              pattern: /^\*[\s\S]+\*$/,
              inside: {
                punctuation: /^\*\*?|\*\*?$/
              }
            },
            punctuation: /^(?:``?|\+{1,3}|##?|\$\$|[~^]|\(\(\(?)|(?:''?|\+{1,3}|##?|\$\$|[~^`]|\)?\)\))$/
          }
        },
        replacement: {
          pattern: /\((?:C|R|TM)\)/,
          alias: "builtin"
        },
        entity: /&#?[\da-z]{1,8};/i,
        "line-continuation": {
          pattern: /(^| )\+$/m,
          lookbehind: !0,
          alias: "punctuation"
        }
      };
      function u(c) {
        c = c.split(" ");
        for (var d = {}, g = 0, b = c.length; g < b; g++)
          d[c[g]] = o[c[g]];
        return d;
      }
      a.inside.interpreted.inside.rest = u("macro inline replacement entity"), o["passthrough-block"].inside.rest = u("macro"), o["literal-block"].inside.rest = u("callout"), o.table.inside.rest = u("comment-block passthrough-block literal-block other-block list-punctuation indented-block comment title attribute-entry attributes hr page-break admonition list-label callout macro inline replacement entity line-continuation"), o["other-block"].inside.rest = u("table list-punctuation indented-block comment attribute-entry attributes hr page-break admonition list-label macro inline replacement entity line-continuation"), o.title.inside.rest = u("macro inline replacement entity"), r.hooks.add("wrap", function(c) {
        c.type === "entity" && (c.attributes.title = c.content.value.replace(/&amp;/, "&"));
      }), r.languages.adoc = r.languages.asciidoc;
    })(t);
  }
  return asciidoc_1;
}
var asm6502_1, hasRequiredAsm6502;
function requireAsm6502() {
  if (hasRequiredAsm6502) return asm6502_1;
  hasRequiredAsm6502 = 1, asm6502_1 = e, e.displayName = "asm6502", e.aliases = [];
  function e(t) {
    t.languages.asm6502 = {
      comment: /;.*/,
      directive: {
        pattern: /\.\w+(?= )/,
        alias: "property"
      },
      string: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
      "op-code": {
        pattern: /\b(?:ADC|AND|ASL|BCC|BCS|BEQ|BIT|BMI|BNE|BPL|BRK|BVC|BVS|CLC|CLD|CLI|CLV|CMP|CPX|CPY|DEC|DEX|DEY|EOR|INC|INX|INY|JMP|JSR|LDA|LDX|LDY|LSR|NOP|ORA|PHA|PHP|PLA|PLP|ROL|ROR|RTI|RTS|SBC|SEC|SED|SEI|STA|STX|STY|TAX|TAY|TSX|TXA|TXS|TYA|adc|and|asl|bcc|bcs|beq|bit|bmi|bne|bpl|brk|bvc|bvs|clc|cld|cli|clv|cmp|cpx|cpy|dec|dex|dey|eor|inc|inx|iny|jmp|jsr|lda|ldx|ldy|lsr|nop|ora|pha|php|pla|plp|rol|ror|rti|rts|sbc|sec|sed|sei|sta|stx|sty|tax|tay|tsx|txa|txs|tya)\b/,
        alias: "keyword"
      },
      "hex-number": {
        pattern: /#?\$[\da-f]{1,4}\b/i,
        alias: "number"
      },
      "binary-number": {
        pattern: /#?%[01]+\b/,
        alias: "number"
      },
      "decimal-number": {
        pattern: /#?\b\d+\b/,
        alias: "number"
      },
      register: {
        pattern: /\b[xya]\b/i,
        alias: "variable"
      },
      punctuation: /[(),:]/
    };
  }
  return asm6502_1;
}
var asmatmel_1, hasRequiredAsmatmel;
function requireAsmatmel() {
  if (hasRequiredAsmatmel) return asmatmel_1;
  hasRequiredAsmatmel = 1, asmatmel_1 = e, e.displayName = "asmatmel", e.aliases = [];
  function e(t) {
    t.languages.asmatmel = {
      comment: {
        pattern: /;.*/,
        greedy: !0
      },
      string: {
        pattern: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      constant: /\b(?:PORT[A-Z]|DDR[A-Z]|(?:DD|P)[A-Z](?:\d|[0-2]\d|3[01]))\b/,
      directive: {
        pattern: /\.\w+(?= )/,
        alias: "property"
      },
      "r-register": {
        pattern: /\br(?:\d|[12]\d|3[01])\b/,
        alias: "variable"
      },
      "op-code": {
        pattern: /\b(?:ADC|ADD|ADIW|AND|ANDI|ASR|BCLR|BLD|BRBC|BRBS|BRCC|BRCS|BREAK|BREQ|BRGE|BRHC|BRHS|BRID|BRIE|BRLO|BRLT|BRMI|BRNE|BRPL|BRSH|BRTC|BRTS|BRVC|BRVS|BSET|BST|CALL|CBI|CBR|CLC|CLH|CLI|CLN|CLR|CLS|CLT|CLV|CLZ|COM|CP|CPC|CPI|CPSE|DEC|DES|EICALL|EIJMP|ELPM|EOR|FMUL|FMULS|FMULSU|ICALL|IJMP|IN|INC|JMP|LAC|LAS|LAT|LD|LD[A-Za-z0-9]|LPM|LSL|LSR|MOV|MOVW|MUL|MULS|MULSU|NEG|NOP|OR|ORI|OUT|POP|PUSH|RCALL|RET|RETI|RJMP|ROL|ROR|SBC|SBCI|SBI|SBIC|SBIS|SBIW|SBR|SBRC|SBRS|SEC|SEH|SEI|SEN|SER|SES|SET|SEV|SEZ|SLEEP|SPM|ST|ST[A-Z0-9]|SUB|SUBI|SWAP|TST|WDR|XCH|adc|add|adiw|and|andi|asr|bclr|bld|brbc|brbs|brcc|brcs|break|breq|brge|brhc|brhs|brid|brie|brlo|brlt|brmi|brne|brpl|brsh|brtc|brts|brvc|brvs|bset|bst|call|cbi|cbr|clc|clh|cli|cln|clr|cls|clt|clv|clz|com|cp|cpc|cpi|cpse|dec|des|eicall|eijmp|elpm|eor|fmul|fmuls|fmulsu|icall|ijmp|in|inc|jmp|lac|las|lat|ld|ld[a-z0-9]|lpm|lsl|lsr|mov|movw|mul|muls|mulsu|neg|nop|or|ori|out|pop|push|rcall|ret|reti|rjmp|rol|ror|sbc|sbci|sbi|sbic|sbis|sbiw|sbr|sbrc|sbrs|sec|seh|sei|sen|ser|ses|set|sev|sez|sleep|spm|st|st[a-zA-Z0-9]|sub|subi|swap|tst|wdr|xch)\b/,
        alias: "keyword"
      },
      "hex-number": {
        pattern: /#?\$[\da-f]{2,4}\b/i,
        alias: "number"
      },
      "binary-number": {
        pattern: /#?%[01]+\b/,
        alias: "number"
      },
      "decimal-number": {
        pattern: /#?\b\d+\b/,
        alias: "number"
      },
      register: {
        pattern: /\b[acznvshtixy]\b/i,
        alias: "variable"
      },
      operator: />>=?|<<=?|&&?|\|\|?|[-+*/%&|^!=<>?]=?/,
      punctuation: /[(),:]/
    };
  }
  return asmatmel_1;
}
var csharp_1, hasRequiredCsharp;
function requireCsharp() {
  if (hasRequiredCsharp) return csharp_1;
  hasRequiredCsharp = 1, csharp_1 = e, e.displayName = "csharp", e.aliases = ["dotnet", "cs"];
  function e(t) {
    (function(r) {
      function a(le, Z) {
        return le.replace(/<<(\d+)>>/g, function(O, z) {
          return "(?:" + Z[+z] + ")";
        });
      }
      function o(le, Z, O) {
        return RegExp(a(le, Z), "");
      }
      function u(le, Z) {
        for (var O = 0; O < Z; O++)
          le = le.replace(/<<self>>/g, function() {
            return "(?:" + le + ")";
          });
        return le.replace(/<<self>>/g, "[^\\s\\S]");
      }
      var c = {
        // keywords which represent a return or variable type
        type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
        // keywords which are used to declare a type
        typeDeclaration: "class enum interface record struct",
        // contextual keywords
        // ("var" and "dynamic" are missing because they are used like types)
        contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
        // all other keywords
        other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
      };
      function d(le) {
        return "\\b(?:" + le.trim().replace(/ /g, "|") + ")\\b";
      }
      var g = d(c.typeDeclaration), b = RegExp(d(c.type + " " + c.typeDeclaration + " " + c.contextual + " " + c.other)), _ = d(c.typeDeclaration + " " + c.contextual + " " + c.other), y = d(c.type + " " + c.typeDeclaration + " " + c.other), A = u(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2), E = u(/\((?:[^()]|<<self>>)*\)/.source, 2), v = /@?\b[A-Za-z_]\w*\b/.source, C = a(/<<0>>(?:\s*<<1>>)?/.source, [v, A]), R = a(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [_, C]), I = /\[\s*(?:,\s*)*\]/.source, w = a(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [R, I]), N = a(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [A, E, I]), F = a(/\(<<0>>+(?:,<<0>>+)+\)/.source, [N]), M = a(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [F, R, I]), x = {
        keyword: b,
        punctuation: /[<>()?,.:[\]]/
      }, P = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source, U = /"(?:\\.|[^\\"\r\n])*"/.source, L = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
      r.languages.csharp = r.languages.extend("clike", {
        string: [{
          pattern: o(/(^|[^$\\])<<0>>/.source, [L]),
          lookbehind: !0,
          greedy: !0
        }, {
          pattern: o(/(^|[^@$\\])<<0>>/.source, [U]),
          lookbehind: !0,
          greedy: !0
        }],
        "class-name": [{
          // Using static
          // using static System.Math;
          pattern: o(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [R]),
          lookbehind: !0,
          inside: x
        }, {
          // Using alias (type)
          // using Project = PC.MyCompany.Project;
          pattern: o(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [v, M]),
          lookbehind: !0,
          inside: x
        }, {
          // Using alias (alias)
          // using Project = PC.MyCompany.Project;
          pattern: o(/(\busing\s+)<<0>>(?=\s*=)/.source, [v]),
          lookbehind: !0
        }, {
          // Type declarations
          // class Foo<A, B>
          // interface Foo<out A, B>
          pattern: o(/(\b<<0>>\s+)<<1>>/.source, [g, C]),
          lookbehind: !0,
          inside: x
        }, {
          // Single catch exception declaration
          // catch(Foo)
          // (things like catch(Foo e) is covered by variable declaration)
          pattern: o(/(\bcatch\s*\(\s*)<<0>>/.source, [R]),
          lookbehind: !0,
          inside: x
        }, {
          // Name of the type parameter of generic constraints
          // where Foo : class
          pattern: o(/(\bwhere\s+)<<0>>/.source, [v]),
          lookbehind: !0
        }, {
          // Casts and checks via as and is.
          // as Foo<A>, is Bar<B>
          // (things like if(a is Foo b) is covered by variable declaration)
          pattern: o(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [w]),
          lookbehind: !0,
          inside: x
        }, {
          // Variable, field and parameter declaration
          // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)
          pattern: o(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [M, y, v]),
          inside: x
        }],
        keyword: b,
        // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals
        number: /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
        operator: />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
        punctuation: /\?\.?|::|[{}[\];(),.:]/
      }), r.languages.insertBefore("csharp", "number", {
        range: {
          pattern: /\.\./,
          alias: "operator"
        }
      }), r.languages.insertBefore("csharp", "punctuation", {
        "named-parameter": {
          pattern: o(/([(,]\s*)<<0>>(?=\s*:)/.source, [v]),
          lookbehind: !0,
          alias: "punctuation"
        }
      }), r.languages.insertBefore("csharp", "class-name", {
        namespace: {
          // namespace Foo.Bar {}
          // using Foo.Bar;
          pattern: o(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [v]),
          lookbehind: !0,
          inside: {
            punctuation: /\./
          }
        },
        "type-expression": {
          // default(Foo), typeof(Foo<Bar>), sizeof(int)
          pattern: o(/(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [E]),
          lookbehind: !0,
          alias: "class-name",
          inside: x
        },
        "return-type": {
          // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0
          // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];
          // int Foo => 0; int Foo { get; set } = 0;
          pattern: o(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [M, R]),
          inside: x,
          alias: "class-name"
        },
        "constructor-invocation": {
          // new List<Foo<Bar[]>> { }
          pattern: o(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [M]),
          lookbehind: !0,
          inside: x,
          alias: "class-name"
        },
        /*'explicit-implementation': {
        // int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();
        pattern: replace(/\b<<0>>(?=\.<<1>>)/, className, methodOrPropertyDeclaration),
        inside: classNameInside,
        alias: 'class-name'
        },*/
        "generic-method": {
          // foo<Bar>()
          pattern: o(/<<0>>\s*<<1>>(?=\s*\()/.source, [v, A]),
          inside: {
            function: o(/^<<0>>/.source, [v]),
            generic: {
              pattern: RegExp(A),
              alias: "class-name",
              inside: x
            }
          }
        },
        "type-list": {
          // The list of types inherited or of generic constraints
          // class Foo<F> : Bar, IList<FooBar>
          // where F : Bar, IList<int>
          pattern: o(/\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source, [g, C, v, M, b.source, E, /\bnew\s*\(\s*\)/.source]),
          lookbehind: !0,
          inside: {
            "record-arguments": {
              pattern: o(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [C, E]),
              lookbehind: !0,
              greedy: !0,
              inside: r.languages.csharp
            },
            keyword: b,
            "class-name": {
              pattern: RegExp(M),
              greedy: !0,
              inside: x
            },
            punctuation: /[,()]/
          }
        },
        preprocessor: {
          pattern: /(^[\t ]*)#.*/m,
          lookbehind: !0,
          alias: "property",
          inside: {
            // highlight preprocessor directives as keywords
            directive: {
              pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
              lookbehind: !0,
              alias: "keyword"
            }
          }
        }
      });
      var H = U + "|" + P, B = a(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [H]), V = u(a(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [B]), 2), X = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source, de = a(/<<0>>(?:\s*\(<<1>>*\))?/.source, [R, V]);
      r.languages.insertBefore("csharp", "class-name", {
        attribute: {
          // Attributes
          // [Foo], [Foo(1), Bar(2, Prop = "foo")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]
          pattern: o(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [X, de]),
          lookbehind: !0,
          greedy: !0,
          inside: {
            target: {
              pattern: o(/^<<0>>(?=\s*:)/.source, [X]),
              alias: "keyword"
            },
            "attribute-arguments": {
              pattern: o(/\(<<0>>*\)/.source, [V]),
              inside: r.languages.csharp
            },
            "class-name": {
              pattern: RegExp(R),
              inside: {
                punctuation: /\./
              }
            },
            punctuation: /[:,]/
          }
        }
      });
      var Y = /:[^}\r\n]+/.source, se = u(a(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [B]), 2), ue = a(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [se, Y]), pe = u(a(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [H]), 2), J = a(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [pe, Y]);
      function j(le, Z) {
        return {
          interpolation: {
            pattern: o(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [le]),
            lookbehind: !0,
            inside: {
              "format-string": {
                pattern: o(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [Z, Y]),
                lookbehind: !0,
                inside: {
                  punctuation: /^:/
                }
              },
              punctuation: /^\{|\}$/,
              expression: {
                pattern: /[\s\S]+/,
                alias: "language-csharp",
                inside: r.languages.csharp
              }
            }
          },
          string: /[\s\S]+/
        };
      }
      r.languages.insertBefore("csharp", "string", {
        "interpolation-string": [{
          pattern: o(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [ue]),
          lookbehind: !0,
          greedy: !0,
          inside: j(ue, se)
        }, {
          pattern: o(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [J]),
          lookbehind: !0,
          greedy: !0,
          inside: j(J, pe)
        }],
        char: {
          pattern: RegExp(P),
          greedy: !0
        }
      }), r.languages.dotnet = r.languages.cs = r.languages.csharp;
    })(t);
  }
  return csharp_1;
}
var aspnet_1, hasRequiredAspnet;
function requireAspnet() {
  if (hasRequiredAspnet) return aspnet_1;
  hasRequiredAspnet = 1;
  var e = requireCsharp();
  aspnet_1 = t, t.displayName = "aspnet", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.aspnet = r.languages.extend("markup", {
      "page-directive": {
        pattern: /<%\s*@.*%>/,
        alias: "tag",
        inside: {
          "page-directive": {
            pattern: /<%\s*@\s*(?:Assembly|Control|Implements|Import|Master(?:Type)?|OutputCache|Page|PreviousPageType|Reference|Register)?|%>/i,
            alias: "tag"
          },
          rest: r.languages.markup.tag.inside
        }
      },
      directive: {
        pattern: /<%.*%>/,
        alias: "tag",
        inside: {
          directive: {
            pattern: /<%\s*?[$=%#:]{0,2}|%>/,
            alias: "tag"
          },
          rest: r.languages.csharp
        }
      }
    }), r.languages.aspnet.tag.pattern = /<(?!%)\/?[^\s>\/]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/, r.languages.insertBefore("inside", "punctuation", {
      directive: r.languages.aspnet.directive
    }, r.languages.aspnet.tag.inside["attr-value"]), r.languages.insertBefore("aspnet", "comment", {
      "asp-comment": {
        pattern: /<%--[\s\S]*?--%>/,
        alias: ["asp", "comment"]
      }
    }), r.languages.insertBefore("aspnet", r.languages.javascript ? "script" : "tag", {
      "asp-script": {
        pattern: /(<script(?=.*runat=['"]?server\b)[^>]*>)[\s\S]*?(?=<\/script>)/i,
        lookbehind: !0,
        alias: ["asp", "script"],
        inside: r.languages.csharp || {}
      }
    });
  }
  return aspnet_1;
}
var autohotkey_1, hasRequiredAutohotkey;
function requireAutohotkey() {
  if (hasRequiredAutohotkey) return autohotkey_1;
  hasRequiredAutohotkey = 1, autohotkey_1 = e, e.displayName = "autohotkey", e.aliases = [];
  function e(t) {
    t.languages.autohotkey = {
      comment: [{
        pattern: /(^|\s);.*/,
        lookbehind: !0
      }, {
        pattern: /(^[\t ]*)\/\*(?:[\r\n](?![ \t]*\*\/)|[^\r\n])*(?:[\r\n][ \t]*\*\/)?/m,
        lookbehind: !0,
        greedy: !0
      }],
      tag: {
        // labels
        pattern: /^([ \t]*)[^\s,`":]+(?=:[ \t]*$)/m,
        lookbehind: !0
      },
      string: /"(?:[^"\n\r]|"")*"/,
      variable: /%\w+%/,
      number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
      operator: /\?|\/\/?=?|:=|\|[=|]?|&[=&]?|\+[=+]?|-[=-]?|\*[=*]?|<(?:<=?|>|=)?|>>?=?|[.^!=~]=?|\b(?:AND|NOT|OR)\b/,
      boolean: /\b(?:false|true)\b/,
      selector: /\b(?:AutoTrim|BlockInput|Break|Click|ClipWait|Continue|Control|ControlClick|ControlFocus|ControlGet|ControlGetFocus|ControlGetPos|ControlGetText|ControlMove|ControlSend|ControlSendRaw|ControlSetText|CoordMode|Critical|DetectHiddenText|DetectHiddenWindows|Drive|DriveGet|DriveSpaceFree|EnvAdd|EnvDiv|EnvGet|EnvMult|EnvSet|EnvSub|EnvUpdate|Exit|ExitApp|FileAppend|FileCopy|FileCopyDir|FileCreateDir|FileCreateShortcut|FileDelete|FileEncoding|FileGetAttrib|FileGetShortcut|FileGetSize|FileGetTime|FileGetVersion|FileInstall|FileMove|FileMoveDir|FileRead|FileReadLine|FileRecycle|FileRecycleEmpty|FileRemoveDir|FileSelectFile|FileSelectFolder|FileSetAttrib|FileSetTime|FormatTime|GetKeyState|Gosub|Goto|GroupActivate|GroupAdd|GroupClose|GroupDeactivate|Gui|GuiControl|GuiControlGet|Hotkey|ImageSearch|IniDelete|IniRead|IniWrite|Input|InputBox|KeyWait|ListHotkeys|ListLines|ListVars|Loop|Menu|MouseClick|MouseClickDrag|MouseGetPos|MouseMove|MsgBox|OnExit|OutputDebug|Pause|PixelGetColor|PixelSearch|PostMessage|Process|Progress|Random|RegDelete|RegRead|RegWrite|Reload|Repeat|Return|Run|RunAs|RunWait|Send|SendEvent|SendInput|SendMessage|SendMode|SendPlay|SendRaw|SetBatchLines|SetCapslockState|SetControlDelay|SetDefaultMouseSpeed|SetEnv|SetFormat|SetKeyDelay|SetMouseDelay|SetNumlockState|SetRegView|SetScrollLockState|SetStoreCapslockMode|SetTimer|SetTitleMatchMode|SetWinDelay|SetWorkingDir|Shutdown|Sleep|Sort|SoundBeep|SoundGet|SoundGetWaveVolume|SoundPlay|SoundSet|SoundSetWaveVolume|SplashImage|SplashTextOff|SplashTextOn|SplitPath|StatusBarGetText|StatusBarWait|StringCaseSense|StringGetPos|StringLeft|StringLen|StringLower|StringMid|StringReplace|StringRight|StringSplit|StringTrimLeft|StringTrimRight|StringUpper|Suspend|SysGet|Thread|ToolTip|Transform|TrayTip|URLDownloadToFile|WinActivate|WinActivateBottom|WinClose|WinGet|WinGetActiveStats|WinGetActiveTitle|WinGetClass|WinGetPos|WinGetText|WinGetTitle|WinHide|WinKill|WinMaximize|WinMenuSelectItem|WinMinimize|WinMinimizeAll|WinMinimizeAllUndo|WinMove|WinRestore|WinSet|WinSetTitle|WinShow|WinWait|WinWaitActive|WinWaitClose|WinWaitNotActive)\b/i,
      constant: /\b(?:a_ahkpath|a_ahkversion|a_appdata|a_appdatacommon|a_autotrim|a_batchlines|a_caretx|a_carety|a_computername|a_controldelay|a_cursor|a_dd|a_ddd|a_dddd|a_defaultmousespeed|a_desktop|a_desktopcommon|a_detecthiddentext|a_detecthiddenwindows|a_endchar|a_eventinfo|a_exitreason|a_fileencoding|a_formatfloat|a_formatinteger|a_gui|a_guicontrol|a_guicontrolevent|a_guievent|a_guiheight|a_guiwidth|a_guix|a_guiy|a_hour|a_iconfile|a_iconhidden|a_iconnumber|a_icontip|a_index|a_ipaddress1|a_ipaddress2|a_ipaddress3|a_ipaddress4|a_is64bitos|a_isadmin|a_iscompiled|a_iscritical|a_ispaused|a_issuspended|a_isunicode|a_keydelay|a_language|a_lasterror|a_linefile|a_linenumber|a_loopfield|a_loopfileattrib|a_loopfiledir|a_loopfileext|a_loopfilefullpath|a_loopfilelongpath|a_loopfilename|a_loopfileshortname|a_loopfileshortpath|a_loopfilesize|a_loopfilesizekb|a_loopfilesizemb|a_loopfiletimeaccessed|a_loopfiletimecreated|a_loopfiletimemodified|a_loopreadline|a_loopregkey|a_loopregname|a_loopregsubkey|a_loopregtimemodified|a_loopregtype|a_mday|a_min|a_mm|a_mmm|a_mmmm|a_mon|a_mousedelay|a_msec|a_mydocuments|a_now|a_nowutc|a_numbatchlines|a_ostype|a_osversion|a_priorhotkey|a_priorkey|a_programfiles|a_programs|a_programscommon|a_ptrsize|a_regview|a_screendpi|a_screenheight|a_screenwidth|a_scriptdir|a_scriptfullpath|a_scripthwnd|a_scriptname|a_sec|a_space|a_startmenu|a_startmenucommon|a_startup|a_startupcommon|a_stringcasesense|a_tab|a_temp|a_thisfunc|a_thishotkey|a_thislabel|a_thismenu|a_thismenuitem|a_thismenuitempos|a_tickcount|a_timeidle|a_timeidlephysical|a_timesincepriorhotkey|a_timesincethishotkey|a_titlematchmode|a_titlematchmodespeed|a_username|a_wday|a_windelay|a_windir|a_workingdir|a_yday|a_year|a_yweek|a_yyyy|clipboard|clipboardall|comspec|errorlevel|programfiles)\b/i,
      builtin: /\b(?:abs|acos|asc|asin|atan|ceil|chr|class|comobjactive|comobjarray|comobjconnect|comobjcreate|comobjerror|comobjflags|comobjget|comobjquery|comobjtype|comobjvalue|cos|dllcall|exp|fileexist|Fileopen|floor|format|il_add|il_create|il_destroy|instr|isfunc|islabel|IsObject|ln|log|ltrim|lv_add|lv_delete|lv_deletecol|lv_getcount|lv_getnext|lv_gettext|lv_insert|lv_insertcol|lv_modify|lv_modifycol|lv_setimagelist|mod|numget|numput|onmessage|regexmatch|regexreplace|registercallback|round|rtrim|sb_seticon|sb_setparts|sb_settext|sin|sqrt|strlen|strreplace|strsplit|substr|tan|tv_add|tv_delete|tv_get|tv_getchild|tv_getcount|tv_getnext|tv_getparent|tv_getprev|tv_getselection|tv_gettext|tv_modify|varsetcapacity|winactive|winexist|__Call|__Get|__New|__Set)\b/i,
      symbol: /\b(?:alt|altdown|altup|appskey|backspace|browser_back|browser_favorites|browser_forward|browser_home|browser_refresh|browser_search|browser_stop|bs|capslock|ctrl|ctrlbreak|ctrldown|ctrlup|del|delete|down|end|enter|esc|escape|f1|f10|f11|f12|f13|f14|f15|f16|f17|f18|f19|f2|f20|f21|f22|f23|f24|f3|f4|f5|f6|f7|f8|f9|home|ins|insert|joy1|joy10|joy11|joy12|joy13|joy14|joy15|joy16|joy17|joy18|joy19|joy2|joy20|joy21|joy22|joy23|joy24|joy25|joy26|joy27|joy28|joy29|joy3|joy30|joy31|joy32|joy4|joy5|joy6|joy7|joy8|joy9|joyaxes|joybuttons|joyinfo|joyname|joypov|joyr|joyu|joyv|joyx|joyy|joyz|lalt|launch_app1|launch_app2|launch_mail|launch_media|lbutton|lcontrol|lctrl|left|lshift|lwin|lwindown|lwinup|mbutton|media_next|media_play_pause|media_prev|media_stop|numlock|numpad0|numpad1|numpad2|numpad3|numpad4|numpad5|numpad6|numpad7|numpad8|numpad9|numpadadd|numpadclear|numpaddel|numpaddiv|numpaddot|numpaddown|numpadend|numpadenter|numpadhome|numpadins|numpadleft|numpadmult|numpadpgdn|numpadpgup|numpadright|numpadsub|numpadup|pgdn|pgup|printscreen|ralt|rbutton|rcontrol|rctrl|right|rshift|rwin|rwindown|rwinup|scrolllock|shift|shiftdown|shiftup|space|tab|up|volume_down|volume_mute|volume_up|wheeldown|wheelleft|wheelright|wheelup|xbutton1|xbutton2)\b/i,
      important: /#\b(?:AllowSameLineComments|ClipboardTimeout|CommentFlag|DerefChar|ErrorStdOut|EscapeChar|HotkeyInterval|HotkeyModifierTimeout|Hotstring|If|IfTimeout|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Include|IncludeAgain|InputLevel|InstallKeybdHook|InstallMouseHook|KeyHistory|MaxHotkeysPerInterval|MaxMem|MaxThreads|MaxThreadsBuffer|MaxThreadsPerHotkey|MenuMaskKey|NoEnv|NoTrayIcon|Persistent|SingleInstance|UseHook|Warn|WinActivateForce)\b/i,
      keyword: /\b(?:Abort|AboveNormal|Add|ahk_class|ahk_exe|ahk_group|ahk_id|ahk_pid|All|Alnum|Alpha|AltSubmit|AltTab|AltTabAndMenu|AltTabMenu|AltTabMenuDismiss|AlwaysOnTop|AutoSize|Background|BackgroundTrans|BelowNormal|between|BitAnd|BitNot|BitOr|BitShiftLeft|BitShiftRight|BitXOr|Bold|Border|Button|ByRef|Catch|Checkbox|Checked|CheckedGray|Choose|ChooseString|Close|Color|ComboBox|Contains|ControlList|Count|Date|DateTime|Days|DDL|Default|DeleteAll|Delimiter|Deref|Destroy|Digit|Disable|Disabled|DropDownList|Edit|Eject|Else|Enable|Enabled|Error|Exist|Expand|ExStyle|FileSystem|Finally|First|Flash|Float|FloatFast|Focus|Font|for|global|Grid|Group|GroupBox|GuiClose|GuiContextMenu|GuiDropFiles|GuiEscape|GuiSize|Hdr|Hidden|Hide|High|HKCC|HKCR|HKCU|HKEY_CLASSES_ROOT|HKEY_CURRENT_CONFIG|HKEY_CURRENT_USER|HKEY_LOCAL_MACHINE|HKEY_USERS|HKLM|HKU|Hours|HScroll|Icon|IconSmall|ID|IDLast|If|IfEqual|IfExist|IfGreater|IfGreaterOrEqual|IfInString|IfLess|IfLessOrEqual|IfMsgBox|IfNotEqual|IfNotExist|IfNotInString|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Ignore|ImageList|in|Integer|IntegerFast|Interrupt|is|italic|Join|Label|LastFound|LastFoundExist|Limit|Lines|List|ListBox|ListView|local|Lock|Logoff|Low|Lower|Lowercase|MainWindow|Margin|Maximize|MaximizeBox|MaxSize|Minimize|MinimizeBox|MinMax|MinSize|Minutes|MonthCal|Mouse|Move|Multi|NA|No|NoActivate|NoDefault|NoHide|NoIcon|NoMainWindow|norm|Normal|NoSort|NoSortHdr|NoStandard|Not|NoTab|NoTimers|Number|Off|Ok|On|OwnDialogs|Owner|Parse|Password|Picture|Pixel|Pos|Pow|Priority|ProcessName|Radio|Range|Read|ReadOnly|Realtime|Redraw|Region|REG_BINARY|REG_DWORD|REG_EXPAND_SZ|REG_MULTI_SZ|REG_SZ|Relative|Rename|Report|Resize|Restore|Retry|RGB|Screen|Seconds|Section|Serial|SetLabel|ShiftAltTab|Show|Single|Slider|SortDesc|Standard|static|Status|StatusBar|StatusCD|strike|Style|Submit|SysMenu|Tab2|TabStop|Text|Theme|Throw|Tile|ToggleCheck|ToggleEnable|ToolWindow|Top|Topmost|TransColor|Transparent|Tray|TreeView|Try|TryAgain|Type|UnCheck|underline|Unicode|Unlock|Until|UpDown|Upper|Uppercase|UseErrorLevel|Vis|VisFirst|Visible|VScroll|Wait|WaitClose|WantCtrlA|WantF2|WantReturn|While|Wrap|Xdigit|xm|xp|xs|Yes|ym|yp|ys)\b/i,
      function: /[^(); \t,\n+*\-=?>:\\\/<&%\[\]]+(?=\()/,
      punctuation: /[{}[\]():,]/
    };
  }
  return autohotkey_1;
}
var autoit_1, hasRequiredAutoit;
function requireAutoit() {
  if (hasRequiredAutoit) return autoit_1;
  hasRequiredAutoit = 1, autoit_1 = e, e.displayName = "autoit", e.aliases = [];
  function e(t) {
    t.languages.autoit = {
      comment: [/;.*/, {
        // The multi-line comments delimiters can actually be commented out with ";"
        pattern: /(^[\t ]*)#(?:comments-start|cs)[\s\S]*?^[ \t]*#(?:ce|comments-end)/m,
        lookbehind: !0
      }],
      url: {
        pattern: /(^[\t ]*#include\s+)(?:<[^\r\n>]+>|"[^\r\n"]+")/m,
        lookbehind: !0
      },
      string: {
        pattern: /(["'])(?:\1\1|(?!\1)[^\r\n])*\1/,
        greedy: !0,
        inside: {
          variable: /([%$@])\w+\1/
        }
      },
      directive: {
        pattern: /(^[\t ]*)#[\w-]+/m,
        lookbehind: !0,
        alias: "keyword"
      },
      function: /\b\w+(?=\()/,
      // Variables and macros
      variable: /[$@]\w+/,
      keyword: /\b(?:Case|Const|Continue(?:Case|Loop)|Default|Dim|Do|Else(?:If)?|End(?:Func|If|Select|Switch|With)|Enum|Exit(?:Loop)?|For|Func|Global|If|In|Local|Next|Null|ReDim|Select|Static|Step|Switch|Then|To|Until|Volatile|WEnd|While|With)\b/i,
      number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,
      boolean: /\b(?:False|True)\b/i,
      operator: /<[=>]?|[-+*\/=&>]=?|[?^]|\b(?:And|Not|Or)\b/i,
      punctuation: /[\[\]().,:]/
    };
  }
  return autoit_1;
}
var avisynth_1, hasRequiredAvisynth;
function requireAvisynth() {
  if (hasRequiredAvisynth) return avisynth_1;
  hasRequiredAvisynth = 1, avisynth_1 = e, e.displayName = "avisynth", e.aliases = ["avs"];
  function e(t) {
    (function(r) {
      function a(_, y) {
        return _.replace(/<<(\d+)>>/g, function(A, E) {
          return y[+E];
        });
      }
      function o(_, y, A) {
        return RegExp(a(_, y), A);
      }
      var u = /bool|clip|float|int|string|val/.source, c = [
        // bools
        /is(?:bool|clip|float|int|string)|defined|(?:(?:internal)?function|var)?exists?/.source,
        // control
        /apply|assert|default|eval|import|nop|select|undefined/.source,
        // global
        /opt_(?:allowfloataudio|avipadscanlines|dwchannelmask|enable_(?:b64a|planartopackedrgb|v210|y3_10_10|y3_10_16)|usewaveextensible|vdubplanarhack)|set(?:cachemode|maxcpu|memorymax|planarlegacyalignment|workingdir)/.source,
        // conv
        /hex(?:value)?|value/.source,
        // numeric
        /abs|ceil|continued(?:denominator|numerator)?|exp|floor|fmod|frac|log(?:10)?|max|min|muldiv|pi|pow|rand|round|sign|spline|sqrt/.source,
        // trig
        /a?sinh?|a?cosh?|a?tan[2h]?/.source,
        // bit
        /(?:bit(?:and|not|x?or|[lr]?shift[aslu]?|sh[lr]|sa[lr]|[lr]rotatel?|ro[rl]|te?st|set(?:count)?|cl(?:ea)?r|ch(?:an)?ge?))/.source,
        // runtime
        /average(?:[bgr]|chroma[uv]|luma)|(?:[rgb]|chroma[uv]|luma|rgb|[yuv](?=difference(?:fromprevious|tonext)))difference(?:fromprevious|tonext)?|[yuvrgb]plane(?:median|min|max|minmaxdifference)/.source,
        // script
        /getprocessinfo|logmsg|script(?:dir(?:utf8)?|file(?:utf8)?|name(?:utf8)?)|setlogparams/.source,
        // string
        /chr|(?:fill|find|left|mid|replace|rev|right)str|format|[lu]case|ord|str(?:cmpi?|fromutf8|len|toutf8)|time|trim(?:all|left|right)/.source,
        // version
        /isversionorgreater|version(?:number|string)/.source,
        // helper
        /buildpixeltype|colorspacenametopixeltype/.source,
        // avsplus
        /addautoloaddir|on(?:cpu|cuda)|prefetch|setfiltermtmode/.source
      ].join("|"), d = [
        // content
        /has(?:audio|video)/.source,
        // resolution
        /height|width/.source,
        // framerate
        /frame(?:count|rate)|framerate(?:denominator|numerator)/.source,
        // interlacing
        /getparity|is(?:field|frame)based/.source,
        // color format
        /bitspercomponent|componentsize|hasalpha|is(?:planar(?:rgba?)?|interleaved|rgb(?:24|32|48|64)?|y(?:8|u(?:va?|y2))?|yv(?:12|16|24|411)|420|422|444|packedrgb)|numcomponents|pixeltype/.source,
        // audio
        /audio(?:bits|channels|duration|length(?:[fs]|hi|lo)?|rate)|isaudio(?:float|int)/.source
      ].join("|"), g = [
        // source
        /avi(?:file)?source|directshowsource|image(?:reader|source|sourceanim)|opendmlsource|segmented(?:avisource|directshowsource)|wavsource/.source,
        // color
        /coloryuv|convertbacktoyuy2|convertto(?:RGB(?:24|32|48|64)|(?:planar)?RGBA?|Y8?|YV(?:12|16|24|411)|YUVA?(?:411|420|422|444)|YUY2)|fixluminance|gr[ae]yscale|invert|levels|limiter|mergea?rgb|merge(?:chroma|luma)|rgbadjust|show(?:alpha|blue|green|red)|swapuv|tweak|[uv]toy8?|ytouv/.source,
        // overlay
        /(?:colorkey|reset)mask|layer|mask(?:hs)?|merge|overlay|subtract/.source,
        // geometry
        /addborders|(?:bicubic|bilinear|blackman|gauss|lanczos4|lanczos|point|sinc|spline(?:16|36|64))resize|crop(?:bottom)?|flip(?:horizontal|vertical)|(?:horizontal|vertical)?reduceby2|letterbox|skewrows|turn(?:180|left|right)/.source,
        // pixel
        /blur|fixbrokenchromaupsampling|generalconvolution|(?:spatial|temporal)soften|sharpen/.source,
        // timeline
        /trim|(?:un)?alignedsplice|(?:assume|assumescaled|change|convert)FPS|(?:delete|duplicate)frame|dissolve|fade(?:in|io|out)[02]?|freezeframe|interleave|loop|reverse|select(?:even|odd|(?:range)?every)/.source,
        // interlace
        /assume[bt]ff|assume(?:field|frame)based|bob|complementparity|doubleweave|peculiarblend|pulldown|separate(?:columns|fields|rows)|swapfields|weave(?:columns|rows)?/.source,
        // audio
        /amplify(?:db)?|assumesamplerate|audiodub(?:ex)?|audiotrim|convertaudioto(?:(?:8|16|24|32)bit|float)|converttomono|delayaudio|ensurevbrmp3sync|get(?:left|right)?channel|kill(?:audio|video)|mergechannels|mixaudio|monotostereo|normalize|resampleaudio|ssrc|supereq|timestretch/.source,
        // conditional
        /animate|applyrange|conditional(?:filter|reader|select)|frameevaluate|scriptclip|tcp(?:server|source)|writefile(?:end|if|start)?/.source,
        // export
        /imagewriter/.source,
        // debug
        /blackness|blankclip|colorbars(?:hd)?|compare|dumpfiltergraph|echo|histogram|info|messageclip|preroll|setgraphanalysis|show(?:framenumber|smpte|time)|showfiveversions|stack(?:horizontal|vertical)|subtitle|tone|version/.source
      ].join("|"), b = [c, d, g].join("|");
      r.languages.avisynth = {
        comment: [{
          // Matches [* *] nestable block comments, but only supports 1 level of nested comments
          // /\[\*(?:[^\[*]|\[(?!\*)|\*(?!\])|<self>)*\*\]/
          pattern: /(^|[^\\])\[\*(?:[^\[*]|\[(?!\*)|\*(?!\])|\[\*(?:[^\[*]|\[(?!\*)|\*(?!\]))*\*\])*\*\]/,
          lookbehind: !0,
          greedy: !0
        }, {
          // Matches /* */ block comments
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: !0,
          greedy: !0
        }, {
          // Matches # comments
          pattern: /(^|[^\\$])#.*/,
          lookbehind: !0,
          greedy: !0
        }],
        // Handle before strings because optional arguments are surrounded by double quotes
        argument: {
          pattern: o(/\b(?:<<0>>)\s+("?)\w+\1/.source, [u], "i"),
          inside: {
            keyword: /^\w+/
          }
        },
        // Optional argument assignment
        "argument-label": {
          pattern: /([,(][\s\\]*)\w+\s*=(?!=)/,
          lookbehind: !0,
          inside: {
            "argument-name": {
              pattern: /^\w+/,
              alias: "punctuation"
            },
            punctuation: /=$/
          }
        },
        string: [{
          // triple double-quoted
          pattern: /"""[\s\S]*?"""/,
          greedy: !0
        }, {
          // single double-quoted
          pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
          greedy: !0,
          inside: {
            constant: {
              // These *are* case-sensitive!
              pattern: /\b(?:DEFAULT_MT_MODE|(?:MAINSCRIPT|PROGRAM|SCRIPT)DIR|(?:MACHINE|USER)_(?:CLASSIC|PLUS)_PLUGINS)\b/
            }
          }
        }],
        // The special "last" variable that takes the value of the last implicitly returned clip
        variable: /\b(?:last)\b/i,
        boolean: /\b(?:false|no|true|yes)\b/i,
        keyword: /\b(?:catch|else|for|function|global|if|return|try|while|__END__)\b/i,
        constant: /\bMT_(?:MULTI_INSTANCE|NICE_FILTER|SERIALIZED|SPECIAL_MT)\b/,
        // AviSynth's internal functions, filters, and properties
        "builtin-function": {
          pattern: o(/\b(?:<<0>>)\b/.source, [b], "i"),
          alias: "function"
        },
        "type-cast": {
          pattern: o(/\b(?:<<0>>)(?=\s*\()/.source, [u], "i"),
          alias: "keyword"
        },
        // External/user-defined filters
        function: {
          pattern: /\b[a-z_]\w*(?=\s*\()|(\.)[a-z_]\w*\b/i,
          lookbehind: !0
        },
        // Matches a \ as the first or last character on a line
        "line-continuation": {
          pattern: /(^[ \t]*)\\|\\(?=[ \t]*$)/m,
          lookbehind: !0,
          alias: "punctuation"
        },
        number: /\B\$(?:[\da-f]{6}|[\da-f]{8})\b|(?:(?:\b|\B-)\d+(?:\.\d*)?\b|\B\.\d+\b)/i,
        operator: /\+\+?|[!=<>]=?|&&|\|\||[?:*/%-]/,
        punctuation: /[{}\[\]();,.]/
      }, r.languages.avs = r.languages.avisynth;
    })(t);
  }
  return avisynth_1;
}
var avroIdl_1, hasRequiredAvroIdl;
function requireAvroIdl() {
  if (hasRequiredAvroIdl) return avroIdl_1;
  hasRequiredAvroIdl = 1, avroIdl_1 = e, e.displayName = "avroIdl", e.aliases = [];
  function e(t) {
    t.languages["avro-idl"] = {
      comment: {
        pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
        greedy: !0
      },
      string: {
        pattern: /(^|[^\\])"(?:[^\r\n"\\]|\\.)*"/,
        lookbehind: !0,
        greedy: !0
      },
      annotation: {
        pattern: /@(?:[$\w.-]|`[^\r\n`]+`)+/,
        greedy: !0,
        alias: "function"
      },
      "function-identifier": {
        pattern: /`[^\r\n`]+`(?=\s*\()/,
        greedy: !0,
        alias: "function"
      },
      identifier: {
        pattern: /`[^\r\n`]+`/,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:enum|error|protocol|record|throws)\b\s+)[$\w]+/,
        lookbehind: !0,
        greedy: !0
      },
      keyword: /\b(?:array|boolean|bytes|date|decimal|double|enum|error|false|fixed|float|idl|import|int|local_timestamp_ms|long|map|null|oneway|protocol|record|schema|string|throws|time_ms|timestamp_ms|true|union|uuid|void)\b/,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      number: [{
        pattern: /(^|[^\w.])-?(?:(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|0x(?:[a-f0-9]+(?:\.[a-f0-9]*)?|\.[a-f0-9]+)(?:p[+-]?\d+)?)[dfl]?(?![\w.])/i,
        lookbehind: !0
      }, /-?\b(?:Infinity|NaN)\b/],
      operator: /=/,
      punctuation: /[()\[\]{}<>.:,;-]/
    }, t.languages.avdl = t.languages["avro-idl"];
  }
  return avroIdl_1;
}
var bash_1, hasRequiredBash;
function requireBash() {
  if (hasRequiredBash) return bash_1;
  hasRequiredBash = 1, bash_1 = e, e.displayName = "bash", e.aliases = ["shell"];
  function e(t) {
    (function(r) {
      var a = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b", o = {
        pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
        lookbehind: !0,
        alias: "punctuation",
        // this looks reasonably well in all themes
        inside: null
        // see below
      }, u = {
        bash: o,
        environment: {
          pattern: RegExp("\\$" + a),
          alias: "constant"
        },
        variable: [
          // [0]: Arithmetic Environment
          {
            pattern: /\$?\(\([\s\S]+?\)\)/,
            greedy: !0,
            inside: {
              // If there is a $ sign at the beginning highlight $(( and )) as variable
              variable: [{
                pattern: /(^\$\(\([\s\S]+)\)\)/,
                lookbehind: !0
              }, /^\$\(\(/],
              number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
              // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
              operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
              // If there is no $ sign at the beginning highlight (( and )) as punctuation
              punctuation: /\(\(?|\)\)?|,|;/
            }
          },
          // [1]: Command Substitution
          {
            pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
            greedy: !0,
            inside: {
              variable: /^\$\(|^`|\)$|`$/
            }
          },
          // [2]: Brace expansion
          {
            pattern: /\$\{[^}]+\}/,
            greedy: !0,
            inside: {
              operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
              punctuation: /[\[\]]/,
              environment: {
                pattern: RegExp("(\\{)" + a),
                lookbehind: !0,
                alias: "constant"
              }
            }
          },
          /\$(?:\w+|[#?*!@$])/
        ],
        // Escape sequences from echo and printf's manuals, and escaped quotes.
        entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
      };
      r.languages.bash = {
        shebang: {
          pattern: /^#!\s*\/.*/,
          alias: "important"
        },
        comment: {
          pattern: /(^|[^"{\\$])#.*/,
          lookbehind: !0
        },
        "function-name": [
          // a) function foo {
          // b) foo() {
          // c) function foo() {
          // but not foo {
          {
            // a) and c)
            pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
            lookbehind: !0,
            alias: "function"
          },
          {
            // b)
            pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
            alias: "function"
          }
        ],
        // Highlight variable names as variables in for and select beginnings.
        "for-or-select": {
          pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
          alias: "variable",
          lookbehind: !0
        },
        // Highlight variable names as variables in the left-hand part
        // of assignments (= and +=).
        "assign-left": {
          pattern: /(^|[\s;|&]|[<>]\()\w+(?=\+?=)/,
          inside: {
            environment: {
              pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + a),
              lookbehind: !0,
              alias: "constant"
            }
          },
          alias: "variable",
          lookbehind: !0
        },
        string: [
          // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
          {
            pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
            lookbehind: !0,
            greedy: !0,
            inside: u
          },
          // Here-document with quotes around the tag
          //  No expansion (so no inside).
          {
            pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
            lookbehind: !0,
            greedy: !0,
            inside: {
              bash: o
            }
          },
          // Normal string
          {
            // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
            pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
            lookbehind: !0,
            greedy: !0,
            inside: u
          },
          {
            // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
            pattern: /(^|[^$\\])'[^']*'/,
            lookbehind: !0,
            greedy: !0
          },
          {
            // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
            pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
            greedy: !0,
            inside: {
              entity: u.entity
            }
          }
        ],
        environment: {
          pattern: RegExp("\\$?" + a),
          alias: "constant"
        },
        variable: u.variable,
        function: {
          pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
          lookbehind: !0
        },
        keyword: {
          pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
          lookbehind: !0
        },
        // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
        builtin: {
          pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
          lookbehind: !0,
          // Alias added to make those easier to distinguish from strings.
          alias: "class-name"
        },
        boolean: {
          pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
          lookbehind: !0
        },
        "file-descriptor": {
          pattern: /\B&\d\b/,
          alias: "important"
        },
        operator: {
          // Lots of redirections here, but not just that.
          pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
          inside: {
            "file-descriptor": {
              pattern: /^\d/,
              alias: "important"
            }
          }
        },
        punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
        number: {
          pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
          lookbehind: !0
        }
      }, o.inside = r.languages.bash;
      for (var c = ["comment", "function-name", "for-or-select", "assign-left", "string", "environment", "function", "keyword", "builtin", "boolean", "file-descriptor", "operator", "punctuation", "number"], d = u.variable[1].inside, g = 0; g < c.length; g++)
        d[c[g]] = r.languages.bash[c[g]];
      r.languages.shell = r.languages.bash;
    })(t);
  }
  return bash_1;
}
var basic_1, hasRequiredBasic;
function requireBasic() {
  if (hasRequiredBasic) return basic_1;
  hasRequiredBasic = 1, basic_1 = e, e.displayName = "basic", e.aliases = [];
  function e(t) {
    t.languages.basic = {
      comment: {
        pattern: /(?:!|REM\b).+/i,
        inside: {
          keyword: /^REM/i
        }
      },
      string: {
        pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
        greedy: !0
      },
      number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
      keyword: /\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SELECT CASE|SHARED|SHELL|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\$|\b)/i,
      function: /\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\$|\b)/i,
      operator: /<[=>]?|>=?|[+\-*\/^=&]|\b(?:AND|EQV|IMP|NOT|OR|XOR)\b/i,
      punctuation: /[,;:()]/
    };
  }
  return basic_1;
}
var batch_1, hasRequiredBatch;
function requireBatch() {
  if (hasRequiredBatch) return batch_1;
  hasRequiredBatch = 1, batch_1 = e, e.displayName = "batch", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = /%%?[~:\w]+%?|!\S+!/, o = {
        pattern: /\/[a-z?]+(?=[ :]|$):?|-[a-z]\b|--[a-z-]+\b/im,
        alias: "attr-name",
        inside: {
          punctuation: /:/
        }
      }, u = /"(?:[\\"]"|[^"])*"(?!")/, c = /(?:\b|-)\d+\b/;
      r.languages.batch = {
        comment: [/^::.*/m, {
          pattern: /((?:^|[&(])[ \t]*)rem\b(?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
          lookbehind: !0
        }],
        label: {
          pattern: /^:.*/m,
          alias: "property"
        },
        command: [{
          // FOR command
          pattern: /((?:^|[&(])[ \t]*)for(?: \/[a-z?](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* \S+ in \([^)]+\) do/im,
          lookbehind: !0,
          inside: {
            keyword: /\b(?:do|in)\b|^for\b/i,
            string: u,
            parameter: o,
            variable: a,
            number: c,
            punctuation: /[()',]/
          }
        }, {
          // IF command
          pattern: /((?:^|[&(])[ \t]*)if(?: \/[a-z?](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* (?:not )?(?:cmdextversion \d+|defined \w+|errorlevel \d+|exist \S+|(?:"[^"]*"|(?!")(?:(?!==)\S)+)?(?:==| (?:equ|geq|gtr|leq|lss|neq) )(?:"[^"]*"|[^\s"]\S*))/im,
          lookbehind: !0,
          inside: {
            keyword: /\b(?:cmdextversion|defined|errorlevel|exist|not)\b|^if\b/i,
            string: u,
            parameter: o,
            variable: a,
            number: c,
            operator: /\^|==|\b(?:equ|geq|gtr|leq|lss|neq)\b/i
          }
        }, {
          // ELSE command
          pattern: /((?:^|[&()])[ \t]*)else\b/im,
          lookbehind: !0,
          inside: {
            keyword: /^else\b/i
          }
        }, {
          // SET command
          pattern: /((?:^|[&(])[ \t]*)set(?: \/[a-z](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* (?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
          lookbehind: !0,
          inside: {
            keyword: /^set\b/i,
            string: u,
            parameter: o,
            variable: [a, /\w+(?=(?:[*\/%+\-&^|]|<<|>>)?=)/],
            number: c,
            operator: /[*\/%+\-&^|]=?|<<=?|>>=?|[!~_=]/,
            punctuation: /[()',]/
          }
        }, {
          // Other commands
          pattern: /((?:^|[&(])[ \t]*@?)\w+\b(?:"(?:[\\"]"|[^"])*"(?!")|[^"^&)\r\n]|\^(?:\r\n|[\s\S]))*/m,
          lookbehind: !0,
          inside: {
            keyword: /^\w+\b/,
            string: u,
            parameter: o,
            label: {
              pattern: /(^\s*):\S+/m,
              lookbehind: !0,
              alias: "property"
            },
            variable: a,
            number: c,
            operator: /\^/
          }
        }],
        operator: /[&@]/,
        punctuation: /[()']/
      };
    })(t);
  }
  return batch_1;
}
var bbcode_1, hasRequiredBbcode;
function requireBbcode() {
  if (hasRequiredBbcode) return bbcode_1;
  hasRequiredBbcode = 1, bbcode_1 = e, e.displayName = "bbcode", e.aliases = ["shortcode"];
  function e(t) {
    t.languages.bbcode = {
      tag: {
        pattern: /\[\/?[^\s=\]]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+))?(?:\s+[^\s=\]]+\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+))*\s*\]/,
        inside: {
          tag: {
            pattern: /^\[\/?[^\s=\]]+/,
            inside: {
              punctuation: /^\[\/?/
            }
          },
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+)/,
            inside: {
              punctuation: [/^=/, {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: !0
              }]
            }
          },
          punctuation: /\]/,
          "attr-name": /[^\s=\]]+/
        }
      }
    }, t.languages.shortcode = t.languages.bbcode;
  }
  return bbcode_1;
}
var bicep_1, hasRequiredBicep;
function requireBicep() {
  if (hasRequiredBicep) return bicep_1;
  hasRequiredBicep = 1, bicep_1 = e, e.displayName = "bicep", e.aliases = [];
  function e(t) {
    t.languages.bicep = {
      comment: [{
        // multiline comments eg /* ASDF */
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        greedy: !0
      }, {
        // singleline comments eg // ASDF
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }],
      property: [{
        pattern: /([\r\n][ \t]*)[a-z_]\w*(?=[ \t]*:)/i,
        lookbehind: !0
      }, {
        pattern: /([\r\n][ \t]*)'(?:\\.|\$(?!\{)|[^'\\\r\n$])*'(?=[ \t]*:)/,
        lookbehind: !0,
        greedy: !0
      }],
      string: [{
        pattern: /'''[^'][\s\S]*?'''/,
        greedy: !0
      }, {
        pattern: /(^|[^\\'])'(?:\\.|\$(?!\{)|[^'\\\r\n$])*'/,
        lookbehind: !0,
        greedy: !0
      }],
      "interpolated-string": {
        pattern: /(^|[^\\'])'(?:\\.|\$(?:(?!\{)|\{[^{}\r\n]*\})|[^'\\\r\n$])*'/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /\$\{[^{}\r\n]*\}/,
            inside: {
              expression: {
                pattern: /(^\$\{)[\s\S]+(?=\}$)/,
                lookbehind: !0
              },
              punctuation: /^\$\{|\}$/
            }
          },
          string: /[\s\S]+/
        }
      },
      datatype: {
        pattern: /(\b(?:output|param)\b[ \t]+\w+[ \t]+)\w+\b/,
        lookbehind: !0,
        alias: "class-name"
      },
      boolean: /\b(?:false|true)\b/,
      // https://github.com/Azure/bicep/blob/114a3251b4e6e30082a58729f19a8cc4e374ffa6/src/textmate/bicep.tmlanguage#L184
      keyword: /\b(?:existing|for|if|in|module|null|output|param|resource|targetScope|var)\b/,
      decorator: /@\w+\b/,
      function: /\b[a-z_]\w*(?=[ \t]*\()/i,
      number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
      operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/,
      punctuation: /[{}[\];(),.:]/
    }, t.languages.bicep["interpolated-string"].inside.interpolation.inside.expression.inside = t.languages.bicep;
  }
  return bicep_1;
}
var birb_1, hasRequiredBirb;
function requireBirb() {
  if (hasRequiredBirb) return birb_1;
  hasRequiredBirb = 1, birb_1 = e, e.displayName = "birb", e.aliases = [];
  function e(t) {
    t.languages.birb = t.languages.extend("clike", {
      string: {
        pattern: /r?("|')(?:\\.|(?!\1)[^\\])*\1/,
        greedy: !0
      },
      "class-name": [
        /\b[A-Z](?:[\d_]*[a-zA-Z]\w*)?\b/,
        // matches variable and function return types (parameters as well).
        /\b(?:[A-Z]\w*|(?!(?:var|void)\b)[a-z]\w*)(?=\s+\w+\s*[;,=()])/
      ],
      keyword: /\b(?:assert|break|case|class|const|default|else|enum|final|follows|for|grab|if|nest|new|next|noSeeb|return|static|switch|throw|var|void|while)\b/,
      operator: /\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?|:/,
      variable: /\b[a-z_]\w*\b/
    }), t.languages.insertBefore("birb", "function", {
      metadata: {
        pattern: /<\w+>/,
        greedy: !0,
        alias: "symbol"
      }
    });
  }
  return birb_1;
}
var bison_1, hasRequiredBison;
function requireBison() {
  if (hasRequiredBison) return bison_1;
  hasRequiredBison = 1;
  var e = requireC();
  bison_1 = t, t.displayName = "bison", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.bison = r.languages.extend("c", {}), r.languages.insertBefore("bison", "comment", {
      bison: {
        // This should match all the beginning of the file
        // including the prologue(s), the bison declarations and
        // the grammar rules.
        pattern: /^(?:[^%]|%(?!%))*%%[\s\S]*?%%/,
        inside: {
          c: {
            // Allow for one level of nested braces
            pattern: /%\{[\s\S]*?%\}|\{(?:\{[^}]*\}|[^{}])*\}/,
            inside: {
              delimiter: {
                pattern: /^%?\{|%?\}$/,
                alias: "punctuation"
              },
              "bison-variable": {
                pattern: /[$@](?:<[^\s>]+>)?[\w$]+/,
                alias: "variable",
                inside: {
                  punctuation: /<|>/
                }
              },
              rest: r.languages.c
            }
          },
          comment: r.languages.c.comment,
          string: r.languages.c.string,
          property: /\S+(?=:)/,
          keyword: /%\w+/,
          number: {
            pattern: /(^|[^@])\b(?:0x[\da-f]+|\d+)/i,
            lookbehind: !0
          },
          punctuation: /%[%?]|[|:;\[\]<>]/
        }
      }
    });
  }
  return bison_1;
}
var bnf_1, hasRequiredBnf;
function requireBnf() {
  if (hasRequiredBnf) return bnf_1;
  hasRequiredBnf = 1, bnf_1 = e, e.displayName = "bnf", e.aliases = ["rbnf"];
  function e(t) {
    t.languages.bnf = {
      string: {
        pattern: /"[^\r\n"]*"|'[^\r\n']*'/
      },
      definition: {
        pattern: /<[^<>\r\n\t]+>(?=\s*::=)/,
        alias: ["rule", "keyword"],
        inside: {
          punctuation: /^<|>$/
        }
      },
      rule: {
        pattern: /<[^<>\r\n\t]+>/,
        inside: {
          punctuation: /^<|>$/
        }
      },
      operator: /::=|[|()[\]{}*+?]|\.{3}/
    }, t.languages.rbnf = t.languages.bnf;
  }
  return bnf_1;
}
var brainfuck_1, hasRequiredBrainfuck;
function requireBrainfuck() {
  if (hasRequiredBrainfuck) return brainfuck_1;
  hasRequiredBrainfuck = 1, brainfuck_1 = e, e.displayName = "brainfuck", e.aliases = [];
  function e(t) {
    t.languages.brainfuck = {
      pointer: {
        pattern: /<|>/,
        alias: "keyword"
      },
      increment: {
        pattern: /\+/,
        alias: "inserted"
      },
      decrement: {
        pattern: /-/,
        alias: "deleted"
      },
      branching: {
        pattern: /\[|\]/,
        alias: "important"
      },
      operator: /[.,]/,
      comment: /\S+/
    };
  }
  return brainfuck_1;
}
var brightscript_1, hasRequiredBrightscript;
function requireBrightscript() {
  if (hasRequiredBrightscript) return brightscript_1;
  hasRequiredBrightscript = 1, brightscript_1 = e, e.displayName = "brightscript", e.aliases = [];
  function e(t) {
    t.languages.brightscript = {
      comment: /(?:\brem|').*/i,
      "directive-statement": {
        pattern: /(^[\t ]*)#(?:const|else(?:[\t ]+if)?|end[\t ]+if|error|if).*/im,
        lookbehind: !0,
        alias: "property",
        inside: {
          "error-message": {
            pattern: /(^#error).+/,
            lookbehind: !0
          },
          directive: {
            pattern: /^#(?:const|else(?:[\t ]+if)?|end[\t ]+if|error|if)/,
            alias: "keyword"
          },
          expression: {
            pattern: /[\s\S]+/,
            inside: null
            // see below
          }
        }
      },
      property: {
        pattern: /([\r\n{,][\t ]*)(?:(?!\d)\w+|"(?:[^"\r\n]|"")*"(?!"))(?=[ \t]*:)/,
        lookbehind: !0,
        greedy: !0
      },
      string: {
        pattern: /"(?:[^"\r\n]|"")*"(?!")/,
        greedy: !0
      },
      "class-name": {
        pattern: /(\bAs[\t ]+)\w+/i,
        lookbehind: !0
      },
      keyword: /\b(?:As|Dim|Each|Else|Elseif|End|Exit|For|Function|Goto|If|In|Print|Return|Step|Stop|Sub|Then|To|While)\b/i,
      boolean: /\b(?:false|true)\b/i,
      function: /\b(?!\d)\w+(?=[\t ]*\()/,
      number: /(?:\b\d+(?:\.\d+)?(?:[ed][+-]\d+)?|&h[a-f\d]+)\b[%&!#]?/i,
      operator: /--|\+\+|>>=?|<<=?|<>|[-+*/\\<>]=?|[:^=?]|\b(?:and|mod|not|or)\b/i,
      punctuation: /[.,;()[\]{}]/,
      constant: /\b(?:LINE_NUM)\b/i
    }, t.languages.brightscript["directive-statement"].inside.expression.inside = t.languages.brightscript;
  }
  return brightscript_1;
}
var bro_1, hasRequiredBro;
function requireBro() {
  if (hasRequiredBro) return bro_1;
  hasRequiredBro = 1, bro_1 = e, e.displayName = "bro", e.aliases = [];
  function e(t) {
    t.languages.bro = {
      comment: {
        pattern: /(^|[^\\$])#.*/,
        lookbehind: !0,
        inside: {
          italic: /\b(?:FIXME|TODO|XXX)\b/
        }
      },
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      boolean: /\b[TF]\b/,
      function: {
        pattern: /(\b(?:event|function|hook)[ \t]+)\w+(?:::\w+)?/,
        lookbehind: !0
      },
      builtin: /(?:@(?:load(?:-(?:plugin|sigs))?|unload|prefixes|ifn?def|else|(?:end)?if|DIR|FILENAME))|(?:&?(?:add_func|create_expire|default|delete_func|encrypt|error_handler|expire_func|group|log|mergeable|optional|persistent|priority|raw_output|read_expire|redef|rotate_interval|rotate_size|synchronized|type_column|write_expire))/,
      constant: {
        pattern: /(\bconst[ \t]+)\w+/i,
        lookbehind: !0
      },
      keyword: /\b(?:add|addr|alarm|any|bool|break|const|continue|count|delete|double|else|enum|event|export|file|for|function|global|hook|if|in|int|interval|local|module|next|of|opaque|pattern|port|print|record|return|schedule|set|string|subnet|table|time|timeout|using|vector|when)\b/,
      operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&|\|\|?|\?|\*|\/|~|\^|%/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      punctuation: /[{}[\];(),.:]/
    };
  }
  return bro_1;
}
var bsl_1, hasRequiredBsl;
function requireBsl() {
  if (hasRequiredBsl) return bsl_1;
  hasRequiredBsl = 1, bsl_1 = e, e.displayName = "bsl", e.aliases = [];
  function e(t) {
    t.languages.bsl = {
      comment: /\/\/.*/,
      string: [
        // 
        // Strings
        {
          pattern: /"(?:[^"]|"")*"(?!")/,
          greedy: !0
        },
        //   
        // Date & time
        {
          pattern: /'(?:[^'\r\n\\]|\\.)*'/
        }
      ],
      keyword: [{
        // RU
        pattern: /(^|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:|||||||||||||||||||||||||||||)(?![\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])/i,
        lookbehind: !0
      }, {
        // EN
        pattern: /\b(?:break|do|each|else|elseif|enddo|endfunction|endif|endprocedure|endtry|except|execute|export|false|for|function|if|in|new|null|procedure|raise|return|then|to|true|try|undefined|val|var|while)\b/i
      }],
      number: {
        pattern: /(^(?=\d)|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:\d+(?:\.\d*)?|\.\d+)(?:E[+-]?\d+)?/i,
        lookbehind: !0
      },
      operator: [
        /[<>+\-*/]=?|[%=]/,
        // RU
        {
          pattern: /(^|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:||)(?![\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])/i,
          lookbehind: !0
        },
        // EN
        {
          pattern: /\b(?:and|not|or)\b/i
        }
      ],
      punctuation: /\(\.|\.\)|[()\[\]:;,.]/,
      directive: [
        //    &, &, ...
        // Preprocessor tags of the type &Client, &Server, ...
        {
          pattern: /^([ \t]*)&.*/m,
          lookbehind: !0,
          greedy: !0,
          alias: "important"
        },
        //   :
        // #  
        // ...
        // #
        // Preprocessor instructions of the form:
        // #If Server Then
        // ...
        // #EndIf
        {
          pattern: /^([ \t]*)#.*/gm,
          lookbehind: !0,
          greedy: !0,
          alias: "important"
        }
      ]
    }, t.languages.oscript = t.languages.bsl;
  }
  return bsl_1;
}
var cfscript_1, hasRequiredCfscript;
function requireCfscript() {
  if (hasRequiredCfscript) return cfscript_1;
  hasRequiredCfscript = 1, cfscript_1 = e, e.displayName = "cfscript", e.aliases = [];
  function e(t) {
    t.languages.cfscript = t.languages.extend("clike", {
      comment: [{
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        inside: {
          annotation: {
            pattern: /(?:^|[^.])@[\w\.]+/,
            alias: "punctuation"
          }
        }
      }, {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }],
      keyword: /\b(?:abstract|break|catch|component|continue|default|do|else|extends|final|finally|for|function|if|in|include|package|private|property|public|remote|required|rethrow|return|static|switch|throw|try|var|while|xml)\b(?!\s*=)/,
      operator: [/\+\+|--|&&|\|\||::|=>|[!=]==|<=?|>=?|[-+*/%&|^!=<>]=?|\?(?:\.|:)?|[?:]/, /\b(?:and|contains|eq|equal|eqv|gt|gte|imp|is|lt|lte|mod|not|or|xor)\b/],
      scope: {
        pattern: /\b(?:application|arguments|cgi|client|cookie|local|session|super|this|variables)\b/,
        alias: "global"
      },
      type: {
        pattern: /\b(?:any|array|binary|boolean|date|guid|numeric|query|string|struct|uuid|void|xml)\b/,
        alias: "builtin"
      }
    }), t.languages.insertBefore("cfscript", "keyword", {
      // This must be declared before keyword because we use "function" inside the lookahead
      "function-variable": {
        pattern: /[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      }
    }), delete t.languages.cfscript["class-name"], t.languages.cfc = t.languages.cfscript;
  }
  return cfscript_1;
}
var chaiscript_1, hasRequiredChaiscript;
function requireChaiscript() {
  if (hasRequiredChaiscript) return chaiscript_1;
  hasRequiredChaiscript = 1;
  var e = requireCpp();
  chaiscript_1 = t, t.displayName = "chaiscript", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.chaiscript = r.languages.extend("clike", {
      string: {
        pattern: /(^|[^\\])'(?:[^'\\]|\\[\s\S])*'/,
        lookbehind: !0,
        greedy: !0
      },
      "class-name": [{
        // e.g. class Rectangle { ... }
        pattern: /(\bclass\s+)\w+/,
        lookbehind: !0
      }, {
        // e.g. attr Rectangle::height, def Rectangle::area() { ... }
        pattern: /(\b(?:attr|def)\s+)\w+(?=\s*::)/,
        lookbehind: !0
      }],
      keyword: /\b(?:attr|auto|break|case|catch|class|continue|def|default|else|finally|for|fun|global|if|return|switch|this|try|var|while)\b/,
      number: [r.languages.cpp.number, /\b(?:Infinity|NaN)\b/],
      operator: />>=?|<<=?|\|\||&&|:[:=]?|--|\+\+|[=!<>+\-*/%|&^]=?|[?~]|`[^`\r\n]{1,4}`/
    }), r.languages.insertBefore("chaiscript", "operator", {
      "parameter-type": {
        // e.g. def foo(int x, Vector y) {...}
        pattern: /([,(]\s*)\w+(?=\s+\w)/,
        lookbehind: !0,
        alias: "class-name"
      }
    }), r.languages.insertBefore("chaiscript", "string", {
      "string-interpolation": {
        pattern: /(^|[^\\])"(?:[^"$\\]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*"/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\}/,
            lookbehind: !0,
            inside: {
              "interpolation-expression": {
                pattern: /(^\$\{)[\s\S]+(?=\}$)/,
                lookbehind: !0,
                inside: r.languages.chaiscript
              },
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              }
            }
          },
          string: /[\s\S]+/
        }
      }
    });
  }
  return chaiscript_1;
}
var cil_1, hasRequiredCil;
function requireCil() {
  if (hasRequiredCil) return cil_1;
  hasRequiredCil = 1, cil_1 = e, e.displayName = "cil", e.aliases = [];
  function e(t) {
    t.languages.cil = {
      comment: /\/\/.*/,
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      directive: {
        pattern: /(^|\W)\.[a-z]+(?=\s)/,
        lookbehind: !0,
        alias: "class-name"
      },
      // Actually an assembly reference
      variable: /\[[\w\.]+\]/,
      keyword: /\b(?:abstract|ansi|assembly|auto|autochar|beforefieldinit|bool|bstr|byvalstr|catch|char|cil|class|currency|date|decimal|default|enum|error|explicit|extends|extern|famandassem|family|famorassem|final(?:ly)?|float32|float64|hidebysig|u?int(?:8|16|32|64)?|iant|idispatch|implements|import|initonly|instance|interface|iunknown|literal|lpstr|lpstruct|lptstr|lpwstr|managed|method|native(?:Type)?|nested|newslot|object(?:ref)?|pinvokeimpl|private|privatescope|public|reqsecobj|rtspecialname|runtime|sealed|sequential|serializable|specialname|static|string|struct|syschar|tbstr|unicode|unmanagedexp|unsigned|value(?:type)?|variant|virtual|void)\b/,
      function: /\b(?:(?:constrained|no|readonly|tail|unaligned|volatile)\.)?(?:conv\.(?:[iu][1248]?|ovf\.[iu][1248]?(?:\.un)?|r\.un|r4|r8)|ldc\.(?:i4(?:\.\d+|\.[mM]1|\.s)?|i8|r4|r8)|ldelem(?:\.[iu][1248]?|\.r[48]|\.ref|a)?|ldind\.(?:[iu][1248]?|r[48]|ref)|stelem\.?(?:i[1248]?|r[48]|ref)?|stind\.(?:i[1248]?|r[48]|ref)?|end(?:fault|filter|finally)|ldarg(?:\.[0-3s]|a(?:\.s)?)?|ldloc(?:\.\d+|\.s)?|sub(?:\.ovf(?:\.un)?)?|mul(?:\.ovf(?:\.un)?)?|add(?:\.ovf(?:\.un)?)?|stloc(?:\.[0-3s])?|refany(?:type|val)|blt(?:\.un)?(?:\.s)?|ble(?:\.un)?(?:\.s)?|bgt(?:\.un)?(?:\.s)?|bge(?:\.un)?(?:\.s)?|unbox(?:\.any)?|init(?:blk|obj)|call(?:i|virt)?|brfalse(?:\.s)?|bne\.un(?:\.s)?|ldloca(?:\.s)?|brzero(?:\.s)?|brtrue(?:\.s)?|brnull(?:\.s)?|brinst(?:\.s)?|starg(?:\.s)?|leave(?:\.s)?|shr(?:\.un)?|rem(?:\.un)?|div(?:\.un)?|clt(?:\.un)?|alignment|castclass|ldvirtftn|beq(?:\.s)?|ckfinite|ldsflda|ldtoken|localloc|mkrefany|rethrow|cgt\.un|arglist|switch|stsfld|sizeof|newobj|newarr|ldsfld|ldnull|ldflda|isinst|throw|stobj|stfld|ldstr|ldobj|ldlen|ldftn|ldfld|cpobj|cpblk|break|br\.s|xor|shl|ret|pop|not|nop|neg|jmp|dup|cgt|ceq|box|and|or|br)\b/,
      boolean: /\b(?:false|true)\b/,
      number: /\b-?(?:0x[0-9a-f]+|\d+)(?:\.[0-9a-f]+)?\b/i,
      punctuation: /[{}[\];(),:=]|IL_[0-9A-Za-z]+/
    };
  }
  return cil_1;
}
var clojure_1, hasRequiredClojure;
function requireClojure() {
  if (hasRequiredClojure) return clojure_1;
  hasRequiredClojure = 1, clojure_1 = e, e.displayName = "clojure", e.aliases = [];
  function e(t) {
    t.languages.clojure = {
      comment: {
        pattern: /;.*/,
        greedy: !0
      },
      string: {
        pattern: /"(?:[^"\\]|\\.)*"/,
        greedy: !0
      },
      char: /\\\w+/,
      symbol: {
        pattern: /(^|[\s()\[\]{},])::?[\w*+!?'<>=/.-]+/,
        lookbehind: !0
      },
      keyword: {
        pattern: /(\()(?:-|->|->>|\.|\.\.|\*|\/|\+|<|<=|=|==|>|>=|accessor|agent|agent-errors|aget|alength|all-ns|alter|and|append-child|apply|array-map|aset|aset-boolean|aset-byte|aset-char|aset-double|aset-float|aset-int|aset-long|aset-short|assert|assoc|await|await-for|bean|binding|bit-and|bit-not|bit-or|bit-shift-left|bit-shift-right|bit-xor|boolean|branch\?|butlast|byte|cast|char|children|class|clear-agent-errors|comment|commute|comp|comparator|complement|concat|cond|conj|cons|constantly|construct-proxy|contains\?|count|create-ns|create-struct|cycle|dec|declare|def|def-|definline|definterface|defmacro|defmethod|defmulti|defn|defn-|defonce|defproject|defprotocol|defrecord|defstruct|deftype|deref|difference|disj|dissoc|distinct|do|doall|doc|dorun|doseq|dosync|dotimes|doto|double|down|drop|drop-while|edit|end\?|ensure|eval|every\?|false\?|ffirst|file-seq|filter|find|find-doc|find-ns|find-var|first|float|flush|fn|fnseq|for|frest|gensym|get|get-proxy-class|hash-map|hash-set|identical\?|identity|if|if-let|if-not|import|in-ns|inc|index|insert-child|insert-left|insert-right|inspect-table|inspect-tree|instance\?|int|interleave|intersection|into|into-array|iterate|join|key|keys|keyword|keyword\?|last|lazy-cat|lazy-cons|left|lefts|let|line-seq|list|list\*|load|load-file|locking|long|loop|macroexpand|macroexpand-1|make-array|make-node|map|map-invert|map\?|mapcat|max|max-key|memfn|merge|merge-with|meta|min|min-key|monitor-enter|name|namespace|neg\?|new|newline|next|nil\?|node|not|not-any\?|not-every\?|not=|ns|ns-imports|ns-interns|ns-map|ns-name|ns-publics|ns-refers|ns-resolve|ns-unmap|nth|nthrest|or|parse|partial|path|peek|pop|pos\?|pr|pr-str|print|print-str|println|println-str|prn|prn-str|project|proxy|proxy-mappings|quot|quote|rand|rand-int|range|re-find|re-groups|re-matcher|re-matches|re-pattern|re-seq|read|read-line|recur|reduce|ref|ref-set|refer|rem|remove|remove-method|remove-ns|rename|rename-keys|repeat|replace|replicate|resolve|rest|resultset-seq|reverse|rfirst|right|rights|root|rrest|rseq|second|select|select-keys|send|send-off|seq|seq-zip|seq\?|set|set!|short|slurp|some|sort|sort-by|sorted-map|sorted-map-by|sorted-set|special-symbol\?|split-at|split-with|str|string\?|struct|struct-map|subs|subvec|symbol|symbol\?|sync|take|take-nth|take-while|test|throw|time|to-array|to-array-2d|tree-seq|true\?|try|union|up|update-proxy|val|vals|var|var-get|var-set|var\?|vector|vector-zip|vector\?|when|when-first|when-let|when-not|with-local-vars|with-meta|with-open|with-out-str|xml-seq|xml-zip|zero\?|zipmap|zipper)(?=[\s)]|$)/,
        lookbehind: !0
      },
      boolean: /\b(?:false|nil|true)\b/,
      number: {
        pattern: /(^|[^\w$@])(?:\d+(?:[/.]\d+)?(?:e[+-]?\d+)?|0x[a-f0-9]+|[1-9]\d?r[a-z0-9]+)[lmn]?(?![\w$@])/i,
        lookbehind: !0
      },
      function: {
        pattern: /((?:^|[^'])\()[\w*+!?'<>=/.-]+(?=[\s)]|$)/,
        lookbehind: !0
      },
      operator: /[#@^`~]/,
      punctuation: /[{}\[\](),]/
    };
  }
  return clojure_1;
}
var cmake_1, hasRequiredCmake;
function requireCmake() {
  if (hasRequiredCmake) return cmake_1;
  hasRequiredCmake = 1, cmake_1 = e, e.displayName = "cmake", e.aliases = [];
  function e(t) {
    t.languages.cmake = {
      comment: /#.*/,
      string: {
        pattern: /"(?:[^\\"]|\\.)*"/,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /\$\{(?:[^{}$]|\$\{[^{}$]*\})*\}/,
            inside: {
              punctuation: /\$\{|\}/,
              variable: /\w+/
            }
          }
        }
      },
      variable: /\b(?:CMAKE_\w+|\w+_(?:(?:BINARY|SOURCE)_DIR|DESCRIPTION|HOMEPAGE_URL|ROOT|VERSION(?:_MAJOR|_MINOR|_PATCH|_TWEAK)?)|(?:ANDROID|APPLE|BORLAND|BUILD_SHARED_LIBS|CACHE|CPACK_(?:ABSOLUTE_DESTINATION_FILES|COMPONENT_INCLUDE_TOPLEVEL_DIRECTORY|ERROR_ON_ABSOLUTE_INSTALL_DESTINATION|INCLUDE_TOPLEVEL_DIRECTORY|INSTALL_DEFAULT_DIRECTORY_PERMISSIONS|INSTALL_SCRIPT|PACKAGING_INSTALL_PREFIX|SET_DESTDIR|WARN_ON_ABSOLUTE_INSTALL_DESTINATION)|CTEST_(?:BINARY_DIRECTORY|BUILD_COMMAND|BUILD_NAME|BZR_COMMAND|BZR_UPDATE_OPTIONS|CHANGE_ID|CHECKOUT_COMMAND|CONFIGURATION_TYPE|CONFIGURE_COMMAND|COVERAGE_COMMAND|COVERAGE_EXTRA_FLAGS|CURL_OPTIONS|CUSTOM_(?:COVERAGE_EXCLUDE|ERROR_EXCEPTION|ERROR_MATCH|ERROR_POST_CONTEXT|ERROR_PRE_CONTEXT|MAXIMUM_FAILED_TEST_OUTPUT_SIZE|MAXIMUM_NUMBER_OF_(?:ERRORS|WARNINGS)|MAXIMUM_PASSED_TEST_OUTPUT_SIZE|MEMCHECK_IGNORE|POST_MEMCHECK|POST_TEST|PRE_MEMCHECK|PRE_TEST|TESTS_IGNORE|WARNING_EXCEPTION|WARNING_MATCH)|CVS_CHECKOUT|CVS_COMMAND|CVS_UPDATE_OPTIONS|DROP_LOCATION|DROP_METHOD|DROP_SITE|DROP_SITE_CDASH|DROP_SITE_PASSWORD|DROP_SITE_USER|EXTRA_COVERAGE_GLOB|GIT_COMMAND|GIT_INIT_SUBMODULES|GIT_UPDATE_CUSTOM|GIT_UPDATE_OPTIONS|HG_COMMAND|HG_UPDATE_OPTIONS|LABELS_FOR_SUBPROJECTS|MEMORYCHECK_(?:COMMAND|COMMAND_OPTIONS|SANITIZER_OPTIONS|SUPPRESSIONS_FILE|TYPE)|NIGHTLY_START_TIME|P4_CLIENT|P4_COMMAND|P4_OPTIONS|P4_UPDATE_OPTIONS|RUN_CURRENT_SCRIPT|SCP_COMMAND|SITE|SOURCE_DIRECTORY|SUBMIT_URL|SVN_COMMAND|SVN_OPTIONS|SVN_UPDATE_OPTIONS|TEST_LOAD|TEST_TIMEOUT|TRIGGER_SITE|UPDATE_COMMAND|UPDATE_OPTIONS|UPDATE_VERSION_ONLY|USE_LAUNCHERS)|CYGWIN|ENV|EXECUTABLE_OUTPUT_PATH|GHS-MULTI|IOS|LIBRARY_OUTPUT_PATH|MINGW|MSVC(?:10|11|12|14|60|70|71|80|90|_IDE|_TOOLSET_VERSION|_VERSION)?|MSYS|PROJECT_(?:BINARY_DIR|DESCRIPTION|HOMEPAGE_URL|NAME|SOURCE_DIR|VERSION|VERSION_(?:MAJOR|MINOR|PATCH|TWEAK))|UNIX|WIN32|WINCE|WINDOWS_PHONE|WINDOWS_STORE|XCODE|XCODE_VERSION))\b/,
      property: /\b(?:cxx_\w+|(?:ARCHIVE_OUTPUT_(?:DIRECTORY|NAME)|COMPILE_DEFINITIONS|COMPILE_PDB_NAME|COMPILE_PDB_OUTPUT_DIRECTORY|EXCLUDE_FROM_DEFAULT_BUILD|IMPORTED_(?:IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_LANGUAGES|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|NO_SONAME|OBJECTS|SONAME)|INTERPROCEDURAL_OPTIMIZATION|LIBRARY_OUTPUT_DIRECTORY|LIBRARY_OUTPUT_NAME|LINK_FLAGS|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|MAP_IMPORTED_CONFIG|OSX_ARCHITECTURES|OUTPUT_NAME|PDB_NAME|PDB_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_NAME|STATIC_LIBRARY_FLAGS|VS_CSHARP|VS_DOTNET_REFERENCEPROP|VS_DOTNET_REFERENCE|VS_GLOBAL_SECTION_POST|VS_GLOBAL_SECTION_PRE|VS_GLOBAL|XCODE_ATTRIBUTE)_\w+|\w+_(?:CLANG_TIDY|COMPILER_LAUNCHER|CPPCHECK|CPPLINT|INCLUDE_WHAT_YOU_USE|OUTPUT_NAME|POSTFIX|VISIBILITY_PRESET)|ABSTRACT|ADDITIONAL_MAKE_CLEAN_FILES|ADVANCED|ALIASED_TARGET|ALLOW_DUPLICATE_CUSTOM_TARGETS|ANDROID_(?:ANT_ADDITIONAL_OPTIONS|API|API_MIN|ARCH|ASSETS_DIRECTORIES|GUI|JAR_DEPENDENCIES|NATIVE_LIB_DEPENDENCIES|NATIVE_LIB_DIRECTORIES|PROCESS_MAX|PROGUARD|PROGUARD_CONFIG_PATH|SECURE_PROPS_PATH|SKIP_ANT_STEP|STL_TYPE)|ARCHIVE_OUTPUT_DIRECTORY|ATTACHED_FILES|ATTACHED_FILES_ON_FAIL|AUTOGEN_(?:BUILD_DIR|ORIGIN_DEPENDS|PARALLEL|SOURCE_GROUP|TARGETS_FOLDER|TARGET_DEPENDS)|AUTOMOC|AUTOMOC_(?:COMPILER_PREDEFINES|DEPEND_FILTERS|EXECUTABLE|MACRO_NAMES|MOC_OPTIONS|SOURCE_GROUP|TARGETS_FOLDER)|AUTORCC|AUTORCC_EXECUTABLE|AUTORCC_OPTIONS|AUTORCC_SOURCE_GROUP|AUTOUIC|AUTOUIC_EXECUTABLE|AUTOUIC_OPTIONS|AUTOUIC_SEARCH_PATHS|BINARY_DIR|BUILDSYSTEM_TARGETS|BUILD_RPATH|BUILD_RPATH_USE_ORIGIN|BUILD_WITH_INSTALL_NAME_DIR|BUILD_WITH_INSTALL_RPATH|BUNDLE|BUNDLE_EXTENSION|CACHE_VARIABLES|CLEAN_NO_CUSTOM|COMMON_LANGUAGE_RUNTIME|COMPATIBLE_INTERFACE_(?:BOOL|NUMBER_MAX|NUMBER_MIN|STRING)|COMPILE_(?:DEFINITIONS|FEATURES|FLAGS|OPTIONS|PDB_NAME|PDB_OUTPUT_DIRECTORY)|COST|CPACK_DESKTOP_SHORTCUTS|CPACK_NEVER_OVERWRITE|CPACK_PERMANENT|CPACK_STARTUP_SHORTCUTS|CPACK_START_MENU_SHORTCUTS|CPACK_WIX_ACL|CROSSCOMPILING_EMULATOR|CUDA_EXTENSIONS|CUDA_PTX_COMPILATION|CUDA_RESOLVE_DEVICE_SYMBOLS|CUDA_SEPARABLE_COMPILATION|CUDA_STANDARD|CUDA_STANDARD_REQUIRED|CXX_EXTENSIONS|CXX_STANDARD|CXX_STANDARD_REQUIRED|C_EXTENSIONS|C_STANDARD|C_STANDARD_REQUIRED|DEBUG_CONFIGURATIONS|DEFINE_SYMBOL|DEFINITIONS|DEPENDS|DEPLOYMENT_ADDITIONAL_FILES|DEPLOYMENT_REMOTE_DIRECTORY|DISABLED|DISABLED_FEATURES|ECLIPSE_EXTRA_CPROJECT_CONTENTS|ECLIPSE_EXTRA_NATURES|ENABLED_FEATURES|ENABLED_LANGUAGES|ENABLE_EXPORTS|ENVIRONMENT|EXCLUDE_FROM_ALL|EXCLUDE_FROM_DEFAULT_BUILD|EXPORT_NAME|EXPORT_PROPERTIES|EXTERNAL_OBJECT|EchoString|FAIL_REGULAR_EXPRESSION|FIND_LIBRARY_USE_LIB32_PATHS|FIND_LIBRARY_USE_LIB64_PATHS|FIND_LIBRARY_USE_LIBX32_PATHS|FIND_LIBRARY_USE_OPENBSD_VERSIONING|FIXTURES_CLEANUP|FIXTURES_REQUIRED|FIXTURES_SETUP|FOLDER|FRAMEWORK|Fortran_FORMAT|Fortran_MODULE_DIRECTORY|GENERATED|GENERATOR_FILE_NAME|GENERATOR_IS_MULTI_CONFIG|GHS_INTEGRITY_APP|GHS_NO_SOURCE_GROUP_FILE|GLOBAL_DEPENDS_DEBUG_MODE|GLOBAL_DEPENDS_NO_CYCLES|GNUtoMS|HAS_CXX|HEADER_FILE_ONLY|HELPSTRING|IMPLICIT_DEPENDS_INCLUDE_TRANSFORM|IMPORTED|IMPORTED_(?:COMMON_LANGUAGE_RUNTIME|CONFIGURATIONS|GLOBAL|IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_(?:LANGUAGES|LIBRARIES|MULTIPLICITY)|LOCATION|NO_SONAME|OBJECTS|SONAME)|IMPORT_PREFIX|IMPORT_SUFFIX|INCLUDE_DIRECTORIES|INCLUDE_REGULAR_EXPRESSION|INSTALL_NAME_DIR|INSTALL_RPATH|INSTALL_RPATH_USE_LINK_PATH|INTERFACE_(?:AUTOUIC_OPTIONS|COMPILE_DEFINITIONS|COMPILE_FEATURES|COMPILE_OPTIONS|INCLUDE_DIRECTORIES|LINK_DEPENDS|LINK_DIRECTORIES|LINK_LIBRARIES|LINK_OPTIONS|POSITION_INDEPENDENT_CODE|SOURCES|SYSTEM_INCLUDE_DIRECTORIES)|INTERPROCEDURAL_OPTIMIZATION|IN_TRY_COMPILE|IOS_INSTALL_COMBINED|JOB_POOLS|JOB_POOL_COMPILE|JOB_POOL_LINK|KEEP_EXTENSION|LABELS|LANGUAGE|LIBRARY_OUTPUT_DIRECTORY|LINKER_LANGUAGE|LINK_(?:DEPENDS|DEPENDS_NO_SHARED|DIRECTORIES|FLAGS|INTERFACE_LIBRARIES|INTERFACE_MULTIPLICITY|LIBRARIES|OPTIONS|SEARCH_END_STATIC|SEARCH_START_STATIC|WHAT_YOU_USE)|LISTFILE_STACK|LOCATION|MACOSX_BUNDLE|MACOSX_BUNDLE_INFO_PLIST|MACOSX_FRAMEWORK_INFO_PLIST|MACOSX_PACKAGE_LOCATION|MACOSX_RPATH|MACROS|MANUALLY_ADDED_DEPENDENCIES|MEASUREMENT|MODIFIED|NAME|NO_SONAME|NO_SYSTEM_FROM_IMPORTED|OBJECT_DEPENDS|OBJECT_OUTPUTS|OSX_ARCHITECTURES|OUTPUT_NAME|PACKAGES_FOUND|PACKAGES_NOT_FOUND|PARENT_DIRECTORY|PASS_REGULAR_EXPRESSION|PDB_NAME|PDB_OUTPUT_DIRECTORY|POSITION_INDEPENDENT_CODE|POST_INSTALL_SCRIPT|PREDEFINED_TARGETS_FOLDER|PREFIX|PRE_INSTALL_SCRIPT|PRIVATE_HEADER|PROCESSORS|PROCESSOR_AFFINITY|PROJECT_LABEL|PUBLIC_HEADER|REPORT_UNDEFINED_PROPERTIES|REQUIRED_FILES|RESOURCE|RESOURCE_LOCK|RULE_LAUNCH_COMPILE|RULE_LAUNCH_CUSTOM|RULE_LAUNCH_LINK|RULE_MESSAGES|RUNTIME_OUTPUT_DIRECTORY|RUN_SERIAL|SKIP_AUTOGEN|SKIP_AUTOMOC|SKIP_AUTORCC|SKIP_AUTOUIC|SKIP_BUILD_RPATH|SKIP_RETURN_CODE|SOURCES|SOURCE_DIR|SOVERSION|STATIC_LIBRARY_FLAGS|STATIC_LIBRARY_OPTIONS|STRINGS|SUBDIRECTORIES|SUFFIX|SYMBOLIC|TARGET_ARCHIVES_MAY_BE_SHARED_LIBS|TARGET_MESSAGES|TARGET_SUPPORTS_SHARED_LIBS|TESTS|TEST_INCLUDE_FILE|TEST_INCLUDE_FILES|TIMEOUT|TIMEOUT_AFTER_MATCH|TYPE|USE_FOLDERS|VALUE|VARIABLES|VERSION|VISIBILITY_INLINES_HIDDEN|VS_(?:CONFIGURATION_TYPE|COPY_TO_OUT_DIR|DEBUGGER_(?:COMMAND|COMMAND_ARGUMENTS|ENVIRONMENT|WORKING_DIRECTORY)|DEPLOYMENT_CONTENT|DEPLOYMENT_LOCATION|DOTNET_REFERENCES|DOTNET_REFERENCES_COPY_LOCAL|GLOBAL_KEYWORD|GLOBAL_PROJECT_TYPES|GLOBAL_ROOTNAMESPACE|INCLUDE_IN_VSIX|IOT_STARTUP_TASK|KEYWORD|RESOURCE_GENERATOR|SCC_AUXPATH|SCC_LOCALPATH|SCC_PROJECTNAME|SCC_PROVIDER|SDK_REFERENCES|SHADER_(?:DISABLE_OPTIMIZATIONS|ENABLE_DEBUG|ENTRYPOINT|FLAGS|MODEL|OBJECT_FILE_NAME|OUTPUT_HEADER_FILE|TYPE|VARIABLE_NAME)|STARTUP_PROJECT|TOOL_OVERRIDE|USER_PROPS|WINRT_COMPONENT|WINRT_EXTENSIONS|WINRT_REFERENCES|XAML_TYPE)|WILL_FAIL|WIN32_EXECUTABLE|WINDOWS_EXPORT_ALL_SYMBOLS|WORKING_DIRECTORY|WRAP_EXCLUDE|XCODE_(?:EMIT_EFFECTIVE_PLATFORM_NAME|EXPLICIT_FILE_TYPE|FILE_ATTRIBUTES|LAST_KNOWN_FILE_TYPE|PRODUCT_TYPE|SCHEME_(?:ADDRESS_SANITIZER|ADDRESS_SANITIZER_USE_AFTER_RETURN|ARGUMENTS|DISABLE_MAIN_THREAD_CHECKER|DYNAMIC_LIBRARY_LOADS|DYNAMIC_LINKER_API_USAGE|ENVIRONMENT|EXECUTABLE|GUARD_MALLOC|MAIN_THREAD_CHECKER_STOP|MALLOC_GUARD_EDGES|MALLOC_SCRIBBLE|MALLOC_STACK|THREAD_SANITIZER(?:_STOP)?|UNDEFINED_BEHAVIOUR_SANITIZER(?:_STOP)?|ZOMBIE_OBJECTS))|XCTEST)\b/,
      keyword: /\b(?:add_compile_definitions|add_compile_options|add_custom_command|add_custom_target|add_definitions|add_dependencies|add_executable|add_library|add_link_options|add_subdirectory|add_test|aux_source_directory|break|build_command|build_name|cmake_host_system_information|cmake_minimum_required|cmake_parse_arguments|cmake_policy|configure_file|continue|create_test_sourcelist|ctest_build|ctest_configure|ctest_coverage|ctest_empty_binary_directory|ctest_memcheck|ctest_read_custom_files|ctest_run_script|ctest_sleep|ctest_start|ctest_submit|ctest_test|ctest_update|ctest_upload|define_property|else|elseif|enable_language|enable_testing|endforeach|endfunction|endif|endmacro|endwhile|exec_program|execute_process|export|export_library_dependencies|file|find_file|find_library|find_package|find_path|find_program|fltk_wrap_ui|foreach|function|get_cmake_property|get_directory_property|get_filename_component|get_property|get_source_file_property|get_target_property|get_test_property|if|include|include_directories|include_external_msproject|include_guard|include_regular_expression|install|install_files|install_programs|install_targets|link_directories|link_libraries|list|load_cache|load_command|macro|make_directory|mark_as_advanced|math|message|option|output_required_files|project|qt_wrap_cpp|qt_wrap_ui|remove|remove_definitions|return|separate_arguments|set|set_directory_properties|set_property|set_source_files_properties|set_target_properties|set_tests_properties|site_name|source_group|string|subdir_depends|subdirs|target_compile_definitions|target_compile_features|target_compile_options|target_include_directories|target_link_directories|target_link_libraries|target_link_options|target_sources|try_compile|try_run|unset|use_mangled_mesa|utility_source|variable_requires|variable_watch|while|write_file)(?=\s*\()\b/,
      boolean: /\b(?:FALSE|OFF|ON|TRUE)\b/,
      namespace: /\b(?:INTERFACE|PRIVATE|PROPERTIES|PUBLIC|SHARED|STATIC|TARGET_OBJECTS)\b/,
      operator: /\b(?:AND|DEFINED|EQUAL|GREATER|LESS|MATCHES|NOT|OR|STREQUAL|STRGREATER|STRLESS|VERSION_EQUAL|VERSION_GREATER|VERSION_LESS)\b/,
      inserted: {
        pattern: /\b\w+::\w+\b/,
        alias: "class-name"
      },
      number: /\b\d+(?:\.\d+)*\b/,
      function: /\b[a-z_]\w*(?=\s*\()\b/i,
      punctuation: /[()>}]|\$[<{]/
    };
  }
  return cmake_1;
}
var cobol_1, hasRequiredCobol;
function requireCobol() {
  if (hasRequiredCobol) return cobol_1;
  hasRequiredCobol = 1, cobol_1 = e, e.displayName = "cobol", e.aliases = [];
  function e(t) {
    t.languages.cobol = {
      comment: {
        pattern: /\*>.*|(^[ \t]*)\*.*/m,
        lookbehind: !0,
        greedy: !0
      },
      string: {
        pattern: /[xzgn]?(?:"(?:[^\r\n"]|"")*"(?!")|'(?:[^\r\n']|'')*'(?!'))/i,
        greedy: !0
      },
      level: {
        pattern: /(^[ \t]*)\d+\b/m,
        lookbehind: !0,
        greedy: !0,
        alias: "number"
      },
      "class-name": {
        // https://github.com/antlr/grammars-v4/blob/42edd5b687d183b5fa679e858a82297bd27141e7/cobol85/Cobol85.g4#L1015
        pattern: /(\bpic(?:ture)?\s+)(?:(?:[-\w$/,:*+<>]|\.(?!\s|$))(?:\(\d+\))?)+/i,
        lookbehind: !0,
        inside: {
          number: {
            pattern: /(\()\d+/,
            lookbehind: !0
          },
          punctuation: /[()]/
        }
      },
      keyword: {
        pattern: /(^|[^\w-])(?:ABORT|ACCEPT|ACCESS|ADD|ADDRESS|ADVANCING|AFTER|ALIGNED|ALL|ALPHABET|ALPHABETIC|ALPHABETIC-LOWER|ALPHABETIC-UPPER|ALPHANUMERIC|ALPHANUMERIC-EDITED|ALSO|ALTER|ALTERNATE|ANY|ARE|AREA|AREAS|AS|ASCENDING|ASCII|ASSIGN|ASSOCIATED-DATA|ASSOCIATED-DATA-LENGTH|AT|ATTRIBUTE|AUTHOR|AUTO|AUTO-SKIP|BACKGROUND-COLOR|BACKGROUND-COLOUR|BASIS|BEEP|BEFORE|BEGINNING|BELL|BINARY|BIT|BLANK|BLINK|BLOCK|BOTTOM|BOUNDS|BY|BYFUNCTION|BYTITLE|CALL|CANCEL|CAPABLE|CCSVERSION|CD|CF|CH|CHAINING|CHANGED|CHANNEL|CHARACTER|CHARACTERS|CLASS|CLASS-ID|CLOCK-UNITS|CLOSE|CLOSE-DISPOSITION|COBOL|CODE|CODE-SET|COL|COLLATING|COLUMN|COM-REG|COMMA|COMMITMENT|COMMON|COMMUNICATION|COMP|COMP-1|COMP-2|COMP-3|COMP-4|COMP-5|COMPUTATIONAL|COMPUTATIONAL-1|COMPUTATIONAL-2|COMPUTATIONAL-3|COMPUTATIONAL-4|COMPUTATIONAL-5|COMPUTE|CONFIGURATION|CONTAINS|CONTENT|CONTINUE|CONTROL|CONTROL-POINT|CONTROLS|CONVENTION|CONVERTING|COPY|CORR|CORRESPONDING|COUNT|CRUNCH|CURRENCY|CURSOR|DATA|DATA-BASE|DATE|DATE-COMPILED|DATE-WRITTEN|DAY|DAY-OF-WEEK|DBCS|DE|DEBUG-CONTENTS|DEBUG-ITEM|DEBUG-LINE|DEBUG-NAME|DEBUG-SUB-1|DEBUG-SUB-2|DEBUG-SUB-3|DEBUGGING|DECIMAL-POINT|DECLARATIVES|DEFAULT|DEFAULT-DISPLAY|DEFINITION|DELETE|DELIMITED|DELIMITER|DEPENDING|DESCENDING|DESTINATION|DETAIL|DFHRESP|DFHVALUE|DISABLE|DISK|DISPLAY|DISPLAY-1|DIVIDE|DIVISION|DONTCARE|DOUBLE|DOWN|DUPLICATES|DYNAMIC|EBCDIC|EGCS|EGI|ELSE|EMI|EMPTY-CHECK|ENABLE|END|END-ACCEPT|END-ADD|END-CALL|END-COMPUTE|END-DELETE|END-DIVIDE|END-EVALUATE|END-IF|END-MULTIPLY|END-OF-PAGE|END-PERFORM|END-READ|END-RECEIVE|END-RETURN|END-REWRITE|END-SEARCH|END-START|END-STRING|END-SUBTRACT|END-UNSTRING|END-WRITE|ENDING|ENTER|ENTRY|ENTRY-PROCEDURE|ENVIRONMENT|EOL|EOP|EOS|ERASE|ERROR|ESCAPE|ESI|EVALUATE|EVENT|EVERY|EXCEPTION|EXCLUSIVE|EXHIBIT|EXIT|EXPORT|EXTEND|EXTENDED|EXTERNAL|FD|FILE|FILE-CONTROL|FILLER|FINAL|FIRST|FOOTING|FOR|FOREGROUND-COLOR|FOREGROUND-COLOUR|FROM|FULL|FUNCTION|FUNCTION-POINTER|FUNCTIONNAME|GENERATE|GIVING|GLOBAL|GO|GOBACK|GRID|GROUP|HEADING|HIGH-VALUE|HIGH-VALUES|HIGHLIGHT|I-O|I-O-CONTROL|ID|IDENTIFICATION|IF|IMPLICIT|IMPORT|IN|INDEX|INDEXED|INDICATE|INITIAL|INITIALIZE|INITIATE|INPUT|INPUT-OUTPUT|INSPECT|INSTALLATION|INTEGER|INTO|INVALID|INVOKE|IS|JUST|JUSTIFIED|KANJI|KEPT|KEY|KEYBOARD|LABEL|LANGUAGE|LAST|LB|LD|LEADING|LEFT|LEFTLINE|LENGTH|LENGTH-CHECK|LIBACCESS|LIBPARAMETER|LIBRARY|LIMIT|LIMITS|LINAGE|LINAGE-COUNTER|LINE|LINE-COUNTER|LINES|LINKAGE|LIST|LOCAL|LOCAL-STORAGE|LOCK|LONG-DATE|LONG-TIME|LOW-VALUE|LOW-VALUES|LOWER|LOWLIGHT|MEMORY|MERGE|MESSAGE|MMDDYYYY|MODE|MODULES|MORE-LABELS|MOVE|MULTIPLE|MULTIPLY|NAMED|NATIONAL|NATIONAL-EDITED|NATIVE|NEGATIVE|NETWORK|NEXT|NO|NO-ECHO|NULL|NULLS|NUMBER|NUMERIC|NUMERIC-DATE|NUMERIC-EDITED|NUMERIC-TIME|OBJECT-COMPUTER|OCCURS|ODT|OF|OFF|OMITTED|ON|OPEN|OPTIONAL|ORDER|ORDERLY|ORGANIZATION|OTHER|OUTPUT|OVERFLOW|OVERLINE|OWN|PACKED-DECIMAL|PADDING|PAGE|PAGE-COUNTER|PASSWORD|PERFORM|PF|PH|PIC|PICTURE|PLUS|POINTER|PORT|POSITION|POSITIVE|PRINTER|PRINTING|PRIVATE|PROCEDURE|PROCEDURE-POINTER|PROCEDURES|PROCEED|PROCESS|PROGRAM|PROGRAM-ID|PROGRAM-LIBRARY|PROMPT|PURGE|QUEUE|QUOTE|QUOTES|RANDOM|RD|READ|READER|REAL|RECEIVE|RECEIVED|RECORD|RECORDING|RECORDS|RECURSIVE|REDEFINES|REEL|REF|REFERENCE|REFERENCES|RELATIVE|RELEASE|REMAINDER|REMARKS|REMOTE|REMOVAL|REMOVE|RENAMES|REPLACE|REPLACING|REPORT|REPORTING|REPORTS|REQUIRED|RERUN|RESERVE|RESET|RETURN|RETURN-CODE|RETURNING|REVERSE-VIDEO|REVERSED|REWIND|REWRITE|RF|RH|RIGHT|ROUNDED|RUN|SAME|SAVE|SCREEN|SD|SEARCH|SECTION|SECURE|SECURITY|SEGMENT|SEGMENT-LIMIT|SELECT|SEND|SENTENCE|SEPARATE|SEQUENCE|SEQUENTIAL|SET|SHARED|SHAREDBYALL|SHAREDBYRUNUNIT|SHARING|SHIFT-IN|SHIFT-OUT|SHORT-DATE|SIGN|SIZE|SORT|SORT-CONTROL|SORT-CORE-SIZE|SORT-FILE-SIZE|SORT-MERGE|SORT-MESSAGE|SORT-MODE-SIZE|SORT-RETURN|SOURCE|SOURCE-COMPUTER|SPACE|SPACES|SPECIAL-NAMES|STANDARD|STANDARD-1|STANDARD-2|START|STATUS|STOP|STRING|SUB-QUEUE-1|SUB-QUEUE-2|SUB-QUEUE-3|SUBTRACT|SUM|SUPPRESS|SYMBOL|SYMBOLIC|SYNC|SYNCHRONIZED|TABLE|TALLY|TALLYING|TAPE|TASK|TERMINAL|TERMINATE|TEST|TEXT|THEN|THREAD|THREAD-LOCAL|THROUGH|THRU|TIME|TIMER|TIMES|TITLE|TO|TODAYS-DATE|TODAYS-NAME|TOP|TRAILING|TRUNCATED|TYPE|TYPEDEF|UNDERLINE|UNIT|UNSTRING|UNTIL|UP|UPON|USAGE|USE|USING|VALUE|VALUES|VARYING|VIRTUAL|WAIT|WHEN|WHEN-COMPILED|WITH|WORDS|WORKING-STORAGE|WRITE|YEAR|YYYYDDD|YYYYMMDD|ZERO-FILL|ZEROES|ZEROS)(?![\w-])/i,
        lookbehind: !0
      },
      boolean: {
        pattern: /(^|[^\w-])(?:false|true)(?![\w-])/i,
        lookbehind: !0
      },
      number: {
        pattern: /(^|[^\w-])(?:[+-]?(?:(?:\d+(?:[.,]\d+)?|[.,]\d+)(?:e[+-]?\d+)?|zero))(?![\w-])/i,
        lookbehind: !0
      },
      operator: [/<>|[<>]=?|[=+*/&]/, {
        pattern: /(^|[^\w-])(?:-|and|equal|greater|less|not|or|than)(?![\w-])/i,
        lookbehind: !0
      }],
      punctuation: /[.:,()]/
    };
  }
  return cobol_1;
}
var coffeescript_1, hasRequiredCoffeescript;
function requireCoffeescript() {
  if (hasRequiredCoffeescript) return coffeescript_1;
  hasRequiredCoffeescript = 1, coffeescript_1 = e, e.displayName = "coffeescript", e.aliases = ["coffee"];
  function e(t) {
    (function(r) {
      var a = /#(?!\{).+/, o = {
        pattern: /#\{[^}]+\}/,
        alias: "variable"
      };
      r.languages.coffeescript = r.languages.extend("javascript", {
        comment: a,
        string: [
          // Strings are multiline
          {
            pattern: /'(?:\\[\s\S]|[^\\'])*'/,
            greedy: !0
          },
          {
            // Strings are multiline
            pattern: /"(?:\\[\s\S]|[^\\"])*"/,
            greedy: !0,
            inside: {
              interpolation: o
            }
          }
        ],
        keyword: /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,
        "class-member": {
          pattern: /@(?!\d)\w+/,
          alias: "variable"
        }
      }), r.languages.insertBefore("coffeescript", "comment", {
        "multiline-comment": {
          pattern: /###[\s\S]+?###/,
          alias: "comment"
        },
        // Block regexp can contain comments and interpolation
        "block-regex": {
          pattern: /\/{3}[\s\S]*?\/{3}/,
          alias: "regex",
          inside: {
            comment: a,
            interpolation: o
          }
        }
      }), r.languages.insertBefore("coffeescript", "string", {
        "inline-javascript": {
          pattern: /`(?:\\[\s\S]|[^\\`])*`/,
          inside: {
            delimiter: {
              pattern: /^`|`$/,
              alias: "punctuation"
            },
            script: {
              pattern: /[\s\S]+/,
              alias: "language-javascript",
              inside: r.languages.javascript
            }
          }
        },
        // Block strings
        "multiline-string": [{
          pattern: /'''[\s\S]*?'''/,
          greedy: !0,
          alias: "string"
        }, {
          pattern: /"""[\s\S]*?"""/,
          greedy: !0,
          alias: "string",
          inside: {
            interpolation: o
          }
        }]
      }), r.languages.insertBefore("coffeescript", "keyword", {
        // Object property
        property: /(?!\d)\w+(?=\s*:(?!:))/
      }), delete r.languages.coffeescript["template-string"], r.languages.coffee = r.languages.coffeescript;
    })(t);
  }
  return coffeescript_1;
}
var concurnas_1, hasRequiredConcurnas;
function requireConcurnas() {
  if (hasRequiredConcurnas) return concurnas_1;
  hasRequiredConcurnas = 1, concurnas_1 = e, e.displayName = "concurnas", e.aliases = ["conc"];
  function e(t) {
    t.languages.concurnas = {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\/\/.*)/,
        lookbehind: !0,
        greedy: !0
      },
      langext: {
        pattern: /\b\w+\s*\|\|[\s\S]+?\|\|/,
        greedy: !0,
        inside: {
          "class-name": /^\w+/,
          string: {
            pattern: /(^\s*\|\|)[\s\S]+(?=\|\|$)/,
            lookbehind: !0
          },
          punctuation: /\|\|/
        }
      },
      function: {
        pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/,
        lookbehind: !0
      },
      keyword: /\b(?:abstract|actor|also|annotation|assert|async|await|bool|boolean|break|byte|case|catch|changed|char|class|closed|constant|continue|def|default|del|double|elif|else|enum|every|extends|false|finally|float|for|from|global|gpudef|gpukernel|if|import|in|init|inject|int|lambda|local|long|loop|match|new|nodefault|null|of|onchange|open|out|override|package|parfor|parforsync|post|pre|private|protected|provide|provider|public|return|shared|short|single|size_t|sizeof|super|sync|this|throw|trait|trans|transient|true|try|typedef|unchecked|using|val|var|void|while|with)\b/,
      boolean: /\b(?:false|true)\b/,
      number: /\b0b[01][01_]*L?\b|\b0x(?:[\da-f_]*\.)?[\da-f_p+-]+\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfls]?/i,
      punctuation: /[{}[\];(),.:]/,
      operator: /<==|>==|=>|->|<-|<>|&==|&<>|\?:?|\.\?|\+\+|--|[-+*/=<>]=?|[!^~]|\b(?:and|as|band|bor|bxor|comp|is|isnot|mod|or)\b=?/,
      annotation: {
        pattern: /@(?:\w+:)?(?:\w+|\[[^\]]+\])?/,
        alias: "builtin"
      }
    }, t.languages.insertBefore("concurnas", "langext", {
      "regex-literal": {
        pattern: /\br("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: !0,
            inside: t.languages.concurnas
          },
          regex: /[\s\S]+/
        }
      },
      "string-literal": {
        pattern: /(?:\B|\bs)("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: !0,
            inside: t.languages.concurnas
          },
          string: /[\s\S]+/
        }
      }
    }), t.languages.conc = t.languages.concurnas;
  }
  return concurnas_1;
}
var coq_1, hasRequiredCoq;
function requireCoq() {
  if (hasRequiredCoq) return coq_1;
  hasRequiredCoq = 1, coq_1 = e, e.displayName = "coq", e.aliases = [];
  function e(t) {
    (function(r) {
      for (var a = /\(\*(?:[^(*]|\((?!\*)|\*(?!\))|<self>)*\*\)/.source, o = 0; o < 2; o++)
        a = a.replace(/<self>/g, function() {
          return a;
        });
      a = a.replace(/<self>/g, "[]"), r.languages.coq = {
        comment: RegExp(a),
        string: {
          pattern: /"(?:[^"]|"")*"(?!")/,
          greedy: !0
        },
        attribute: [{
          pattern: RegExp(/#\[(?:[^\[\]("]|"(?:[^"]|"")*"(?!")|\((?!\*)|<comment>)*\]/.source.replace(/<comment>/g, function() {
            return a;
          })),
          greedy: !0,
          alias: "attr-name",
          inside: {
            comment: RegExp(a),
            string: {
              pattern: /"(?:[^"]|"")*"(?!")/,
              greedy: !0
            },
            operator: /=/,
            punctuation: /^#\[|\]$|[,()]/
          }
        }, {
          pattern: /\b(?:Cumulative|Global|Local|Monomorphic|NonCumulative|Polymorphic|Private|Program)\b/,
          alias: "attr-name"
        }],
        keyword: /\b(?:Abort|About|Add|Admit|Admitted|All|Arguments|As|Assumptions|Axiom|Axioms|Back|BackTo|Backtrace|BinOp|BinOpSpec|BinRel|Bind|Blacklist|Canonical|Case|Cd|Check|Class|Classes|Close|CoFixpoint|CoInductive|Coercion|Coercions|Collection|Combined|Compute|Conjecture|Conjectures|Constant|Constants|Constraint|Constructors|Context|Corollary|Create|CstOp|Custom|Cut|Debug|Declare|Defined|Definition|Delimit|Dependencies|Dependent|Derive|Diffs|Drop|Elimination|End|Entry|Equality|Eval|Example|Existential|Existentials|Existing|Export|Extern|Extraction|Fact|Fail|Field|File|Firstorder|Fixpoint|Flags|Focus|From|Funclass|Function|Functional|GC|Generalizable|Goal|Grab|Grammar|Graph|Guarded|Haskell|Heap|Hide|Hint|HintDb|Hints|Hypotheses|Hypothesis|IF|Identity|Immediate|Implicit|Implicits|Import|Include|Induction|Inductive|Infix|Info|Initial|InjTyp|Inline|Inspect|Instance|Instances|Intro|Intros|Inversion|Inversion_clear|JSON|Language|Left|Lemma|Let|Lia|Libraries|Library|Load|LoadPath|Locate|Ltac|Ltac2|ML|Match|Method|Minimality|Module|Modules|Morphism|Next|NoInline|Notation|Number|OCaml|Obligation|Obligations|Opaque|Open|Optimize|Parameter|Parameters|Parametric|Path|Paths|Prenex|Preterm|Primitive|Print|Profile|Projections|Proof|Prop|PropBinOp|PropOp|PropUOp|Property|Proposition|Pwd|Qed|Quit|Rec|Record|Recursive|Redirect|Reduction|Register|Relation|Remark|Remove|Require|Reserved|Reset|Resolve|Restart|Rewrite|Right|Ring|Rings|SProp|Saturate|Save|Scheme|Scope|Scopes|Search|SearchHead|SearchPattern|SearchRewrite|Section|Separate|Set|Setoid|Show|Signatures|Solve|Solver|Sort|Sortclass|Sorted|Spec|Step|Strategies|Strategy|String|Structure|SubClass|Subgraph|SuchThat|Tactic|Term|TestCompile|Theorem|Time|Timeout|To|Transparent|Type|Typeclasses|Types|Typing|UnOp|UnOpSpec|Undelimit|Undo|Unfocus|Unfocused|Unfold|Universe|Universes|Unshelve|Variable|Variables|Variant|Verbose|View|Visibility|Zify|_|apply|as|at|by|cofix|else|end|exists|exists2|fix|for|forall|fun|if|in|let|match|measure|move|removed|return|struct|then|using|wf|where|with)\b/,
        number: /\b(?:0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]+)?(?:p[+-]?\d[\d_]*)?|\d[\d_]*(?:\.[\d_]+)?(?:e[+-]?\d[\d_]*)?)\b/i,
        punct: {
          pattern: /@\{|\{\||\[=|:>/,
          alias: "punctuation"
        },
        operator: /\/\\|\\\/|\.{2,3}|:{1,2}=|\*\*|[-=]>|<(?:->?|[+:=>]|<:)|>(?:=|->)|\|[-|]?|[-!%&*+/<=>?@^~']/,
        punctuation: /\.\(|`\(|@\{|`\{|\{\||\[=|:>|[:.,;(){}\[\]]/
      };
    })(t);
  }
  return coq_1;
}
var ruby_1, hasRequiredRuby;
function requireRuby() {
  if (hasRequiredRuby) return ruby_1;
  hasRequiredRuby = 1, ruby_1 = e, e.displayName = "ruby", e.aliases = ["rb"];
  function e(t) {
    (function(r) {
      r.languages.ruby = r.languages.extend("clike", {
        comment: {
          pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
          greedy: !0
        },
        "class-name": {
          pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
          lookbehind: !0,
          inside: {
            punctuation: /[.\\]/
          }
        },
        keyword: /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
        operator: /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
        punctuation: /[(){}[\].,;]/
      }), r.languages.insertBefore("ruby", "operator", {
        "double-colon": {
          pattern: /::/,
          alias: "punctuation"
        }
      });
      var a = {
        pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
        lookbehind: !0,
        inside: {
          content: {
            pattern: /^(#\{)[\s\S]+(?=\}$)/,
            lookbehind: !0,
            inside: r.languages.ruby
          },
          delimiter: {
            pattern: /^#\{|\}$/,
            alias: "punctuation"
          }
        }
      };
      delete r.languages.ruby.function;
      var o = "(?:" + [/([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source, /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source, /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source, /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source, /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source].join("|") + ")", u = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
      r.languages.insertBefore("ruby", "keyword", {
        "regex-literal": [{
          pattern: RegExp(/%r/.source + o + /[egimnosux]{0,6}/.source),
          greedy: !0,
          inside: {
            interpolation: a,
            regex: /[\s\S]+/
          }
        }, {
          pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
          lookbehind: !0,
          greedy: !0,
          inside: {
            interpolation: a,
            regex: /[\s\S]+/
          }
        }],
        variable: /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
        symbol: [{
          pattern: RegExp(/(^|[^:]):/.source + u),
          lookbehind: !0,
          greedy: !0
        }, {
          pattern: RegExp(/([\r\n{(,][ \t]*)/.source + u + /(?=:(?!:))/.source),
          lookbehind: !0,
          greedy: !0
        }],
        "method-definition": {
          pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
          lookbehind: !0,
          inside: {
            function: /\b\w+$/,
            keyword: /^self\b/,
            "class-name": /^\w+/,
            punctuation: /\./
          }
        }
      }), r.languages.insertBefore("ruby", "string", {
        "string-literal": [{
          pattern: RegExp(/%[qQiIwWs]?/.source + o),
          greedy: !0,
          inside: {
            interpolation: a,
            string: /[\s\S]+/
          }
        }, {
          pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
          greedy: !0,
          inside: {
            interpolation: a,
            string: /[\s\S]+/
          }
        }, {
          pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
          alias: "heredoc-string",
          greedy: !0,
          inside: {
            delimiter: {
              pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
              inside: {
                symbol: /\b\w+/,
                punctuation: /^<<[-~]?/
              }
            },
            interpolation: a,
            string: /[\s\S]+/
          }
        }, {
          pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
          alias: "heredoc-string",
          greedy: !0,
          inside: {
            delimiter: {
              pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
              inside: {
                symbol: /\b\w+/,
                punctuation: /^<<[-~]?'|'$/
              }
            },
            string: /[\s\S]+/
          }
        }],
        "command-literal": [{
          pattern: RegExp(/%x/.source + o),
          greedy: !0,
          inside: {
            interpolation: a,
            command: {
              pattern: /[\s\S]+/,
              alias: "string"
            }
          }
        }, {
          pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
          greedy: !0,
          inside: {
            interpolation: a,
            command: {
              pattern: /[\s\S]+/,
              alias: "string"
            }
          }
        }]
      }), delete r.languages.ruby.string, r.languages.insertBefore("ruby", "number", {
        builtin: /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
        constant: /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
      }), r.languages.rb = r.languages.ruby;
    })(t);
  }
  return ruby_1;
}
var crystal_1, hasRequiredCrystal;
function requireCrystal() {
  if (hasRequiredCrystal) return crystal_1;
  hasRequiredCrystal = 1;
  var e = requireRuby();
  crystal_1 = t, t.displayName = "crystal", t.aliases = [];
  function t(r) {
    r.register(e), function(a) {
      a.languages.crystal = a.languages.extend("ruby", {
        keyword: [/\b(?:__DIR__|__END_LINE__|__FILE__|__LINE__|abstract|alias|annotation|as|asm|begin|break|case|class|def|do|else|elsif|end|ensure|enum|extend|for|fun|if|ifdef|include|instance_sizeof|lib|macro|module|next|of|out|pointerof|private|protected|ptr|require|rescue|return|select|self|sizeof|struct|super|then|type|typeof|undef|uninitialized|union|unless|until|when|while|with|yield)\b/, {
          pattern: /(\.\s*)(?:is_a|responds_to)\?/,
          lookbehind: !0
        }],
        number: /\b(?:0b[01_]*[01]|0o[0-7_]*[0-7]|0x[\da-fA-F_]*[\da-fA-F]|(?:\d(?:[\d_]*\d)?)(?:\.[\d_]*\d)?(?:[eE][+-]?[\d_]*\d)?)(?:_(?:[uif](?:8|16|32|64))?)?\b/,
        operator: [/->/, a.languages.ruby.operator],
        punctuation: /[(){}[\].,;\\]/
      }), a.languages.insertBefore("crystal", "string-literal", {
        attribute: {
          pattern: /@\[.*?\]/,
          inside: {
            delimiter: {
              pattern: /^@\[|\]$/,
              alias: "punctuation"
            },
            attribute: {
              pattern: /^(\s*)\w+/,
              lookbehind: !0,
              alias: "class-name"
            },
            args: {
              pattern: /\S(?:[\s\S]*\S)?/,
              inside: a.languages.crystal
            }
          }
        },
        expansion: {
          pattern: /\{(?:\{.*?\}|%.*?%)\}/,
          inside: {
            content: {
              pattern: /^(\{.)[\s\S]+(?=.\}$)/,
              lookbehind: !0,
              inside: a.languages.crystal
            },
            delimiter: {
              pattern: /^\{[\{%]|[\}%]\}$/,
              alias: "operator"
            }
          }
        },
        char: {
          pattern: /'(?:[^\\\r\n]{1,2}|\\(?:.|u(?:[A-Fa-f0-9]{1,4}|\{[A-Fa-f0-9]{1,6}\})))'/,
          greedy: !0
        }
      });
    }(r);
  }
  return crystal_1;
}
var cshtml_1, hasRequiredCshtml;
function requireCshtml() {
  if (hasRequiredCshtml) return cshtml_1;
  hasRequiredCshtml = 1;
  var e = requireCsharp();
  cshtml_1 = t, t.displayName = "cshtml", t.aliases = ["razor"];
  function t(r) {
    r.register(e), function(a) {
      var o = /\/(?![/*])|\/\/.*[\r\n]|\/\*[^*]*(?:\*(?!\/)[^*]*)*\*\//.source, u = /@(?!")|"(?:[^\r\n\\"]|\\.)*"|@"(?:[^\\"]|""|\\[\s\S])*"(?!")/.source + "|" + /'(?:(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'|(?=[^\\](?!')))/.source;
      function c(R, I) {
        for (var w = 0; w < I; w++)
          R = R.replace(/<self>/g, function() {
            return "(?:" + R + ")";
          });
        return R.replace(/<self>/g, "[^\\s\\S]").replace(/<str>/g, "(?:" + u + ")").replace(/<comment>/g, "(?:" + o + ")");
      }
      var d = c(/\((?:[^()'"@/]|<str>|<comment>|<self>)*\)/.source, 2), g = c(/\[(?:[^\[\]'"@/]|<str>|<comment>|<self>)*\]/.source, 2), b = c(/\{(?:[^{}'"@/]|<str>|<comment>|<self>)*\}/.source, 2), _ = c(/<(?:[^<>'"@/]|<str>|<comment>|<self>)*>/.source, 2), y = /(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?/.source, A = /(?!\d)[^\s>\/=$<%]+/.source + y + /\s*\/?>/.source, E = /\B@?/.source + "(?:" + /<([a-zA-Z][\w:]*)/.source + y + /\s*>/.source + "(?:" + (/[^<]/.source + "|" + // all tags that are not the start tag
      // eslint-disable-next-line regexp/strict
      /<\/?(?!\1\b)/.source + A + "|" + // nested start tag
      c(
        // eslint-disable-next-line regexp/strict
        /<\1/.source + y + /\s*>/.source + "(?:" + (/[^<]/.source + "|" + // all tags that are not the start tag
        // eslint-disable-next-line regexp/strict
        /<\/?(?!\1\b)/.source + A + "|<self>") + ")*" + // eslint-disable-next-line regexp/strict
        /<\/\1\s*>/.source,
        2
      )) + ")*" + // eslint-disable-next-line regexp/strict
      /<\/\1\s*>/.source + "|" + /</.source + A + ")";
      a.languages.cshtml = a.languages.extend("markup", {});
      var v = a.languages.insertBefore("csharp", "string", {
        html: {
          pattern: RegExp(E),
          greedy: !0,
          inside: a.languages.cshtml
        }
      }, {
        csharp: a.languages.extend("csharp", {})
      }), C = {
        pattern: /\S[\s\S]*/,
        alias: "language-csharp",
        inside: v
      };
      a.languages.insertBefore("cshtml", "prolog", {
        "razor-comment": {
          pattern: /@\*[\s\S]*?\*@/,
          greedy: !0,
          alias: "comment"
        },
        block: {
          pattern: RegExp(/(^|[^@])@/.source + "(?:" + [
            // @{ ... }
            b,
            // @code{ ... }
            /(?:code|functions)\s*/.source + b,
            // @for (...) { ... }
            /(?:for|foreach|lock|switch|using|while)\s*/.source + d + /\s*/.source + b,
            // @do { ... } while (...);
            /do\s*/.source + b + /\s*while\s*/.source + d + /(?:\s*;)?/.source,
            // @try { ... } catch (...) { ... } finally { ... }
            /try\s*/.source + b + /\s*catch\s*/.source + d + /\s*/.source + b + /\s*finally\s*/.source + b,
            // @if (...) {...} else if (...) {...} else {...}
            /if\s*/.source + d + /\s*/.source + b + "(?:" + /\s*else/.source + "(?:" + /\s+if\s*/.source + d + ")?" + /\s*/.source + b + ")*"
          ].join("|") + ")"),
          lookbehind: !0,
          greedy: !0,
          inside: {
            keyword: /^@\w*/,
            csharp: C
          }
        },
        directive: {
          pattern: /^([ \t]*)@(?:addTagHelper|attribute|implements|inherits|inject|layout|model|namespace|page|preservewhitespace|removeTagHelper|section|tagHelperPrefix|using)(?=\s).*/m,
          lookbehind: !0,
          greedy: !0,
          inside: {
            keyword: /^@\w+/,
            csharp: C
          }
        },
        value: {
          pattern: RegExp(/(^|[^@])@/.source + /(?:await\b\s*)?/.source + "(?:" + /\w+\b/.source + "|" + d + ")(?:" + /[?!]?\.\w+\b/.source + "|" + d + "|" + g + "|" + _ + d + ")*"),
          lookbehind: !0,
          greedy: !0,
          alias: "variable",
          inside: {
            keyword: /^@/,
            csharp: C
          }
        },
        "delegate-operator": {
          pattern: /(^|[^@])@(?=<)/,
          lookbehind: !0,
          alias: "operator"
        }
      }), a.languages.razor = a.languages.cshtml;
    }(r);
  }
  return cshtml_1;
}
var csp_1, hasRequiredCsp;
function requireCsp() {
  if (hasRequiredCsp) return csp_1;
  hasRequiredCsp = 1, csp_1 = e, e.displayName = "csp", e.aliases = [];
  function e(t) {
    (function(r) {
      function a(o) {
        return RegExp(/([ \t])/.source + "(?:" + o + ")" + /(?=[\s;]|$)/.source, "i");
      }
      r.languages.csp = {
        directive: {
          pattern: /(^|[\s;])(?:base-uri|block-all-mixed-content|(?:child|connect|default|font|frame|img|manifest|media|object|prefetch|script|style|worker)-src|disown-opener|form-action|frame-(?:ancestors|options)|input-protection(?:-(?:clip|selectors))?|navigate-to|plugin-types|policy-uri|referrer|reflected-xss|report-(?:to|uri)|require-sri-for|sandbox|(?:script|style)-src-(?:attr|elem)|upgrade-insecure-requests)(?=[\s;]|$)/i,
          lookbehind: !0,
          alias: "property"
        },
        scheme: {
          pattern: a(/[a-z][a-z0-9.+-]*:/.source),
          lookbehind: !0
        },
        none: {
          pattern: a(/'none'/.source),
          lookbehind: !0,
          alias: "keyword"
        },
        nonce: {
          pattern: a(/'nonce-[-+/\w=]+'/.source),
          lookbehind: !0,
          alias: "number"
        },
        hash: {
          pattern: a(/'sha(?:256|384|512)-[-+/\w=]+'/.source),
          lookbehind: !0,
          alias: "number"
        },
        host: {
          pattern: a(/[a-z][a-z0-9.+-]*:\/\/[^\s;,']*/.source + "|" + /\*[^\s;,']*/.source + "|" + /[a-z0-9-]+(?:\.[a-z0-9-]+)+(?::[\d*]+)?(?:\/[^\s;,']*)?/.source),
          lookbehind: !0,
          alias: "url",
          inside: {
            important: /\*/
          }
        },
        keyword: [{
          pattern: a(/'unsafe-[a-z-]+'/.source),
          lookbehind: !0,
          alias: "unsafe"
        }, {
          pattern: a(/'[a-z-]+'/.source),
          lookbehind: !0,
          alias: "safe"
        }],
        punctuation: /;/
      };
    })(t);
  }
  return csp_1;
}
var cssExtras_1, hasRequiredCssExtras;
function requireCssExtras() {
  if (hasRequiredCssExtras) return cssExtras_1;
  hasRequiredCssExtras = 1, cssExtras_1 = e, e.displayName = "cssExtras", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, o;
      r.languages.css.selector = {
        pattern: r.languages.css.selector.pattern,
        lookbehind: !0,
        inside: o = {
          "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,
          "pseudo-class": /:[-\w]+/,
          class: /\.[-\w]+/,
          id: /#[-\w]+/,
          attribute: {
            pattern: RegExp(`\\[(?:[^[\\]"']|` + a.source + ")*\\]"),
            greedy: !0,
            inside: {
              punctuation: /^\[|\]$/,
              "case-sensitivity": {
                pattern: /(\s)[si]$/i,
                lookbehind: !0,
                alias: "keyword"
              },
              namespace: {
                pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/,
                lookbehind: !0,
                inside: {
                  punctuation: /\|$/
                }
              },
              "attr-name": {
                pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/,
                lookbehind: !0
              },
              "attr-value": [a, {
                pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/,
                lookbehind: !0
              }],
              operator: /[|~*^$]?=/
            }
          },
          "n-th": [{
            pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/,
            lookbehind: !0,
            inside: {
              number: /[\dn]+/,
              operator: /[+-]/
            }
          }, {
            pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i,
            lookbehind: !0
          }],
          combinator: />|\+|~|\|\|/,
          // the `tag` token has been existed and removed.
          // because we can't find a perfect tokenize to match it.
          // if you want to add it, please read https://github.com/PrismJS/prism/pull/2373 first.
          punctuation: /[(),]/
        }
      }, r.languages.css.atrule.inside["selector-function-argument"].inside = o, r.languages.insertBefore("css", "property", {
        variable: {
          pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i,
          lookbehind: !0
        }
      });
      var u = {
        pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/,
        lookbehind: !0
      }, c = {
        pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
        lookbehind: !0
      };
      r.languages.insertBefore("css", "function", {
        operator: {
          pattern: /(\s)[+\-*\/](?=\s)/,
          lookbehind: !0
        },
        // CAREFUL!
        // Previewers and Inline color use hexcode and color.
        hexcode: {
          pattern: /\B#[\da-f]{3,8}\b/i,
          alias: "color"
        },
        color: [{
          pattern: /(^|[^\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\w-])/i,
          lookbehind: !0
        }, {
          pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
          inside: {
            unit: u,
            number: c,
            function: /[\w-]+(?=\()/,
            punctuation: /[(),]/
          }
        }],
        // it's important that there is no boundary assertion after the hex digits
        entity: /\\[\da-f]{1,8}/i,
        unit: u,
        number: c
      });
    })(t);
  }
  return cssExtras_1;
}
var csv_1, hasRequiredCsv;
function requireCsv() {
  if (hasRequiredCsv) return csv_1;
  hasRequiredCsv = 1, csv_1 = e, e.displayName = "csv", e.aliases = [];
  function e(t) {
    t.languages.csv = {
      value: /[^\r\n,"]+|"(?:[^"]|"")*"(?!")/,
      punctuation: /,/
    };
  }
  return csv_1;
}
var cypher_1, hasRequiredCypher;
function requireCypher() {
  if (hasRequiredCypher) return cypher_1;
  hasRequiredCypher = 1, cypher_1 = e, e.displayName = "cypher", e.aliases = [];
  function e(t) {
    t.languages.cypher = {
      // https://neo4j.com/docs/cypher-manual/current/syntax/comments/
      comment: /\/\/.*/,
      string: {
        pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/,
        greedy: !0
      },
      "class-name": {
        pattern: /(:\s*)(?:\w+|`(?:[^`\\\r\n])*`)(?=\s*[{):])/,
        lookbehind: !0,
        greedy: !0
      },
      relationship: {
        pattern: /(-\[\s*(?:\w+\s*|`(?:[^`\\\r\n])*`\s*)?:\s*|\|\s*:\s*)(?:\w+|`(?:[^`\\\r\n])*`)/,
        lookbehind: !0,
        greedy: !0,
        alias: "property"
      },
      identifier: {
        pattern: /`(?:[^`\\\r\n])*`/,
        greedy: !0
      },
      variable: /\$\w+/,
      // https://neo4j.com/docs/cypher-manual/current/syntax/reserved/
      keyword: /\b(?:ADD|ALL|AND|AS|ASC|ASCENDING|ASSERT|BY|CALL|CASE|COMMIT|CONSTRAINT|CONTAINS|CREATE|CSV|DELETE|DESC|DESCENDING|DETACH|DISTINCT|DO|DROP|ELSE|END|ENDS|EXISTS|FOR|FOREACH|IN|INDEX|IS|JOIN|KEY|LIMIT|LOAD|MANDATORY|MATCH|MERGE|NODE|NOT|OF|ON|OPTIONAL|OR|ORDER(?=\s+BY)|PERIODIC|REMOVE|REQUIRE|RETURN|SCALAR|SCAN|SET|SKIP|START|STARTS|THEN|UNION|UNIQUE|UNWIND|USING|WHEN|WHERE|WITH|XOR|YIELD)\b/i,
      function: /\b\w+\b(?=\s*\()/,
      boolean: /\b(?:false|null|true)\b/i,
      number: /\b(?:0x[\da-fA-F]+|\d+(?:\.\d+)?(?:[eE][+-]?\d+)?)\b/,
      // https://neo4j.com/docs/cypher-manual/current/syntax/operators/
      operator: /:|<--?|--?>?|<>|=~?|[<>]=?|[+*/%^|]|\.\.\.?/,
      punctuation: /[()[\]{},;.]/
    };
  }
  return cypher_1;
}
var d_1, hasRequiredD;
function requireD() {
  if (hasRequiredD) return d_1;
  hasRequiredD = 1, d_1 = e, e.displayName = "d", e.aliases = [];
  function e(t) {
    t.languages.d = t.languages.extend("clike", {
      comment: [{
        // Shebang
        pattern: /^\s*#!.+/,
        greedy: !0
      }, {
        pattern: RegExp(/(^|[^\\])/.source + "(?:" + [
          // /+ comment +/
          // Allow one level of nesting
          /\/\+(?:\/\+(?:[^+]|\+(?!\/))*\+\/|(?!\/\+)[\s\S])*?\+\//.source,
          // // comment
          /\/\/.*/.source,
          // /* comment */
          /\/\*[\s\S]*?\*\//.source
        ].join("|") + ")"),
        lookbehind: !0,
        greedy: !0
      }],
      string: [{
        pattern: RegExp([
          // r"", x""
          /\b[rx]"(?:\\[\s\S]|[^\\"])*"[cwd]?/.source,
          // q"[]", q"()", q"<>", q"{}"
          /\bq"(?:\[[\s\S]*?\]|\([\s\S]*?\)|<[\s\S]*?>|\{[\s\S]*?\})"/.source,
          // q"IDENT
          // ...
          // IDENT"
          /\bq"((?!\d)\w+)$[\s\S]*?^\1"/.source,
          // q"//", q"||", etc.
          // eslint-disable-next-line regexp/strict
          /\bq"(.)[\s\S]*?\2"/.source,
          // eslint-disable-next-line regexp/strict
          /(["`])(?:\\[\s\S]|(?!\3)[^\\])*\3[cwd]?/.source
        ].join("|"), "m"),
        greedy: !0
      }, {
        pattern: /\bq\{(?:\{[^{}]*\}|[^{}])*\}/,
        greedy: !0,
        alias: "token-string"
      }],
      // In order: $, keywords and special tokens, globally defined symbols
      keyword: /\$|\b(?:__(?:(?:DATE|EOF|FILE|FUNCTION|LINE|MODULE|PRETTY_FUNCTION|TIMESTAMP|TIME|VENDOR|VERSION)__|gshared|parameters|traits|vector)|abstract|alias|align|asm|assert|auto|body|bool|break|byte|case|cast|catch|cdouble|cent|cfloat|char|class|const|continue|creal|dchar|debug|default|delegate|delete|deprecated|do|double|dstring|else|enum|export|extern|false|final|finally|float|for|foreach|foreach_reverse|function|goto|idouble|if|ifloat|immutable|import|inout|int|interface|invariant|ireal|lazy|long|macro|mixin|module|new|nothrow|null|out|override|package|pragma|private|protected|ptrdiff_t|public|pure|real|ref|return|scope|shared|short|size_t|static|string|struct|super|switch|synchronized|template|this|throw|true|try|typedef|typeid|typeof|ubyte|ucent|uint|ulong|union|unittest|ushort|version|void|volatile|wchar|while|with|wstring)\b/,
      number: [
        // The lookbehind and the negative look-ahead try to prevent bad highlighting of the .. operator
        // Hexadecimal numbers must be handled separately to avoid problems with exponent "e"
        /\b0x\.?[a-f\d_]+(?:(?!\.\.)\.[a-f\d_]*)?(?:p[+-]?[a-f\d_]+)?[ulfi]{0,4}/i,
        {
          pattern: /((?:\.\.)?)(?:\b0b\.?|\b|\.)\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:e[+-]?\d[\d_]*)?[ulfi]{0,4}/i,
          lookbehind: !0
        }
      ],
      operator: /\|[|=]?|&[&=]?|\+[+=]?|-[-=]?|\.?\.\.|=[>=]?|!(?:i[ns]\b|<>?=?|>=?|=)?|\bi[ns]\b|(?:<[<>]?|>>?>?|\^\^|[*\/%^~])=?/
    }), t.languages.insertBefore("d", "string", {
      // Characters
      // 'a', '\\', '\n', '\xFF', '\377', '\uFFFF', '\U0010FFFF', '\quot'
      char: /'(?:\\(?:\W|\w+)|[^\\])'/
    }), t.languages.insertBefore("d", "keyword", {
      property: /\B@\w*/
    }), t.languages.insertBefore("d", "function", {
      register: {
        // Iasm registers
        pattern: /\b(?:[ABCD][LHX]|E?(?:BP|DI|SI|SP)|[BS]PL|[ECSDGF]S|CR[0234]|[DS]IL|DR[012367]|E[ABCD]X|X?MM[0-7]|R(?:1[0-5]|[89])[BWD]?|R[ABCD]X|R[BS]P|R[DS]I|TR[3-7]|XMM(?:1[0-5]|[89])|YMM(?:1[0-5]|\d))\b|\bST(?:\([0-7]\)|\b)/,
        alias: "variable"
      }
    });
  }
  return d_1;
}
var dart_1, hasRequiredDart;
function requireDart() {
  if (hasRequiredDart) return dart_1;
  hasRequiredDart = 1, dart_1 = e, e.displayName = "dart", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = [/\b(?:async|sync|yield)\*/, /\b(?:abstract|assert|async|await|break|case|catch|class|const|continue|covariant|default|deferred|do|dynamic|else|enum|export|extends|extension|external|factory|final|finally|for|get|hide|if|implements|import|in|interface|library|mixin|new|null|on|operator|part|rethrow|return|set|show|static|super|switch|sync|this|throw|try|typedef|var|void|while|with|yield)\b/], o = /(^|[^\w.])(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source, u = {
        pattern: RegExp(o + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
        lookbehind: !0,
        inside: {
          namespace: {
            pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
            inside: {
              punctuation: /\./
            }
          }
        }
      };
      r.languages.dart = r.languages.extend("clike", {
        "class-name": [u, {
          // variables and parameters
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(o + /[A-Z]\w*(?=\s+\w+\s*[;,=()])/.source),
          lookbehind: !0,
          inside: u.inside
        }],
        keyword: a,
        operator: /\bis!|\b(?:as|is)\b|\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?/
      }), r.languages.insertBefore("dart", "string", {
        "string-literal": {
          pattern: /r?(?:("""|''')[\s\S]*?\1|(["'])(?:\\.|(?!\2)[^\\\r\n])*\2(?!\2))/,
          greedy: !0,
          inside: {
            interpolation: {
              pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
              lookbehind: !0,
              inside: {
                punctuation: /^\$\{?|\}$/,
                expression: {
                  pattern: /[\s\S]+/,
                  inside: r.languages.dart
                }
              }
            },
            string: /[\s\S]+/
          }
        },
        string: void 0
      }), r.languages.insertBefore("dart", "class-name", {
        metadata: {
          pattern: /@\w+/,
          alias: "function"
        }
      }), r.languages.insertBefore("dart", "class-name", {
        generics: {
          pattern: /<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<[\w\s,.&?]*>)*>)*>)*>/,
          inside: {
            "class-name": u,
            keyword: a,
            punctuation: /[<>(),.:]/,
            operator: /[?&|]/
          }
        }
      });
    })(t);
  }
  return dart_1;
}
var dataweave_1, hasRequiredDataweave;
function requireDataweave() {
  if (hasRequiredDataweave) return dataweave_1;
  hasRequiredDataweave = 1, dataweave_1 = e, e.displayName = "dataweave", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.dataweave = {
        url: /\b[A-Za-z]+:\/\/[\w/:.?=&-]+|\burn:[\w:.?=&-]+/,
        property: {
          pattern: /(?:\b\w+#)?(?:"(?:\\.|[^\\"\r\n])*"|\b\w+)(?=\s*[:@])/,
          greedy: !0
        },
        string: {
          pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
          greedy: !0
        },
        "mime-type": /\b(?:application|audio|image|multipart|text|video)\/[\w+-]+/,
        date: {
          pattern: /\|[\w:+-]+\|/,
          greedy: !0
        },
        comment: [{
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: !0,
          greedy: !0
        }, {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }],
        regex: {
          pattern: /\/(?:[^\\\/\r\n]|\\[^\r\n])+\//,
          greedy: !0
        },
        keyword: /\b(?:and|as|at|case|do|else|fun|if|input|is|match|not|ns|null|or|output|type|unless|update|using|var)\b/,
        function: /\b[A-Z_]\w*(?=\s*\()/i,
        number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
        punctuation: /[{}[\];(),.:@]/,
        operator: /<<|>>|->|[<>~=]=?|!=|--?-?|\+\+?|!|\?/,
        boolean: /\b(?:false|true)\b/
      };
    })(t);
  }
  return dataweave_1;
}
var dax_1, hasRequiredDax;
function requireDax() {
  if (hasRequiredDax) return dax_1;
  hasRequiredDax = 1, dax_1 = e, e.displayName = "dax", e.aliases = [];
  function e(t) {
    t.languages.dax = {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/).*)/,
        lookbehind: !0
      },
      "data-field": {
        pattern: /'(?:[^']|'')*'(?!')(?:\[[ \w\xA0-\uFFFF]+\])?|\w+\[[ \w\xA0-\uFFFF]+\]/,
        alias: "symbol"
      },
      measure: {
        pattern: /\[[ \w\xA0-\uFFFF]+\]/,
        alias: "constant"
      },
      string: {
        pattern: /"(?:[^"]|"")*"(?!")/,
        greedy: !0
      },
      function: /\b(?:ABS|ACOS|ACOSH|ACOT|ACOTH|ADDCOLUMNS|ADDMISSINGITEMS|ALL|ALLCROSSFILTERED|ALLEXCEPT|ALLNOBLANKROW|ALLSELECTED|AND|APPROXIMATEDISTINCTCOUNT|ASIN|ASINH|ATAN|ATANH|AVERAGE|AVERAGEA|AVERAGEX|BETA\.DIST|BETA\.INV|BLANK|CALCULATE|CALCULATETABLE|CALENDAR|CALENDARAUTO|CEILING|CHISQ\.DIST|CHISQ\.DIST\.RT|CHISQ\.INV|CHISQ\.INV\.RT|CLOSINGBALANCEMONTH|CLOSINGBALANCEQUARTER|CLOSINGBALANCEYEAR|COALESCE|COMBIN|COMBINA|COMBINEVALUES|CONCATENATE|CONCATENATEX|CONFIDENCE\.NORM|CONFIDENCE\.T|CONTAINS|CONTAINSROW|CONTAINSSTRING|CONTAINSSTRINGEXACT|CONVERT|COS|COSH|COT|COTH|COUNT|COUNTA|COUNTAX|COUNTBLANK|COUNTROWS|COUNTX|CROSSFILTER|CROSSJOIN|CURRENCY|CURRENTGROUP|CUSTOMDATA|DATATABLE|DATE|DATEADD|DATEDIFF|DATESBETWEEN|DATESINPERIOD|DATESMTD|DATESQTD|DATESYTD|DATEVALUE|DAY|DEGREES|DETAILROWS|DISTINCT|DISTINCTCOUNT|DISTINCTCOUNTNOBLANK|DIVIDE|EARLIER|EARLIEST|EDATE|ENDOFMONTH|ENDOFQUARTER|ENDOFYEAR|EOMONTH|ERROR|EVEN|EXACT|EXCEPT|EXP|EXPON\.DIST|FACT|FALSE|FILTER|FILTERS|FIND|FIRSTDATE|FIRSTNONBLANK|FIRSTNONBLANKVALUE|FIXED|FLOOR|FORMAT|GCD|GENERATE|GENERATEALL|GENERATESERIES|GEOMEAN|GEOMEANX|GROUPBY|HASONEFILTER|HASONEVALUE|HOUR|IF|IF\.EAGER|IFERROR|IGNORE|INT|INTERSECT|ISBLANK|ISCROSSFILTERED|ISEMPTY|ISERROR|ISEVEN|ISFILTERED|ISINSCOPE|ISLOGICAL|ISNONTEXT|ISNUMBER|ISO\.CEILING|ISODD|ISONORAFTER|ISSELECTEDMEASURE|ISSUBTOTAL|ISTEXT|KEEPFILTERS|KEYWORDMATCH|LASTDATE|LASTNONBLANK|LASTNONBLANKVALUE|LCM|LEFT|LEN|LN|LOG|LOG10|LOOKUPVALUE|LOWER|MAX|MAXA|MAXX|MEDIAN|MEDIANX|MID|MIN|MINA|MINUTE|MINX|MOD|MONTH|MROUND|NATURALINNERJOIN|NATURALLEFTOUTERJOIN|NEXTDAY|NEXTMONTH|NEXTQUARTER|NEXTYEAR|NONVISUAL|NORM\.DIST|NORM\.INV|NORM\.S\.DIST|NORM\.S\.INV|NOT|NOW|ODD|OPENINGBALANCEMONTH|OPENINGBALANCEQUARTER|OPENINGBALANCEYEAR|OR|PARALLELPERIOD|PATH|PATHCONTAINS|PATHITEM|PATHITEMREVERSE|PATHLENGTH|PERCENTILE\.EXC|PERCENTILE\.INC|PERCENTILEX\.EXC|PERCENTILEX\.INC|PERMUT|PI|POISSON\.DIST|POWER|PREVIOUSDAY|PREVIOUSMONTH|PREVIOUSQUARTER|PREVIOUSYEAR|PRODUCT|PRODUCTX|QUARTER|QUOTIENT|RADIANS|RAND|RANDBETWEEN|RANK\.EQ|RANKX|RELATED|RELATEDTABLE|REMOVEFILTERS|REPLACE|REPT|RIGHT|ROLLUP|ROLLUPADDISSUBTOTAL|ROLLUPGROUP|ROLLUPISSUBTOTAL|ROUND|ROUNDDOWN|ROUNDUP|ROW|SAMEPERIODLASTYEAR|SAMPLE|SEARCH|SECOND|SELECTCOLUMNS|SELECTEDMEASURE|SELECTEDMEASUREFORMATSTRING|SELECTEDMEASURENAME|SELECTEDVALUE|SIGN|SIN|SINH|SQRT|SQRTPI|STARTOFMONTH|STARTOFQUARTER|STARTOFYEAR|STDEV\.P|STDEV\.S|STDEVX\.P|STDEVX\.S|SUBSTITUTE|SUBSTITUTEWITHINDEX|SUM|SUMMARIZE|SUMMARIZECOLUMNS|SUMX|SWITCH|T\.DIST|T\.DIST\.2T|T\.DIST\.RT|T\.INV|T\.INV\.2T|TAN|TANH|TIME|TIMEVALUE|TODAY|TOPN|TOPNPERLEVEL|TOPNSKIP|TOTALMTD|TOTALQTD|TOTALYTD|TREATAS|TRIM|TRUE|TRUNC|UNICHAR|UNICODE|UNION|UPPER|USERELATIONSHIP|USERNAME|USEROBJECTID|USERPRINCIPALNAME|UTCNOW|UTCTODAY|VALUE|VALUES|VAR\.P|VAR\.S|VARX\.P|VARX\.S|WEEKDAY|WEEKNUM|XIRR|XNPV|YEAR|YEARFRAC)(?=\s*\()/i,
      keyword: /\b(?:DEFINE|EVALUATE|MEASURE|ORDER\s+BY|RETURN|VAR|START\s+AT|ASC|DESC)\b/i,
      boolean: {
        pattern: /\b(?:FALSE|NULL|TRUE)\b/i,
        alias: "constant"
      },
      number: /\b\d+(?:\.\d*)?|\B\.\d+\b/,
      operator: /:=|[-+*\/=^]|&&?|\|\||<(?:=>?|<|>)?|>[>=]?|\b(?:IN|NOT)\b/i,
      punctuation: /[;\[\](){}`,.]/
    };
  }
  return dax_1;
}
var dhall_1, hasRequiredDhall;
function requireDhall() {
  if (hasRequiredDhall) return dhall_1;
  hasRequiredDhall = 1, dhall_1 = e, e.displayName = "dhall", e.aliases = [];
  function e(t) {
    t.languages.dhall = {
      // Multi-line comments can be nested. E.g. {- foo {- bar -} -}
      // The multi-line pattern is essentially this:
      //   \{-(?:[^-{]|-(?!\})|\{(?!-)|<SELF>)*-\}
      comment: /--.*|\{-(?:[^-{]|-(?!\})|\{(?!-)|\{-(?:[^-{]|-(?!\})|\{(?!-))*-\})*-\}/,
      string: {
        pattern: /"(?:[^"\\]|\\.)*"|''(?:[^']|'(?!')|'''|''\$\{)*''(?!'|\$)/,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /\$\{[^{}]*\}/,
            inside: {
              expression: {
                pattern: /(^\$\{)[\s\S]+(?=\}$)/,
                lookbehind: !0,
                alias: "language-dhall",
                inside: null
                // see blow
              },
              punctuation: /\$\{|\}/
            }
          }
        }
      },
      label: {
        pattern: /`[^`]*`/,
        greedy: !0
      },
      url: {
        // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L596
        pattern: /\bhttps?:\/\/[\w.:%!$&'*+;=@~-]+(?:\/[\w.:%!$&'*+;=@~-]*)*(?:\?[/?\w.:%!$&'*+;=@~-]*)?/,
        greedy: !0
      },
      env: {
        // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L661
        pattern: /\benv:(?:(?!\d)\w+|"(?:[^"\\=]|\\.)*")/,
        greedy: !0,
        inside: {
          function: /^env/,
          operator: /^:/,
          variable: /[\s\S]+/
        }
      },
      hash: {
        // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L725
        pattern: /\bsha256:[\da-fA-F]{64}\b/,
        inside: {
          function: /sha256/,
          operator: /:/,
          number: /[\da-fA-F]{64}/
        }
      },
      // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L359
      keyword: /\b(?:as|assert|else|forall|if|in|let|merge|missing|then|toMap|using|with)\b|\u2200/,
      builtin: /\b(?:None|Some)\b/,
      boolean: /\b(?:False|True)\b/,
      number: /\bNaN\b|-?\bInfinity\b|[+-]?\b(?:0x[\da-fA-F]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/,
      operator: /\/\\|\/\/\\\\|&&|\|\||===|[!=]=|\/\/|->|\+\+|::|[+*#@=:?<>|\\\u2227\u2a53\u2261\u2afd\u03bb\u2192]/,
      punctuation: /\.\.|[{}\[\](),./]/,
      // we'll just assume that every capital word left is a type name
      "class-name": /\b[A-Z]\w*\b/
    }, t.languages.dhall.string.inside.interpolation.inside.expression.inside = t.languages.dhall;
  }
  return dhall_1;
}
var diff_1, hasRequiredDiff;
function requireDiff() {
  if (hasRequiredDiff) return diff_1;
  hasRequiredDiff = 1, diff_1 = e, e.displayName = "diff", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.diff = {
        coord: [
          // Match all kinds of coord lines (prefixed by "+++", "---" or "***").
          /^(?:\*{3}|-{3}|\+{3}).*$/m,
          // Match "@@ ... @@" coord lines in unified diff.
          /^@@.*@@$/m,
          // Match coord lines in normal diff (starts with a number).
          /^\d.*$/m
        ]
        // deleted, inserted, unchanged, diff
      };
      var a = {
        "deleted-sign": "-",
        "deleted-arrow": "<",
        "inserted-sign": "+",
        "inserted-arrow": ">",
        unchanged: " ",
        diff: "!"
      };
      Object.keys(a).forEach(function(o) {
        var u = a[o], c = [];
        /^\w+$/.test(o) || c.push(/\w+/.exec(o)[0]), o === "diff" && c.push("bold"), r.languages.diff[o] = {
          pattern: RegExp("^(?:[" + u + `].*(?:\r
?|
|(?![\\s\\S])))+`, "m"),
          alias: c,
          inside: {
            line: {
              pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
              lookbehind: !0
            },
            prefix: {
              pattern: /[\s\S]/,
              alias: /\w+/.exec(o)[0]
            }
          }
        };
      }), Object.defineProperty(r.languages.diff, "PREFIXES", {
        value: a
      });
    })(t);
  }
  return diff_1;
}
var markupTemplating_1, hasRequiredMarkupTemplating;
function requireMarkupTemplating() {
  if (hasRequiredMarkupTemplating) return markupTemplating_1;
  hasRequiredMarkupTemplating = 1, markupTemplating_1 = e, e.displayName = "markupTemplating", e.aliases = [];
  function e(t) {
    (function(r) {
      function a(o, u) {
        return "___" + o.toUpperCase() + u + "___";
      }
      Object.defineProperties(r.languages["markup-templating"] = {}, {
        buildPlaceholders: {
          /**
           * Tokenize all inline templating expressions matching `placeholderPattern`.
           *
           * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
           * `true` will be replaced.
           *
           * @param {object} env The environment of the `before-tokenize` hook.
           * @param {string} language The language id.
           * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
           * @param {(match: string) => boolean} [replaceFilter]
           */
          value: function(o, u, c, d) {
            if (o.language === u) {
              var g = o.tokenStack = [];
              o.code = o.code.replace(c, function(b) {
                if (typeof d == "function" && !d(b))
                  return b;
                for (var _ = g.length, y; o.code.indexOf(y = a(u, _)) !== -1; )
                  ++_;
                return g[_] = b, y;
              }), o.grammar = r.languages.markup;
            }
          }
        },
        tokenizePlaceholders: {
          /**
           * Replace placeholders with proper tokens after tokenizing.
           *
           * @param {object} env The environment of the `after-tokenize` hook.
           * @param {string} language The language id.
           */
          value: function(o, u) {
            if (o.language !== u || !o.tokenStack)
              return;
            o.grammar = r.languages[u];
            var c = 0, d = Object.keys(o.tokenStack);
            function g(b) {
              for (var _ = 0; _ < b.length && !(c >= d.length); _++) {
                var y = b[_];
                if (typeof y == "string" || y.content && typeof y.content == "string") {
                  var A = d[c], E = o.tokenStack[A], v = typeof y == "string" ? y : y.content, C = a(u, A), R = v.indexOf(C);
                  if (R > -1) {
                    ++c;
                    var I = v.substring(0, R), w = new r.Token(u, r.tokenize(E, o.grammar), "language-" + u, E), N = v.substring(R + C.length), F = [];
                    I && F.push.apply(F, g([I])), F.push(w), N && F.push.apply(F, g([N])), typeof y == "string" ? b.splice.apply(b, [_, 1].concat(F)) : y.content = F;
                  }
                } else y.content && g(y.content);
              }
              return b;
            }
            g(o.tokens);
          }
        }
      });
    })(t);
  }
  return markupTemplating_1;
}
var django_1, hasRequiredDjango;
function requireDjango() {
  if (hasRequiredDjango) return django_1;
  hasRequiredDjango = 1;
  var e = requireMarkupTemplating();
  django_1 = t, t.displayName = "django", t.aliases = ["jinja2"];
  function t(r) {
    r.register(e), function(a) {
      a.languages.django = {
        comment: /^\{#[\s\S]*?#\}$/,
        tag: {
          pattern: /(^\{%[+-]?\s*)\w+/,
          lookbehind: !0,
          alias: "keyword"
        },
        delimiter: {
          pattern: /^\{[{%][+-]?|[+-]?[}%]\}$/,
          alias: "punctuation"
        },
        string: {
          pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
          greedy: !0
        },
        filter: {
          pattern: /(\|)\w+/,
          lookbehind: !0,
          alias: "function"
        },
        test: {
          pattern: /(\bis\s+(?:not\s+)?)(?!not\b)\w+/,
          lookbehind: !0,
          alias: "function"
        },
        function: /\b[a-z_]\w+(?=\s*\()/i,
        keyword: /\b(?:and|as|by|else|for|if|import|in|is|loop|not|or|recursive|with|without)\b/,
        operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
        number: /\b\d+(?:\.\d+)?\b/,
        boolean: /[Ff]alse|[Nn]one|[Tt]rue/,
        variable: /\b\w+\b/,
        punctuation: /[{}[\](),.:;]/
      };
      var o = /\{\{[\s\S]*?\}\}|\{%[\s\S]*?%\}|\{#[\s\S]*?#\}/g, u = a.languages["markup-templating"];
      a.hooks.add("before-tokenize", function(c) {
        u.buildPlaceholders(c, "django", o);
      }), a.hooks.add("after-tokenize", function(c) {
        u.tokenizePlaceholders(c, "django");
      }), a.languages.jinja2 = a.languages.django, a.hooks.add("before-tokenize", function(c) {
        u.buildPlaceholders(c, "jinja2", o);
      }), a.hooks.add("after-tokenize", function(c) {
        u.tokenizePlaceholders(c, "jinja2");
      });
    }(r);
  }
  return django_1;
}
var dnsZoneFile_1, hasRequiredDnsZoneFile;
function requireDnsZoneFile() {
  if (hasRequiredDnsZoneFile) return dnsZoneFile_1;
  hasRequiredDnsZoneFile = 1, dnsZoneFile_1 = e, e.displayName = "dnsZoneFile", e.aliases = [];
  function e(t) {
    t.languages["dns-zone-file"] = {
      comment: /;.*/,
      string: {
        pattern: /"(?:\\.|[^"\\\r\n])*"/,
        greedy: !0
      },
      variable: [{
        pattern: /(^\$ORIGIN[ \t]+)\S+/m,
        lookbehind: !0
      }, {
        pattern: /(^|\s)@(?=\s|$)/,
        lookbehind: !0
      }],
      keyword: /^\$(?:INCLUDE|ORIGIN|TTL)(?=\s|$)/m,
      class: {
        // https://tools.ietf.org/html/rfc1035#page-13
        pattern: /(^|\s)(?:CH|CS|HS|IN)(?=\s|$)/,
        lookbehind: !0,
        alias: "keyword"
      },
      type: {
        // https://en.wikipedia.org/wiki/List_of_DNS_record_types
        pattern: /(^|\s)(?:A|A6|AAAA|AFSDB|APL|ATMA|CAA|CDNSKEY|CDS|CERT|CNAME|DHCID|DLV|DNAME|DNSKEY|DS|EID|GID|GPOS|HINFO|HIP|IPSECKEY|ISDN|KEY|KX|LOC|MAILA|MAILB|MB|MD|MF|MG|MINFO|MR|MX|NAPTR|NB|NBSTAT|NIMLOC|NINFO|NS|NSAP|NSAP-PTR|NSEC|NSEC3|NSEC3PARAM|NULL|NXT|OPENPGPKEY|PTR|PX|RKEY|RP|RRSIG|RT|SIG|SINK|SMIMEA|SOA|SPF|SRV|SSHFP|TA|TKEY|TLSA|TSIG|TXT|UID|UINFO|UNSPEC|URI|WKS|X25)(?=\s|$)/,
        lookbehind: !0,
        alias: "keyword"
      },
      punctuation: /[()]/
    }, t.languages["dns-zone"] = t.languages["dns-zone-file"];
  }
  return dnsZoneFile_1;
}
var docker_1, hasRequiredDocker;
function requireDocker() {
  if (hasRequiredDocker) return docker_1;
  hasRequiredDocker = 1, docker_1 = e, e.displayName = "docker", e.aliases = ["dockerfile"];
  function e(t) {
    (function(r) {
      var a = /\\[\r\n](?:\s|\\[\r\n]|#.*(?!.))*(?![\s#]|\\[\r\n])/.source, o = /(?:[ \t]+(?![ \t])(?:<SP_BS>)?|<SP_BS>)/.source.replace(/<SP_BS>/g, function() {
        return a;
      }), u = /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"|'(?:[^'\\\r\n]|\\(?:\r\n|[\s\S]))*'/.source, c = /--[\w-]+=(?:<STR>|(?!["'])(?:[^\s\\]|\\.)+)/.source.replace(/<STR>/g, function() {
        return u;
      }), d = {
        pattern: RegExp(u),
        greedy: !0
      }, g = {
        pattern: /(^[ \t]*)#.*/m,
        lookbehind: !0,
        greedy: !0
      };
      function b(_, y) {
        return _ = _.replace(/<OPT>/g, function() {
          return c;
        }).replace(/<SP>/g, function() {
          return o;
        }), RegExp(_, y);
      }
      r.languages.docker = {
        instruction: {
          pattern: /(^[ \t]*)(?:ADD|ARG|CMD|COPY|ENTRYPOINT|ENV|EXPOSE|FROM|HEALTHCHECK|LABEL|MAINTAINER|ONBUILD|RUN|SHELL|STOPSIGNAL|USER|VOLUME|WORKDIR)(?=\s)(?:\\.|[^\r\n\\])*(?:\\$(?:\s|#.*$)*(?![\s#])(?:\\.|[^\r\n\\])*)*/im,
          lookbehind: !0,
          greedy: !0,
          inside: {
            options: {
              pattern: b(/(^(?:ONBUILD<SP>)?\w+<SP>)<OPT>(?:<SP><OPT>)*/.source, "i"),
              lookbehind: !0,
              greedy: !0,
              inside: {
                property: {
                  pattern: /(^|\s)--[\w-]+/,
                  lookbehind: !0
                },
                string: [d, {
                  pattern: /(=)(?!["'])(?:[^\s\\]|\\.)+/,
                  lookbehind: !0
                }],
                operator: /\\$/m,
                punctuation: /=/
              }
            },
            keyword: [{
              // https://docs.docker.com/engine/reference/builder/#healthcheck
              pattern: b(/(^(?:ONBUILD<SP>)?HEALTHCHECK<SP>(?:<OPT><SP>)*)(?:CMD|NONE)\b/.source, "i"),
              lookbehind: !0,
              greedy: !0
            }, {
              // https://docs.docker.com/engine/reference/builder/#from
              pattern: b(/(^(?:ONBUILD<SP>)?FROM<SP>(?:<OPT><SP>)*(?!--)[^ \t\\]+<SP>)AS/.source, "i"),
              lookbehind: !0,
              greedy: !0
            }, {
              // https://docs.docker.com/engine/reference/builder/#onbuild
              pattern: b(/(^ONBUILD<SP>)\w+/.source, "i"),
              lookbehind: !0,
              greedy: !0
            }, {
              pattern: /^\w+/,
              greedy: !0
            }],
            comment: g,
            string: d,
            variable: /\$(?:\w+|\{[^{}"'\\]*\})/,
            operator: /\\$/m
          }
        },
        comment: g
      }, r.languages.dockerfile = r.languages.docker;
    })(t);
  }
  return docker_1;
}
var dot_1, hasRequiredDot;
function requireDot() {
  if (hasRequiredDot) return dot_1;
  hasRequiredDot = 1, dot_1 = e, e.displayName = "dot", e.aliases = ["gv"];
  function e(t) {
    (function(r) {
      var a = "(?:" + [
        // an identifier
        /[a-zA-Z_\x80-\uFFFF][\w\x80-\uFFFF]*/.source,
        // a number
        /-?(?:\.\d+|\d+(?:\.\d*)?)/.source,
        // a double-quoted string
        /"[^"\\]*(?:\\[\s\S][^"\\]*)*"/.source,
        // HTML-like string
        /<(?:[^<>]|(?!<!--)<(?:[^<>"']|"[^"]*"|'[^']*')+>|<!--(?:[^-]|-(?!->))*-->)*>/.source
      ].join("|") + ")", o = {
        markup: {
          pattern: /(^<)[\s\S]+(?=>$)/,
          lookbehind: !0,
          alias: ["language-markup", "language-html", "language-xml"],
          inside: r.languages.markup
        }
      };
      function u(c, d) {
        return RegExp(c.replace(/<ID>/g, function() {
          return a;
        }), d);
      }
      r.languages.dot = {
        comment: {
          pattern: /\/\/.*|\/\*[\s\S]*?\*\/|^#.*/m,
          greedy: !0
        },
        "graph-name": {
          pattern: u(/(\b(?:digraph|graph|subgraph)[ \t\r\n]+)<ID>/.source, "i"),
          lookbehind: !0,
          greedy: !0,
          alias: "class-name",
          inside: o
        },
        "attr-value": {
          pattern: u(/(=[ \t\r\n]*)<ID>/.source),
          lookbehind: !0,
          greedy: !0,
          inside: o
        },
        "attr-name": {
          pattern: u(/([\[;, \t\r\n])<ID>(?=[ \t\r\n]*=)/.source),
          lookbehind: !0,
          greedy: !0,
          inside: o
        },
        keyword: /\b(?:digraph|edge|graph|node|strict|subgraph)\b/i,
        "compass-point": {
          pattern: /(:[ \t\r\n]*)(?:[ewc_]|[ns][ew]?)(?![\w\x80-\uFFFF])/,
          lookbehind: !0,
          alias: "builtin"
        },
        node: {
          pattern: u(/(^|[^-.\w\x80-\uFFFF\\])<ID>/.source),
          lookbehind: !0,
          greedy: !0,
          inside: o
        },
        operator: /[=:]|-[->]/,
        punctuation: /[\[\]{};,]/
      }, r.languages.gv = r.languages.dot;
    })(t);
  }
  return dot_1;
}
var ebnf_1, hasRequiredEbnf;
function requireEbnf() {
  if (hasRequiredEbnf) return ebnf_1;
  hasRequiredEbnf = 1, ebnf_1 = e, e.displayName = "ebnf", e.aliases = [];
  function e(t) {
    t.languages.ebnf = {
      comment: /\(\*[\s\S]*?\*\)/,
      string: {
        pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
        greedy: !0
      },
      special: {
        pattern: /\?[^?\r\n]*\?/,
        greedy: !0,
        alias: "class-name"
      },
      definition: {
        pattern: /^([\t ]*)[a-z]\w*(?:[ \t]+[a-z]\w*)*(?=\s*=)/im,
        lookbehind: !0,
        alias: ["rule", "keyword"]
      },
      rule: /\b[a-z]\w*(?:[ \t]+[a-z]\w*)*\b/i,
      punctuation: /\([:/]|[:/]\)|[.,;()[\]{}]/,
      operator: /[-=|*/!]/
    };
  }
  return ebnf_1;
}
var editorconfig_1, hasRequiredEditorconfig;
function requireEditorconfig() {
  if (hasRequiredEditorconfig) return editorconfig_1;
  hasRequiredEditorconfig = 1, editorconfig_1 = e, e.displayName = "editorconfig", e.aliases = [];
  function e(t) {
    t.languages.editorconfig = {
      // https://editorconfig-specification.readthedocs.io
      comment: /[;#].*/,
      section: {
        pattern: /(^[ \t]*)\[.+\]/m,
        lookbehind: !0,
        alias: "selector",
        inside: {
          regex: /\\\\[\[\]{},!?.*]/,
          // Escape special characters with '\\'
          operator: /[!?]|\.\.|\*{1,2}/,
          punctuation: /[\[\]{},]/
        }
      },
      key: {
        pattern: /(^[ \t]*)[^\s=]+(?=[ \t]*=)/m,
        lookbehind: !0,
        alias: "attr-name"
      },
      value: {
        pattern: /=.*/,
        alias: "attr-value",
        inside: {
          punctuation: /^=/
        }
      }
    };
  }
  return editorconfig_1;
}
var eiffel_1, hasRequiredEiffel;
function requireEiffel() {
  if (hasRequiredEiffel) return eiffel_1;
  hasRequiredEiffel = 1, eiffel_1 = e, e.displayName = "eiffel", e.aliases = [];
  function e(t) {
    t.languages.eiffel = {
      comment: /--.*/,
      string: [
        // Aligned-verbatim-strings
        {
          pattern: /"([^[]*)\[[\s\S]*?\]\1"/,
          greedy: !0
        },
        // Non-aligned-verbatim-strings
        {
          pattern: /"([^{]*)\{[\s\S]*?\}\1"/,
          greedy: !0
        },
        // Single-line string
        {
          pattern: /"(?:%(?:(?!\n)\s)*\n\s*%|%\S|[^%"\r\n])*"/,
          greedy: !0
        }
      ],
      // normal char | special char | char code
      char: /'(?:%.|[^%'\r\n])+'/,
      keyword: /\b(?:across|agent|alias|all|and|as|assign|attached|attribute|check|class|convert|create|Current|debug|deferred|detachable|do|else|elseif|end|ensure|expanded|export|external|feature|from|frozen|if|implies|inherit|inspect|invariant|like|local|loop|not|note|obsolete|old|once|or|Precursor|redefine|rename|require|rescue|Result|retry|select|separate|some|then|undefine|until|variant|Void|when|xor)\b/i,
      boolean: /\b(?:False|True)\b/i,
      // Convention: class-names are always all upper-case characters
      "class-name": /\b[A-Z][\dA-Z_]*\b/,
      number: [
        // hexa | octal | bin
        /\b0[xcb][\da-f](?:_*[\da-f])*\b/i,
        // Decimal
        /(?:\b\d(?:_*\d)*)?\.(?:(?:\d(?:_*\d)*)?e[+-]?)?\d(?:_*\d)*\b|\b\d(?:_*\d)*\b\.?/i
      ],
      punctuation: /:=|<<|>>|\(\||\|\)|->|\.(?=\w)|[{}[\];(),:?]/,
      operator: /\\\\|\|\.\.\||\.\.|\/[~\/=]?|[><]=?|[-+*^=~]/
    };
  }
  return eiffel_1;
}
var ejs_1, hasRequiredEjs;
function requireEjs() {
  if (hasRequiredEjs) return ejs_1;
  hasRequiredEjs = 1;
  var e = requireMarkupTemplating();
  ejs_1 = t, t.displayName = "ejs", t.aliases = ["eta"];
  function t(r) {
    r.register(e), function(a) {
      a.languages.ejs = {
        delimiter: {
          pattern: /^<%[-_=]?|[-_]?%>$/,
          alias: "punctuation"
        },
        comment: /^#[\s\S]*/,
        "language-javascript": {
          pattern: /[\s\S]+/,
          inside: a.languages.javascript
        }
      }, a.hooks.add("before-tokenize", function(o) {
        var u = /<%(?!%)[\s\S]+?%>/g;
        a.languages["markup-templating"].buildPlaceholders(o, "ejs", u);
      }), a.hooks.add("after-tokenize", function(o) {
        a.languages["markup-templating"].tokenizePlaceholders(o, "ejs");
      }), a.languages.eta = a.languages.ejs;
    }(r);
  }
  return ejs_1;
}
var elixir_1, hasRequiredElixir;
function requireElixir() {
  if (hasRequiredElixir) return elixir_1;
  hasRequiredElixir = 1, elixir_1 = e, e.displayName = "elixir", e.aliases = [];
  function e(t) {
    t.languages.elixir = {
      doc: {
        pattern: /@(?:doc|moduledoc)\s+(?:("""|''')[\s\S]*?\1|("|')(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2)/,
        inside: {
          attribute: /^@\w+/,
          string: /['"][\s\S]+/
        }
      },
      comment: {
        pattern: /#.*/,
        greedy: !0
      },
      // ~r"""foo""" (multi-line), ~r'''foo''' (multi-line), ~r/foo/, ~r|foo|, ~r"foo", ~r'foo', ~r(foo), ~r[foo], ~r{foo}, ~r<foo>
      regex: {
        pattern: /~[rR](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|[^\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[uismxfr]*/,
        greedy: !0
      },
      string: [{
        // ~s"""foo""" (multi-line), ~s'''foo''' (multi-line), ~s/foo/, ~s|foo|, ~s"foo", ~s'foo', ~s(foo), ~s[foo], ~s{foo} (with interpolation care), ~s<foo>
        pattern: /~[cCsSwW](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|#\{[^}]+\}|#(?!\{)|[^#\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[csa]?/,
        greedy: !0,
        inside: {
          // See interpolation below
        }
      }, {
        pattern: /("""|''')[\s\S]*?\1/,
        greedy: !0,
        inside: {
          // See interpolation below
        }
      }, {
        // Multi-line strings are allowed
        pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0,
        inside: {
          // See interpolation below
        }
      }],
      atom: {
        // Look-behind prevents bad highlighting of the :: operator
        pattern: /(^|[^:]):\w+/,
        lookbehind: !0,
        alias: "symbol"
      },
      module: {
        pattern: /\b[A-Z]\w*\b/,
        alias: "class-name"
      },
      // Look-ahead prevents bad highlighting of the :: operator
      "attr-name": /\b\w+\??:(?!:)/,
      argument: {
        // Look-behind prevents bad highlighting of the && operator
        pattern: /(^|[^&])&\d+/,
        lookbehind: !0,
        alias: "variable"
      },
      attribute: {
        pattern: /@\w+/,
        alias: "variable"
      },
      function: /\b[_a-zA-Z]\w*[?!]?(?:(?=\s*(?:\.\s*)?\()|(?=\/\d))/,
      number: /\b(?:0[box][a-f\d_]+|\d[\d_]*)(?:\.[\d_]+)?(?:e[+-]?[\d_]+)?\b/i,
      keyword: /\b(?:after|alias|and|case|catch|cond|def(?:callback|delegate|exception|impl|macro|module|n|np|p|protocol|struct)?|do|else|end|fn|for|if|import|not|or|quote|raise|require|rescue|try|unless|unquote|use|when)\b/,
      boolean: /\b(?:false|nil|true)\b/,
      operator: [/\bin\b|&&?|\|[|>]?|\\\\|::|\.\.\.?|\+\+?|-[->]?|<[-=>]|>=|!==?|\B!|=(?:==?|[>~])?|[*\/^]/, {
        // We don't want to match <<
        pattern: /([^<])<(?!<)/,
        lookbehind: !0
      }, {
        // We don't want to match >>
        pattern: /([^>])>(?!>)/,
        lookbehind: !0
      }],
      punctuation: /<<|>>|[.,%\[\]{}()]/
    }, t.languages.elixir.string.forEach(function(r) {
      r.inside = {
        interpolation: {
          pattern: /#\{[^}]+\}/,
          inside: {
            delimiter: {
              pattern: /^#\{|\}$/,
              alias: "punctuation"
            },
            rest: t.languages.elixir
          }
        }
      };
    });
  }
  return elixir_1;
}
var elm_1, hasRequiredElm;
function requireElm() {
  if (hasRequiredElm) return elm_1;
  hasRequiredElm = 1, elm_1 = e, e.displayName = "elm", e.aliases = [];
  function e(t) {
    t.languages.elm = {
      comment: /--.*|\{-[\s\S]*?-\}/,
      char: {
        pattern: /'(?:[^\\'\r\n]|\\(?:[abfnrtv\\']|\d+|x[0-9a-fA-F]+|u\{[0-9a-fA-F]+\}))'/,
        greedy: !0
      },
      string: [{
        // Multiline strings are wrapped in triple ". Quotes may appear unescaped.
        pattern: /"""[\s\S]*?"""/,
        greedy: !0
      }, {
        pattern: /"(?:[^\\"\r\n]|\\.)*"/,
        greedy: !0
      }],
      "import-statement": {
        // The imported or hidden names are not included in this import
        // statement. This is because we want to highlight those exactly like
        // we do for the names in the program.
        pattern: /(^[\t ]*)import\s+[A-Z]\w*(?:\.[A-Z]\w*)*(?:\s+as\s+(?:[A-Z]\w*)(?:\.[A-Z]\w*)*)?(?:\s+exposing\s+)?/m,
        lookbehind: !0,
        inside: {
          keyword: /\b(?:as|exposing|import)\b/
        }
      },
      keyword: /\b(?:alias|as|case|else|exposing|if|in|infixl|infixr|let|module|of|then|type)\b/,
      // These are builtin variables only. Constructors are highlighted later as a constant.
      builtin: /\b(?:abs|acos|always|asin|atan|atan2|ceiling|clamp|compare|cos|curry|degrees|e|flip|floor|fromPolar|identity|isInfinite|isNaN|logBase|max|min|negate|never|not|pi|radians|rem|round|sin|sqrt|tan|toFloat|toPolar|toString|truncate|turns|uncurry|xor)\b/,
      // decimal integers and floating point numbers | hexadecimal integers
      number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0x[0-9a-f]+)\b/i,
      // Most of this is needed because of the meaning of a single '.'.
      // If it stands alone freely, it is the function composition.
      // It may also be a separator between a module name and an identifier => no
      // operator. If it comes together with other special characters it is an
      // operator too.
      // Valid operator characters in 0.18: +-/*=.$<>:&|^?%#@~!
      // Ref: https://groups.google.com/forum/#!msg/elm-dev/0AHSnDdkSkQ/E0SVU70JEQAJ
      operator: /\s\.\s|[+\-/*=.$<>:&|^?%#@~!]{2,}|[+\-/*=$<>:&|^?%#@~!]/,
      // In Elm, nearly everything is a variable, do not highlight these.
      hvariable: /\b(?:[A-Z]\w*\.)*[a-z]\w*\b/,
      constant: /\b(?:[A-Z]\w*\.)*[A-Z]\w*\b/,
      punctuation: /[{}[\]|(),.:]/
    };
  }
  return elm_1;
}
var erb_1, hasRequiredErb;
function requireErb() {
  if (hasRequiredErb) return erb_1;
  hasRequiredErb = 1;
  var e = requireRuby(), t = requireMarkupTemplating();
  erb_1 = r, r.displayName = "erb", r.aliases = [];
  function r(a) {
    a.register(e), a.register(t), function(o) {
      o.languages.erb = {
        delimiter: {
          pattern: /^(\s*)<%=?|%>(?=\s*$)/,
          lookbehind: !0,
          alias: "punctuation"
        },
        ruby: {
          pattern: /\s*\S[\s\S]*/,
          alias: "language-ruby",
          inside: o.languages.ruby
        }
      }, o.hooks.add("before-tokenize", function(u) {
        var c = /<%=?(?:[^\r\n]|[\r\n](?!=begin)|[\r\n]=begin\s(?:[^\r\n]|[\r\n](?!=end))*[\r\n]=end)+?%>/g;
        o.languages["markup-templating"].buildPlaceholders(u, "erb", c);
      }), o.hooks.add("after-tokenize", function(u) {
        o.languages["markup-templating"].tokenizePlaceholders(u, "erb");
      });
    }(a);
  }
  return erb_1;
}
var erlang_1, hasRequiredErlang;
function requireErlang() {
  if (hasRequiredErlang) return erlang_1;
  hasRequiredErlang = 1, erlang_1 = e, e.displayName = "erlang", e.aliases = [];
  function e(t) {
    t.languages.erlang = {
      comment: /%.+/,
      string: {
        pattern: /"(?:\\.|[^\\"\r\n])*"/,
        greedy: !0
      },
      "quoted-function": {
        pattern: /'(?:\\.|[^\\'\r\n])+'(?=\()/,
        alias: "function"
      },
      "quoted-atom": {
        pattern: /'(?:\\.|[^\\'\r\n])+'/,
        alias: "atom"
      },
      boolean: /\b(?:false|true)\b/,
      keyword: /\b(?:after|case|catch|end|fun|if|of|receive|try|when)\b/,
      number: [/\$\\?./, /\b\d+#[a-z0-9]+/i, /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i],
      function: /\b[a-z][\w@]*(?=\()/,
      variable: {
        // Look-behind is used to prevent wrong highlighting of atoms containing "@"
        pattern: /(^|[^@])(?:\b|\?)[A-Z_][\w@]*/,
        lookbehind: !0
      },
      operator: [/[=\/<>:]=|=[:\/]=|\+\+?|--?|[=*\/!]|\b(?:and|andalso|band|bnot|bor|bsl|bsr|bxor|div|not|or|orelse|rem|xor)\b/, {
        // We don't want to match <<
        pattern: /(^|[^<])<(?!<)/,
        lookbehind: !0
      }, {
        // We don't want to match >>
        pattern: /(^|[^>])>(?!>)/,
        lookbehind: !0
      }],
      atom: /\b[a-z][\w@]*/,
      punctuation: /[()[\]{}:;,.#|]|<<|>>/
    };
  }
  return erlang_1;
}
var lua_1, hasRequiredLua;
function requireLua() {
  if (hasRequiredLua) return lua_1;
  hasRequiredLua = 1, lua_1 = e, e.displayName = "lua", e.aliases = [];
  function e(t) {
    t.languages.lua = {
      comment: /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
      // \z may be used to skip the following space
      string: {
        pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
        greedy: !0
      },
      number: /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
      keyword: /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
      function: /(?!\d)\w+(?=\s*(?:[({]))/,
      operator: [/[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/, {
        // Match ".." but don't break "..."
        pattern: /(^|[^.])\.\.(?!\.)/,
        lookbehind: !0
      }],
      punctuation: /[\[\](){},;]|\.+|:+/
    };
  }
  return lua_1;
}
var etlua_1, hasRequiredEtlua;
function requireEtlua() {
  if (hasRequiredEtlua) return etlua_1;
  hasRequiredEtlua = 1;
  var e = requireLua(), t = requireMarkupTemplating();
  etlua_1 = r, r.displayName = "etlua", r.aliases = [];
  function r(a) {
    a.register(e), a.register(t), function(o) {
      o.languages.etlua = {
        delimiter: {
          pattern: /^<%[-=]?|-?%>$/,
          alias: "punctuation"
        },
        "language-lua": {
          pattern: /[\s\S]+/,
          inside: o.languages.lua
        }
      }, o.hooks.add("before-tokenize", function(u) {
        var c = /<%[\s\S]+?%>/g;
        o.languages["markup-templating"].buildPlaceholders(u, "etlua", c);
      }), o.hooks.add("after-tokenize", function(u) {
        o.languages["markup-templating"].tokenizePlaceholders(u, "etlua");
      });
    }(a);
  }
  return etlua_1;
}
var excelFormula_1, hasRequiredExcelFormula;
function requireExcelFormula() {
  if (hasRequiredExcelFormula) return excelFormula_1;
  hasRequiredExcelFormula = 1, excelFormula_1 = e, e.displayName = "excelFormula", e.aliases = [];
  function e(t) {
    t.languages["excel-formula"] = {
      comment: {
        pattern: /(\bN\(\s*)"(?:[^"]|"")*"(?=\s*\))/i,
        lookbehind: !0,
        greedy: !0
      },
      string: {
        pattern: /"(?:[^"]|"")*"(?!")/,
        greedy: !0
      },
      reference: {
        // https://www.ablebits.com/office-addins-blog/2015/12/08/excel-reference-another-sheet-workbook/
        // Sales!B2
        // 'Winter sales'!B2
        // [Sales.xlsx]Jan!B2:B5
        // D:\Reports\[Sales.xlsx]Jan!B2:B5
        // '[Sales.xlsx]Jan sales'!B2:B5
        // 'D:\Reports\[Sales.xlsx]Jan sales'!B2:B5
        pattern: /(?:'[^']*'|(?:[^\s()[\]{}<>*?"';,$&]*\[[^^\s()[\]{}<>*?"']+\])?\w+)!/,
        greedy: !0,
        alias: "string",
        inside: {
          operator: /!$/,
          punctuation: /'/,
          sheet: {
            pattern: /[^[\]]+$/,
            alias: "function"
          },
          file: {
            pattern: /\[[^[\]]+\]$/,
            inside: {
              punctuation: /[[\]]/
            }
          },
          path: /[\s\S]+/
        }
      },
      "function-name": {
        pattern: /\b[A-Z]\w*(?=\()/i,
        alias: "keyword"
      },
      range: {
        pattern: /\$?\b(?:[A-Z]+\$?\d+:\$?[A-Z]+\$?\d+|[A-Z]+:\$?[A-Z]+|\d+:\$?\d+)\b/i,
        alias: "property",
        inside: {
          operator: /:/,
          cell: /\$?[A-Z]+\$?\d+/i,
          column: /\$?[A-Z]+/i,
          row: /\$?\d+/
        }
      },
      cell: {
        // Excel is case insensitive, so the string "foo1" could be either a variable or a cell.
        // To combat this, we match cells case insensitive, if the contain at least one "$", and case sensitive otherwise.
        pattern: /\b[A-Z]+\d+\b|\$[A-Za-z]+\$?\d+\b|\b[A-Za-z]+\$\d+\b/,
        alias: "property"
      },
      number: /(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e[+-]?\d+)?\b/i,
      boolean: /\b(?:FALSE|TRUE)\b/i,
      operator: /[-+*/^%=&,]|<[=>]?|>=?/,
      punctuation: /[[\]();{}|]/
    }, t.languages.xlsx = t.languages.xls = t.languages["excel-formula"];
  }
  return excelFormula_1;
}
var factor_1, hasRequiredFactor;
function requireFactor() {
  if (hasRequiredFactor) return factor_1;
  hasRequiredFactor = 1, factor_1 = e, e.displayName = "factor", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = {
        function: /\b(?:BUGS?|FIX(?:MES?)?|NOTES?|TODOS?|XX+|HACKS?|WARN(?:ING)?|\?{2,}|!{2,})\b/
      }, o = {
        number: /\\[^\s']|%\w/
      }, u = {
        comment: [
          {
            // ! single-line exclamation point comments with whitespace after/around the !
            pattern: /(^|\s)(?:! .*|!$)/,
            lookbehind: !0,
            inside: a
          },
          /* from basis/multiline: */
          {
            // /* comment */, /* comment*/
            pattern: /(^|\s)\/\*\s[\s\S]*?\*\/(?=\s|$)/,
            lookbehind: !0,
            greedy: !0,
            inside: a
          },
          {
            // ![[ comment ]] , ![===[ comment]===]
            pattern: /(^|\s)!\[(={0,6})\[\s[\s\S]*?\]\2\](?=\s|$)/,
            lookbehind: !0,
            greedy: !0,
            inside: a
          }
        ],
        number: [{
          // basic base 10 integers 9, -9
          pattern: /(^|\s)[+-]?\d+(?=\s|$)/,
          lookbehind: !0
        }, {
          // base prefix integers 0b010 0o70 0xad 0d10 0XAD -0xa9
          pattern: /(^|\s)[+-]?0(?:b[01]+|o[0-7]+|d\d+|x[\dA-F]+)(?=\s|$)/i,
          lookbehind: !0
        }, {
          // fractional ratios 1/5 -1/5 and the literal float approximations 1/5. -1/5.
          pattern: /(^|\s)[+-]?\d+\/\d+\.?(?=\s|$)/,
          lookbehind: !0
        }, {
          // positive mixed numbers 23+1/5 +23+1/5
          pattern: /(^|\s)\+?\d+\+\d+\/\d+(?=\s|$)/,
          lookbehind: !0
        }, {
          // negative mixed numbers -23-1/5
          pattern: /(^|\s)-\d+-\d+\/\d+(?=\s|$)/,
          lookbehind: !0
        }, {
          // basic decimal floats -0.01 0. .0 .1 -.1 -1. -12.13 +12.13
          // and scientific notation with base 10 exponents 3e4 3e-4 .3e-4
          pattern: /(^|\s)[+-]?(?:\d*\.\d+|\d+\.\d*|\d+)(?:e[+-]?\d+)?(?=\s|$)/i,
          lookbehind: !0
        }, {
          // NAN literal syntax NAN: 80000deadbeef, NAN: a
          pattern: /(^|\s)NAN:\s+[\da-fA-F]+(?=\s|$)/,
          lookbehind: !0
        }, {
          /*
          base prefix floats 0x1.0p3 (8.0) 0b1.010p2 (5.0) 0x1.p1 0b1.11111111p11111...
          "The normalized hex form 0x1.MMMMMMMMMMMMM[pP]EEEE allows any floating-point number to be specified precisely.
          The values of MMMMMMMMMMMMM and EEEE map directly to the mantissa and exponent fields of the binary IEEE 754 representation."
          <https://docs.factorcode.org/content/article-syntax-floats.html>
          */
          pattern: /(^|\s)[+-]?0(?:b1\.[01]*|o1\.[0-7]*|d1\.\d*|x1\.[\dA-F]*)p\d+(?=\s|$)/i,
          lookbehind: !0
        }],
        // R/ regexp?\/\\/
        regexp: {
          pattern: /(^|\s)R\/\s(?:\\\S|[^\\/])*\/(?:[idmsr]*|[idmsr]+-[idmsr]+)(?=\s|$)/,
          lookbehind: !0,
          alias: "number",
          inside: {
            variable: /\\\S/,
            keyword: /[+?*\[\]^$(){}.|]/,
            operator: {
              pattern: /(\/)[idmsr]+(?:-[idmsr]+)?/,
              lookbehind: !0
            }
          }
        },
        boolean: {
          pattern: /(^|\s)[tf](?=\s|$)/,
          lookbehind: !0
        },
        // SBUF" asd", URL" ://...", P" /etc/"
        "custom-string": {
          pattern: /(^|\s)[A-Z0-9\-]+"\s(?:\\\S|[^"\\])*"/,
          lookbehind: !0,
          greedy: !0,
          alias: "string",
          inside: {
            number: /\\\S|%\w|\//
          }
        },
        "multiline-string": [{
          // STRING: name \n content \n ; -> CONSTANT: name "content" (symbol)
          pattern: /(^|\s)STRING:\s+\S+(?:\n|\r\n).*(?:\n|\r\n)\s*;(?=\s|$)/,
          lookbehind: !0,
          greedy: !0,
          alias: "string",
          inside: {
            number: o.number,
            // trailing semicolon on its own line
            "semicolon-or-setlocal": {
              pattern: /([\r\n][ \t]*);(?=\s|$)/,
              lookbehind: !0,
              alias: "function"
            }
          }
        }, {
          // HEREDOC: marker \n content \n marker ; -> "content" (immediate)
          pattern: /(^|\s)HEREDOC:\s+\S+(?:\n|\r\n).*(?:\n|\r\n)\s*\S+(?=\s|$)/,
          lookbehind: !0,
          greedy: !0,
          alias: "string",
          inside: o
        }, {
          // [[ string ]], [==[ string]==]
          pattern: /(^|\s)\[(={0,6})\[\s[\s\S]*?\]\2\](?=\s|$)/,
          lookbehind: !0,
          greedy: !0,
          alias: "string",
          inside: o
        }],
        "special-using": {
          pattern: /(^|\s)USING:(?:\s\S+)*(?=\s+;(?:\s|$))/,
          lookbehind: !0,
          alias: "function",
          inside: {
            // this is essentially a regex for vocab names, which i don't want to specify
            // but the USING: gets picked up as a vocab name
            string: {
              pattern: /(\s)[^:\s]+/,
              lookbehind: !0
            }
          }
        },
        /* this description of stack effect literal syntax is not complete and not as specific as theoretically possible
        trying to do better is more work and regex-computation-time than it's worth though.
        - we'd like to have the "delimiter" parts of the stack effect [ (, --, and ) ] be a different (less-important or comment-like) colour to the stack effect contents
        - we'd like if nested stack effects were treated as such rather than just appearing flat (with `inside`)
        - we'd like if the following variable name conventions were recognised specifically:
        special row variables = ..a b..
        type and stack effect annotations end with a colon = ( quot: ( a: ( -- ) -- b ) -- x ), ( x: number -- )
        word throws unconditional error = *
        any other word-like variable name = a ? q' etc
        https://docs.factorcode.org/content/article-effects.html
        these are pretty complicated to highlight properly without a real parser, and therefore out of scope
        the old pattern, which may be later useful, was: (^|\s)(?:call|execute|eval)?\((?:\s+[^"\r\n\t ]\S*)*?\s+--(?:\s+[^"\n\t ]\S*)*?\s+\)(?=\s|$)
        */
        // current solution is not great
        "stack-effect-delimiter": [{
          // opening parenthesis
          pattern: /(^|\s)(?:call|eval|execute)?\((?=\s)/,
          lookbehind: !0,
          alias: "operator"
        }, {
          // middle --
          pattern: /(\s)--(?=\s)/,
          lookbehind: !0,
          alias: "operator"
        }, {
          // closing parenthesis
          pattern: /(\s)\)(?=\s|$)/,
          lookbehind: !0,
          alias: "operator"
        }],
        combinators: {
          pattern: null,
          lookbehind: !0,
          alias: "keyword"
        },
        "kernel-builtin": {
          pattern: null,
          lookbehind: !0,
          alias: "variable"
        },
        "sequences-builtin": {
          pattern: null,
          lookbehind: !0,
          alias: "variable"
        },
        "math-builtin": {
          pattern: null,
          lookbehind: !0,
          alias: "variable"
        },
        "constructor-word": {
          // <array> but not <=>
          pattern: /(^|\s)<(?!=+>|-+>)\S+>(?=\s|$)/,
          lookbehind: !0,
          alias: "keyword"
        },
        "other-builtin-syntax": {
          pattern: null,
          lookbehind: !0,
          alias: "operator"
        },
        /*
        full list of supported word naming conventions: (the convention appears outside of the [brackets])
        set-[x]
        change-[x]
        with-[x]
        new-[x]
        >[string]
        [base]>
        [string]>[number]
        +[symbol]+
        [boolean-word]?
        ?[of]
        [slot-reader]>>
        >>[slot-setter]
        [slot-writer]<<
        ([implementation-detail])
        [mutater]!
        [variant]*
        [prettyprint].
        $[help-markup]
        <constructors>, SYNTAX:, etc are supported by their own patterns.
        `with` and `new` from `kernel` are their own builtins.
        see <https://docs.factorcode.org/content/article-conventions.html>
        */
        "conventionally-named-word": {
          pattern: /(^|\s)(?!")(?:(?:change|new|set|with)-\S+|\$\S+|>[^>\s]+|[^:>\s]+>|[^>\s]+>[^>\s]+|\+[^+\s]+\+|[^?\s]+\?|\?[^?\s]+|[^>\s]+>>|>>[^>\s]+|[^<\s]+<<|\([^()\s]+\)|[^!\s]+!|[^*\s]\S*\*|[^.\s]\S*\.)(?=\s|$)/,
          lookbehind: !0,
          alias: "keyword"
        },
        "colon-syntax": {
          pattern: /(^|\s)(?:[A-Z0-9\-]+#?)?:{1,2}\s+(?:;\S+|(?!;)\S+)(?=\s|$)/,
          lookbehind: !0,
          greedy: !0,
          alias: "function"
        },
        "semicolon-or-setlocal": {
          pattern: /(\s)(?:;|:>)(?=\s|$)/,
          lookbehind: !0,
          alias: "function"
        },
        // do not highlight leading } or trailing X{ at the begin/end of the file as it's invalid syntax
        "curly-brace-literal-delimiter": [{
          // opening
          pattern: /(^|\s)[a-z]*\{(?=\s)/i,
          lookbehind: !0,
          alias: "operator"
        }, {
          // closing
          pattern: /(\s)\}(?=\s|$)/,
          lookbehind: !0,
          alias: "operator"
        }],
        // do not highlight leading ] or trailing [ at the begin/end of the file as it's invalid syntax
        "quotation-delimiter": [{
          // opening
          pattern: /(^|\s)\[(?=\s)/,
          lookbehind: !0,
          alias: "operator"
        }, {
          // closing
          pattern: /(\s)\](?=\s|$)/,
          lookbehind: !0,
          alias: "operator"
        }],
        "normal-word": {
          pattern: /(^|\s)[^"\s]\S*(?=\s|$)/,
          lookbehind: !0
        },
        /*
        basic first-class string "a"
        with escaped double-quote "a\""
        escaped backslash "\\"
        and general escapes since Factor has so many "\N"
        syntax that works in the reference implementation that isn't fully
        supported because it's an implementation detail:
        "string 1""string 2" -> 2 strings (works anyway)
        "string"5 -> string, 5
        "string"[ ] -> string, quotation
        { "a"} -> array<string>
        the rest of those examples all properly recognise the string, but not
        the other object (number, quotation, etc)
        this is fine for a regex-only implementation.
        */
        string: {
          pattern: /"(?:\\\S|[^"\\])*"/,
          greedy: !0,
          inside: o
        }
      }, c = function(_) {
        return (_ + "").replace(/([.?*+\^$\[\]\\(){}|\-])/g, "\\$1");
      }, d = function(_) {
        return new RegExp("(^|\\s)(?:" + _.map(c).join("|") + ")(?=\\s|$)");
      }, g = {
        "kernel-builtin": ["or", "2nipd", "4drop", "tuck", "wrapper", "nip", "wrapper?", "callstack>array", "die", "dupd", "callstack", "callstack?", "3dup", "hashcode", "pick", "4nip", "build", ">boolean", "nipd", "clone", "5nip", "eq?", "?", "=", "swapd", "2over", "clear", "2dup", "get-retainstack", "not", "tuple?", "dup", "3nipd", "call", "-rotd", "object", "drop", "assert=", "assert?", "-rot", "execute", "boa", "get-callstack", "curried?", "3drop", "pickd", "overd", "over", "roll", "3nip", "swap", "and", "2nip", "rotd", "throw", "(clone)", "hashcode*", "spin", "reach", "4dup", "equal?", "get-datastack", "assert", "2drop", "<wrapper>", "boolean?", "identity-hashcode", "identity-tuple?", "null", "composed?", "new", "5drop", "rot", "-roll", "xor", "identity-tuple", "boolean"],
        "other-builtin-syntax": [
          // syntax
          "=======",
          "recursive",
          "flushable",
          ">>",
          "<<<<<<",
          "M\\",
          "B",
          "PRIVATE>",
          "\\",
          "======",
          "final",
          "inline",
          "delimiter",
          "deprecated",
          "<PRIVATE",
          ">>>>>>",
          "<<<<<<<",
          "parse-complex",
          "malformed-complex",
          "read-only",
          ">>>>>>>",
          "call-next-method",
          "<<",
          "foldable",
          // literals
          "$",
          "$[",
          "${"
        ],
        "sequences-builtin": ["member-eq?", "mismatch", "append", "assert-sequence=", "longer", "repetition", "clone-like", "3sequence", "assert-sequence?", "last-index-from", "reversed", "index-from", "cut*", "pad-tail", "join-as", "remove-eq!", "concat-as", "but-last", "snip", "nths", "nth", "sequence", "longest", "slice?", "<slice>", "remove-nth", "tail-slice", "empty?", "tail*", "member?", "virtual-sequence?", "set-length", "drop-prefix", "iota", "unclip", "bounds-error?", "unclip-last-slice", "non-negative-integer-expected", "non-negative-integer-expected?", "midpoint@", "longer?", "?set-nth", "?first", "rest-slice", "prepend-as", "prepend", "fourth", "sift", "subseq-start", "new-sequence", "?last", "like", "first4", "1sequence", "reverse", "slice", "virtual@", "repetition?", "set-last", "index", "4sequence", "max-length", "set-second", "immutable-sequence", "first2", "first3", "supremum", "unclip-slice", "suffix!", "insert-nth", "tail", "3append", "short", "suffix", "concat", "flip", "immutable?", "reverse!", "2sequence", "sum", "delete-all", "indices", "snip-slice", "<iota>", "check-slice", "sequence?", "head", "append-as", "halves", "sequence=", "collapse-slice", "?second", "slice-error?", "product", "bounds-check?", "bounds-check", "immutable", "virtual-exemplar", "harvest", "remove", "pad-head", "last", "set-fourth", "cartesian-product", "remove-eq", "shorten", "shorter", "reversed?", "shorter?", "shortest", "head-slice", "pop*", "tail-slice*", "but-last-slice", "iota?", "append!", "cut-slice", "new-resizable", "head-slice*", "sequence-hashcode", "pop", "set-nth", "?nth", "second", "join", "immutable-sequence?", "<reversed>", "3append-as", "virtual-sequence", "subseq?", "remove-nth!", "length", "last-index", "lengthen", "assert-sequence", "copy", "move", "third", "first", "tail?", "set-first", "prefix", "bounds-error", "<repetition>", "exchange", "surround", "cut", "min-length", "set-third", "push-all", "head?", "subseq-start-from", "delete-slice", "rest", "sum-lengths", "head*", "infimum", "remove!", "glue", "slice-error", "subseq", "push", "replace-slice", "subseq-as", "unclip-last"],
        "math-builtin": ["number=", "next-power-of-2", "?1+", "fp-special?", "imaginary-part", "float>bits", "number?", "fp-infinity?", "bignum?", "fp-snan?", "denominator", "gcd", "*", "+", "fp-bitwise=", "-", "u>=", "/", ">=", "bitand", "power-of-2?", "log2-expects-positive", "neg?", "<", "log2", ">", "integer?", "number", "bits>double", "2/", "zero?", "bits>float", "float?", "shift", "ratio?", "rect>", "even?", "ratio", "fp-sign", "bitnot", ">fixnum", "complex?", "/i", "integer>fixnum", "/f", "sgn", ">bignum", "next-float", "u<", "u>", "mod", "recip", "rational", ">float", "2^", "integer", "fixnum?", "neg", "fixnum", "sq", "bignum", ">rect", "bit?", "fp-qnan?", "simple-gcd", "complex", "<fp-nan>", "real", ">fraction", "double>bits", "bitor", "rem", "fp-nan-payload", "real-part", "log2-expects-positive?", "prev-float", "align", "unordered?", "float", "fp-nan?", "abs", "bitxor", "integer>fixnum-strict", "u<=", "odd?", "<=", "/mod", ">integer", "real?", "rational?", "numerator"]
        // that's all for now
      };
      Object.keys(g).forEach(function(_) {
        u[_].pattern = d(g[_]);
      });
      var b = [
        // kernel
        "2bi",
        "while",
        "2tri",
        "bi*",
        "4dip",
        "both?",
        "same?",
        "tri@",
        "curry",
        "prepose",
        "3bi",
        "?if",
        "tri*",
        "2keep",
        "3keep",
        "curried",
        "2keepd",
        "when",
        "2bi*",
        "2tri*",
        "4keep",
        "bi@",
        "keepdd",
        "do",
        "unless*",
        "tri-curry",
        "if*",
        "loop",
        "bi-curry*",
        "when*",
        "2bi@",
        "2tri@",
        "with",
        "2with",
        "either?",
        "bi",
        "until",
        "3dip",
        "3curry",
        "tri-curry*",
        "tri-curry@",
        "bi-curry",
        "keepd",
        "compose",
        "2dip",
        "if",
        "3tri",
        "unless",
        "tuple",
        "keep",
        "2curry",
        "tri",
        "most",
        "while*",
        "dip",
        "composed",
        "bi-curry@",
        // sequences
        "find-last-from",
        "trim-head-slice",
        "map-as",
        "each-from",
        "none?",
        "trim-tail",
        "partition",
        "if-empty",
        "accumulate*",
        "reject!",
        "find-from",
        "accumulate-as",
        "collector-for-as",
        "reject",
        "map",
        "map-sum",
        "accumulate!",
        "2each-from",
        "follow",
        "supremum-by",
        "map!",
        "unless-empty",
        "collector",
        "padding",
        "reduce-index",
        "replicate-as",
        "infimum-by",
        "trim-tail-slice",
        "count",
        "find-index",
        "filter",
        "accumulate*!",
        "reject-as",
        "map-integers",
        "map-find",
        "reduce",
        "selector",
        "interleave",
        "2map",
        "filter-as",
        "binary-reduce",
        "map-index-as",
        "find",
        "produce",
        "filter!",
        "replicate",
        "cartesian-map",
        "cartesian-each",
        "find-index-from",
        "map-find-last",
        "3map-as",
        "3map",
        "find-last",
        "selector-as",
        "2map-as",
        "2map-reduce",
        "accumulate",
        "each",
        "each-index",
        "accumulate*-as",
        "when-empty",
        "all?",
        "collector-as",
        "push-either",
        "new-like",
        "collector-for",
        "2selector",
        "push-if",
        "2all?",
        "map-reduce",
        "3each",
        "any?",
        "trim-slice",
        "2reduce",
        "change-nth",
        "produce-as",
        "2each",
        "trim",
        "trim-head",
        "cartesian-find",
        "map-index",
        // math
        "if-zero",
        "each-integer",
        "unless-zero",
        "(find-integer)",
        "when-zero",
        "find-last-integer",
        "(all-integers?)",
        "times",
        "(each-integer)",
        "find-integer",
        "all-integers?",
        // math.combinators
        "unless-negative",
        "if-positive",
        "when-positive",
        "when-negative",
        "unless-positive",
        "if-negative",
        // combinators
        "case",
        "2cleave",
        "cond>quot",
        "case>quot",
        "3cleave",
        "wrong-values",
        "to-fixed-point",
        "alist>quot",
        "cond",
        "cleave",
        "call-effect",
        "recursive-hashcode",
        "spread",
        "deep-spread>quot",
        // combinators.short-circuit
        "2||",
        "0||",
        "n||",
        "0&&",
        "2&&",
        "3||",
        "1||",
        "1&&",
        "n&&",
        "3&&",
        // combinators.smart
        "smart-unless*",
        "keep-inputs",
        "reduce-outputs",
        "smart-when*",
        "cleave>array",
        "smart-with",
        "smart-apply",
        "smart-if",
        "inputs/outputs",
        "output>sequence-n",
        "map-outputs",
        "map-reduce-outputs",
        "dropping",
        "output>array",
        "smart-map-reduce",
        "smart-2map-reduce",
        "output>array-n",
        "nullary",
        "input<sequence",
        "append-outputs",
        "drop-inputs",
        "inputs",
        "smart-2reduce",
        "drop-outputs",
        "smart-reduce",
        "preserving",
        "smart-when",
        "outputs",
        "append-outputs-as",
        "smart-unless",
        "smart-if*",
        "sum-outputs",
        "input<sequence-unsafe",
        "output>sequence"
        // tafn
      ];
      u.combinators.pattern = d(b), r.languages.factor = u;
    })(t);
  }
  return factor_1;
}
var _false, hasRequired_false;
function require_false() {
  if (hasRequired_false) return _false;
  hasRequired_false = 1, _false = e, e.displayName = "$false", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.false = {
        comment: {
          pattern: /\{[^}]*\}/
        },
        string: {
          pattern: /"[^"]*"/,
          greedy: !0
        },
        "character-code": {
          pattern: /'(?:[^\r]|\r\n?)/,
          alias: "number"
        },
        "assembler-code": {
          pattern: /\d+`/,
          alias: "important"
        },
        number: /\d+/,
        operator: /[-!#$%&'*+,./:;=>?@\\^_`|~]/,
        punctuation: /\[|\]/,
        variable: /[a-z]/,
        "non-standard": {
          pattern: /[()<BDO]/,
          alias: "bold"
        }
      };
    })(t);
  }
  return _false;
}
var firestoreSecurityRules_1, hasRequiredFirestoreSecurityRules;
function requireFirestoreSecurityRules() {
  if (hasRequiredFirestoreSecurityRules) return firestoreSecurityRules_1;
  hasRequiredFirestoreSecurityRules = 1, firestoreSecurityRules_1 = e, e.displayName = "firestoreSecurityRules", e.aliases = [];
  function e(t) {
    t.languages["firestore-security-rules"] = t.languages.extend("clike", {
      comment: /\/\/.*/,
      keyword: /\b(?:allow|function|if|match|null|return|rules_version|service)\b/,
      operator: /&&|\|\||[<>!=]=?|[-+*/%]|\b(?:in|is)\b/
    }), delete t.languages["firestore-security-rules"]["class-name"], t.languages.insertBefore("firestore-security-rules", "keyword", {
      path: {
        pattern: /(^|[\s(),])(?:\/(?:[\w\xA0-\uFFFF]+|\{[\w\xA0-\uFFFF]+(?:=\*\*)?\}|\$\([\w\xA0-\uFFFF.]+\)))+/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          variable: {
            pattern: /\{[\w\xA0-\uFFFF]+(?:=\*\*)?\}|\$\([\w\xA0-\uFFFF.]+\)/,
            inside: {
              operator: /=/,
              keyword: /\*\*/,
              punctuation: /[.$(){}]/
            }
          },
          punctuation: /\//
        }
      },
      method: {
        // to make the pattern shorter, the actual method names are omitted
        pattern: /(\ballow\s+)[a-z]+(?:\s*,\s*[a-z]+)*(?=\s*[:;])/,
        lookbehind: !0,
        alias: "builtin",
        inside: {
          punctuation: /,/
        }
      }
    });
  }
  return firestoreSecurityRules_1;
}
var flow_1, hasRequiredFlow;
function requireFlow() {
  if (hasRequiredFlow) return flow_1;
  hasRequiredFlow = 1, flow_1 = e, e.displayName = "flow", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.flow = r.languages.extend("javascript", {}), r.languages.insertBefore("flow", "keyword", {
        type: [{
          pattern: /\b(?:[Bb]oolean|Function|[Nn]umber|[Ss]tring|any|mixed|null|void)\b/,
          alias: "tag"
        }]
      }), r.languages.flow["function-variable"].pattern = /(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=\s*(?:function\b|(?:\([^()]*\)(?:\s*:\s*\w+)?|(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/i, delete r.languages.flow.parameter, r.languages.insertBefore("flow", "operator", {
        "flow-punctuation": {
          pattern: /\{\||\|\}/,
          alias: "punctuation"
        }
      }), Array.isArray(r.languages.flow.keyword) || (r.languages.flow.keyword = [r.languages.flow.keyword]), r.languages.flow.keyword.unshift({
        pattern: /(^|[^$]\b)(?:Class|declare|opaque|type)\b(?!\$)/,
        lookbehind: !0
      }, {
        pattern: /(^|[^$]\B)\$(?:Diff|Enum|Exact|Keys|ObjMap|PropertyType|Record|Shape|Subtype|Supertype|await)\b(?!\$)/,
        lookbehind: !0
      });
    })(t);
  }
  return flow_1;
}
var fortran_1, hasRequiredFortran;
function requireFortran() {
  if (hasRequiredFortran) return fortran_1;
  hasRequiredFortran = 1, fortran_1 = e, e.displayName = "fortran", e.aliases = [];
  function e(t) {
    t.languages.fortran = {
      "quoted-number": {
        pattern: /[BOZ](['"])[A-F0-9]+\1/i,
        alias: "number"
      },
      string: {
        pattern: /(?:\b\w+_)?(['"])(?:\1\1|&(?:\r\n?|\n)(?:[ \t]*!.*(?:\r\n?|\n)|(?![ \t]*!))|(?!\1).)*(?:\1|&)/,
        inside: {
          comment: {
            pattern: /(&(?:\r\n?|\n)\s*)!.*/,
            lookbehind: !0
          }
        }
      },
      comment: {
        pattern: /!.*/,
        greedy: !0
      },
      boolean: /\.(?:FALSE|TRUE)\.(?:_\w+)?/i,
      number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[ED][+-]?\d+)?(?:_\w+)?/i,
      keyword: [
        // Types
        /\b(?:CHARACTER|COMPLEX|DOUBLE ?PRECISION|INTEGER|LOGICAL|REAL)\b/i,
        // END statements
        /\b(?:END ?)?(?:BLOCK ?DATA|DO|FILE|FORALL|FUNCTION|IF|INTERFACE|MODULE(?! PROCEDURE)|PROGRAM|SELECT|SUBROUTINE|TYPE|WHERE)\b/i,
        // Statements
        /\b(?:ALLOCATABLE|ALLOCATE|BACKSPACE|CALL|CASE|CLOSE|COMMON|CONTAINS|CONTINUE|CYCLE|DATA|DEALLOCATE|DIMENSION|DO|END|EQUIVALENCE|EXIT|EXTERNAL|FORMAT|GO ?TO|IMPLICIT(?: NONE)?|INQUIRE|INTENT|INTRINSIC|MODULE PROCEDURE|NAMELIST|NULLIFY|OPEN|OPTIONAL|PARAMETER|POINTER|PRINT|PRIVATE|PUBLIC|READ|RETURN|REWIND|SAVE|SELECT|STOP|TARGET|WHILE|WRITE)\b/i,
        // Others
        /\b(?:ASSIGNMENT|DEFAULT|ELEMENTAL|ELSE|ELSEIF|ELSEWHERE|ENTRY|IN|INCLUDE|INOUT|KIND|NULL|ONLY|OPERATOR|OUT|PURE|RECURSIVE|RESULT|SEQUENCE|STAT|THEN|USE)\b/i
      ],
      operator: [/\*\*|\/\/|=>|[=\/]=|[<>]=?|::|[+\-*=%]|\.[A-Z]+\./i, {
        // Use lookbehind to prevent confusion with (/ /)
        pattern: /(^|(?!\().)\/(?!\))/,
        lookbehind: !0
      }],
      punctuation: /\(\/|\/\)|[(),;:&]/
    };
  }
  return fortran_1;
}
var fsharp_1, hasRequiredFsharp;
function requireFsharp() {
  if (hasRequiredFsharp) return fsharp_1;
  hasRequiredFsharp = 1, fsharp_1 = e, e.displayName = "fsharp", e.aliases = [];
  function e(t) {
    t.languages.fsharp = t.languages.extend("clike", {
      comment: [{
        pattern: /(^|[^\\])\(\*(?!\))[\s\S]*?\*\)/,
        lookbehind: !0,
        greedy: !0
      }, {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }],
      string: {
        pattern: /(?:"""[\s\S]*?"""|@"(?:""|[^"])*"|"(?:\\[\s\S]|[^\\"])*")B?/,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:exception|inherit|interface|new|of|type)\s+|\w\s*:\s*|\s:\??>\s*)[.\w]+\b(?:\s*(?:->|\*)\s*[.\w]+\b)*(?!\s*[:.])/,
        lookbehind: !0,
        inside: {
          operator: /->|\*/,
          punctuation: /\./
        }
      },
      keyword: /\b(?:let|return|use|yield)(?:!\B|\b)|\b(?:abstract|and|as|asr|assert|atomic|base|begin|break|checked|class|component|const|constraint|constructor|continue|default|delegate|do|done|downcast|downto|eager|elif|else|end|event|exception|extern|external|false|finally|fixed|for|fun|function|functor|global|if|in|include|inherit|inline|interface|internal|land|lazy|lor|lsl|lsr|lxor|match|member|method|mixin|mod|module|mutable|namespace|new|not|null|object|of|open|or|override|parallel|private|process|protected|public|pure|rec|sealed|select|sig|static|struct|tailcall|then|to|trait|true|try|type|upcast|val|virtual|void|volatile|when|while|with)\b/,
      number: [/\b0x[\da-fA-F]+(?:LF|lf|un)?\b/, /\b0b[01]+(?:uy|y)?\b/, /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[fm]|e[+-]?\d+)?\b/i, /\b\d+(?:[IlLsy]|UL|u[lsy]?)?\b/],
      operator: /([<>~&^])\1\1|([*.:<>&])\2|<-|->|[!=:]=|<?\|{1,3}>?|\??(?:<=|>=|<>|[-+*/%=<>])\??|[!?^&]|~[+~-]|:>|:\?>?/
    }), t.languages.insertBefore("fsharp", "keyword", {
      preprocessor: {
        pattern: /(^[\t ]*)#.*/m,
        lookbehind: !0,
        alias: "property",
        inside: {
          directive: {
            pattern: /(^#)\b(?:else|endif|if|light|line|nowarn)\b/,
            lookbehind: !0,
            alias: "keyword"
          }
        }
      }
    }), t.languages.insertBefore("fsharp", "punctuation", {
      "computation-expression": {
        pattern: /\b[_a-z]\w*(?=\s*\{)/i,
        alias: "keyword"
      }
    }), t.languages.insertBefore("fsharp", "string", {
      annotation: {
        pattern: /\[<.+?>\]/,
        greedy: !0,
        inside: {
          punctuation: /^\[<|>\]$/,
          "class-name": {
            pattern: /^\w+$|(^|;\s*)[A-Z]\w*(?=\()/,
            lookbehind: !0
          },
          "annotation-content": {
            pattern: /[\s\S]+/,
            inside: t.languages.fsharp
          }
        }
      },
      char: {
        pattern: /'(?:[^\\']|\\(?:.|\d{3}|x[a-fA-F\d]{2}|u[a-fA-F\d]{4}|U[a-fA-F\d]{8}))'B?/,
        greedy: !0
      }
    });
  }
  return fsharp_1;
}
var ftl_1, hasRequiredFtl;
function requireFtl() {
  if (hasRequiredFtl) return ftl_1;
  hasRequiredFtl = 1;
  var e = requireMarkupTemplating();
  ftl_1 = t, t.displayName = "ftl", t.aliases = [];
  function t(r) {
    r.register(e), function(a) {
      for (var o = /[^<()"']|\((?:<expr>)*\)|<(?!#--)|<#--(?:[^-]|-(?!->))*-->|"(?:[^\\"]|\\.)*"|'(?:[^\\']|\\.)*'/.source, u = 0; u < 2; u++)
        o = o.replace(/<expr>/g, function() {
          return o;
        });
      o = o.replace(/<expr>/g, /[^\s\S]/.source);
      var c = {
        comment: /<#--[\s\S]*?-->/,
        string: [{
          // raw string
          pattern: /\br("|')(?:(?!\1)[^\\]|\\.)*\1/,
          greedy: !0
        }, {
          pattern: RegExp(/("|')(?:(?!\1|\$\{)[^\\]|\\.|\$\{(?:(?!\})(?:<expr>))*\})*\1/.source.replace(/<expr>/g, function() {
            return o;
          })),
          greedy: !0,
          inside: {
            interpolation: {
              pattern: RegExp(/((?:^|[^\\])(?:\\\\)*)\$\{(?:(?!\})(?:<expr>))*\}/.source.replace(/<expr>/g, function() {
                return o;
              })),
              lookbehind: !0,
              inside: {
                "interpolation-punctuation": {
                  pattern: /^\$\{|\}$/,
                  alias: "punctuation"
                },
                rest: null
              }
            }
          }
        }],
        keyword: /\b(?:as)\b/,
        boolean: /\b(?:false|true)\b/,
        "builtin-function": {
          pattern: /((?:^|[^?])\?\s*)\w+/,
          lookbehind: !0,
          alias: "function"
        },
        function: /\b\w+(?=\s*\()/,
        number: /\b\d+(?:\.\d+)?\b/,
        operator: /\.\.[<*!]?|->|--|\+\+|&&|\|\||\?{1,2}|[-+*/%!=<>]=?|\b(?:gt|gte|lt|lte)\b/,
        punctuation: /[,;.:()[\]{}]/
      };
      c.string[1].inside.interpolation.inside.rest = c, a.languages.ftl = {
        "ftl-comment": {
          // the pattern is shortened to be more efficient
          pattern: /^<#--[\s\S]*/,
          alias: "comment"
        },
        "ftl-directive": {
          pattern: /^<[\s\S]+>$/,
          inside: {
            directive: {
              pattern: /(^<\/?)[#@][a-z]\w*/i,
              lookbehind: !0,
              alias: "keyword"
            },
            punctuation: /^<\/?|\/?>$/,
            content: {
              pattern: /\s*\S[\s\S]*/,
              alias: "ftl",
              inside: c
            }
          }
        },
        "ftl-interpolation": {
          pattern: /^\$\{[\s\S]*\}$/,
          inside: {
            punctuation: /^\$\{|\}$/,
            content: {
              pattern: /\s*\S[\s\S]*/,
              alias: "ftl",
              inside: c
            }
          }
        }
      }, a.hooks.add("before-tokenize", function(d) {
        var g = RegExp(/<#--[\s\S]*?-->|<\/?[#@][a-zA-Z](?:<expr>)*?>|\$\{(?:<expr>)*?\}/.source.replace(/<expr>/g, function() {
          return o;
        }), "gi");
        a.languages["markup-templating"].buildPlaceholders(d, "ftl", g);
      }), a.hooks.add("after-tokenize", function(d) {
        a.languages["markup-templating"].tokenizePlaceholders(d, "ftl");
      });
    }(r);
  }
  return ftl_1;
}
var gap_1, hasRequiredGap;
function requireGap() {
  if (hasRequiredGap) return gap_1;
  hasRequiredGap = 1, gap_1 = e, e.displayName = "gap", e.aliases = [];
  function e(t) {
    t.languages.gap = {
      shell: {
        pattern: /^gap>[\s\S]*?(?=^gap>|$(?![\s\S]))/m,
        greedy: !0,
        inside: {
          gap: {
            pattern: /^(gap>).+(?:(?:\r(?:\n|(?!\n))|\n)>.*)*/,
            lookbehind: !0,
            inside: null
            // see below
          },
          punctuation: /^gap>/
        }
      },
      comment: {
        pattern: /#.*/,
        greedy: !0
      },
      string: {
        pattern: /(^|[^\\'"])(?:'(?:[^\r\n\\']|\\.){1,10}'|"(?:[^\r\n\\"]|\\.)*"(?!")|"""[\s\S]*?""")/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          continuation: {
            pattern: /([\r\n])>/,
            lookbehind: !0,
            alias: "punctuation"
          }
        }
      },
      keyword: /\b(?:Assert|Info|IsBound|QUIT|TryNextMethod|Unbind|and|atomic|break|continue|do|elif|else|end|fi|for|function|if|in|local|mod|not|od|or|quit|readonly|readwrite|rec|repeat|return|then|until|while)\b/,
      boolean: /\b(?:false|true)\b/,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      number: {
        pattern: /(^|[^\w.]|\.\.)(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?:_[a-z]?)?(?=$|[^\w.]|\.\.)/,
        lookbehind: !0
      },
      continuation: {
        pattern: /([\r\n])>/,
        lookbehind: !0,
        alias: "punctuation"
      },
      operator: /->|[-+*/^~=!]|<>|[<>]=?|:=|\.\./,
      punctuation: /[()[\]{},;.:]/
    }, t.languages.gap.shell.inside.gap.inside = t.languages.gap;
  }
  return gap_1;
}
var gcode_1, hasRequiredGcode;
function requireGcode() {
  if (hasRequiredGcode) return gcode_1;
  hasRequiredGcode = 1, gcode_1 = e, e.displayName = "gcode", e.aliases = [];
  function e(t) {
    t.languages.gcode = {
      comment: /;.*|\B\(.*?\)\B/,
      string: {
        pattern: /"(?:""|[^"])*"/,
        greedy: !0
      },
      keyword: /\b[GM]\d+(?:\.\d+)?\b/,
      property: /\b[A-Z]/,
      checksum: {
        pattern: /(\*)\d+/,
        lookbehind: !0,
        alias: "number"
      },
      // T0:0:0
      punctuation: /[:*]/
    };
  }
  return gcode_1;
}
var gdscript_1, hasRequiredGdscript;
function requireGdscript() {
  if (hasRequiredGdscript) return gdscript_1;
  hasRequiredGdscript = 1, gdscript_1 = e, e.displayName = "gdscript", e.aliases = [];
  function e(t) {
    t.languages.gdscript = {
      comment: /#.*/,
      string: {
        pattern: /@?(?:("|')(?:(?!\1)[^\n\\]|\\[\s\S])*\1(?!"|')|"""(?:[^\\]|\\[\s\S])*?""")/,
        greedy: !0
      },
      "class-name": {
        // class_name Foo, extends Bar, class InnerClass
        // export(int) var baz, export(int, 0) var i
        // as Node
        // const FOO: int = 9, var bar: bool = true
        // func add(reference: Item, amount: int) -> Item:
        pattern: /(^(?:class|class_name|extends)[ \t]+|^export\([ \t]*|\bas[ \t]+|(?:\b(?:const|var)[ \t]|[,(])[ \t]*\w+[ \t]*:[ \t]*|->[ \t]*)[a-zA-Z_]\w*/m,
        lookbehind: !0
      },
      keyword: /\b(?:and|as|assert|break|breakpoint|class|class_name|const|continue|elif|else|enum|export|extends|for|func|if|in|is|master|mastersync|match|not|null|onready|or|pass|preload|puppet|puppetsync|remote|remotesync|return|self|setget|signal|static|tool|var|while|yield)\b/,
      function: /\b[a-z_]\w*(?=[ \t]*\()/i,
      variable: /\$\w+/,
      number: [/\b0b[01_]+\b|\b0x[\da-fA-F_]+\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.[\d_]+)(?:e[+-]?[\d_]+)?\b/, /\b(?:INF|NAN|PI|TAU)\b/],
      constant: /\b[A-Z][A-Z_\d]*\b/,
      boolean: /\b(?:false|true)\b/,
      operator: /->|:=|&&|\|\||<<|>>|[-+*/%&|!<>=]=?|[~^]/,
      punctuation: /[.:,;()[\]{}]/
    };
  }
  return gdscript_1;
}
var gedcom_1, hasRequiredGedcom;
function requireGedcom() {
  if (hasRequiredGedcom) return gedcom_1;
  hasRequiredGedcom = 1, gedcom_1 = e, e.displayName = "gedcom", e.aliases = [];
  function e(t) {
    t.languages.gedcom = {
      "line-value": {
        // Preceded by level, optional pointer, and tag
        pattern: /(^[\t ]*\d+ +(?:@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@ +)?\w+ ).+/m,
        lookbehind: !0,
        inside: {
          pointer: {
            pattern: /^@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@$/,
            alias: "variable"
          }
        }
      },
      tag: {
        // Preceded by level and optional pointer
        pattern: /(^[\t ]*\d+ +(?:@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@ +)?)\w+/m,
        lookbehind: !0,
        alias: "string"
      },
      level: {
        pattern: /(^[\t ]*)\d+/m,
        lookbehind: !0,
        alias: "number"
      },
      pointer: {
        pattern: /@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@/,
        alias: "variable"
      }
    };
  }
  return gedcom_1;
}
var gherkin_1, hasRequiredGherkin;
function requireGherkin() {
  if (hasRequiredGherkin) return gherkin_1;
  hasRequiredGherkin = 1, gherkin_1 = e, e.displayName = "gherkin", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = /(?:\r?\n|\r)[ \t]*\|.+\|(?:(?!\|).)*/.source;
      r.languages.gherkin = {
        pystring: {
          pattern: /("""|''')[\s\S]+?\1/,
          alias: "string"
        },
        comment: {
          pattern: /(^[ \t]*)#.*/m,
          lookbehind: !0
        },
        tag: {
          pattern: /(^[ \t]*)@\S*/m,
          lookbehind: !0
        },
        feature: {
          pattern: /((?:^|\r?\n|\r)[ \t]*)(?:Ability|Ahoy matey!|Arwedd|Aspekt|Besigheid Behoefte|Business Need|Caracteristica|Caracterstica|Egenskab|Egenskap|Eiginleiki|Feature|Fa|Fitur|Fonctionnalit|Fonksyonalite|Funcionalidade|Funcionalitat|Functionalitate|Funcionalitate|Funcionalitate|Functionaliteit|Fungsi|Funkcia|Funkcija|Funkcionalitte|Funkcionalnost|Funkcja|Funksie|Funktionalitt|Funktionalitit|Funzionalit|Hwaet|Hwt|Jellemz|Karakteristik|Lastnost|Mak|Mogucnost|laH|Mogunost|Moznosti|Monosti|OH HAI|Omadus|Ominaisuus|Osobina|zellik|Potrzeba biznesowa|perbogh|poQbogh malja'|Poadavek|Poiadavka|Pretty much|Qap|Qu'meH 'ut|Savyb|Tnh nng|Trajto|Vermo|Vlastnos|Waciwo|Znailnost||||||||||||||||  || || ||||||||||):(?:[^:\r\n]+(?:\r?\n|\r|$))*/,
          lookbehind: !0,
          inside: {
            important: {
              pattern: /(:)[^\r\n]+/,
              lookbehind: !0
            },
            keyword: /[^:\r\n]+:/
          }
        },
        scenario: {
          pattern: /(^[ \t]*)(?:Abstract Scenario|Abstrakt Scenario|Achtergrond|Aer|r|Agtergrond|All y'all|Antecedentes|Antecedents|Atburars|Atburarsir|Awww, look mate|B4|Background|Baggrund|Bakgrund|Bakgrunn|Bakgrunnur|Beispiele|Beispiller|Bi cnh|Cefndir|Cenario|Cenrio|Cenario de Fundo|Cenrio de Fundo|Cenarios|Cenrios|Contesto|Context|Contexte|Contexto|Conto|Contoh|Contone|Dmi|Dasar|Dead men tell no tales|Delineacao do Cenario|Delineao do Cenrio|Dis is what went down|D liu|Dyagram Senaryo|Dyagram senaryo|Egzanp|Ejemplos|Eksempler|Ekzemploj|Enghreifftiau|Esbozo do escenario|Escenari|Escenario|Esempi|Esquema de l'escenari|Esquema del escenario|Esquema do Cenario|Esquema do Cenrio|EXAMPLZ|Examples|Exempel|Exemple|Exemples|Exemplos|First off|Fono|Forgatknyv|Forgatknyv vzlat|Fundo|Gemi|Grundlage|Hannergrond|ghantoH|Httr|Heave to|Istorik|Juhtumid|Keadaan|Khung kch bn|Khung tnh hung|Kch bn|Koncept|Konsep skenario|Kontks|Kontekst|Kontekstas|Konteksts|Kontext|Konturo de la scenaro|Latar Belakang|lut chovnatlh|lut|lutmey|Lsing Atburarsar|Lsing Dma|MISHUN SRSLY|MISHUN|Menggariskan Senario|mo'|Nrt Scenra|Nrt Scne|Nrt Scenru|Oris scenarija|rnekler|Osnova|Osnova Scenra|Osnova scne|Osnutek|Ozadje|Paraugs|Pavyzdiai|Pldk|Piemri|Plan du scnario|Plan du Scnario|Plan Senaryo|Plan senaryo|Plang vum Szenario|Pozad|Pozadie|Pozadina|Prklady|Pklady|Primer|Primeri|Primjeri|Przykady|Raamstsenaarium|Reckon it's like|Rerefons|Scenr|Scn|Scenarie|Scenarij|Scenarijai|Scenarijaus ablonas|Scenariji|Scenrijs|Scenrijs pc parauga|Scenarijus|Scenario|Scnario|Scenario Amlinellol|Scenario Outline|Scenario Template|Scenariomal|Scenariomall|Scenarios|Scenariu|Scenariusz|Scenaro|Schema dello scenario|Se e|Se the|Se e|Senario|Senaryo Deskripsyon|Senaryo deskripsyon|Senaryo|Senaryo tasla|Shiver me timbers|Situcija|Situai|Situasie Uiteensetting|Situasie|Skenario konsep|Skenario|Skica|Structura scenariu|Structur scenariu|Struktura scenarija|Stsenaarium|Swa hwaer swa|Swa|Swa hwr swa|Szablon scenariusza|Szenario|Szenariogrundriss|Tapaukset|Tapaus|Tapausaihio|Taust|Tausta|Template Keadaan|Template Senario|Template Situai|The thing of it is|Tnh hung|Variantai|Voorbeelde|Voorbeelden|Wharrimean is|Yo-ho-ho|You'll wanna|Zaoenia|| ||||||||||||||||||  || | | || | |||||||| ||| || |||| ||   || ||| |||| |  |||||||||||||||||| ||||||||||||||||||):[^:\r\n]*/m,
          lookbehind: !0,
          inside: {
            important: {
              pattern: /(:)[^\r\n]*/,
              lookbehind: !0
            },
            keyword: /[^:\r\n]+:/
          }
        },
        "table-body": {
          // Look-behind is used to skip the table head, which has the same format as any table row
          pattern: RegExp("(" + a + ")(?:" + a + ")+"),
          lookbehind: !0,
          inside: {
            outline: {
              pattern: /<[^>]+>/,
              alias: "variable"
            },
            td: {
              pattern: /\s*[^\s|][^|]*/,
              alias: "string"
            },
            punctuation: /\|/
          }
        },
        "table-head": {
          pattern: RegExp(a),
          inside: {
            th: {
              pattern: /\s*[^\s|][^|]*/,
              alias: "variable"
            },
            punctuation: /\|/
          }
        },
        atrule: {
          pattern: /(^[ \t]+)(?:'a|'ach|'ej|7|a|A tak|A taktie|A tie|A zrove|Aber|Ac|Adott|Akkor|Ak|Aleshores|Ale|Ali|Allora|Alors|Als|Ama|Amennyiben|Amikor|Ampak|an|AN|Ananging|And y'all|And|Angenommen|Anrhegedig a|An|Apabila|Ats|Atesa|Atunci|Avast!|Aye|A|awer|Bagi|Banjur|Bet|Bit|Blimey!|Buh|But at the end of the day I reckon|But y'all|But|BUT|Cal|Cnd|Cand|Cando|Ce|Cuando|e|a e|a|Dadas|Dada|Dados|Dado|DaH ghu' bejlu'|dann|Dann|Dano|Dan|Dar|Dat fiind|Data|Date fiind|Date|Dati fiind|Dati|Dai fiind|Dai fiind|DEN|Dato|De|Den youse gotta|Dengan|Diberi|Diyelim ki|Donada|Donat|Donitao|Do|Dun|Duota|urh|Eeldades|Ef|Eer ki|Entao|Ento|Entn|E|En|Entonces|Epi|s|Etant donne|Etant donn|Et|tant donnes|tant donne|tant donn|Etant donnes|Etant donns|tant donns|Fakat|Gangway!|Gdy|Gegeben seien|Gegeben sei|Gegeven|Gegewe|ghu' noblu'|Gitt|Given y'all|Given|Givet|Givun|Ha|Cho|I CAN HAZ|In|Ir|It's just unbelievable|I|Ja|Jeli|Jeeli|Kad|Kada|Kadar|Kai|Kaj|Kdy|Ke|Kemudian|Ketika|Khi|Kiedy|Ko|Kuid|Kui|Kun|Lan|latlh|Le sa a|Let go and haul|Le|L sa a|L|Logo|Lorsqu'<|Lorsque|m|Maar|Mais|Majc|Ma|Majd|Maka|Manawa|Mas|Men|Menawa|Mutta|Nalika|Nalikaning|Nanging|Nr|Nr|Nato|Nhng|Niin|Njuk|O zaman|Och|Og|Oletetaan|Ond|Onda|Oraz|Pak|Pero|Per|Podano|Pokia|Pokud|Potem|Potom|Privzeto|Pryd|Quan|Quand|Quando|qaSDI'|S|Sed|Se|Siis|Sipoze ke|Sipoze Ke|Sipoze|Si|i|i|Soit|Stel|Tada|Tad|Takrat|Tak|Tapi|Ter|Tetapi|Tha the|Tha|Then y'all|Then|Th|Thurh|Toda|Too right|Un|Und|ugeholl|V|vaj|Vendar|Ve|wann|Wanneer|WEN|Wenn|When y'all|When|Wtedy|Wun|Y'know|Yeah nah|Yna|Youse know like when|Youse know when youse got|Y|Za predpokladu|Za pedpokladu|Zadan|Zadani|Zadano|Zadate|Zadato|Zakadajc|Zaradi|Zatati|a e|a||egar|urh|||||| |||||||||||||||||||||  ||||||||||||, |||||||||||||||||||||| |||||||| |||||||||||||||||||| ||||| ||||||||||||||<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<)(?=[ \t])/m,
          lookbehind: !0
        },
        string: {
          pattern: /"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'/,
          inside: {
            outline: {
              pattern: /<[^>]+>/,
              alias: "variable"
            }
          }
        },
        outline: {
          pattern: /<[^>]+>/,
          alias: "variable"
        }
      };
    })(t);
  }
  return gherkin_1;
}
var git_1, hasRequiredGit;
function requireGit() {
  if (hasRequiredGit) return git_1;
  hasRequiredGit = 1, git_1 = e, e.displayName = "git", e.aliases = [];
  function e(t) {
    t.languages.git = {
      /*
       * A simple one line comment like in a git status command
       * For instance:
       * $ git status
       * # On branch infinite-scroll
       * # Your branch and 'origin/sharedBranches/frontendTeam/infinite-scroll' have diverged,
       * # and have 1 and 2 different commits each, respectively.
       * nothing to commit (working directory clean)
       */
      comment: /^#.*/m,
      /*
       * Regexp to match the changed lines in a git diff output. Check the example below.
       */
      deleted: /^[-].*/m,
      inserted: /^\+.*/m,
      /*
       * a string (double and simple quote)
       */
      string: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
      /*
       * a git command. It starts with a random prompt finishing by a $, then "git" then some other parameters
       * For instance:
       * $ git add file.txt
       */
      command: {
        pattern: /^.*\$ git .*$/m,
        inside: {
          /*
           * A git command can contain a parameter starting by a single or a double dash followed by a string
           * For instance:
           * $ git diff --cached
           * $ git log -p
           */
          parameter: /\s--?\w+/
        }
      },
      /*
       * Coordinates displayed in a git diff command
       * For instance:
       * $ git diff
       * diff --git file.txt file.txt
       * index 6214953..1d54a52 100644
       * --- file.txt
       * +++ file.txt
       * @@ -1 +1,2 @@
       * -Here's my tetx file
       * +Here's my text file
       * +And this is the second line
       */
      coord: /^@@.*@@$/m,
      /*
       * Match a "commit [SHA1]" line in a git log output.
       * For instance:
       * $ git log
       * commit a11a14ef7e26f2ca62d4b35eac455ce636d0dc09
       * Author: lgiraudel
       * Date:   Mon Feb 17 11:18:34 2014 +0100
       *
       *     Add of a new line
       */
      "commit-sha1": /^commit \w{40}$/m
    };
  }
  return git_1;
}
var glsl_1, hasRequiredGlsl;
function requireGlsl() {
  if (hasRequiredGlsl) return glsl_1;
  hasRequiredGlsl = 1;
  var e = requireC();
  glsl_1 = t, t.displayName = "glsl", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.glsl = r.languages.extend("c", {
      keyword: /\b(?:active|asm|atomic_uint|attribute|[ibdu]?vec[234]|bool|break|buffer|case|cast|centroid|class|coherent|common|const|continue|d?mat[234](?:x[234])?|default|discard|do|double|else|enum|extern|external|false|filter|fixed|flat|float|for|fvec[234]|goto|half|highp|hvec[234]|[iu]?sampler2DMS(?:Array)?|[iu]?sampler2DRect|[iu]?samplerBuffer|[iu]?samplerCube|[iu]?samplerCubeArray|[iu]?sampler[123]D|[iu]?sampler[12]DArray|[iu]?image2DMS(?:Array)?|[iu]?image2DRect|[iu]?imageBuffer|[iu]?imageCube|[iu]?imageCubeArray|[iu]?image[123]D|[iu]?image[12]DArray|if|in|inline|inout|input|int|interface|invariant|layout|long|lowp|mediump|namespace|noinline|noperspective|out|output|partition|patch|precise|precision|public|readonly|resource|restrict|return|sample|sampler[12]DArrayShadow|sampler[12]DShadow|sampler2DRectShadow|sampler3DRect|samplerCubeArrayShadow|samplerCubeShadow|shared|short|sizeof|smooth|static|struct|subroutine|superp|switch|template|this|true|typedef|uint|uniform|union|unsigned|using|varying|void|volatile|while|writeonly)\b/
    });
  }
  return glsl_1;
}
var gml_1, hasRequiredGml;
function requireGml() {
  if (hasRequiredGml) return gml_1;
  hasRequiredGml = 1, gml_1 = e, e.displayName = "gml", e.aliases = [];
  function e(t) {
    t.languages.gamemakerlanguage = t.languages.gml = t.languages.extend("clike", {
      keyword: /\b(?:break|case|continue|default|do|else|enum|exit|for|globalvar|if|repeat|return|switch|until|var|while)\b/,
      number: /(?:\b0x[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ulf]{0,4}/i,
      operator: /--|\+\+|[-+%/=]=?|!=|\*\*?=?|<[<=>]?|>[=>]?|&&?|\^\^?|\|\|?|~|\b(?:and|at|not|or|with|xor)\b/,
      constant: /\b(?:GM_build_date|GM_version|action_(?:continue|restart|reverse|stop)|all|gamespeed_(?:fps|microseconds)|global|local|noone|other|pi|pointer_(?:invalid|null)|self|timezone_(?:local|utc)|undefined|ev_(?:create|destroy|step|alarm|keyboard|mouse|collision|other|draw|draw_(?:begin|end|post|pre)|keypress|keyrelease|trigger|(?:left|middle|no|right)_button|(?:left|middle|right)_press|(?:left|middle|right)_release|mouse_(?:enter|leave|wheel_down|wheel_up)|global_(?:left|middle|right)_button|global_(?:left|middle|right)_press|global_(?:left|middle|right)_release|joystick(?:1|2)_(?:button1|button2|button3|button4|button5|button6|button7|button8|down|left|right|up)|outside|boundary|game_start|game_end|room_start|room_end|no_more_lives|animation_end|end_of_path|no_more_health|user\d|gui|gui_begin|gui_end|step_(?:begin|end|normal))|vk_(?:alt|anykey|backspace|control|delete|down|end|enter|escape|home|insert|left|nokey|pagedown|pageup|pause|printscreen|return|right|shift|space|tab|up|f\d|numpad\d|add|decimal|divide|lalt|lcontrol|lshift|multiply|ralt|rcontrol|rshift|subtract)|achievement_(?:filter_(?:all_players|favorites_only|friends_only)|friends_info|info|leaderboard_info|our_info|pic_loaded|show_(?:achievement|bank|friend_picker|leaderboard|profile|purchase_prompt|ui)|type_challenge|type_score_challenge)|asset_(?:font|object|path|room|script|shader|sound|sprite|tiles|timeline|unknown)|audio_(?:3d|falloff_(?:exponent_distance|exponent_distance_clamped|inverse_distance|inverse_distance_clamped|linear_distance|linear_distance_clamped|none)|mono|new_system|old_system|stereo)|bm_(?:add|complex|dest_alpha|dest_color|dest_colour|inv_dest_alpha|inv_dest_color|inv_dest_colour|inv_src_alpha|inv_src_color|inv_src_colour|max|normal|one|src_alpha|src_alpha_sat|src_color|src_colour|subtract|zero)|browser_(?:chrome|firefox|ie|ie_mobile|not_a_browser|opera|safari|safari_mobile|tizen|unknown|windows_store)|buffer_(?:bool|f16|f32|f64|fast|fixed|generalerror|grow|invalidtype|network|outofbounds|outofspace|s16|s32|s8|seek_end|seek_relative|seek_start|string|text|u16|u32|u64|u8|vbuffer|wrap)|c_(?:aqua|black|blue|dkgray|fuchsia|gray|green|lime|ltgray|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)|cmpfunc_(?:always|equal|greater|greaterequal|less|lessequal|never|notequal)|cr_(?:appstart|arrow|beam|cross|default|drag|handpoint|hourglass|none|size_all|size_nesw|size_ns|size_nwse|size_we|uparrow)|cull_(?:clockwise|counterclockwise|noculling)|device_(?:emulator|tablet)|device_ios_(?:ipad|ipad_retina|iphone|iphone5|iphone6|iphone6plus|iphone_retina|unknown)|display_(?:landscape|landscape_flipped|portrait|portrait_flipped)|dll_(?:cdecl|cdel|stdcall)|ds_type_(?:grid|list|map|priority|queue|stack)|ef_(?:cloud|ellipse|explosion|firework|flare|rain|ring|smoke|smokeup|snow|spark|star)|fa_(?:archive|bottom|center|directory|hidden|left|middle|readonly|right|sysfile|top|volumeid)|fb_login_(?:default|fallback_to_webview|forcing_safari|forcing_webview|no_fallback_to_webview|use_system_account)|iap_(?:available|canceled|ev_consume|ev_product|ev_purchase|ev_restore|ev_storeload|failed|purchased|refunded|status_available|status_loading|status_processing|status_restoring|status_unavailable|status_uninitialised|storeload_failed|storeload_ok|unavailable)|leaderboard_type_(?:number|time_mins_secs)|lighttype_(?:dir|point)|matrix_(?:projection|view|world)|mb_(?:any|left|middle|none|right)|network_(?:config_(?:connect_timeout|disable_reliable_udp|enable_reliable_udp|use_non_blocking_socket)|socket_(?:bluetooth|tcp|udp)|type_(?:connect|data|disconnect|non_blocking_connect))|of_challenge_(?:lose|tie|win)|os_(?:android|ios|linux|macosx|ps3|ps4|psvita|unknown|uwp|win32|win8native|windows|winphone|xboxone)|phy_debug_render_(?:aabb|collision_pairs|coms|core_shapes|joints|obb|shapes)|phy_joint_(?:anchor_1_x|anchor_1_y|anchor_2_x|anchor_2_y|angle|angle_limits|damping_ratio|frequency|length_1|length_2|lower_angle_limit|max_force|max_length|max_motor_force|max_motor_torque|max_torque|motor_force|motor_speed|motor_torque|reaction_force_x|reaction_force_y|reaction_torque|speed|translation|upper_angle_limit)|phy_particle_data_flag_(?:category|color|colour|position|typeflags|velocity)|phy_particle_flag_(?:colormixing|colourmixing|elastic|powder|spring|tensile|viscous|wall|water|zombie)|phy_particle_group_flag_(?:rigid|solid)|pr_(?:linelist|linestrip|pointlist|trianglefan|trianglelist|trianglestrip)|ps_(?:distr|shape)_(?:diamond|ellipse|gaussian|invgaussian|line|linear|rectangle)|pt_shape_(?:circle|cloud|disk|explosion|flare|line|pixel|ring|smoke|snow|spark|sphere|square|star)|ty_(?:real|string)|gp_(?:face\d|axislh|axislv|axisrh|axisrv|padd|padl|padr|padu|select|shoulderl|shoulderlb|shoulderr|shoulderrb|start|stickl|stickr)|lb_disp_(?:none|numeric|time_ms|time_sec)|lb_sort_(?:ascending|descending|none)|ov_(?:achievements|community|friends|gamegroup|players|settings)|ugc_(?:filetype_(?:community|microtrans)|list_(?:Favorited|Followed|Published|Subscribed|UsedOrPlayed|VotedDown|VotedOn|VotedUp|WillVoteLater)|match_(?:AllGuides|Artwork|Collections|ControllerBindings|IntegratedGuides|Items|Items_Mtx|Items_ReadyToUse|Screenshots|UsableInGame|Videos|WebGuides)|query_(?:AcceptedForGameRankedByAcceptanceDate|CreatedByFriendsRankedByPublicationDate|FavoritedByFriendsRankedByPublicationDate|NotYetRated)|query_RankedBy(?:NumTimesReported|PublicationDate|TextSearch|TotalVotesAsc|Trend|Vote|VotesUp)|result_success|sortorder_CreationOrder(?:Asc|Desc)|sortorder_(?:ForModeration|LastUpdatedDesc|SubscriptionDateDesc|TitleAsc|VoteScoreDesc)|visibility_(?:friends_only|private|public))|vertex_usage_(?:binormal|blendindices|blendweight|color|colour|depth|fog|normal|position|psize|sample|tangent|texcoord|textcoord)|vertex_type_(?:float\d|color|colour|ubyte4)|input_type|layerelementtype_(?:background|instance|oldtilemap|particlesystem|sprite|tile|tilemap|undefined)|se_(?:chorus|compressor|echo|equalizer|flanger|gargle|none|reverb)|text_type|tile_(?:flip|index_mask|mirror|rotate)|(?:obj|rm|scr|spr)\w+)\b/,
      variable: /\b(?:alarm|application_surface|async_load|background_(?:alpha|blend|color|colour|foreground|height|hspeed|htiled|index|showcolor|showcolour|visible|vspeed|vtiled|width|x|xscale|y|yscale)|bbox_(?:bottom|left|right|top)|browser_(?:height|width)|caption_(?:health|lives|score)|current_(?:day|hour|minute|month|second|time|weekday|year)|cursor_sprite|debug_mode|delta_time|direction|display_aa|error_(?:last|occurred)|event_(?:action|number|object|type)|fps|fps_real|friction|game_(?:display|project|save)_(?:id|name)|gamemaker_(?:pro|registered|version)|gravity|gravity_direction|(?:h|v)speed|health|iap_data|id|image_(?:alpha|angle|blend|depth|index|number|speed|xscale|yscale)|instance_(?:count|id)|keyboard_(?:key|lastchar|lastkey|string)|layer|lives|mask_index|mouse_(?:button|lastbutton|x|y)|object_index|os_(?:browser|device|type|version)|path_(?:endaction|index|orientation|position|positionprevious|scale|speed)|persistent|phy_(?:rotation|(?:col_normal|collision|com|linear_velocity|position|speed)_(?:x|y)|angular_(?:damping|velocity)|position_(?:x|y)previous|speed|linear_damping|bullet|fixed_rotation|active|mass|inertia|dynamic|kinematic|sleeping|collision_points)|pointer_(?:invalid|null)|room|room_(?:caption|first|height|last|persistent|speed|width)|score|secure_mode|show_(?:health|lives|score)|solid|speed|sprite_(?:height|index|width|xoffset|yoffset)|temp_directory|timeline_(?:index|loop|position|running|speed)|transition_(?:color|kind|steps)|undefined|view_(?:angle|current|enabled|(?:h|v)(?:border|speed)|(?:h|w|x|y)port|(?:h|w|x|y)view|object|surface_id|visible)|visible|webgl_enabled|working_directory|(?:x|y)(?:previous|start)|x|y|argument(?:_relitive|_count|\d)|argument|global|local|other|self)\b/
    });
  }
  return gml_1;
}
var gn_1, hasRequiredGn;
function requireGn() {
  if (hasRequiredGn) return gn_1;
  hasRequiredGn = 1, gn_1 = e, e.displayName = "gn", e.aliases = ["gni"];
  function e(t) {
    t.languages.gn = {
      comment: {
        pattern: /#.*/,
        greedy: !0
      },
      "string-literal": {
        pattern: /(^|[^\\"])"(?:[^\r\n"\\]|\\.)*"/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\{[\s\S]*?\}|[a-zA-Z_]\w*|0x[a-fA-F0-9]{2})/,
            lookbehind: !0,
            inside: {
              number: /^\$0x[\s\S]{2}$/,
              variable: /^\$\w+$/,
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              expression: {
                pattern: /[\s\S]+/,
                inside: null
                // see below
              }
            }
          },
          string: /[\s\S]+/
        }
      },
      keyword: /\b(?:else|if)\b/,
      boolean: /\b(?:false|true)\b/,
      "builtin-function": {
        // a few functions get special highlighting to improve readability
        pattern: /\b(?:assert|defined|foreach|import|pool|print|template|tool|toolchain)(?=\s*\()/i,
        alias: "keyword"
      },
      function: /\b[a-z_]\w*(?=\s*\()/i,
      constant: /\b(?:current_cpu|current_os|current_toolchain|default_toolchain|host_cpu|host_os|root_build_dir|root_gen_dir|root_out_dir|target_cpu|target_gen_dir|target_os|target_out_dir)\b/,
      number: /-?\b\d+\b/,
      operator: /[-+!=<>]=?|&&|\|\|/,
      punctuation: /[(){}[\],.]/
    }, t.languages.gn["string-literal"].inside.interpolation.inside.expression.inside = t.languages.gn, t.languages.gni = t.languages.gn;
  }
  return gn_1;
}
var goModule_1, hasRequiredGoModule;
function requireGoModule() {
  if (hasRequiredGoModule) return goModule_1;
  hasRequiredGoModule = 1, goModule_1 = e, e.displayName = "goModule", e.aliases = [];
  function e(t) {
    t.languages["go-mod"] = t.languages["go-module"] = {
      comment: {
        pattern: /\/\/.*/,
        greedy: !0
      },
      version: {
        pattern: /(^|[\s()[\],])v\d+\.\d+\.\d+(?:[+-][-+.\w]*)?(?![^\s()[\],])/,
        lookbehind: !0,
        alias: "number"
      },
      "go-version": {
        pattern: /((?:^|\s)go\s+)\d+(?:\.\d+){1,2}/,
        lookbehind: !0,
        alias: "number"
      },
      keyword: {
        pattern: /^([ \t]*)(?:exclude|go|module|replace|require|retract)\b/m,
        lookbehind: !0
      },
      operator: /=>/,
      punctuation: /[()[\],]/
    };
  }
  return goModule_1;
}
var go_1, hasRequiredGo;
function requireGo() {
  if (hasRequiredGo) return go_1;
  hasRequiredGo = 1, go_1 = e, e.displayName = "go", e.aliases = [];
  function e(t) {
    t.languages.go = t.languages.extend("clike", {
      string: {
        pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
        lookbehind: !0,
        greedy: !0
      },
      keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
      boolean: /\b(?:_|false|iota|nil|true)\b/,
      number: [
        // binary and octal integers
        /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
        // hexadecimal integers and floats
        /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
        // decimal integers and floats
        /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
      ],
      operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
      builtin: /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
    }), t.languages.insertBefore("go", "string", {
      char: {
        pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
        greedy: !0
      }
    }), delete t.languages.go["class-name"];
  }
  return go_1;
}
var graphql_1, hasRequiredGraphql;
function requireGraphql() {
  if (hasRequiredGraphql) return graphql_1;
  hasRequiredGraphql = 1, graphql_1 = e, e.displayName = "graphql", e.aliases = [];
  function e(t) {
    t.languages.graphql = {
      comment: /#.*/,
      description: {
        pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i,
        greedy: !0,
        alias: "string",
        inside: {
          "language-markdown": {
            pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/,
            lookbehind: !0,
            inside: t.languages.markdown
          }
        }
      },
      string: {
        pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/,
        greedy: !0
      },
      number: /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
      boolean: /\b(?:false|true)\b/,
      variable: /\$[a-z_]\w*/i,
      directive: {
        pattern: /@[a-z_]\w*/i,
        alias: "function"
      },
      "attr-name": {
        pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i,
        greedy: !0
      },
      "atom-input": {
        pattern: /\b[A-Z]\w*Input\b/,
        alias: "class-name"
      },
      scalar: /\b(?:Boolean|Float|ID|Int|String)\b/,
      constant: /\b[A-Z][A-Z_\d]*\b/,
      "class-name": {
        pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/,
        lookbehind: !0
      },
      fragment: {
        pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/,
        lookbehind: !0,
        alias: "function"
      },
      "definition-mutation": {
        pattern: /(\bmutation\s+)[a-zA-Z_]\w*/,
        lookbehind: !0,
        alias: "function"
      },
      "definition-query": {
        pattern: /(\bquery\s+)[a-zA-Z_]\w*/,
        lookbehind: !0,
        alias: "function"
      },
      keyword: /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/,
      operator: /[!=|&]|\.{3}/,
      "property-query": /\w+(?=\s*\()/,
      object: /\w+(?=\s*\{)/,
      punctuation: /[!(){}\[\]:=,]/,
      property: /\w+/
    }, t.hooks.add("after-tokenize", function(a) {
      if (a.language !== "graphql")
        return;
      var o = a.tokens.filter(function(I) {
        return typeof I != "string" && I.type !== "comment" && I.type !== "scalar";
      }), u = 0;
      function c(I) {
        return o[u + I];
      }
      function d(I, w) {
        w = w || 0;
        for (var N = 0; N < I.length; N++) {
          var F = c(N + w);
          if (!F || F.type !== I[N])
            return !1;
        }
        return !0;
      }
      function g(I, w) {
        for (var N = 1, F = u; F < o.length; F++) {
          var M = o[F], x = M.content;
          if (M.type === "punctuation" && typeof x == "string") {
            if (I.test(x))
              N++;
            else if (w.test(x) && (N--, N === 0))
              return F;
          }
        }
        return -1;
      }
      function b(I, w) {
        var N = I.alias;
        N ? Array.isArray(N) || (I.alias = N = [N]) : I.alias = N = [], N.push(w);
      }
      for (; u < o.length; ) {
        var _ = o[u++];
        if (_.type === "keyword" && _.content === "mutation") {
          var y = [];
          if (d(["definition-mutation", "punctuation"]) && c(1).content === "(") {
            u += 2;
            var A = g(/^\($/, /^\)$/);
            if (A === -1)
              continue;
            for (; u < A; u++) {
              var E = c(0);
              E.type === "variable" && (b(E, "variable-input"), y.push(E.content));
            }
            u = A + 1;
          }
          if (d(["punctuation", "property-query"]) && c(0).content === "{" && (u++, b(c(0), "property-mutation"), y.length > 0)) {
            var v = g(/^\{$/, /^\}$/);
            if (v === -1)
              continue;
            for (var C = u; C < v; C++) {
              var R = o[C];
              R.type === "variable" && y.indexOf(R.content) >= 0 && b(R, "variable-input");
            }
          }
        }
      }
    });
  }
  return graphql_1;
}
var groovy_1, hasRequiredGroovy;
function requireGroovy() {
  if (hasRequiredGroovy) return groovy_1;
  hasRequiredGroovy = 1, groovy_1 = e, e.displayName = "groovy", e.aliases = [];
  function e(t) {
    t.languages.groovy = t.languages.extend("clike", {
      string: [{
        // https://groovy-lang.org/syntax.html#_dollar_slashy_string
        pattern: /("""|''')(?:[^\\]|\\[\s\S])*?\1|\$\/(?:[^/$]|\$(?:[/$]|(?![/$]))|\/(?!\$))*\/\$/,
        greedy: !0
      }, {
        // TODO: Slash strings (e.g. /foo/) can contain line breaks but this will cause a lot of trouble with
        // simple division (see JS regex), so find a fix maybe?
        pattern: /(["'/])(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      }],
      keyword: /\b(?:abstract|as|assert|boolean|break|byte|case|catch|char|class|const|continue|def|default|do|double|else|enum|extends|final|finally|float|for|goto|if|implements|import|in|instanceof|int|interface|long|native|new|package|private|protected|public|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|trait|transient|try|void|volatile|while)\b/,
      number: /\b(?:0b[01_]+|0x[\da-f_]+(?:\.[\da-f_p\-]+)?|[\d_]+(?:\.[\d_]+)?(?:e[+-]?\d+)?)[glidf]?\b/i,
      operator: {
        pattern: /(^|[^.])(?:~|==?~?|\?[.:]?|\*(?:[.=]|\*=?)?|\.[@&]|\.\.<|\.\.(?!\.)|-[-=>]?|\+[+=]?|!=?|<(?:<=?|=>?)?|>(?:>>?=?|=)?|&[&=]?|\|[|=]?|\/=?|\^=?|%=?)/,
        lookbehind: !0
      },
      punctuation: /\.+|[{}[\];(),:$]/
    }), t.languages.insertBefore("groovy", "string", {
      shebang: {
        pattern: /#!.+/,
        alias: "comment"
      }
    }), t.languages.insertBefore("groovy", "punctuation", {
      "spock-block": /\b(?:and|cleanup|expect|given|setup|then|when|where):/
    }), t.languages.insertBefore("groovy", "function", {
      annotation: {
        pattern: /(^|[^.])@\w+/,
        lookbehind: !0,
        alias: "punctuation"
      }
    }), t.hooks.add("wrap", function(r) {
      if (r.language === "groovy" && r.type === "string") {
        var a = r.content.value[0];
        if (a != "'") {
          var o = /([^\\])(?:\$(?:\{.*?\}|[\w.]+))/;
          a === "$" && (o = /([^\$])(?:\$(?:\{.*?\}|[\w.]+))/), r.content.value = r.content.value.replace(/&lt;/g, "<").replace(/&amp;/g, "&"), r.content = t.highlight(r.content.value, {
            expression: {
              pattern: o,
              lookbehind: !0,
              inside: t.languages.groovy
            }
          }), r.classes.push(a === "/" ? "regex" : "gstring");
        }
      }
    });
  }
  return groovy_1;
}
var haml_1, hasRequiredHaml;
function requireHaml() {
  if (hasRequiredHaml) return haml_1;
  hasRequiredHaml = 1;
  var e = requireRuby();
  haml_1 = t, t.displayName = "haml", t.aliases = [];
  function t(r) {
    r.register(e), function(a) {
      a.languages.haml = {
        // Multiline stuff should appear before the rest
        "multiline-comment": {
          pattern: /((?:^|\r?\n|\r)([\t ]*))(?:\/|-#).*(?:(?:\r?\n|\r)\2[\t ].+)*/,
          lookbehind: !0,
          alias: "comment"
        },
        "multiline-code": [{
          pattern: /((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*,[\t ]*(?:(?:\r?\n|\r)\2[\t ].*,[\t ]*)*(?:(?:\r?\n|\r)\2[\t ].+)/,
          lookbehind: !0,
          inside: a.languages.ruby
        }, {
          pattern: /((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*\|[\t ]*(?:(?:\r?\n|\r)\2[\t ].*\|[\t ]*)*/,
          lookbehind: !0,
          inside: a.languages.ruby
        }],
        // See at the end of the file for known filters
        filter: {
          pattern: /((?:^|\r?\n|\r)([\t ]*)):[\w-]+(?:(?:\r?\n|\r)(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/,
          lookbehind: !0,
          inside: {
            "filter-name": {
              pattern: /^:[\w-]+/,
              alias: "symbol"
            }
          }
        },
        markup: {
          pattern: /((?:^|\r?\n|\r)[\t ]*)<.+/,
          lookbehind: !0,
          inside: a.languages.markup
        },
        doctype: {
          pattern: /((?:^|\r?\n|\r)[\t ]*)!!!(?: .+)?/,
          lookbehind: !0
        },
        tag: {
          // Allows for one nested group of braces
          pattern: /((?:^|\r?\n|\r)[\t ]*)[%.#][\w\-#.]*[\w\-](?:\([^)]+\)|\{(?:\{[^}]+\}|[^{}])+\}|\[[^\]]+\])*[\/<>]*/,
          lookbehind: !0,
          inside: {
            attributes: [{
              // Lookbehind tries to prevent interpolations from breaking it all
              // Allows for one nested group of braces
              pattern: /(^|[^#])\{(?:\{[^}]+\}|[^{}])+\}/,
              lookbehind: !0,
              inside: a.languages.ruby
            }, {
              pattern: /\([^)]+\)/,
              inside: {
                "attr-value": {
                  pattern: /(=\s*)(?:"(?:\\.|[^\\"\r\n])*"|[^)\s]+)/,
                  lookbehind: !0
                },
                "attr-name": /[\w:-]+(?=\s*!?=|\s*[,)])/,
                punctuation: /[=(),]/
              }
            }, {
              pattern: /\[[^\]]+\]/,
              inside: a.languages.ruby
            }],
            punctuation: /[<>]/
          }
        },
        code: {
          pattern: /((?:^|\r?\n|\r)[\t ]*(?:[~-]|[&!]?=)).+/,
          lookbehind: !0,
          inside: a.languages.ruby
        },
        // Interpolations in plain text
        interpolation: {
          pattern: /#\{[^}]+\}/,
          inside: {
            delimiter: {
              pattern: /^#\{|\}$/,
              alias: "punctuation"
            },
            ruby: {
              pattern: /[\s\S]+/,
              inside: a.languages.ruby
            }
          }
        },
        punctuation: {
          pattern: /((?:^|\r?\n|\r)[\t ]*)[~=\-&!]+/,
          lookbehind: !0
        }
      };
      for (var o = "((?:^|\\r?\\n|\\r)([\\t ]*)):{{filter_name}}(?:(?:\\r?\\n|\\r)(?:\\2[\\t ].+|\\s*?(?=\\r?\\n|\\r)))+", u = ["css", {
        filter: "coffee",
        language: "coffeescript"
      }, "erb", "javascript", "less", "markdown", "ruby", "scss", "textile"], c = {}, d = 0, g = u.length; d < g; d++) {
        var b = u[d];
        b = typeof b == "string" ? {
          filter: b,
          language: b
        } : b, a.languages[b.language] && (c["filter-" + b.filter] = {
          pattern: RegExp(o.replace("{{filter_name}}", function() {
            return b.filter;
          })),
          lookbehind: !0,
          inside: {
            "filter-name": {
              pattern: /^:[\w-]+/,
              alias: "symbol"
            },
            text: {
              pattern: /[\s\S]+/,
              alias: [b.language, "language-" + b.language],
              inside: a.languages[b.language]
            }
          }
        });
      }
      a.languages.insertBefore("haml", "filter", c);
    }(r);
  }
  return haml_1;
}
var handlebars_1, hasRequiredHandlebars;
function requireHandlebars() {
  if (hasRequiredHandlebars) return handlebars_1;
  hasRequiredHandlebars = 1;
  var e = requireMarkupTemplating();
  handlebars_1 = t, t.displayName = "handlebars", t.aliases = ["hbs"];
  function t(r) {
    r.register(e), function(a) {
      a.languages.handlebars = {
        comment: /\{\{![\s\S]*?\}\}/,
        delimiter: {
          pattern: /^\{\{\{?|\}\}\}?$/,
          alias: "punctuation"
        },
        string: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
        number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][+-]?\d+)?/,
        boolean: /\b(?:false|true)\b/,
        block: {
          pattern: /^(\s*(?:~\s*)?)[#\/]\S+?(?=\s*(?:~\s*)?$|\s)/,
          lookbehind: !0,
          alias: "keyword"
        },
        brackets: {
          pattern: /\[[^\]]+\]/,
          inside: {
            punctuation: /\[|\]/,
            variable: /[\s\S]+/
          }
        },
        punctuation: /[!"#%&':()*+,.\/;<=>@\[\\\]^`{|}~]/,
        variable: /[^!"#%&'()*+,\/;<=>@\[\\\]^`{|}~\s]+/
      }, a.hooks.add("before-tokenize", function(o) {
        var u = /\{\{\{[\s\S]+?\}\}\}|\{\{[\s\S]+?\}\}/g;
        a.languages["markup-templating"].buildPlaceholders(o, "handlebars", u);
      }), a.hooks.add("after-tokenize", function(o) {
        a.languages["markup-templating"].tokenizePlaceholders(o, "handlebars");
      }), a.languages.hbs = a.languages.handlebars;
    }(r);
  }
  return handlebars_1;
}
var haskell_1, hasRequiredHaskell;
function requireHaskell() {
  if (hasRequiredHaskell) return haskell_1;
  hasRequiredHaskell = 1, haskell_1 = e, e.displayName = "haskell", e.aliases = ["hs"];
  function e(t) {
    t.languages.haskell = {
      comment: {
        pattern: /(^|[^-!#$%*+=?&@|~.:<>^\\\/])(?:--(?:(?=.)[^-!#$%*+=?&@|~.:<>^\\\/].*|$)|\{-[\s\S]*?-\})/m,
        lookbehind: !0
      },
      char: {
        pattern: /'(?:[^\\']|\\(?:[abfnrtv\\"'&]|\^[A-Z@[\]^_]|ACK|BEL|BS|CAN|CR|DC1|DC2|DC3|DC4|DEL|DLE|EM|ENQ|EOT|ESC|ETB|ETX|FF|FS|GS|HT|LF|NAK|NUL|RS|SI|SO|SOH|SP|STX|SUB|SYN|US|VT|\d+|o[0-7]+|x[0-9a-fA-F]+))'/,
        alias: "string"
      },
      string: {
        pattern: /"(?:[^\\"]|\\(?:\S|\s+\\))*"/,
        greedy: !0
      },
      keyword: /\b(?:case|class|data|deriving|do|else|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\b/,
      "import-statement": {
        // The imported or hidden names are not included in this import
        // statement. This is because we want to highlight those exactly like
        // we do for the names in the program.
        pattern: /(^[\t ]*)import\s+(?:qualified\s+)?(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*(?:\s+as\s+(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*)?(?:\s+hiding\b)?/m,
        lookbehind: !0,
        inside: {
          keyword: /\b(?:as|hiding|import|qualified)\b/,
          punctuation: /\./
        }
      },
      // These are builtin variables only. Constructors are highlighted later as a constant.
      builtin: /\b(?:abs|acos|acosh|all|and|any|appendFile|approxRational|asTypeOf|asin|asinh|atan|atan2|atanh|basicIORun|break|catch|ceiling|chr|compare|concat|concatMap|const|cos|cosh|curry|cycle|decodeFloat|denominator|digitToInt|div|divMod|drop|dropWhile|either|elem|encodeFloat|enumFrom|enumFromThen|enumFromThenTo|enumFromTo|error|even|exp|exponent|fail|filter|flip|floatDigits|floatRadix|floatRange|floor|fmap|foldl|foldl1|foldr|foldr1|fromDouble|fromEnum|fromInt|fromInteger|fromIntegral|fromRational|fst|gcd|getChar|getContents|getLine|group|head|id|inRange|index|init|intToDigit|interact|ioError|isAlpha|isAlphaNum|isAscii|isControl|isDenormalized|isDigit|isHexDigit|isIEEE|isInfinite|isLower|isNaN|isNegativeZero|isOctDigit|isPrint|isSpace|isUpper|iterate|last|lcm|length|lex|lexDigits|lexLitChar|lines|log|logBase|lookup|map|mapM|mapM_|max|maxBound|maximum|maybe|min|minBound|minimum|mod|negate|not|notElem|null|numerator|odd|or|ord|otherwise|pack|pi|pred|primExitWith|print|product|properFraction|putChar|putStr|putStrLn|quot|quotRem|range|rangeSize|read|readDec|readFile|readFloat|readHex|readIO|readInt|readList|readLitChar|readLn|readOct|readParen|readSigned|reads|readsPrec|realToFrac|recip|rem|repeat|replicate|return|reverse|round|scaleFloat|scanl|scanl1|scanr|scanr1|seq|sequence|sequence_|show|showChar|showInt|showList|showLitChar|showParen|showSigned|showString|shows|showsPrec|significand|signum|sin|sinh|snd|sort|span|splitAt|sqrt|subtract|succ|sum|tail|take|takeWhile|tan|tanh|threadToIOResult|toEnum|toInt|toInteger|toLower|toRational|toUpper|truncate|uncurry|undefined|unlines|until|unwords|unzip|unzip3|userError|words|writeFile|zip|zip3|zipWith|zipWith3)\b/,
      // decimal integers and floating point numbers | octal integers | hexadecimal integers
      number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0o[0-7]+|0x[0-9a-f]+)\b/i,
      operator: [
        {
          // infix operator
          pattern: /`(?:[A-Z][\w']*\.)*[_a-z][\w']*`/,
          greedy: !0
        },
        {
          // function composition
          pattern: /(\s)\.(?=\s)/,
          lookbehind: !0
        },
        // Most of this is needed because of the meaning of a single '.'.
        // If it stands alone freely, it is the function composition.
        // It may also be a separator between a module name and an identifier => no
        // operator. If it comes together with other special characters it is an
        // operator too.
        //
        // This regex means: /[-!#$%*+=?&@|~.:<>^\\\/]+/ without /\./.
        /[-!#$%*+=?&@|~:<>^\\\/][-!#$%*+=?&@|~.:<>^\\\/]*|\.[-!#$%*+=?&@|~.:<>^\\\/]+/
      ],
      // In Haskell, nearly everything is a variable, do not highlight these.
      hvariable: {
        pattern: /\b(?:[A-Z][\w']*\.)*[_a-z][\w']*/,
        inside: {
          punctuation: /\./
        }
      },
      constant: {
        pattern: /\b(?:[A-Z][\w']*\.)*[A-Z][\w']*/,
        inside: {
          punctuation: /\./
        }
      },
      punctuation: /[{}[\];(),.:]/
    }, t.languages.hs = t.languages.haskell;
  }
  return haskell_1;
}
var haxe_1, hasRequiredHaxe;
function requireHaxe() {
  if (hasRequiredHaxe) return haxe_1;
  hasRequiredHaxe = 1, haxe_1 = e, e.displayName = "haxe", e.aliases = [];
  function e(t) {
    t.languages.haxe = t.languages.extend("clike", {
      string: {
        // Strings can be multi-line
        pattern: /"(?:[^"\\]|\\[\s\S])*"/,
        greedy: !0
      },
      "class-name": [
        {
          pattern: /(\b(?:abstract|class|enum|extends|implements|interface|new|typedef)\s+)[A-Z_]\w*/,
          lookbehind: !0
        },
        // based on naming convention
        /\b[A-Z]\w*/
      ],
      // The final look-ahead prevents highlighting of keywords if expressions such as "haxe.macro.Expr"
      keyword: /\bthis\b|\b(?:abstract|as|break|case|cast|catch|class|continue|default|do|dynamic|else|enum|extends|extern|final|for|from|function|if|implements|import|in|inline|interface|macro|new|null|operator|overload|override|package|private|public|return|static|super|switch|throw|to|try|typedef|untyped|using|var|while)(?!\.)\b/,
      function: {
        pattern: /\b[a-z_]\w*(?=\s*(?:<[^<>]*>\s*)?\()/i,
        greedy: !0
      },
      operator: /\.{3}|\+\+|--|&&|\|\||->|=>|(?:<<?|>{1,3}|[-+*/%!=&|^])=?|[?:~]/
    }), t.languages.insertBefore("haxe", "string", {
      "string-interpolation": {
        pattern: /'(?:[^'\\]|\\[\s\S])*'/,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /(^|[^\\])\$(?:\w+|\{[^{}]+\})/,
            lookbehind: !0,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{?|\}$/,
                alias: "punctuation"
              },
              expression: {
                pattern: /[\s\S]+/,
                inside: t.languages.haxe
              }
            }
          },
          string: /[\s\S]+/
        }
      }
    }), t.languages.insertBefore("haxe", "class-name", {
      regex: {
        pattern: /~\/(?:[^\/\\\r\n]|\\.)+\/[a-z]*/,
        greedy: !0,
        inside: {
          "regex-flags": /\b[a-z]+$/,
          "regex-source": {
            pattern: /^(~\/)[\s\S]+(?=\/$)/,
            lookbehind: !0,
            alias: "language-regex",
            inside: t.languages.regex
          },
          "regex-delimiter": /^~\/|\/$/
        }
      }
    }), t.languages.insertBefore("haxe", "keyword", {
      preprocessor: {
        pattern: /#(?:else|elseif|end|if)\b.*/,
        alias: "property"
      },
      metadata: {
        pattern: /@:?[\w.]+/,
        alias: "symbol"
      },
      reification: {
        pattern: /\$(?:\w+|(?=\{))/,
        alias: "important"
      }
    });
  }
  return haxe_1;
}
var hcl_1, hasRequiredHcl;
function requireHcl() {
  if (hasRequiredHcl) return hcl_1;
  hasRequiredHcl = 1, hcl_1 = e, e.displayName = "hcl", e.aliases = [];
  function e(t) {
    t.languages.hcl = {
      comment: /(?:\/\/|#).*|\/\*[\s\S]*?(?:\*\/|$)/,
      heredoc: {
        pattern: /<<-?(\w+\b)[\s\S]*?^[ \t]*\1/m,
        greedy: !0,
        alias: "string"
      },
      keyword: [{
        pattern: /(?:data|resource)\s+(?:"(?:\\[\s\S]|[^\\"])*")(?=\s+"[\w-]+"\s+\{)/i,
        inside: {
          type: {
            pattern: /(resource|data|\s+)(?:"(?:\\[\s\S]|[^\\"])*")/i,
            lookbehind: !0,
            alias: "variable"
          }
        }
      }, {
        pattern: /(?:backend|module|output|provider|provisioner|variable)\s+(?:[\w-]+|"(?:\\[\s\S]|[^\\"])*")\s+(?=\{)/i,
        inside: {
          type: {
            pattern: /(backend|module|output|provider|provisioner|variable)\s+(?:[\w-]+|"(?:\\[\s\S]|[^\\"])*")\s+/i,
            lookbehind: !0,
            alias: "variable"
          }
        }
      }, /[\w-]+(?=\s+\{)/],
      property: [/[-\w\.]+(?=\s*=(?!=))/, /"(?:\\[\s\S]|[^\\"])+"(?=\s*[:=])/],
      string: {
        pattern: /"(?:[^\\$"]|\\[\s\S]|\$(?:(?=")|\$+(?!\$)|[^"${])|\$\{(?:[^{}"]|"(?:[^\\"]|\\[\s\S])*")*\})*"/,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /(^|[^$])\$\{(?:[^{}"]|"(?:[^\\"]|\\[\s\S])*")*\}/,
            lookbehind: !0,
            inside: {
              type: {
                pattern: /(\b(?:count|data|local|module|path|self|terraform|var)\b\.)[\w\*]+/i,
                lookbehind: !0,
                alias: "variable"
              },
              keyword: /\b(?:count|data|local|module|path|self|terraform|var)\b/i,
              function: /\w+(?=\()/,
              string: {
                pattern: /"(?:\\[\s\S]|[^\\"])*"/,
                greedy: !0
              },
              number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
              punctuation: /[!\$#%&'()*+,.\/;<=>@\[\\\]^`{|}~?:]/
            }
          }
        }
      },
      number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
      boolean: /\b(?:false|true)\b/i,
      punctuation: /[=\[\]{}]/
    };
  }
  return hcl_1;
}
var hlsl_1, hasRequiredHlsl;
function requireHlsl() {
  if (hasRequiredHlsl) return hlsl_1;
  hasRequiredHlsl = 1;
  var e = requireC();
  hlsl_1 = t, t.displayName = "hlsl", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.hlsl = r.languages.extend("c", {
      // Regarding keywords and class names:
      // The list of all keywords was split into 'keyword' and 'class-name' tokens based on whether they are capitalized.
      // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-keywords
      // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-reserved-words
      "class-name": [r.languages.c["class-name"], /\b(?:AppendStructuredBuffer|BlendState|Buffer|ByteAddressBuffer|CompileShader|ComputeShader|ConsumeStructuredBuffer|DepthStencilState|DepthStencilView|DomainShader|GeometryShader|Hullshader|InputPatch|LineStream|OutputPatch|PixelShader|PointStream|RWBuffer|RWByteAddressBuffer|RWStructuredBuffer|RWTexture(?:1D|1DArray|2D|2DArray|3D)|RasterizerState|RenderTargetView|SamplerComparisonState|SamplerState|StructuredBuffer|Texture(?:1D|1DArray|2D|2DArray|2DMS|2DMSArray|3D|Cube|CubeArray)|TriangleStream|VertexShader)\b/],
      keyword: [
        // HLSL keyword
        /\b(?:asm|asm_fragment|auto|break|case|catch|cbuffer|centroid|char|class|column_major|compile|compile_fragment|const|const_cast|continue|default|delete|discard|do|dynamic_cast|else|enum|explicit|export|extern|for|friend|fxgroup|goto|groupshared|if|in|inline|inout|interface|line|lineadj|linear|long|matrix|mutable|namespace|new|nointerpolation|noperspective|operator|out|packoffset|pass|pixelfragment|point|precise|private|protected|public|register|reinterpret_cast|return|row_major|sample|sampler|shared|short|signed|sizeof|snorm|stateblock|stateblock_state|static|static_cast|string|struct|switch|tbuffer|technique|technique10|technique11|template|texture|this|throw|triangle|triangleadj|try|typedef|typename|uniform|union|unorm|unsigned|using|vector|vertexfragment|virtual|void|volatile|while)\b/,
        // scalar, vector, and matrix types
        /\b(?:bool|double|dword|float|half|int|min(?:10float|12int|16(?:float|int|uint))|uint)(?:[1-4](?:x[1-4])?)?\b/
      ],
      // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-grammar#floating-point-numbers
      number: /(?:(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+)?|\b0x[\da-fA-F]+)[fFhHlLuU]?\b/,
      boolean: /\b(?:false|true)\b/
    });
  }
  return hlsl_1;
}
var hoon_1, hasRequiredHoon;
function requireHoon() {
  if (hasRequiredHoon) return hoon_1;
  hasRequiredHoon = 1, hoon_1 = e, e.displayName = "hoon", e.aliases = [];
  function e(t) {
    t.languages.hoon = {
      comment: {
        pattern: /::.*/,
        greedy: !0
      },
      string: {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: !0
      },
      constant: /%(?:\.[ny]|[\w-]+)/,
      "class-name": /@(?:[a-z0-9-]*[a-z0-9])?|\*/i,
      function: /(?:\+[-+] {2})?(?:[a-z](?:[a-z0-9-]*[a-z0-9])?)/,
      keyword: /\.[\^\+\*=\?]|![><:\.=\?!]|=[>|:,\.\-\^<+;/~\*\?]|\?[>|:\.\-\^<\+&~=@!]|\|[\$_%:\.\-\^~\*=@\?]|\+[|\$\+\*]|:[_\-\^\+~\*]|%[_:\.\-\^\+~\*=]|\^[|:\.\-\+&~\*=\?]|\$[|_%:<>\-\^&~@=\?]|;[:<\+;\/~\*=]|~[>|\$_%<\+\/&=\?!]|--|==/
    };
  }
  return hoon_1;
}
var hpkp_1, hasRequiredHpkp;
function requireHpkp() {
  if (hasRequiredHpkp) return hpkp_1;
  hasRequiredHpkp = 1, hpkp_1 = e, e.displayName = "hpkp", e.aliases = [];
  function e(t) {
    t.languages.hpkp = {
      directive: {
        pattern: /\b(?:includeSubDomains|max-age|pin-sha256|preload|report-to|report-uri|strict)(?=[\s;=]|$)/i,
        alias: "property"
      },
      operator: /=/,
      punctuation: /;/
    };
  }
  return hpkp_1;
}
var hsts_1, hasRequiredHsts;
function requireHsts() {
  if (hasRequiredHsts) return hsts_1;
  hasRequiredHsts = 1, hsts_1 = e, e.displayName = "hsts", e.aliases = [];
  function e(t) {
    t.languages.hsts = {
      directive: {
        pattern: /\b(?:includeSubDomains|max-age|preload)(?=[\s;=]|$)/i,
        alias: "property"
      },
      operator: /=/,
      punctuation: /;/
    };
  }
  return hsts_1;
}
var http_1, hasRequiredHttp;
function requireHttp() {
  if (hasRequiredHttp) return http_1;
  hasRequiredHttp = 1, http_1 = e, e.displayName = "http", e.aliases = [];
  function e(t) {
    (function(r) {
      function a(y) {
        return RegExp("(^(?:" + y + "):[ 	]*(?![ 	]))[^]+", "i");
      }
      r.languages.http = {
        "request-line": {
          pattern: /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\s(?:https?:\/\/|\/)\S*\sHTTP\/[\d.]+/m,
          inside: {
            // HTTP Method
            method: {
              pattern: /^[A-Z]+\b/,
              alias: "property"
            },
            // Request Target e.g. http://example.com, /path/to/file
            "request-target": {
              pattern: /^(\s)(?:https?:\/\/|\/)\S*(?=\s)/,
              lookbehind: !0,
              alias: "url",
              inside: r.languages.uri
            },
            // HTTP Version
            "http-version": {
              pattern: /^(\s)HTTP\/[\d.]+/,
              lookbehind: !0,
              alias: "property"
            }
          }
        },
        "response-status": {
          pattern: /^HTTP\/[\d.]+ \d+ .+/m,
          inside: {
            // HTTP Version
            "http-version": {
              pattern: /^HTTP\/[\d.]+/,
              alias: "property"
            },
            // Status Code
            "status-code": {
              pattern: /^(\s)\d+(?=\s)/,
              lookbehind: !0,
              alias: "number"
            },
            // Reason Phrase
            "reason-phrase": {
              pattern: /^(\s).+/,
              lookbehind: !0,
              alias: "string"
            }
          }
        },
        header: {
          pattern: /^[\w-]+:.+(?:(?:\r\n?|\n)[ \t].+)*/m,
          inside: {
            "header-value": [{
              pattern: a(/Content-Security-Policy/.source),
              lookbehind: !0,
              alias: ["csp", "languages-csp"],
              inside: r.languages.csp
            }, {
              pattern: a(/Public-Key-Pins(?:-Report-Only)?/.source),
              lookbehind: !0,
              alias: ["hpkp", "languages-hpkp"],
              inside: r.languages.hpkp
            }, {
              pattern: a(/Strict-Transport-Security/.source),
              lookbehind: !0,
              alias: ["hsts", "languages-hsts"],
              inside: r.languages.hsts
            }, {
              pattern: a(/[^:]+/.source),
              lookbehind: !0
            }],
            "header-name": {
              pattern: /^[^:]+/,
              alias: "keyword"
            },
            punctuation: /^:/
          }
        }
      };
      var o = r.languages, u = {
        "application/javascript": o.javascript,
        "application/json": o.json || o.javascript,
        "application/xml": o.xml,
        "text/xml": o.xml,
        "text/html": o.html,
        "text/css": o.css,
        "text/plain": o.plain
      }, c = {
        "application/json": !0,
        "application/xml": !0
      };
      function d(y) {
        var A = y.replace(/^[a-z]+\//, ""), E = "\\w+/(?:[\\w.-]+\\+)+" + A + "(?![+\\w.-])";
        return "(?:" + y + "|" + E + ")";
      }
      var g;
      for (var b in u)
        if (u[b]) {
          g = g || {};
          var _ = c[b] ? d(b) : b;
          g[b.replace(/\//g, "-")] = {
            pattern: RegExp("(" + /content-type:\s*/.source + _ + /(?:(?:\r\n?|\n)[\w-].*)*(?:\r(?:\n|(?!\n))|\n)/.source + ")" + // This is a little interesting:
            // The HTTP format spec required 1 empty line before the body to make everything unambiguous.
            // However, when writing code by hand (e.g. to display on a website) people can forget about this,
            // so we want to be liberal here. We will allow the empty line to be omitted if the first line of
            // the body does not start with a [\w-] character (as headers do).
            /[^ \t\w-][\s\S]*/.source, "i"),
            lookbehind: !0,
            inside: u[b]
          };
        }
      g && r.languages.insertBefore("http", "header", g);
    })(t);
  }
  return http_1;
}
var ichigojam_1, hasRequiredIchigojam;
function requireIchigojam() {
  if (hasRequiredIchigojam) return ichigojam_1;
  hasRequiredIchigojam = 1, ichigojam_1 = e, e.displayName = "ichigojam", e.aliases = [];
  function e(t) {
    t.languages.ichigojam = {
      comment: /(?:\B'|REM)(?:[^\n\r]*)/i,
      string: {
        pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
        greedy: !0
      },
      number: /\B#[0-9A-F]+|\B`[01]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
      keyword: /\b(?:BEEP|BPS|CASE|CLEAR|CLK|CLO|CLP|CLS|CLT|CLV|CONT|COPY|ELSE|END|FILE|FILES|FOR|GOSUB|GOTO|GSB|IF|INPUT|KBD|LED|LET|LIST|LOAD|LOCATE|LRUN|NEW|NEXT|OUT|PLAY|POKE|PRINT|PWM|REM|RENUM|RESET|RETURN|RIGHT|RTN|RUN|SAVE|SCROLL|SLEEP|SRND|STEP|STOP|SUB|TEMPO|THEN|TO|UART|VIDEO|WAIT)(?:\$|\b)/i,
      function: /\b(?:ABS|ANA|ASC|BIN|BTN|DEC|END|FREE|HELP|HEX|I2CR|I2CW|IN|INKEY|LEN|LINE|PEEK|RND|SCR|SOUND|STR|TICK|USR|VER|VPEEK|ZER)(?:\$|\b)/i,
      label: /(?:\B@\S+)/,
      operator: /<[=>]?|>=?|\|\||&&|[+\-*\/=|&^~!]|\b(?:AND|NOT|OR)\b/i,
      punctuation: /[\[,;:()\]]/
    };
  }
  return ichigojam_1;
}
var icon_1, hasRequiredIcon;
function requireIcon() {
  if (hasRequiredIcon) return icon_1;
  hasRequiredIcon = 1, icon_1 = e, e.displayName = "icon", e.aliases = [];
  function e(t) {
    t.languages.icon = {
      comment: /#.*/,
      string: {
        pattern: /(["'])(?:(?!\1)[^\\\r\n_]|\\.|_(?!\1)(?:\r\n|[\s\S]))*\1/,
        greedy: !0
      },
      number: /\b(?:\d+r[a-z\d]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b|\.\d+\b/i,
      "builtin-keyword": {
        pattern: /&(?:allocated|ascii|clock|collections|cset|current|date|dateline|digits|dump|e|error(?:number|text|value)?|errout|fail|features|file|host|input|lcase|letters|level|line|main|null|output|phi|pi|pos|progname|random|regions|source|storage|subject|time|trace|ucase|version)\b/,
        alias: "variable"
      },
      directive: {
        pattern: /\$\w+/,
        alias: "builtin"
      },
      keyword: /\b(?:break|by|case|create|default|do|else|end|every|fail|global|if|initial|invocable|link|local|next|not|of|procedure|record|repeat|return|static|suspend|then|to|until|while)\b/,
      function: /\b(?!\d)\w+(?=\s*[({]|\s*!\s*\[)/,
      operator: /[+-]:(?!=)|(?:[\/?@^%&]|\+\+?|--?|==?=?|~==?=?|\*\*?|\|\|\|?|<(?:->?|<?=?)|>>?=?)(?::=)?|:(?:=:?)?|[!.\\|~]/,
      punctuation: /[\[\](){},;]/
    };
  }
  return icon_1;
}
var icuMessageFormat_1, hasRequiredIcuMessageFormat;
function requireIcuMessageFormat() {
  if (hasRequiredIcuMessageFormat) return icuMessageFormat_1;
  hasRequiredIcuMessageFormat = 1, icuMessageFormat_1 = e, e.displayName = "icuMessageFormat", e.aliases = [];
  function e(t) {
    (function(r) {
      function a(b, _) {
        return _ <= 0 ? /[]/.source : b.replace(/<SELF>/g, function() {
          return a(b, _ - 1);
        });
      }
      var o = /'[{}:=,](?:[^']|'')*'(?!')/, u = {
        pattern: /''/,
        greedy: !0,
        alias: "operator"
      }, c = {
        pattern: o,
        greedy: !0,
        inside: {
          escape: u
        }
      }, d = a(/\{(?:[^{}']|'(?![{},'])|''|<STR>|<SELF>)*\}/.source.replace(/<STR>/g, function() {
        return o.source;
      }), 8), g = {
        pattern: RegExp(d),
        inside: {
          message: {
            pattern: /^(\{)[\s\S]+(?=\}$)/,
            lookbehind: !0,
            inside: null
            // see below
          },
          "message-delimiter": {
            pattern: /./,
            alias: "punctuation"
          }
        }
      };
      r.languages["icu-message-format"] = {
        argument: {
          pattern: RegExp(d),
          greedy: !0,
          inside: {
            content: {
              pattern: /^(\{)[\s\S]+(?=\}$)/,
              lookbehind: !0,
              inside: {
                "argument-name": {
                  pattern: /^(\s*)[^{}:=,\s]+/,
                  lookbehind: !0
                },
                "choice-style": {
                  // https://unicode-org.github.io/icu-docs/apidoc/released/icu4c/classicu_1_1ChoiceFormat.html#details
                  pattern: /^(\s*,\s*choice\s*,\s*)\S(?:[\s\S]*\S)?/,
                  lookbehind: !0,
                  inside: {
                    punctuation: /\|/,
                    range: {
                      pattern: /^(\s*)[+-]?(?:\d+(?:\.\d*)?|\u221e)\s*[<#\u2264]/,
                      lookbehind: !0,
                      inside: {
                        operator: /[<#\u2264]/,
                        number: /\S+/
                      }
                    },
                    rest: null
                    // see below
                  }
                },
                "plural-style": {
                  // https://unicode-org.github.io/icu-docs/apidoc/released/icu4j/com/ibm/icu/text/PluralFormat.html#:~:text=Patterns%20and%20Their%20Interpretation
                  pattern: /^(\s*,\s*(?:plural|selectordinal)\s*,\s*)\S(?:[\s\S]*\S)?/,
                  lookbehind: !0,
                  inside: {
                    offset: /^offset:\s*\d+/,
                    "nested-message": g,
                    selector: {
                      pattern: /=\d+|[^{}:=,\s]+/,
                      inside: {
                        keyword: /^(?:few|many|one|other|two|zero)$/
                      }
                    }
                  }
                },
                "select-style": {
                  // https://unicode-org.github.io/icu-docs/apidoc/released/icu4j/com/ibm/icu/text/SelectFormat.html#:~:text=Patterns%20and%20Their%20Interpretation
                  pattern: /^(\s*,\s*select\s*,\s*)\S(?:[\s\S]*\S)?/,
                  lookbehind: !0,
                  inside: {
                    "nested-message": g,
                    selector: {
                      pattern: /[^{}:=,\s]+/,
                      inside: {
                        keyword: /^other$/
                      }
                    }
                  }
                },
                keyword: /\b(?:choice|plural|select|selectordinal)\b/,
                "arg-type": {
                  pattern: /\b(?:date|duration|number|ordinal|spellout|time)\b/,
                  alias: "keyword"
                },
                "arg-skeleton": {
                  pattern: /(,\s*)::[^{}:=,\s]+/,
                  lookbehind: !0
                },
                "arg-style": {
                  pattern: /(,\s*)(?:currency|full|integer|long|medium|percent|short)(?=\s*$)/,
                  lookbehind: !0
                },
                "arg-style-text": {
                  pattern: RegExp(/(^\s*,\s*(?=\S))/.source + a(/(?:[^{}']|'[^']*'|\{(?:<SELF>)?\})+/.source, 8) + "$"),
                  lookbehind: !0,
                  alias: "string"
                },
                punctuation: /,/
              }
            },
            "argument-delimiter": {
              pattern: /./,
              alias: "operator"
            }
          }
        },
        escape: u,
        string: c
      }, g.inside.message.inside = r.languages["icu-message-format"], r.languages["icu-message-format"].argument.inside.content.inside["choice-style"].inside.rest = r.languages["icu-message-format"];
    })(t);
  }
  return icuMessageFormat_1;
}
var idris_1, hasRequiredIdris;
function requireIdris() {
  if (hasRequiredIdris) return idris_1;
  hasRequiredIdris = 1;
  var e = requireHaskell();
  idris_1 = t, t.displayName = "idris", t.aliases = ["idr"];
  function t(r) {
    r.register(e), r.languages.idris = r.languages.extend("haskell", {
      comment: {
        pattern: /(?:(?:--|\|\|\|).*$|\{-[\s\S]*?-\})/m
      },
      keyword: /\b(?:Type|case|class|codata|constructor|corecord|data|do|dsl|else|export|if|implementation|implicit|import|impossible|in|infix|infixl|infixr|instance|interface|let|module|mutual|namespace|of|parameters|partial|postulate|private|proof|public|quoteGoal|record|rewrite|syntax|then|total|using|where|with)\b/,
      builtin: void 0
    }), r.languages.insertBefore("idris", "keyword", {
      "import-statement": {
        pattern: /(^\s*import\s+)(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*/m,
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      }
    }), r.languages.idr = r.languages.idris;
  }
  return idris_1;
}
var iecst_1, hasRequiredIecst;
function requireIecst() {
  if (hasRequiredIecst) return iecst_1;
  hasRequiredIecst = 1, iecst_1 = e, e.displayName = "iecst", e.aliases = [];
  function e(t) {
    t.languages.iecst = {
      comment: [{
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\(\*[\s\S]*?(?:\*\)|$)|\{[\s\S]*?(?:\}|$))/,
        lookbehind: !0,
        greedy: !0
      }, {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }],
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      keyword: [/\b(?:END_)?(?:PROGRAM|CONFIGURATION|INTERFACE|FUNCTION_BLOCK|FUNCTION|ACTION|TRANSITION|TYPE|STRUCT|(?:INITIAL_)?STEP|NAMESPACE|LIBRARY|CHANNEL|FOLDER|RESOURCE|VAR_(?:ACCESS|CONFIG|EXTERNAL|GLOBAL|INPUT|IN_OUT|OUTPUT|TEMP)|VAR|METHOD|PROPERTY)\b/i, /\b(?:AT|BY|(?:END_)?(?:CASE|FOR|IF|REPEAT|WHILE)|CONSTANT|CONTINUE|DO|ELSE|ELSIF|EXIT|EXTENDS|FROM|GET|GOTO|IMPLEMENTS|JMP|NON_RETAIN|OF|PRIVATE|PROTECTED|PUBLIC|RETAIN|RETURN|SET|TASK|THEN|TO|UNTIL|USING|WITH|__CATCH|__ENDTRY|__FINALLY|__TRY)\b/],
      "class-name": /\b(?:ANY|ARRAY|BOOL|BYTE|U?(?:D|L|S)?INT|(?:D|L)?WORD|DATE(?:_AND_TIME)?|DT|L?REAL|POINTER|STRING|TIME(?:_OF_DAY)?|TOD)\b/,
      address: {
        pattern: /%[IQM][XBWDL][\d.]*|%[IQ][\d.]*/,
        alias: "symbol"
      },
      number: /\b(?:16#[\da-f]+|2#[01_]+|0x[\da-f]+)\b|\b(?:D|DT|T|TOD)#[\d_shmd:]*|\b[A-Z]*#[\d.,_]*|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      boolean: /\b(?:FALSE|NULL|TRUE)\b/,
      operator: /S?R?:?=>?|&&?|\*\*?|<[=>]?|>=?|[-:^/+#]|\b(?:AND|EQ|EXPT|GE|GT|LE|LT|MOD|NE|NOT|OR|XOR)\b/,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      punctuation: /[()[\].,;]/
    };
  }
  return iecst_1;
}
var ignore_1, hasRequiredIgnore;
function requireIgnore() {
  if (hasRequiredIgnore) return ignore_1;
  hasRequiredIgnore = 1, ignore_1 = e, e.displayName = "ignore", e.aliases = ["gitignore", "hgignore", "npmignore"];
  function e(t) {
    (function(r) {
      r.languages.ignore = {
        // https://git-scm.com/docs/gitignore
        comment: /^#.*/m,
        entry: {
          pattern: /\S(?:.*(?:(?:\\ )|\S))?/,
          alias: "string",
          inside: {
            operator: /^!|\*\*?|\?/,
            regex: {
              pattern: /(^|[^\\])\[[^\[\]]*\]/,
              lookbehind: !0
            },
            punctuation: /\//
          }
        }
      }, r.languages.gitignore = r.languages.ignore, r.languages.hgignore = r.languages.ignore, r.languages.npmignore = r.languages.ignore;
    })(t);
  }
  return ignore_1;
}
var inform7_1, hasRequiredInform7;
function requireInform7() {
  if (hasRequiredInform7) return inform7_1;
  hasRequiredInform7 = 1, inform7_1 = e, e.displayName = "inform7", e.aliases = [];
  function e(t) {
    t.languages.inform7 = {
      string: {
        pattern: /"[^"]*"/,
        inside: {
          substitution: {
            pattern: /\[[^\[\]]+\]/,
            inside: {
              delimiter: {
                pattern: /\[|\]/,
                alias: "punctuation"
              }
              // See rest below
            }
          }
        }
      },
      comment: {
        pattern: /\[[^\[\]]+\]/,
        greedy: !0
      },
      title: {
        pattern: /^[ \t]*(?:book|chapter|part(?! of)|section|table|volume)\b.+/im,
        alias: "important"
      },
      number: {
        pattern: /(^|[^-])(?:\b\d+(?:\.\d+)?(?:\^\d+)?(?:(?!\d)\w+)?|\b(?:eight|eleven|five|four|nine|one|seven|six|ten|three|twelve|two))\b(?!-)/i,
        lookbehind: !0
      },
      verb: {
        pattern: /(^|[^-])\b(?:answering|applying to|are|asking|attacking|be(?:ing)?|burning|buying|called|carries|carry(?! out)|carrying|climbing|closing|conceal(?:ing|s)?|consulting|contain(?:ing|s)?|cutting|drinking|dropping|eating|enclos(?:es?|ing)|entering|examining|exiting|getting|giving|going|ha(?:s|ve|ving)|hold(?:ing|s)?|impl(?:ies|y)|incorporat(?:es?|ing)|inserting|is|jumping|kissing|listening|locking|looking|mean(?:ing|s)?|opening|provid(?:es?|ing)|pulling|pushing|putting|relat(?:es?|ing)|removing|searching|see(?:ing|s)?|setting|showing|singing|sleeping|smelling|squeezing|support(?:ing|s)?|swearing|switching|taking|tasting|telling|thinking|throwing|touching|turning|tying|unlock(?:ing|s)?|var(?:ies|y|ying)|waiting|waking|waving|wear(?:ing|s)?)\b(?!-)/i,
        lookbehind: !0,
        alias: "operator"
      },
      keyword: {
        pattern: /(^|[^-])\b(?:after|before|carry out|check|continue the action|definition(?= *:)|do nothing|else|end (?:if|the story|unless)|every turn|if|include|instead(?: of)?|let|move|no|now|otherwise|repeat|report|resume the story|rule for|running through|say(?:ing)?|stop the action|test|try(?:ing)?|understand|unless|use|when|while|yes)\b(?!-)/i,
        lookbehind: !0
      },
      property: {
        pattern: /(^|[^-])\b(?:adjacent(?! to)|carried|closed|concealed|contained|dark|described|edible|empty|enclosed|enterable|even|female|fixed in place|full|handled|held|improper-named|incorporated|inedible|invisible|lighted|lit|lock(?:able|ed)|male|marked for listing|mentioned|negative|neuter|non-(?:empty|full|recurring)|odd|opaque|open(?:able)?|plural-named|portable|positive|privately-named|proper-named|provided|publically-named|pushable between rooms|recurring|related|rubbing|scenery|seen|singular-named|supported|swinging|switch(?:able|ed(?: off| on)?)|touch(?:able|ed)|transparent|unconcealed|undescribed|unlit|unlocked|unmarked for listing|unmentioned|unopenable|untouchable|unvisited|variable|visible|visited|wearable|worn)\b(?!-)/i,
        lookbehind: !0,
        alias: "symbol"
      },
      position: {
        pattern: /(^|[^-])\b(?:above|adjacent to|back side of|below|between|down|east|everywhere|front side|here|in|inside(?: from)?|north(?:east|west)?|nowhere|on(?: top of)?|other side|outside(?: from)?|parts? of|regionally in|south(?:east|west)?|through|up|west|within)\b(?!-)/i,
        lookbehind: !0,
        alias: "keyword"
      },
      type: {
        pattern: /(^|[^-])\b(?:actions?|activit(?:ies|y)|actors?|animals?|backdrops?|containers?|devices?|directions?|doors?|holders?|kinds?|lists?|m[ae]n|nobody|nothing|nouns?|numbers?|objects?|people|persons?|player(?:'s holdall)?|regions?|relations?|rooms?|rule(?:book)?s?|scenes?|someone|something|supporters?|tables?|texts?|things?|time|vehicles?|wom[ae]n)\b(?!-)/i,
        lookbehind: !0,
        alias: "variable"
      },
      punctuation: /[.,:;(){}]/
    }, t.languages.inform7.string.inside.substitution.inside.rest = t.languages.inform7, t.languages.inform7.string.inside.substitution.inside.rest.text = {
      pattern: /\S(?:\s*\S)*/,
      alias: "comment"
    };
  }
  return inform7_1;
}
var ini_1, hasRequiredIni;
function requireIni() {
  if (hasRequiredIni) return ini_1;
  hasRequiredIni = 1, ini_1 = e, e.displayName = "ini", e.aliases = [];
  function e(t) {
    t.languages.ini = {
      /**
       * The component mimics the behavior of the Win32 API parser.
       *
       * @see {@link https://github.com/PrismJS/prism/issues/2775#issuecomment-787477723}
       */
      comment: {
        pattern: /(^[ \f\t\v]*)[#;][^\n\r]*/m,
        lookbehind: !0
      },
      section: {
        pattern: /(^[ \f\t\v]*)\[[^\n\r\]]*\]?/m,
        lookbehind: !0,
        inside: {
          "section-name": {
            pattern: /(^\[[ \f\t\v]*)[^ \f\t\v\]]+(?:[ \f\t\v]+[^ \f\t\v\]]+)*/,
            lookbehind: !0,
            alias: "selector"
          },
          punctuation: /\[|\]/
        }
      },
      key: {
        pattern: /(^[ \f\t\v]*)[^ \f\n\r\t\v=]+(?:[ \f\t\v]+[^ \f\n\r\t\v=]+)*(?=[ \f\t\v]*=)/m,
        lookbehind: !0,
        alias: "attr-name"
      },
      value: {
        pattern: /(=[ \f\t\v]*)[^ \f\n\r\t\v]+(?:[ \f\t\v]+[^ \f\n\r\t\v]+)*/,
        lookbehind: !0,
        alias: "attr-value",
        inside: {
          "inner-value": {
            pattern: /^("|').+(?=\1$)/,
            lookbehind: !0
          }
        }
      },
      punctuation: /=/
    };
  }
  return ini_1;
}
var io_1, hasRequiredIo;
function requireIo() {
  if (hasRequiredIo) return io_1;
  hasRequiredIo = 1, io_1 = e, e.displayName = "io", e.aliases = [];
  function e(t) {
    t.languages.io = {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\/\/.*|#.*)/,
        lookbehind: !0,
        greedy: !0
      },
      "triple-quoted-string": {
        pattern: /"""(?:\\[\s\S]|(?!""")[^\\])*"""/,
        greedy: !0,
        alias: "string"
      },
      string: {
        pattern: /"(?:\\.|[^\\\r\n"])*"/,
        greedy: !0
      },
      keyword: /\b(?:activate|activeCoroCount|asString|block|break|call|catch|clone|collectGarbage|compileString|continue|do|doFile|doMessage|doString|else|elseif|exit|for|foreach|forward|getEnvironmentVariable|getSlot|hasSlot|if|ifFalse|ifNil|ifNilEval|ifTrue|isActive|isNil|isResumable|list|message|method|parent|pass|pause|perform|performWithArgList|print|println|proto|raise|raiseResumable|removeSlot|resend|resume|schedulerSleepSeconds|self|sender|setSchedulerSleepSeconds|setSlot|shallowCopy|slotNames|super|system|then|thisBlock|thisContext|try|type|uniqueId|updateSlot|wait|while|write|yield)\b/,
      builtin: /\b(?:Array|AudioDevice|AudioMixer|BigNum|Block|Box|Buffer|CFunction|CGI|Color|Curses|DBM|DNSResolver|DOConnection|DOProxy|DOServer|Date|Directory|Duration|DynLib|Error|Exception|FFT|File|Fnmatch|Font|Future|GL|GLE|GLScissor|GLU|GLUCylinder|GLUQuadric|GLUSphere|GLUT|Host|Image|Importer|LinkList|List|Lobby|Locals|MD5|MP3Decoder|MP3Encoder|Map|Message|Movie|Notification|Number|Object|OpenGL|Point|Protos|Random|Regex|SGML|SGMLElement|SGMLParser|SQLite|Sequence|Server|ShowMessage|SleepyCat|SleepyCatCursor|Socket|SocketManager|Sound|Soup|Store|String|Tree|UDPSender|UPDReceiver|URL|User|Warning|WeakLink)\b/,
      boolean: /\b(?:false|nil|true)\b/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e-?\d+)?/i,
      operator: /[=!*/%+\-^&|]=|>>?=?|<<?=?|:?:?=|\+\+?|--?|\*\*?|\/\/?|%|\|\|?|&&?|\b(?:and|not|or|return)\b|@@?|\?\??|\.\./,
      punctuation: /[{}[\];(),.:]/
    };
  }
  return io_1;
}
var j_1, hasRequiredJ;
function requireJ() {
  if (hasRequiredJ) return j_1;
  hasRequiredJ = 1, j_1 = e, e.displayName = "j", e.aliases = [];
  function e(t) {
    t.languages.j = {
      comment: {
        pattern: /\bNB\..*/,
        greedy: !0
      },
      string: {
        pattern: /'(?:''|[^'\r\n])*'/,
        greedy: !0
      },
      keyword: /\b(?:(?:CR|LF|adverb|conjunction|def|define|dyad|monad|noun|verb)\b|(?:assert|break|case|catch[dt]?|continue|do|else|elseif|end|fcase|for|for_\w+|goto_\w+|if|label_\w+|return|select|throw|try|while|whilst)\.)/,
      verb: {
        // Negative look-ahead prevents bad highlighting
        // of ^: ;. =. =: !. !:
        pattern: /(?!\^:|;\.|[=!][.:])(?:\{(?:\.|::?)?|p(?:\.\.?|:)|[=!\]]|[<>+*\-%$|,#][.:]?|[?^]\.?|[;\[]:?|[~}"i][.:]|[ACeEIjLor]\.|(?:[_\/\\qsux]|_?\d):)/,
        alias: "keyword"
      },
      number: /\b_?(?:(?!\d:)\d+(?:\.\d+)?(?:(?:ad|ar|[ejpx])_?\d+(?:\.\d+)?)*(?:b_?[\da-z]+(?:\.[\da-z]+)?)?|_\b(?!\.))/,
      adverb: {
        pattern: /[~}]|[\/\\]\.?|[bfM]\.|t[.:]/,
        alias: "builtin"
      },
      operator: /[=a][.:]|_\./,
      conjunction: {
        pattern: /&(?:\.:?|:)?|[.:@][.:]?|[!D][.:]|[;dHT]\.|`:?|[\^LS]:|"/,
        alias: "variable"
      },
      punctuation: /[()]/
    };
  }
  return j_1;
}
var java_1, hasRequiredJava;
function requireJava() {
  if (hasRequiredJava) return java_1;
  hasRequiredJava = 1, java_1 = e, e.displayName = "java", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/, o = /(^|[^\w.])(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source, u = {
        pattern: RegExp(o + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
        lookbehind: !0,
        inside: {
          namespace: {
            pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
            inside: {
              punctuation: /\./
            }
          },
          punctuation: /\./
        }
      };
      r.languages.java = r.languages.extend("clike", {
        string: {
          pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
          lookbehind: !0,
          greedy: !0
        },
        "class-name": [u, {
          // variables and parameters
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(o + /[A-Z]\w*(?=\s+\w+\s*[;,=()])/.source),
          lookbehind: !0,
          inside: u.inside
        }],
        keyword: a,
        function: [r.languages.clike.function, {
          pattern: /(::\s*)[a-z_]\w*/,
          lookbehind: !0
        }],
        number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
        operator: {
          pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
          lookbehind: !0
        }
      }), r.languages.insertBefore("java", "string", {
        "triple-quoted-string": {
          // http://openjdk.java.net/jeps/355#Description
          pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
          greedy: !0,
          alias: "string"
        },
        char: {
          pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
          greedy: !0
        }
      }), r.languages.insertBefore("java", "class-name", {
        annotation: {
          pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
          lookbehind: !0,
          alias: "punctuation"
        },
        generics: {
          pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
          inside: {
            "class-name": u,
            keyword: a,
            punctuation: /[<>(),.:]/,
            operator: /[?&|]/
          }
        },
        namespace: {
          pattern: RegExp(/(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
            return a.source;
          })),
          lookbehind: !0,
          inside: {
            punctuation: /\./
          }
        }
      });
    })(t);
  }
  return java_1;
}
var javadoclike_1, hasRequiredJavadoclike;
function requireJavadoclike() {
  if (hasRequiredJavadoclike) return javadoclike_1;
  hasRequiredJavadoclike = 1, javadoclike_1 = e, e.displayName = "javadoclike", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = r.languages.javadoclike = {
        parameter: {
          pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*@(?:arg|arguments|param)\s+)\w+/m,
          lookbehind: !0
        },
        keyword: {
          // keywords are the first word in a line preceded be an `@` or surrounded by curly braces.
          // @word, {@word}
          pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*|\{)@[a-z][a-zA-Z-]+\b/m,
          lookbehind: !0
        },
        punctuation: /[{}]/
      };
      function o(c, d) {
        var g = "doc-comment", b = r.languages[c];
        if (b) {
          var _ = b[g];
          if (!_) {
            var y = {};
            y[g] = {
              pattern: /(^|[^\\])\/\*\*[^/][\s\S]*?(?:\*\/|$)/,
              lookbehind: !0,
              alias: "comment"
            }, b = r.languages.insertBefore(c, "comment", y), _ = b[g];
          }
          if (_ instanceof RegExp && (_ = b[g] = {
            pattern: _
          }), Array.isArray(_))
            for (var A = 0, E = _.length; A < E; A++)
              _[A] instanceof RegExp && (_[A] = {
                pattern: _[A]
              }), d(_[A]);
          else
            d(_);
        }
      }
      function u(c, d) {
        typeof c == "string" && (c = [c]), c.forEach(function(g) {
          o(g, function(b) {
            b.inside || (b.inside = {}), b.inside.rest = d;
          });
        });
      }
      Object.defineProperty(a, "addSupport", {
        value: u
      }), a.addSupport(["java", "javascript", "php"], a);
    })(t);
  }
  return javadoclike_1;
}
var javadoc_1, hasRequiredJavadoc;
function requireJavadoc() {
  if (hasRequiredJavadoc) return javadoc_1;
  hasRequiredJavadoc = 1;
  var e = requireJava(), t = requireJavadoclike();
  javadoc_1 = r, r.displayName = "javadoc", r.aliases = [];
  function r(a) {
    a.register(e), a.register(t), function(o) {
      var u = /(^(?:[\t ]*(?:\*\s*)*))[^*\s].*$/m, c = /#\s*\w+(?:\s*\([^()]*\))?/.source, d = /(?:\b[a-zA-Z]\w+\s*\.\s*)*\b[A-Z]\w*(?:\s*<mem>)?|<mem>/.source.replace(/<mem>/g, function() {
        return c;
      });
      o.languages.javadoc = o.languages.extend("javadoclike", {}), o.languages.insertBefore("javadoc", "keyword", {
        reference: {
          pattern: RegExp(/(@(?:exception|link|linkplain|see|throws|value)\s+(?:\*\s*)?)/.source + "(?:" + d + ")"),
          lookbehind: !0,
          inside: {
            function: {
              pattern: /(#\s*)\w+(?=\s*\()/,
              lookbehind: !0
            },
            field: {
              pattern: /(#\s*)\w+/,
              lookbehind: !0
            },
            namespace: {
              pattern: /\b(?:[a-z]\w*\s*\.\s*)+/,
              inside: {
                punctuation: /\./
              }
            },
            "class-name": /\b[A-Z]\w*/,
            keyword: o.languages.java.keyword,
            punctuation: /[#()[\],.]/
          }
        },
        "class-name": {
          // @param <T> the first generic type parameter
          pattern: /(@param\s+)<[A-Z]\w*>/,
          lookbehind: !0,
          inside: {
            punctuation: /[.<>]/
          }
        },
        "code-section": [{
          pattern: /(\{@code\s+(?!\s))(?:[^\s{}]|\s+(?![\s}])|\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\})+(?=\s*\})/,
          lookbehind: !0,
          inside: {
            code: {
              // there can't be any HTML inside of {@code} tags
              pattern: u,
              lookbehind: !0,
              inside: o.languages.java,
              alias: "language-java"
            }
          }
        }, {
          pattern: /(<(code|pre|tt)>(?!<code>)\s*)\S(?:\S|\s+\S)*?(?=\s*<\/\2>)/,
          lookbehind: !0,
          inside: {
            line: {
              pattern: u,
              lookbehind: !0,
              inside: {
                // highlight HTML tags and entities
                tag: o.languages.markup.tag,
                entity: o.languages.markup.entity,
                code: {
                  // everything else is Java code
                  pattern: /.+/,
                  inside: o.languages.java,
                  alias: "language-java"
                }
              }
            }
          }
        }],
        tag: o.languages.markup.tag,
        entity: o.languages.markup.entity
      }), o.languages.javadoclike.addSupport("java", o.languages.javadoc);
    }(a);
  }
  return javadoc_1;
}
var javastacktrace_1, hasRequiredJavastacktrace;
function requireJavastacktrace() {
  if (hasRequiredJavastacktrace) return javastacktrace_1;
  hasRequiredJavastacktrace = 1, javastacktrace_1 = e, e.displayName = "javastacktrace", e.aliases = [];
  function e(t) {
    t.languages.javastacktrace = {
      // java.sql.SQLException: Violation of unique constraint MY_ENTITY_UK_1: duplicate value(s) for column(s) MY_COLUMN in statement [...]
      // Caused by: java.sql.SQLException: Violation of unique constraint MY_ENTITY_UK_1: duplicate value(s) for column(s) MY_COLUMN in statement [...]
      // Caused by: com.example.myproject.MyProjectServletException
      // Caused by: MidLevelException: LowLevelException
      // Suppressed: Resource$CloseFailException: Resource ID = 0
      summary: {
        pattern: /^([\t ]*)(?:(?:Caused by:|Suppressed:|Exception in thread "[^"]*")[\t ]+)?[\w$.]+(?::.*)?$/m,
        lookbehind: !0,
        inside: {
          keyword: {
            pattern: /^([\t ]*)(?:(?:Caused by|Suppressed)(?=:)|Exception in thread)/m,
            lookbehind: !0
          },
          // the current thread if the summary starts with 'Exception in thread'
          string: {
            pattern: /^(\s*)"[^"]*"/,
            lookbehind: !0
          },
          exceptions: {
            pattern: /^(:?\s*)[\w$.]+(?=:|$)/,
            lookbehind: !0,
            inside: {
              "class-name": /[\w$]+$/,
              namespace: /\b[a-z]\w*\b/,
              punctuation: /\./
            }
          },
          message: {
            pattern: /(:\s*)\S.*/,
            lookbehind: !0,
            alias: "string"
          },
          punctuation: /:/
        }
      },
      // at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1166)
      // at org.hsqldb.jdbc.Util.throwError(Unknown Source) here could be some notes
      // at java.base/java.lang.Class.forName0(Native Method)
      // at Util.<init>(Unknown Source)
      // at com.foo.loader/foo@9.0/com.foo.Main.run(Main.java:101)
      // at com.foo.loader//com.foo.bar.App.run(App.java:12)
      // at acme@2.1/org.acme.Lib.test(Lib.java:80)
      // at MyClass.mash(MyClass.java:9)
      //
      // More information:
      // https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/StackTraceElement.html#toString()
      //
      // A valid Java module name is defined as:
      //   "A module name consists of one or more Java identifiers (3.8) separated by "." tokens."
      // https://docs.oracle.com/javase/specs/jls/se9/html/jls-6.html#jls-ModuleName
      //
      // A Java module version is defined by this class:
      // https://docs.oracle.com/javase/9/docs/api/java/lang/module/ModuleDescriptor.Version.html
      // This is the implementation of the `parse` method in JDK13:
      // https://github.com/matcdac/jdk/blob/2305df71d1b7710266ae0956d73927a225132c0f/src/java.base/share/classes/java/lang/module/ModuleDescriptor.java#L1108
      // However, to keep this simple, a version will be matched by the pattern /@[\w$.+-]*/.
      "stack-frame": {
        pattern: /^([\t ]*)at (?:[\w$./]|@[\w$.+-]*\/)+(?:<init>)?\([^()]*\)/m,
        lookbehind: !0,
        inside: {
          keyword: {
            pattern: /^(\s*)at(?= )/,
            lookbehind: !0
          },
          source: [
            // (Main.java:15)
            // (Main.scala:15)
            {
              pattern: /(\()\w+\.\w+:\d+(?=\))/,
              lookbehind: !0,
              inside: {
                file: /^\w+\.\w+/,
                punctuation: /:/,
                "line-number": {
                  pattern: /\b\d+\b/,
                  alias: "number"
                }
              }
            },
            // (Unknown Source)
            // (Native Method)
            // (...something...)
            {
              pattern: /(\()[^()]*(?=\))/,
              lookbehind: !0,
              inside: {
                keyword: /^(?:Native Method|Unknown Source)$/
              }
            }
          ],
          "class-name": /[\w$]+(?=\.(?:<init>|[\w$]+)\()/,
          function: /(?:<init>|[\w$]+)(?=\()/,
          "class-loader": {
            pattern: /(\s)[a-z]\w*(?:\.[a-z]\w*)*(?=\/[\w@$.]*\/)/,
            lookbehind: !0,
            alias: "namespace",
            inside: {
              punctuation: /\./
            }
          },
          module: {
            pattern: /([\s/])[a-z]\w*(?:\.[a-z]\w*)*(?:@[\w$.+-]*)?(?=\/)/,
            lookbehind: !0,
            inside: {
              version: {
                pattern: /(@)[\s\S]+/,
                lookbehind: !0,
                alias: "number"
              },
              punctuation: /[@.]/
            }
          },
          namespace: {
            pattern: /(?:\b[a-z]\w*\.)+/,
            inside: {
              punctuation: /\./
            }
          },
          punctuation: /[()/.]/
        }
      },
      // ... 32 more
      // ... 32 common frames omitted
      more: {
        pattern: /^([\t ]*)\.{3} \d+ [a-z]+(?: [a-z]+)*/m,
        lookbehind: !0,
        inside: {
          punctuation: /\.{3}/,
          number: /\d+/,
          keyword: /\b[a-z]+(?: [a-z]+)*\b/
        }
      }
    };
  }
  return javastacktrace_1;
}
var jexl_1, hasRequiredJexl;
function requireJexl() {
  if (hasRequiredJexl) return jexl_1;
  hasRequiredJexl = 1, jexl_1 = e, e.displayName = "jexl", e.aliases = [];
  function e(t) {
    t.languages.jexl = {
      string: /(["'])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
      transform: {
        pattern: /(\|\s*)[a-zA-Z--_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][\w--\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*/,
        alias: "function",
        lookbehind: !0
      },
      function: /[a-zA-Z--_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][\w--\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*\s*(?=\()/,
      number: /\b\d+(?:\.\d+)?\b|\B\.\d+\b/,
      operator: /[<>!]=?|-|\+|&&|==|\|\|?|\/\/?|[?:*^%]/,
      boolean: /\b(?:false|true)\b/,
      keyword: /\bin\b/,
      punctuation: /[{}[\](),.]/
    };
  }
  return jexl_1;
}
var jolie_1, hasRequiredJolie;
function requireJolie() {
  if (hasRequiredJolie) return jolie_1;
  hasRequiredJolie = 1, jolie_1 = e, e.displayName = "jolie", e.aliases = [];
  function e(t) {
    t.languages.jolie = t.languages.extend("clike", {
      string: {
        pattern: /(^|[^\\])"(?:\\[\s\S]|[^"\\])*"/,
        lookbehind: !0,
        greedy: !0
      },
      "class-name": {
        pattern: /((?:\b(?:as|courier|embed|in|inputPort|outputPort|service)\b|@)[ \t]*)\w+/,
        lookbehind: !0
      },
      keyword: /\b(?:as|cH|comp|concurrent|constants|courier|cset|csets|default|define|else|embed|embedded|execution|exit|extender|for|foreach|forward|from|global|if|import|in|include|init|inputPort|install|instanceof|interface|is_defined|linkIn|linkOut|main|new|nullProcess|outputPort|over|private|provide|public|scope|sequential|service|single|spawn|synchronized|this|throw|throws|type|undef|until|while|with)\b/,
      function: /\b[a-z_]\w*(?=[ \t]*[@(])/i,
      number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?l?/i,
      operator: /-[-=>]?|\+[+=]?|<[<=]?|[>=*!]=?|&&|\|\||[?\/%^@|]/,
      punctuation: /[()[\]{},;.:]/,
      builtin: /\b(?:Byte|any|bool|char|double|enum|float|int|length|long|ranges|regex|string|undefined|void)\b/
    }), t.languages.insertBefore("jolie", "keyword", {
      aggregates: {
        pattern: /(\bAggregates\s*:\s*)(?:\w+(?:\s+with\s+\w+)?\s*,\s*)*\w+(?:\s+with\s+\w+)?/,
        lookbehind: !0,
        inside: {
          keyword: /\bwith\b/,
          "class-name": /\w+/,
          punctuation: /,/
        }
      },
      redirects: {
        pattern: /(\bRedirects\s*:\s*)(?:\w+\s*=>\s*\w+\s*,\s*)*(?:\w+\s*=>\s*\w+)/,
        lookbehind: !0,
        inside: {
          punctuation: /,/,
          "class-name": /\w+/,
          operator: /=>/
        }
      },
      property: {
        pattern: /\b(?:Aggregates|[Ii]nterfaces|Java|Javascript|Jolie|[Ll]ocation|OneWay|[Pp]rotocol|Redirects|RequestResponse)\b(?=[ \t]*:)/
      }
    });
  }
  return jolie_1;
}
var jq_1, hasRequiredJq;
function requireJq() {
  if (hasRequiredJq) return jq_1;
  hasRequiredJq = 1, jq_1 = e, e.displayName = "jq", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = /\\\((?:[^()]|\([^()]*\))*\)/.source, o = RegExp(/(^|[^\\])"(?:[^"\r\n\\]|\\[^\r\n(]|__)*"/.source.replace(/__/g, function() {
        return a;
      })), u = {
        interpolation: {
          pattern: RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + a),
          lookbehind: !0,
          inside: {
            content: {
              pattern: /^(\\\()[\s\S]+(?=\)$)/,
              lookbehind: !0,
              inside: null
              // see below
            },
            punctuation: /^\\\(|\)$/
          }
        }
      }, c = r.languages.jq = {
        comment: /#.*/,
        property: {
          pattern: RegExp(o.source + /(?=\s*:(?!:))/.source),
          lookbehind: !0,
          greedy: !0,
          inside: u
        },
        string: {
          pattern: o,
          lookbehind: !0,
          greedy: !0,
          inside: u
        },
        function: {
          pattern: /(\bdef\s+)[a-z_]\w+/i,
          lookbehind: !0
        },
        variable: /\B\$\w+/,
        "property-literal": {
          pattern: /\b[a-z_]\w*(?=\s*:(?!:))/i,
          alias: "property"
        },
        keyword: /\b(?:as|break|catch|def|elif|else|end|foreach|if|import|include|label|module|modulemeta|null|reduce|then|try|while)\b/,
        boolean: /\b(?:false|true)\b/,
        number: /(?:\b\d+\.|\B\.)?\b\d+(?:[eE][+-]?\d+)?\b/,
        operator: [{
          pattern: /\|=?/,
          alias: "pipe"
        }, /\.\.|[!=<>]?=|\?\/\/|\/\/=?|[-+*/%]=?|[<>?]|\b(?:and|not|or)\b/],
        "c-style-function": {
          pattern: /\b[a-z_]\w*(?=\s*\()/i,
          alias: "function"
        },
        punctuation: /::|[()\[\]{},:;]|\.(?=\s*[\[\w$])/,
        dot: {
          pattern: /\./,
          alias: "important"
        }
      };
      u.interpolation.inside.content.inside = c;
    })(t);
  }
  return jq_1;
}
var jsExtras_1, hasRequiredJsExtras;
function requireJsExtras() {
  if (hasRequiredJsExtras) return jsExtras_1;
  hasRequiredJsExtras = 1, jsExtras_1 = e, e.displayName = "jsExtras", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.insertBefore("javascript", "function-variable", {
        "method-variable": {
          pattern: RegExp("(\\.\\s*)" + r.languages.javascript["function-variable"].pattern.source),
          lookbehind: !0,
          alias: ["function-variable", "method", "function", "property-access"]
        }
      }), r.languages.insertBefore("javascript", "function", {
        method: {
          pattern: RegExp("(\\.\\s*)" + r.languages.javascript.function.source),
          lookbehind: !0,
          alias: ["function", "property-access"]
        }
      }), r.languages.insertBefore("javascript", "constant", {
        "known-class-name": [{
          // standard built-ins
          // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects
          pattern: /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/,
          alias: "class-name"
        }, {
          // errors
          pattern: /\b(?:[A-Z]\w*)Error\b/,
          alias: "class-name"
        }]
      });
      function a(b, _) {
        return RegExp(b.replace(/<ID>/g, function() {
          return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
        }), _);
      }
      r.languages.insertBefore("javascript", "keyword", {
        imports: {
          // https://tc39.es/ecma262/#sec-imports
          pattern: a(/(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source),
          lookbehind: !0,
          inside: r.languages.javascript
        },
        exports: {
          // https://tc39.es/ecma262/#sec-exports
          pattern: a(/(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source),
          lookbehind: !0,
          inside: r.languages.javascript
        }
      }), r.languages.javascript.keyword.unshift({
        pattern: /\b(?:as|default|export|from|import)\b/,
        alias: "module"
      }, {
        pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/,
        alias: "control-flow"
      }, {
        pattern: /\bnull\b/,
        alias: ["null", "nil"]
      }, {
        pattern: /\bundefined\b/,
        alias: "nil"
      }), r.languages.insertBefore("javascript", "operator", {
        spread: {
          pattern: /\.{3}/,
          alias: "operator"
        },
        arrow: {
          pattern: /=>/,
          alias: "operator"
        }
      }), r.languages.insertBefore("javascript", "punctuation", {
        "property-access": {
          pattern: a(/(\.\s*)#?<ID>/.source),
          lookbehind: !0
        },
        "maybe-class-name": {
          pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/,
          lookbehind: !0
        },
        dom: {
          // this contains only a few commonly used DOM variables
          pattern: /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/,
          alias: "variable"
        },
        console: {
          pattern: /\bconsole(?=\s*\.)/,
          alias: "class-name"
        }
      });
      for (var o = ["function", "function-variable", "method", "method-variable", "property-access"], u = 0; u < o.length; u++) {
        var c = o[u], d = r.languages.javascript[c];
        r.util.type(d) === "RegExp" && (d = r.languages.javascript[c] = {
          pattern: d
        });
        var g = d.inside || {};
        d.inside = g, g["maybe-class-name"] = /^[A-Z][\s\S]*/;
      }
    })(t);
  }
  return jsExtras_1;
}
var jsTemplates_1, hasRequiredJsTemplates;
function requireJsTemplates() {
  if (hasRequiredJsTemplates) return jsTemplates_1;
  hasRequiredJsTemplates = 1, jsTemplates_1 = e, e.displayName = "jsTemplates", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = r.languages.javascript["template-string"], o = a.pattern.source, u = a.inside.interpolation, c = u.inside["interpolation-punctuation"], d = u.pattern.source;
      function g(C, R) {
        if (r.languages[C])
          return {
            pattern: RegExp("((?:" + R + ")\\s*)" + o),
            lookbehind: !0,
            greedy: !0,
            inside: {
              "template-punctuation": {
                pattern: /^`|`$/,
                alias: "string"
              },
              "embedded-code": {
                pattern: /[\s\S]+/,
                alias: C
              }
            }
          };
      }
      r.languages.javascript["template-string"] = [
        // styled-jsx:
        //   css`a { color: #25F; }`
        // styled-components:
        //   styled.h1`color: red;`
        g("css", /\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),
        // html`<p></p>`
        // div.innerHTML = `<p></p>`
        g("html", /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source),
        // svg`<path fill="#fff" d="M55.37 ..."/>`
        g("svg", /\bsvg/.source),
        // md`# h1`, markdown`## h2`
        g("markdown", /\b(?:markdown|md)/.source),
        // gql`...`, graphql`...`, graphql.experimental`...`
        g("graphql", /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source),
        // sql`...`
        g("sql", /\bsql/.source),
        // vanilla template string
        a
      ].filter(Boolean);
      function b(C, R) {
        return "___" + R.toUpperCase() + "_" + C + "___";
      }
      function _(C, R, I) {
        var w = {
          code: C,
          grammar: R,
          language: I
        };
        return r.hooks.run("before-tokenize", w), w.tokens = r.tokenize(w.code, w.grammar), r.hooks.run("after-tokenize", w), w.tokens;
      }
      function y(C) {
        var R = {};
        R["interpolation-punctuation"] = c;
        var I = r.tokenize(C, R);
        if (I.length === 3) {
          var w = [1, 1];
          w.push.apply(w, _(I[1], r.languages.javascript, "javascript")), I.splice.apply(I, w);
        }
        return new r.Token("interpolation", I, u.alias, C);
      }
      function A(C, R, I) {
        var w = r.tokenize(C, {
          interpolation: {
            pattern: RegExp(d),
            lookbehind: !0
          }
        }), N = 0, F = {}, M = w.map(function(L) {
          if (typeof L == "string")
            return L;
          for (var H = L.content, B; C.indexOf(B = b(N++, I)) !== -1; )
            ;
          return F[B] = H, B;
        }).join(""), x = _(M, R, I), P = Object.keys(F);
        N = 0;
        function U(L) {
          for (var H = 0; H < L.length; H++) {
            if (N >= P.length)
              return;
            var B = L[H];
            if (typeof B == "string" || typeof B.content == "string") {
              var V = P[N], X = typeof B == "string" ? B : (
                /** @type {string} */
                B.content
              ), de = X.indexOf(V);
              if (de !== -1) {
                ++N;
                var Y = X.substring(0, de), se = y(F[V]), ue = X.substring(de + V.length), pe = [];
                if (Y && pe.push(Y), pe.push(se), ue) {
                  var J = [ue];
                  U(J), pe.push.apply(pe, J);
                }
                typeof B == "string" ? (L.splice.apply(L, [H, 1].concat(pe)), H += pe.length - 1) : B.content = pe;
              }
            } else {
              var j = B.content;
              Array.isArray(j) ? U(j) : U([j]);
            }
          }
        }
        return U(x), new r.Token(I, x, "language-" + I, C);
      }
      var E = {
        javascript: !0,
        js: !0,
        typescript: !0,
        ts: !0,
        jsx: !0,
        tsx: !0
      };
      r.hooks.add("after-tokenize", function(C) {
        if (!(C.language in E))
          return;
        function R(I) {
          for (var w = 0, N = I.length; w < N; w++) {
            var F = I[w];
            if (typeof F != "string") {
              var M = F.content;
              if (!Array.isArray(M)) {
                typeof M != "string" && R([M]);
                continue;
              }
              if (F.type === "template-string") {
                var x = M[1];
                if (M.length === 3 && typeof x != "string" && x.type === "embedded-code") {
                  var P = v(x), U = x.alias, L = Array.isArray(U) ? U[0] : U, H = r.languages[L];
                  if (!H)
                    continue;
                  M[1] = A(P, H, L);
                }
              } else
                R(M);
            }
          }
        }
        R(C.tokens);
      });
      function v(C) {
        return typeof C == "string" ? C : Array.isArray(C) ? C.map(v).join("") : v(C.content);
      }
    })(t);
  }
  return jsTemplates_1;
}
var typescript_1, hasRequiredTypescript;
function requireTypescript() {
  if (hasRequiredTypescript) return typescript_1;
  hasRequiredTypescript = 1, typescript_1 = e, e.displayName = "typescript", e.aliases = ["ts"];
  function e(t) {
    (function(r) {
      r.languages.typescript = r.languages.extend("javascript", {
        "class-name": {
          pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
          lookbehind: !0,
          greedy: !0,
          inside: null
          // see below
        },
        builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
      }), r.languages.typescript.keyword.push(
        /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
        // keywords that have to be followed by an identifier
        /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
        // This is for `import type *, {}`
        /\btype\b(?=\s*(?:[\{*]|$))/
      ), delete r.languages.typescript.parameter, delete r.languages.typescript["literal-property"];
      var a = r.languages.extend("typescript", {});
      delete a["class-name"], r.languages.typescript["class-name"].inside = a, r.languages.insertBefore("typescript", "function", {
        decorator: {
          pattern: /@[$\w\xA0-\uFFFF]+/,
          inside: {
            at: {
              pattern: /^@/,
              alias: "operator"
            },
            function: /^[\s\S]+/
          }
        },
        "generic-function": {
          // e.g. foo<T extends "bar" | "baz">( ...
          pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
          greedy: !0,
          inside: {
            function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
            generic: {
              pattern: /<[\s\S]+/,
              // everything after the first <
              alias: "class-name",
              inside: a
            }
          }
        }
      }), r.languages.ts = r.languages.typescript;
    })(t);
  }
  return typescript_1;
}
var jsdoc_1, hasRequiredJsdoc;
function requireJsdoc() {
  if (hasRequiredJsdoc) return jsdoc_1;
  hasRequiredJsdoc = 1;
  var e = requireJavadoclike(), t = requireTypescript();
  jsdoc_1 = r, r.displayName = "jsdoc", r.aliases = [];
  function r(a) {
    a.register(e), a.register(t), function(o) {
      var u = o.languages.javascript, c = /\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})+\}/.source, d = "(@(?:arg|argument|param|property)\\s+(?:" + c + "\\s+)?)";
      o.languages.jsdoc = o.languages.extend("javadoclike", {
        parameter: {
          // @param {string} foo - foo bar
          pattern: RegExp(d + /(?:(?!\s)[$\w\xA0-\uFFFF.])+(?=\s|$)/.source),
          lookbehind: !0,
          inside: {
            punctuation: /\./
          }
        }
      }), o.languages.insertBefore("jsdoc", "keyword", {
        "optional-parameter": {
          // @param {string} [baz.foo="bar"] foo bar
          pattern: RegExp(d + /\[(?:(?!\s)[$\w\xA0-\uFFFF.])+(?:=[^[\]]+)?\](?=\s|$)/.source),
          lookbehind: !0,
          inside: {
            parameter: {
              pattern: /(^\[)[$\w\xA0-\uFFFF\.]+/,
              lookbehind: !0,
              inside: {
                punctuation: /\./
              }
            },
            code: {
              pattern: /(=)[\s\S]*(?=\]$)/,
              lookbehind: !0,
              inside: u,
              alias: "language-javascript"
            },
            punctuation: /[=[\]]/
          }
        },
        "class-name": [{
          pattern: RegExp(/(@(?:augments|class|extends|interface|memberof!?|template|this|typedef)\s+(?:<TYPE>\s+)?)[A-Z]\w*(?:\.[A-Z]\w*)*/.source.replace(/<TYPE>/g, function() {
            return c;
          })),
          lookbehind: !0,
          inside: {
            punctuation: /\./
          }
        }, {
          pattern: RegExp("(@[a-z]+\\s+)" + c),
          lookbehind: !0,
          inside: {
            string: u.string,
            number: u.number,
            boolean: u.boolean,
            keyword: o.languages.typescript.keyword,
            operator: /=>|\.\.\.|[&|?:*]/,
            punctuation: /[.,;=<>{}()[\]]/
          }
        }],
        example: {
          pattern: /(@example\s+(?!\s))(?:[^@\s]|\s+(?!\s))+?(?=\s*(?:\*\s*)?(?:@\w|\*\/))/,
          lookbehind: !0,
          inside: {
            code: {
              pattern: /^([\t ]*(?:\*\s*)?)\S.*$/m,
              lookbehind: !0,
              inside: u,
              alias: "language-javascript"
            }
          }
        }
      }), o.languages.javadoclike.addSupport("javascript", o.languages.jsdoc);
    }(a);
  }
  return jsdoc_1;
}
var json_1, hasRequiredJson;
function requireJson() {
  if (hasRequiredJson) return json_1;
  hasRequiredJson = 1, json_1 = e, e.displayName = "json", e.aliases = ["webmanifest"];
  function e(t) {
    t.languages.json = {
      property: {
        pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
        lookbehind: !0,
        greedy: !0
      },
      string: {
        pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
        lookbehind: !0,
        greedy: !0
      },
      comment: {
        pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
        greedy: !0
      },
      number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
      punctuation: /[{}[\],]/,
      operator: /:/,
      boolean: /\b(?:false|true)\b/,
      null: {
        pattern: /\bnull\b/,
        alias: "keyword"
      }
    }, t.languages.webmanifest = t.languages.json;
  }
  return json_1;
}
var json5_1, hasRequiredJson5;
function requireJson5() {
  if (hasRequiredJson5) return json5_1;
  hasRequiredJson5 = 1;
  var e = requireJson();
  json5_1 = t, t.displayName = "json5", t.aliases = [];
  function t(r) {
    r.register(e), function(a) {
      var o = /("|')(?:\\(?:\r\n?|\n|.)|(?!\1)[^\\\r\n])*\1/;
      a.languages.json5 = a.languages.extend("json", {
        property: [{
          pattern: RegExp(o.source + "(?=\\s*:)"),
          greedy: !0
        }, {
          pattern: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/,
          alias: "unquoted"
        }],
        string: {
          pattern: o,
          greedy: !0
        },
        number: /[+-]?\b(?:NaN|Infinity|0x[a-fA-F\d]+)\b|[+-]?(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+\b)?/
      });
    }(r);
  }
  return json5_1;
}
var jsonp_1, hasRequiredJsonp;
function requireJsonp() {
  if (hasRequiredJsonp) return jsonp_1;
  hasRequiredJsonp = 1;
  var e = requireJson();
  jsonp_1 = t, t.displayName = "jsonp", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.jsonp = r.languages.extend("json", {
      punctuation: /[{}[\]();,.]/
    }), r.languages.insertBefore("jsonp", "punctuation", {
      function: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*\()/
    });
  }
  return jsonp_1;
}
var jsstacktrace_1, hasRequiredJsstacktrace;
function requireJsstacktrace() {
  if (hasRequiredJsstacktrace) return jsstacktrace_1;
  hasRequiredJsstacktrace = 1, jsstacktrace_1 = e, e.displayName = "jsstacktrace", e.aliases = [];
  function e(t) {
    t.languages.jsstacktrace = {
      "error-message": {
        pattern: /^\S.*/m,
        alias: "string"
      },
      "stack-frame": {
        pattern: /(^[ \t]+)at[ \t].*/m,
        lookbehind: !0,
        inside: {
          "not-my-code": {
            pattern: /^at[ \t]+(?!\s)(?:node\.js|<unknown>|.*(?:node_modules|\(<anonymous>\)|\(<unknown>|<anonymous>$|\(internal\/|\(node\.js)).*/m,
            alias: "comment"
          },
          filename: {
            pattern: /(\bat\s+(?!\s)|\()(?:[a-zA-Z]:)?[^():]+(?=:)/,
            lookbehind: !0,
            alias: "url"
          },
          function: {
            pattern: /(\bat\s+(?:new\s+)?)(?!\s)[_$a-zA-Z\xA0-\uFFFF<][.$\w\xA0-\uFFFF<>]*/,
            lookbehind: !0,
            inside: {
              punctuation: /\./
            }
          },
          punctuation: /[()]/,
          keyword: /\b(?:at|new)\b/,
          alias: {
            pattern: /\[(?:as\s+)?(?!\s)[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\]/,
            alias: "variable"
          },
          "line-number": {
            pattern: /:\d+(?::\d+)?\b/,
            alias: "number",
            inside: {
              punctuation: /:/
            }
          }
        }
      }
    };
  }
  return jsstacktrace_1;
}
var jsx_1, hasRequiredJsx;
function requireJsx() {
  if (hasRequiredJsx) return jsx_1;
  hasRequiredJsx = 1, jsx_1 = e, e.displayName = "jsx", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = r.util.clone(r.languages.javascript), o = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source, u = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source, c = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
      function d(_, y) {
        return _ = _.replace(/<S>/g, function() {
          return o;
        }).replace(/<BRACES>/g, function() {
          return u;
        }).replace(/<SPREAD>/g, function() {
          return c;
        }), RegExp(_, y);
      }
      c = d(c).source, r.languages.jsx = r.languages.extend("markup", a), r.languages.jsx.tag.pattern = d(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source), r.languages.jsx.tag.inside.tag.pattern = /^<\/?[^\s>\/]*/, r.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/, r.languages.jsx.tag.inside.tag.inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/, r.languages.jsx.tag.inside.comment = a.comment, r.languages.insertBefore("inside", "attr-name", {
        spread: {
          pattern: d(/<SPREAD>/.source),
          inside: r.languages.jsx
        }
      }, r.languages.jsx.tag), r.languages.insertBefore("inside", "special-attr", {
        script: {
          // Allow for two levels of nesting
          pattern: d(/=<BRACES>/.source),
          alias: "language-javascript",
          inside: {
            "script-punctuation": {
              pattern: /^=(?=\{)/,
              alias: "punctuation"
            },
            rest: r.languages.jsx
          }
        }
      }, r.languages.jsx.tag);
      var g = function(_) {
        return _ ? typeof _ == "string" ? _ : typeof _.content == "string" ? _.content : _.content.map(g).join("") : "";
      }, b = function(_) {
        for (var y = [], A = 0; A < _.length; A++) {
          var E = _[A], v = !1;
          if (typeof E != "string" && (E.type === "tag" && E.content[0] && E.content[0].type === "tag" ? E.content[0].content[0].content === "</" ? y.length > 0 && y[y.length - 1].tagName === g(E.content[0].content[1]) && y.pop() : E.content[E.content.length - 1].content === "/>" || y.push({
            tagName: g(E.content[0].content[1]),
            openedBraces: 0
          }) : y.length > 0 && E.type === "punctuation" && E.content === "{" ? y[y.length - 1].openedBraces++ : y.length > 0 && y[y.length - 1].openedBraces > 0 && E.type === "punctuation" && E.content === "}" ? y[y.length - 1].openedBraces-- : v = !0), (v || typeof E == "string") && y.length > 0 && y[y.length - 1].openedBraces === 0) {
            var C = g(E);
            A < _.length - 1 && (typeof _[A + 1] == "string" || _[A + 1].type === "plain-text") && (C += g(_[A + 1]), _.splice(A + 1, 1)), A > 0 && (typeof _[A - 1] == "string" || _[A - 1].type === "plain-text") && (C = g(_[A - 1]) + C, _.splice(A - 1, 1), A--), _[A] = new r.Token("plain-text", C, null, C);
          }
          E.content && typeof E.content != "string" && b(E.content);
        }
      };
      r.hooks.add("after-tokenize", function(_) {
        _.language !== "jsx" && _.language !== "tsx" || b(_.tokens);
      });
    })(t);
  }
  return jsx_1;
}
var julia_1, hasRequiredJulia;
function requireJulia() {
  if (hasRequiredJulia) return julia_1;
  hasRequiredJulia = 1, julia_1 = e, e.displayName = "julia", e.aliases = [];
  function e(t) {
    t.languages.julia = {
      comment: {
        // support one level of nested comments
        // https://github.com/JuliaLang/julia/pull/6128
        pattern: /(^|[^\\])(?:#=(?:[^#=]|=(?!#)|#(?!=)|#=(?:[^#=]|=(?!#)|#(?!=))*=#)*=#|#.*)/,
        lookbehind: !0
      },
      regex: {
        // https://docs.julialang.org/en/v1/manual/strings/#Regular-Expressions-1
        pattern: /r"(?:\\.|[^"\\\r\n])*"[imsx]{0,4}/,
        greedy: !0
      },
      string: {
        // https://docs.julialang.org/en/v1/manual/strings/#String-Basics-1
        // https://docs.julialang.org/en/v1/manual/strings/#non-standard-string-literals-1
        // https://docs.julialang.org/en/v1/manual/running-external-programs/#Running-External-Programs-1
        pattern: /"""[\s\S]+?"""|(?:\b\w+)?"(?:\\.|[^"\\\r\n])*"|`(?:[^\\`\r\n]|\\.)*`/,
        greedy: !0
      },
      char: {
        // https://docs.julialang.org/en/v1/manual/strings/#man-characters-1
        pattern: /(^|[^\w'])'(?:\\[^\r\n][^'\r\n]*|[^\\\r\n])'/,
        lookbehind: !0,
        greedy: !0
      },
      keyword: /\b(?:abstract|baremodule|begin|bitstype|break|catch|ccall|const|continue|do|else|elseif|end|export|finally|for|function|global|if|immutable|import|importall|in|let|local|macro|module|print|println|quote|return|struct|try|type|typealias|using|while)\b/,
      boolean: /\b(?:false|true)\b/,
      number: /(?:\b(?=\d)|\B(?=\.))(?:0[box])?(?:[\da-f]+(?:_[\da-f]+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[efp][+-]?\d+(?:_\d+)*)?j?/i,
      // https://docs.julialang.org/en/v1/manual/mathematical-operations/
      // https://docs.julialang.org/en/v1/manual/mathematical-operations/#Operator-Precedence-and-Associativity-1
      operator: /&&|\|\||[-+*^%&$\\]=?|\/[\/=]?|!=?=?|\|[=>]?|<(?:<=?|[=:|])?|>(?:=|>>?=?)?|==?=?|[~']/,
      punctuation: /::?|[{}[\]();,.?]/,
      // https://docs.julialang.org/en/v1/base/numbers/#Base.im
      constant: /\b(?:(?:Inf|NaN)(?:16|32|64)?|im|pi)\b|[]/
    };
  }
  return julia_1;
}
var keepalived_1, hasRequiredKeepalived;
function requireKeepalived() {
  if (hasRequiredKeepalived) return keepalived_1;
  hasRequiredKeepalived = 1, keepalived_1 = e, e.displayName = "keepalived", e.aliases = [];
  function e(t) {
    t.languages.keepalived = {
      comment: {
        pattern: /[#!].*/,
        greedy: !0
      },
      string: {
        pattern: /(^|[^\\])(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/,
        lookbehind: !0,
        greedy: !0
      },
      // support IPv4, IPv6, subnet mask
      ip: {
        pattern: RegExp(/\b(?:(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){5}:(?:[\da-f]{1,4}:)?[\da-f]{1,4}|(?:[\da-f]{1,4}:){4}:(?:[\da-f]{1,4}:){0,2}[\da-f]{1,4}|(?:[\da-f]{1,4}:){3}:(?:[\da-f]{1,4}:){0,3}[\da-f]{1,4}|(?:[\da-f]{1,4}:){2}:(?:[\da-f]{1,4}:){0,4}[\da-f]{1,4}|(?:[\da-f]{1,4}:){6}<ipv4>|(?:[\da-f]{1,4}:){0,5}:<ipv4>|::(?:[\da-f]{1,4}:){0,5}<ipv4>|[\da-f]{1,4}::(?:[\da-f]{1,4}:){0,5}[\da-f]{1,4}|::(?:[\da-f]{1,4}:){0,6}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:)(?:\/\d{1,3})?|<ipv4>(?:\/\d{1,2})?)\b/.source.replace(/<ipv4>/g, function() {
          return /(?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d))/.source;
        }), "i"),
        alias: "number"
      },
      // support *nix / Windows, directory / file
      path: {
        pattern: /(\s)\/(?:[^\/\s]+\/)*[^\/\s]*|\b[a-zA-Z]:\\(?:[^\\\s]+\\)*[^\\\s]*/,
        lookbehind: !0,
        alias: "string"
      },
      variable: /\$\{?\w+\}?/,
      email: {
        pattern: /[\w-]+@[\w-]+(?:\.[\w-]{2,3}){1,2}/,
        alias: "string"
      },
      "conditional-configuration": {
        pattern: /@\^?[\w-]+/,
        alias: "variable"
      },
      operator: /=/,
      property: /\b(?:BFD_CHECK|DNS_CHECK|FILE_CHECK|HTTP_GET|MISC_CHECK|NAME|PING_CHECK|SCRIPTS|SMTP_CHECK|SSL|SSL_GET|TCP_CHECK|UDP_CHECK|accept|advert_int|alpha|auth_pass|auth_type|authentication|bfd_cpu_affinity|bfd_instance|bfd_no_swap|bfd_priority|bfd_process_name|bfd_rlimit_rttime|bfd_rt_priority|bind_if|bind_port|bindto|ca|certificate|check_unicast_src|checker|checker_cpu_affinity|checker_log_all_failures|checker_no_swap|checker_priority|checker_rlimit_rttime|checker_rt_priority|child_wait_time|connect_ip|connect_port|connect_timeout|dbus_service_name|debug|default_interface|delay|delay_before_retry|delay_loop|digest|dont_track_primary|dynamic|dynamic_interfaces|enable_(?:dbus|script_security|sni|snmp_checker|snmp_rfc|snmp_rfcv2|snmp_rfcv3|snmp_vrrp|traps)|end|fall|fast_recovery|file|flag-[123]|fork_delay|full_command|fwmark|garp_group|garp_interval|garp_lower_prio_delay|garp_lower_prio_repeat|garp_master_delay|garp_master_refresh|garp_master_refresh_repeat|garp_master_repeat|global_defs|global_tracking|gna_interval|group|ha_suspend|hashed|helo_name|higher_prio_send_advert|hoplimit|http_protocol|hysteresis|idle_tx|include|inhibit_on_failure|init_fail|init_file|instance|interface|interfaces|interval|ip_family|ipvs_process_name|keepalived.conf|kernel_rx_buf_size|key|linkbeat_interfaces|linkbeat_use_polling|log_all_failures|log_unknown_vrids|lower_prio_no_advert|lthreshold|lvs_flush|lvs_flush_onstop|lvs_method|lvs_netlink_cmd_rcv_bufs|lvs_netlink_cmd_rcv_bufs_force|lvs_netlink_monitor_rcv_bufs|lvs_netlink_monitor_rcv_bufs_force|lvs_notify_fifo|lvs_notify_fifo_script|lvs_sched|lvs_sync_daemon|max_auto_priority|max_hops|mcast_src_ip|mh-fallback|mh-port|min_auto_priority_delay|min_rx|min_tx|misc_dynamic|misc_path|misc_timeout|multiplier|name|namespace_with_ipsets|native_ipv6|neighbor_ip|net_namespace|net_namespace_ipvs|nftables|nftables_counters|nftables_ifindex|nftables_priority|no_accept|no_checker_emails|no_email_faults|nopreempt|notification_email|notification_email_from|notify|notify_backup|notify_deleted|notify_down|notify_fault|notify_fifo|notify_fifo_script|notify_master|notify_master_rx_lower_pri|notify_priority_changes|notify_stop|notify_up|old_unicast_checksum|omega|ops|param_match|passive|password|path|persistence_engine|persistence_granularity|persistence_timeout|preempt|preempt_delay|priority|process|process_monitor_rcv_bufs|process_monitor_rcv_bufs_force|process_name|process_names|promote_secondaries|protocol|proxy_arp|proxy_arp_pvlan|quorum|quorum_down|quorum_max|quorum_up|random_seed|real_server|regex|regex_max_offset|regex_min_offset|regex_no_match|regex_options|regex_stack|reload_repeat|reload_time_file|require_reply|retry|rise|router_id|rs_init_notifies|script|script_user|sh-fallback|sh-port|shutdown_script|shutdown_script_timeout|skip_check_adv_addr|smtp_alert|smtp_alert_checker|smtp_alert_vrrp|smtp_connect_timeout|smtp_helo_name|smtp_server|snmp_socket|sorry_server|sorry_server_inhibit|sorry_server_lvs_method|source_ip|start|startup_script|startup_script_timeout|state|static_ipaddress|static_routes|static_rules|status_code|step|strict_mode|sync_group_tracking_weight|terminate_delay|timeout|track_bfd|track_file|track_group|track_interface|track_process|track_script|track_src_ip|ttl|type|umask|unicast_peer|unicast_src_ip|unicast_ttl|url|use_ipvlan|use_pid_dir|use_vmac|user|uthreshold|val[123]|version|virtual_ipaddress|virtual_ipaddress_excluded|virtual_router_id|virtual_routes|virtual_rules|virtual_server|virtual_server_group|virtualhost|vmac_xmit_base|vrrp|vrrp_(?:check_unicast_src|cpu_affinity|garp_interval|garp_lower_prio_delay|garp_lower_prio_repeat|garp_master_delay|garp_master_refresh|garp_master_refresh_repeat|garp_master_repeat|gna_interval|higher_prio_send_advert|instance|ipsets|iptables|lower_prio_no_advert|mcast_group4|mcast_group6|min_garp|netlink_cmd_rcv_bufs|netlink_cmd_rcv_bufs_force|netlink_monitor_rcv_bufs|netlink_monitor_rcv_bufs_force|no_swap|notify_fifo|notify_fifo_script|notify_priority_changes|priority|process_name|rlimit_rttime|rt_priority|rx_bufs_multiplier|rx_bufs_policy|script|skip_check_adv_addr|startup_delay|strict|sync_group|track_process|version)|warmup|weight)\b/,
      constant: /\b(?:A|AAAA|AH|BACKUP|CNAME|DR|MASTER|MX|NAT|NS|PASS|SCTP|SOA|TCP|TUN|TXT|UDP|dh|fo|lblc|lblcr|lc|mh|nq|ovf|rr|sed|sh|wlc|wrr)\b/,
      number: {
        pattern: /(^|[^\w.-])-?\d+(?:\.\d+)?/,
        lookbehind: !0
      },
      boolean: /\b(?:false|no|off|on|true|yes)\b/,
      punctuation: /[\{\}]/
    };
  }
  return keepalived_1;
}
var keyman_1, hasRequiredKeyman;
function requireKeyman() {
  if (hasRequiredKeyman) return keyman_1;
  hasRequiredKeyman = 1, keyman_1 = e, e.displayName = "keyman", e.aliases = [];
  function e(t) {
    t.languages.keyman = {
      comment: {
        pattern: /\bc .*/i,
        greedy: !0
      },
      string: {
        pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
        greedy: !0
      },
      "virtual-key": {
        pattern: /\[\s*(?:(?:ALT|CAPS|CTRL|LALT|LCTRL|NCAPS|RALT|RCTRL|SHIFT)\s+)*(?:[TKU]_[\w?]+|[A-E]\d\d?|"[^"\r\n]*"|'[^'\r\n]*')\s*\]/i,
        greedy: !0,
        alias: "function"
        // alias for styles
      },
      // https://help.keyman.com/developer/language/guide/headers
      "header-keyword": {
        pattern: /&\w+/,
        alias: "bold"
        // alias for styles
      },
      "header-statement": {
        pattern: /\b(?:bitmap|bitmaps|caps always off|caps on only|copyright|hotkey|language|layout|message|name|shift frees caps|version)\b/i,
        alias: "bold"
        // alias for styles
      },
      "rule-keyword": {
        pattern: /\b(?:any|baselayout|beep|call|context|deadkey|dk|if|index|layer|notany|nul|outs|platform|reset|return|save|set|store|use)\b/i,
        alias: "keyword"
      },
      "structural-keyword": {
        pattern: /\b(?:ansi|begin|group|match|nomatch|unicode|using keys)\b/i,
        alias: "keyword"
      },
      "compile-target": {
        pattern: /\$(?:keyman|keymanonly|keymanweb|kmfl|weaver):/i,
        alias: "property"
      },
      // U+####, x###, d### characters and numbers
      number: /\b(?:U\+[\dA-F]+|d\d+|x[\da-f]+|\d+)\b/i,
      operator: /[+>\\$]|\.\./,
      punctuation: /[()=,]/
    };
  }
  return keyman_1;
}
var kotlin_1, hasRequiredKotlin;
function requireKotlin() {
  if (hasRequiredKotlin) return kotlin_1;
  hasRequiredKotlin = 1, kotlin_1 = e, e.displayName = "kotlin", e.aliases = ["kt", "kts"];
  function e(t) {
    (function(r) {
      r.languages.kotlin = r.languages.extend("clike", {
        keyword: {
          // The lookbehind prevents wrong highlighting of e.g. kotlin.properties.get
          pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/,
          lookbehind: !0
        },
        function: [{
          pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/,
          greedy: !0
        }, {
          pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/,
          lookbehind: !0,
          greedy: !0
        }],
        number: /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/,
        operator: /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/
      }), delete r.languages.kotlin["class-name"];
      var a = {
        "interpolation-punctuation": {
          pattern: /^\$\{?|\}$/,
          alias: "punctuation"
        },
        expression: {
          pattern: /[\s\S]+/,
          inside: r.languages.kotlin
        }
      };
      r.languages.insertBefore("kotlin", "string", {
        // https://kotlinlang.org/spec/expressions.html#string-interpolation-expressions
        "string-literal": [{
          pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/,
          alias: "multiline",
          inside: {
            interpolation: {
              pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i,
              inside: a
            },
            string: /[\s\S]+/
          }
        }, {
          pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/,
          alias: "singleline",
          inside: {
            interpolation: {
              pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i,
              lookbehind: !0,
              inside: a
            },
            string: /[\s\S]+/
          }
        }],
        char: {
          // https://kotlinlang.org/spec/expressions.html#character-literals
          pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/,
          greedy: !0
        }
      }), delete r.languages.kotlin.string, r.languages.insertBefore("kotlin", "keyword", {
        annotation: {
          pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/,
          alias: "builtin"
        }
      }), r.languages.insertBefore("kotlin", "function", {
        label: {
          pattern: /\b\w+@|@\w+\b/,
          alias: "symbol"
        }
      }), r.languages.kt = r.languages.kotlin, r.languages.kts = r.languages.kotlin;
    })(t);
  }
  return kotlin_1;
}
var kumir_1, hasRequiredKumir;
function requireKumir() {
  if (hasRequiredKumir) return kumir_1;
  hasRequiredKumir = 1, kumir_1 = e, e.displayName = "kumir", e.aliases = ["kum"];
  function e(t) {
    (function(r) {
      var a = /\s\x00-\x1f\x22-\x2f\x3a-\x3f\x5b-\x5e\x60\x7b-\x7e/.source;
      function o(u, c) {
        return RegExp(u.replace(/<nonId>/g, a), c);
      }
      r.languages.kumir = {
        comment: {
          pattern: /\|.*/
        },
        prolog: {
          pattern: /#.*/,
          greedy: !0
        },
        string: {
          pattern: /"[^\n\r"]*"|'[^\n\r']*'/,
          greedy: !0
        },
        boolean: {
          pattern: o(/(^|[<nonId>])(?:|)(?=[<nonId>]|$)/.source),
          lookbehind: !0
        },
        "operator-word": {
          pattern: o(/(^|[<nonId>])(?:||)(?=[<nonId>]|$)/.source),
          lookbehind: !0,
          alias: "keyword"
        },
        "system-variable": {
          pattern: o(/(^|[<nonId>])(?=[<nonId>]|$)/.source),
          lookbehind: !0,
          alias: "keyword"
        },
        type: [{
          pattern: o(/(^|[<nonId>])(?:||||)(?:\x20*)?(?=[<nonId>]|$)/.source),
          lookbehind: !0,
          alias: "builtin"
        }, {
          pattern: o(/(^|[<nonId>])(?:|||)(?=[<nonId>]|$)/.source),
          lookbehind: !0,
          alias: "important"
        }],
        /**
         * Should be performed after searching for type names because of "".
         * "" is a reserved word, but never used without a preceding type name.
         * "", "", and "" are not reserved words.
         */
        keyword: {
          pattern: o(/(^|[<nonId>])(?:|(?:\x20*)?|||[]||||||||||||(?:(?:\x20+|_))?|(?:(?:\x20+|_))?|||||||||?||||||)(?=[<nonId>]|$)/.source),
          lookbehind: !0
        },
        /** Should be performed after searching for reserved words. */
        name: {
          // eslint-disable-next-line regexp/no-super-linear-backtracking
          pattern: o(/(^|[<nonId>])[^\d<nonId>][^<nonId>]*(?:\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source),
          lookbehind: !0
        },
        /** Should be performed after searching for names. */
        number: {
          pattern: o(/(^|[<nonId>])(?:\B\$[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?=[<nonId>]|$)/.source, "i"),
          lookbehind: !0
        },
        /** Should be performed after searching for words. */
        punctuation: /:=|[(),:;\[\]]/,
        /**
         * Should be performed after searching for
         * - numeric constants (because of "+" and "-");
         * - punctuation marks (because of ":=" and "=").
         */
        "operator-char": {
          pattern: /\*\*?|<[=>]?|>=?|[-+/=]/,
          alias: "operator"
        }
      }, r.languages.kum = r.languages.kumir;
    })(t);
  }
  return kumir_1;
}
var kusto_1, hasRequiredKusto;
function requireKusto() {
  if (hasRequiredKusto) return kusto_1;
  hasRequiredKusto = 1, kusto_1 = e, e.displayName = "kusto", e.aliases = [];
  function e(t) {
    t.languages.kusto = {
      comment: {
        pattern: /\/\/.*/,
        greedy: !0
      },
      string: {
        pattern: /```[\s\S]*?```|[hH]?(?:"(?:[^\r\n\\"]|\\.)*"|'(?:[^\r\n\\']|\\.)*'|@(?:"[^\r\n"]*"|'[^\r\n']*'))/,
        greedy: !0
      },
      verb: {
        pattern: /(\|\s*)[a-z][\w-]*/i,
        lookbehind: !0,
        alias: "keyword"
      },
      command: {
        pattern: /\.[a-z][a-z\d-]*\b/,
        alias: "keyword"
      },
      "class-name": /\b(?:bool|datetime|decimal|dynamic|guid|int|long|real|string|timespan)\b/,
      keyword: /\b(?:access|alias|and|anti|as|asc|auto|between|by|(?:contains|(?:ends|starts)with|has(?:perfix|suffix)?)(?:_cs)?|database|declare|desc|external|from|fullouter|has_all|in|ingestion|inline|inner|innerunique|into|(?:left|right)(?:anti(?:semi)?|inner|outer|semi)?|let|like|local|not|of|on|or|pattern|print|query_parameters|range|restrict|schema|set|step|table|tables|to|view|where|with|matches\s+regex|nulls\s+(?:first|last))(?![\w-])/,
      boolean: /\b(?:false|null|true)\b/,
      function: /\b[a-z_]\w*(?=\s*\()/,
      datetime: [{
        // RFC 822 + RFC 850
        pattern: /\b(?:(?:Fri|Friday|Mon|Monday|Sat|Saturday|Sun|Sunday|Thu|Thursday|Tue|Tuesday|Wed|Wednesday)\s*,\s*)?\d{1,2}(?:\s+|-)(?:Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)(?:\s+|-)\d{2}\s+\d{2}:\d{2}(?::\d{2})?(?:\s*(?:\b(?:[A-Z]|(?:[ECMT][DS]|GM|U)T)|[+-]\d{4}))?\b/,
        alias: "number"
      }, {
        // ISO 8601
        pattern: /[+-]?\b(?:\d{4}-\d{2}-\d{2}(?:[ T]\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?)?|\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?)Z?/,
        alias: "number"
      }],
      number: /\b(?:0x[0-9A-Fa-f]+|\d+(?:\.\d+)?(?:[Ee][+-]?\d+)?)(?:(?:min|sec|[mn]s|[dhms]|microsecond|tick)\b)?|[+-]?\binf\b/,
      operator: /=>|[!=]~|[!=<>]=?|[-+*/%|]|\.\./,
      punctuation: /[()\[\]{},;.:]/
    };
  }
  return kusto_1;
}
var latex_1, hasRequiredLatex;
function requireLatex() {
  if (hasRequiredLatex) return latex_1;
  hasRequiredLatex = 1, latex_1 = e, e.displayName = "latex", e.aliases = ["tex", "context"];
  function e(t) {
    (function(r) {
      var a = /\\(?:[^a-z()[\]]|[a-z*]+)/i, o = {
        "equation-command": {
          pattern: a,
          alias: "regex"
        }
      };
      r.languages.latex = {
        comment: /%.*/,
        // the verbatim environment prints whitespace to the document
        cdata: {
          pattern: /(\\begin\{((?:lstlisting|verbatim)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
          lookbehind: !0
        },
        /*
         * equations can be between $$ $$ or $ $ or \( \) or \[ \]
         * (all are multiline)
         */
        equation: [{
          pattern: /\$\$(?:\\[\s\S]|[^\\$])+\$\$|\$(?:\\[\s\S]|[^\\$])+\$|\\\([\s\S]*?\\\)|\\\[[\s\S]*?\\\]/,
          inside: o,
          alias: "string"
        }, {
          pattern: /(\\begin\{((?:align|eqnarray|equation|gather|math|multline)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
          lookbehind: !0,
          inside: o,
          alias: "string"
        }],
        /*
         * arguments which are keywords or references are highlighted
         * as keywords
         */
        keyword: {
          pattern: /(\\(?:begin|cite|documentclass|end|label|ref|usepackage)(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
          lookbehind: !0
        },
        url: {
          pattern: /(\\url\{)[^}]+(?=\})/,
          lookbehind: !0
        },
        /*
         * section or chapter headlines are highlighted as bold so that
         * they stand out more
         */
        headline: {
          pattern: /(\\(?:chapter|frametitle|paragraph|part|section|subparagraph|subsection|subsubparagraph|subsubsection|subsubsubparagraph)\*?(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
          lookbehind: !0,
          alias: "class-name"
        },
        function: {
          pattern: a,
          alias: "selector"
        },
        punctuation: /[[\]{}&]/
      }, r.languages.tex = r.languages.latex, r.languages.context = r.languages.latex;
    })(t);
  }
  return latex_1;
}
var php_1, hasRequiredPhp;
function requirePhp() {
  if (hasRequiredPhp) return php_1;
  hasRequiredPhp = 1;
  var e = requireMarkupTemplating();
  php_1 = t, t.displayName = "php", t.aliases = [];
  function t(r) {
    r.register(e), function(a) {
      var o = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/, u = [{
        pattern: /\b(?:false|true)\b/i,
        alias: "boolean"
      }, {
        pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
        greedy: !0,
        lookbehind: !0
      }, {
        pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
        greedy: !0,
        lookbehind: !0
      }, /\b(?:null)\b/i, /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/], c = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i, d = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/, g = /[{}\[\](),:;]/;
      a.languages.php = {
        delimiter: {
          pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
          alias: "important"
        },
        comment: o,
        variable: /\$+(?:\w+\b|(?=\{))/,
        package: {
          pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        },
        "class-name-definition": {
          pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
          lookbehind: !0,
          alias: "class-name"
        },
        "function-definition": {
          pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
          lookbehind: !0,
          alias: "function"
        },
        keyword: [
          {
            pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
            alias: "type-casting",
            greedy: !0,
            lookbehind: !0
          },
          {
            pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
            alias: "type-hint",
            greedy: !0,
            lookbehind: !0
          },
          {
            pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string|void)\b/i,
            alias: "return-type",
            greedy: !0,
            lookbehind: !0
          },
          {
            pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
            alias: "type-declaration",
            greedy: !0
          },
          {
            pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
            alias: "type-declaration",
            greedy: !0,
            lookbehind: !0
          },
          {
            pattern: /\b(?:parent|self|static)(?=\s*::)/i,
            alias: "static-context",
            greedy: !0
          },
          {
            // yield from
            pattern: /(\byield\s+)from\b/i,
            lookbehind: !0
          },
          // `class` is always a keyword unlike other keywords
          /\bclass\b/i,
          {
            // https://www.php.net/manual/en/reserved.keywords.php
            //
            // keywords cannot be preceded by "->"
            // the complex lookbehind means `(?<!(?:->|::)\s*)`
            pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|new|or|parent|print|private|protected|public|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
            lookbehind: !0
          }
        ],
        "argument-name": {
          pattern: /([(,]\s+)\b[a-z_]\w*(?=\s*:(?!:))/i,
          lookbehind: !0
        },
        "class-name": [{
          pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
          greedy: !0,
          lookbehind: !0
        }, {
          pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
          greedy: !0,
          lookbehind: !0
        }, {
          pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
          greedy: !0
        }, {
          pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
          alias: "class-name-fully-qualified",
          greedy: !0,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        }, {
          pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
          alias: "class-name-fully-qualified",
          greedy: !0,
          inside: {
            punctuation: /\\/
          }
        }, {
          pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
          alias: "class-name-fully-qualified",
          greedy: !0,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        }, {
          pattern: /\b[a-z_]\w*(?=\s*\$)/i,
          alias: "type-declaration",
          greedy: !0
        }, {
          pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
          alias: ["class-name-fully-qualified", "type-declaration"],
          greedy: !0,
          inside: {
            punctuation: /\\/
          }
        }, {
          pattern: /\b[a-z_]\w*(?=\s*::)/i,
          alias: "static-context",
          greedy: !0
        }, {
          pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
          alias: ["class-name-fully-qualified", "static-context"],
          greedy: !0,
          inside: {
            punctuation: /\\/
          }
        }, {
          pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
          alias: "type-hint",
          greedy: !0,
          lookbehind: !0
        }, {
          pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
          alias: ["class-name-fully-qualified", "type-hint"],
          greedy: !0,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        }, {
          pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
          alias: "return-type",
          greedy: !0,
          lookbehind: !0
        }, {
          pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
          alias: ["class-name-fully-qualified", "return-type"],
          greedy: !0,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        }],
        constant: u,
        function: {
          pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
          lookbehind: !0,
          inside: {
            punctuation: /\\/
          }
        },
        property: {
          pattern: /(->\s*)\w+/,
          lookbehind: !0
        },
        number: c,
        operator: d,
        punctuation: g
      };
      var b = {
        pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
        lookbehind: !0,
        inside: a.languages.php
      }, _ = [{
        pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
        alias: "nowdoc-string",
        greedy: !0,
        inside: {
          delimiter: {
            pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
            alias: "symbol",
            inside: {
              punctuation: /^<<<'?|[';]$/
            }
          }
        }
      }, {
        pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
        alias: "heredoc-string",
        greedy: !0,
        inside: {
          delimiter: {
            pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
            alias: "symbol",
            inside: {
              punctuation: /^<<<"?|[";]$/
            }
          },
          interpolation: b
        }
      }, {
        pattern: /`(?:\\[\s\S]|[^\\`])*`/,
        alias: "backtick-quoted-string",
        greedy: !0
      }, {
        pattern: /'(?:\\[\s\S]|[^\\'])*'/,
        alias: "single-quoted-string",
        greedy: !0
      }, {
        pattern: /"(?:\\[\s\S]|[^\\"])*"/,
        alias: "double-quoted-string",
        greedy: !0,
        inside: {
          interpolation: b
        }
      }];
      a.languages.insertBefore("php", "variable", {
        string: _,
        attribute: {
          pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
          greedy: !0,
          inside: {
            "attribute-content": {
              pattern: /^(#\[)[\s\S]+(?=\]$)/,
              lookbehind: !0,
              // inside can appear subset of php
              inside: {
                comment: o,
                string: _,
                "attribute-class-name": [{
                  pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
                  alias: "class-name",
                  greedy: !0,
                  lookbehind: !0
                }, {
                  pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
                  alias: ["class-name", "class-name-fully-qualified"],
                  greedy: !0,
                  lookbehind: !0,
                  inside: {
                    punctuation: /\\/
                  }
                }],
                constant: u,
                number: c,
                operator: d,
                punctuation: g
              }
            },
            delimiter: {
              pattern: /^#\[|\]$/,
              alias: "punctuation"
            }
          }
        }
      }), a.hooks.add("before-tokenize", function(y) {
        if (/<\?/.test(y.code)) {
          var A = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
          a.languages["markup-templating"].buildPlaceholders(y, "php", A);
        }
      }), a.hooks.add("after-tokenize", function(y) {
        a.languages["markup-templating"].tokenizePlaceholders(y, "php");
      });
    }(r);
  }
  return php_1;
}
var latte_1, hasRequiredLatte;
function requireLatte() {
  if (hasRequiredLatte) return latte_1;
  hasRequiredLatte = 1;
  var e = requireMarkupTemplating(), t = requirePhp();
  latte_1 = r, r.displayName = "latte", r.aliases = [];
  function r(a) {
    a.register(e), a.register(t), function(o) {
      o.languages.latte = {
        comment: /^\{\*[\s\S]*/,
        "latte-tag": {
          // https://latte.nette.org/en/tags
          pattern: /(^\{(?:\/(?=[a-z]))?)(?:[=_]|[a-z]\w*\b(?!\())/i,
          lookbehind: !0,
          alias: "important"
        },
        delimiter: {
          pattern: /^\{\/?|\}$/,
          alias: "punctuation"
        },
        php: {
          pattern: /\S(?:[\s\S]*\S)?/,
          alias: "language-php",
          inside: o.languages.php
        }
      };
      var u = o.languages.extend("markup", {});
      o.languages.insertBefore("inside", "attr-value", {
        "n-attr": {
          pattern: /n:[\w-]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+))?/,
          inside: {
            "attr-name": {
              pattern: /^[^\s=]+/,
              alias: "important"
            },
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                punctuation: [/^=/, {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: !0
                }],
                php: {
                  pattern: /\S(?:[\s\S]*\S)?/,
                  inside: o.languages.php
                }
              }
            }
          }
        }
      }, u.tag), o.hooks.add("before-tokenize", function(c) {
        if (c.language === "latte") {
          var d = /\{\*[\s\S]*?\*\}|\{[^'"\s{}*](?:[^"'/{}]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|\/\*(?:[^*]|\*(?!\/))*\*\/)*\}/g;
          o.languages["markup-templating"].buildPlaceholders(c, "latte", d), c.grammar = u;
        }
      }), o.hooks.add("after-tokenize", function(c) {
        o.languages["markup-templating"].tokenizePlaceholders(c, "latte");
      });
    }(a);
  }
  return latte_1;
}
var less_1, hasRequiredLess;
function requireLess() {
  if (hasRequiredLess) return less_1;
  hasRequiredLess = 1, less_1 = e, e.displayName = "less", e.aliases = [];
  function e(t) {
    t.languages.less = t.languages.extend("css", {
      comment: [/\/\*[\s\S]*?\*\//, {
        pattern: /(^|[^\\])\/\/.*/,
        lookbehind: !0
      }],
      atrule: {
        pattern: /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
        inside: {
          punctuation: /[:()]/
        }
      },
      // selectors and mixins are considered the same
      selector: {
        pattern: /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
        inside: {
          // mixin parameters
          variable: /@+[\w-]+/
        }
      },
      property: /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
      operator: /[+\-*\/]/
    }), t.languages.insertBefore("less", "property", {
      variable: [
        // Variable declaration (the colon must be consumed!)
        {
          pattern: /@[\w-]+\s*:/,
          inside: {
            punctuation: /:/
          }
        },
        // Variable usage
        /@@?[\w-]+/
      ],
      "mixin-usage": {
        pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
        lookbehind: !0,
        alias: "function"
      }
    });
  }
  return less_1;
}
var scheme_1, hasRequiredScheme;
function requireScheme() {
  if (hasRequiredScheme) return scheme_1;
  hasRequiredScheme = 1, scheme_1 = e, e.displayName = "scheme", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.scheme = {
        // this supports "normal" single-line comments:
        //   ; comment
        // and (potentially nested) multiline comments:
        //   #| comment #| nested |# still comment |#
        // (only 1 level of nesting is supported)
        comment: /;.*|#;\s*(?:\((?:[^()]|\([^()]*\))*\)|\[(?:[^\[\]]|\[[^\[\]]*\])*\])|#\|(?:[^#|]|#(?!\|)|\|(?!#)|#\|(?:[^#|]|#(?!\|)|\|(?!#))*\|#)*\|#/,
        string: {
          pattern: /"(?:[^"\\]|\\.)*"/,
          greedy: !0
        },
        symbol: {
          pattern: /'[^()\[\]#'\s]+/,
          greedy: !0
        },
        char: {
          pattern: /#\\(?:[ux][a-fA-F\d]+\b|[-a-zA-Z]+\b|[\uD800-\uDBFF][\uDC00-\uDFFF]|\S)/,
          greedy: !0
        },
        "lambda-parameter": [
          // https://www.cs.cmu.edu/Groups/AI/html/r4rs/r4rs_6.html#SEC30
          {
            pattern: /((?:^|[^'`#])[(\[]lambda\s+)(?:[^|()\[\]'\s]+|\|(?:[^\\|]|\\.)*\|)/,
            lookbehind: !0
          },
          {
            pattern: /((?:^|[^'`#])[(\[]lambda\s+[(\[])[^()\[\]']+/,
            lookbehind: !0
          }
        ],
        keyword: {
          pattern: /((?:^|[^'`#])[(\[])(?:begin|case(?:-lambda)?|cond(?:-expand)?|define(?:-library|-macro|-record-type|-syntax|-values)?|defmacro|delay(?:-force)?|do|else|except|export|guard|if|import|include(?:-ci|-library-declarations)?|lambda|let(?:rec)?(?:-syntax|-values|\*)?|let\*-values|only|parameterize|prefix|(?:quasi-?)?quote|rename|set!|syntax-(?:case|rules)|unless|unquote(?:-splicing)?|when)(?=[()\[\]\s]|$)/,
          lookbehind: !0
        },
        builtin: {
          // all functions of the base library of R7RS plus some of built-ins of R5Rs
          pattern: /((?:^|[^'`#])[(\[])(?:abs|and|append|apply|assoc|ass[qv]|binary-port\?|boolean=?\?|bytevector(?:-append|-copy|-copy!|-length|-u8-ref|-u8-set!|\?)?|caar|cadr|call-with-(?:current-continuation|port|values)|call\/cc|car|cdar|cddr|cdr|ceiling|char(?:->integer|-ready\?|\?|<\?|<=\?|=\?|>\?|>=\?)|close-(?:input-port|output-port|port)|complex\?|cons|current-(?:error|input|output)-port|denominator|dynamic-wind|eof-object\??|eq\?|equal\?|eqv\?|error|error-object(?:-irritants|-message|\?)|eval|even\?|exact(?:-integer-sqrt|-integer\?|\?)?|expt|features|file-error\?|floor(?:-quotient|-remainder|\/)?|flush-output-port|for-each|gcd|get-output-(?:bytevector|string)|inexact\??|input-port(?:-open\?|\?)|integer(?:->char|\?)|lcm|length|list(?:->string|->vector|-copy|-ref|-set!|-tail|\?)?|make-(?:bytevector|list|parameter|string|vector)|map|max|member|memq|memv|min|modulo|negative\?|newline|not|null\?|number(?:->string|\?)|numerator|odd\?|open-(?:input|output)-(?:bytevector|string)|or|output-port(?:-open\?|\?)|pair\?|peek-char|peek-u8|port\?|positive\?|procedure\?|quotient|raise|raise-continuable|rational\?|rationalize|read-(?:bytevector|bytevector!|char|error\?|line|string|u8)|real\?|remainder|reverse|round|set-c[ad]r!|square|string(?:->list|->number|->symbol|->utf8|->vector|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\?|<\?|<=\?|=\?|>\?|>=\?)?|substring|symbol(?:->string|\?|=\?)|syntax-error|textual-port\?|truncate(?:-quotient|-remainder|\/)?|u8-ready\?|utf8->string|values|vector(?:->list|->string|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\?)?|with-exception-handler|write-(?:bytevector|char|string|u8)|zero\?)(?=[()\[\]\s]|$)/,
          lookbehind: !0
        },
        operator: {
          pattern: /((?:^|[^'`#])[(\[])(?:[-+*%/]|[<>]=?|=>?)(?=[()\[\]\s]|$)/,
          lookbehind: !0
        },
        number: {
          // The number pattern from [the R7RS spec](https://small.r7rs.org/attachment/r7rs.pdf).
          //
          // <number>      := <num 2>|<num 8>|<num 10>|<num 16>
          // <num R>       := <prefix R><complex R>
          // <complex R>   := <real R>(?:@<real R>|<imaginary R>)?|<imaginary R>
          // <imaginary R> := [+-](?:<ureal R>|(?:inf|nan)\.0)?i
          // <real R>      := [+-]?<ureal R>|[+-](?:inf|nan)\.0
          // <ureal R>     := <uint R>(?:\/<uint R>)?
          //                | <decimal R>
          //
          // <decimal 10>  := (?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?
          // <uint R>      := <digit R>+
          // <prefix R>    := <radix R>(?:#[ei])?|(?:#[ei])?<radix R>
          // <radix 2>     := #b
          // <radix 8>     := #o
          // <radix 10>    := (?:#d)?
          // <radix 16>    := #x
          // <digit 2>     := [01]
          // <digit 8>     := [0-7]
          // <digit 10>    := \d
          // <digit 16>    := [0-9a-f]
          //
          // The problem with this grammar is that the resulting regex is way to complex, so we simplify by grouping all
          // non-decimal bases together. This results in a decimal (dec) and combined binary, octal, and hexadecimal (box)
          // pattern:
          pattern: RegExp(a({
            "<ureal dec>": /\d+(?:\/\d+)|(?:\d+(?:\.\d*)?|\.\d+)(?:[esfdl][+-]?\d+)?/.source,
            "<real dec>": /[+-]?<ureal dec>|[+-](?:inf|nan)\.0/.source,
            "<imaginary dec>": /[+-](?:<ureal dec>|(?:inf|nan)\.0)?i/.source,
            "<complex dec>": /<real dec>(?:@<real dec>|<imaginary dec>)?|<imaginary dec>/.source,
            "<num dec>": /(?:#d(?:#[ei])?|#[ei](?:#d)?)?<complex dec>/.source,
            "<ureal box>": /[0-9a-f]+(?:\/[0-9a-f]+)?/.source,
            "<real box>": /[+-]?<ureal box>|[+-](?:inf|nan)\.0/.source,
            "<imaginary box>": /[+-](?:<ureal box>|(?:inf|nan)\.0)?i/.source,
            "<complex box>": /<real box>(?:@<real box>|<imaginary box>)?|<imaginary box>/.source,
            "<num box>": /#[box](?:#[ei])?|(?:#[ei])?#[box]<complex box>/.source,
            "<number>": /(^|[()\[\]\s])(?:<num dec>|<num box>)(?=[()\[\]\s]|$)/.source
          }), "i"),
          lookbehind: !0
        },
        boolean: {
          pattern: /(^|[()\[\]\s])#(?:[ft]|false|true)(?=[()\[\]\s]|$)/,
          lookbehind: !0
        },
        function: {
          pattern: /((?:^|[^'`#])[(\[])(?:[^|()\[\]'\s]+|\|(?:[^\\|]|\\.)*\|)(?=[()\[\]\s]|$)/,
          lookbehind: !0
        },
        identifier: {
          pattern: /(^|[()\[\]\s])\|(?:[^\\|]|\\.)*\|(?=[()\[\]\s]|$)/,
          lookbehind: !0,
          greedy: !0
        },
        punctuation: /[()\[\]']/
      };
      function a(o) {
        for (var u in o)
          o[u] = o[u].replace(/<[\w\s]+>/g, function(c) {
            return "(?:" + o[c].trim() + ")";
          });
        return o[u];
      }
    })(t);
  }
  return scheme_1;
}
var lilypond_1, hasRequiredLilypond;
function requireLilypond() {
  if (hasRequiredLilypond) return lilypond_1;
  hasRequiredLilypond = 1;
  var e = requireScheme();
  lilypond_1 = t, t.displayName = "lilypond", t.aliases = [];
  function t(r) {
    r.register(e), function(a) {
      for (var o = /\((?:[^();"#\\]|\\[\s\S]|;.*(?!.)|"(?:[^"\\]|\\.)*"|#(?:\{(?:(?!#\})[\s\S])*#\}|[^{])|<expr>)*\)/.source, u = 5, c = 0; c < u; c++)
        o = o.replace(/<expr>/g, function() {
          return o;
        });
      o = o.replace(/<expr>/g, /[^\s\S]/.source);
      var d = a.languages.lilypond = {
        comment: /%(?:(?!\{).*|\{[\s\S]*?%\})/,
        "embedded-scheme": {
          pattern: RegExp(/(^|[=\s])#(?:"(?:[^"\\]|\\.)*"|[^\s()"]*(?:[^\s()]|<expr>))/.source.replace(/<expr>/g, function() {
            return o;
          }), "m"),
          lookbehind: !0,
          greedy: !0,
          inside: {
            scheme: {
              pattern: /^(#)[\s\S]+$/,
              lookbehind: !0,
              alias: "language-scheme",
              inside: {
                "embedded-lilypond": {
                  pattern: /#\{[\s\S]*?#\}/,
                  greedy: !0,
                  inside: {
                    punctuation: /^#\{|#\}$/,
                    lilypond: {
                      pattern: /[\s\S]+/,
                      alias: "language-lilypond",
                      inside: null
                      // see below
                    }
                  }
                },
                rest: a.languages.scheme
              }
            },
            punctuation: /#/
          }
        },
        string: {
          pattern: /"(?:[^"\\]|\\.)*"/,
          greedy: !0
        },
        "class-name": {
          pattern: /(\\new\s+)[\w-]+/,
          lookbehind: !0
        },
        keyword: {
          pattern: /\\[a-z][-\w]*/i,
          inside: {
            punctuation: /^\\/
          }
        },
        operator: /[=|]|<<|>>/,
        punctuation: {
          pattern: /(^|[a-z\d])(?:'+|,+|[_^]?-[_^]?(?:[-+^!>._]|(?=\d))|[_^]\.?|[.!])|[{}()[\]<>^~]|\\[()[\]<>\\!]|--|__/,
          lookbehind: !0
        },
        number: /\b\d+(?:\/\d+)?\b/
      };
      d["embedded-scheme"].inside.scheme.inside["embedded-lilypond"].inside.lilypond.inside = d, a.languages.ly = d;
    }(r);
  }
  return lilypond_1;
}
var liquid_1, hasRequiredLiquid;
function requireLiquid() {
  if (hasRequiredLiquid) return liquid_1;
  hasRequiredLiquid = 1;
  var e = requireMarkupTemplating();
  liquid_1 = t, t.displayName = "liquid", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.liquid = {
      comment: {
        pattern: /(^\{%\s*comment\s*%\})[\s\S]+(?=\{%\s*endcomment\s*%\}$)/,
        lookbehind: !0
      },
      delimiter: {
        pattern: /^\{(?:\{\{|[%\{])-?|-?(?:\}\}|[%\}])\}$/,
        alias: "punctuation"
      },
      string: {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: !0
      },
      keyword: /\b(?:as|assign|break|(?:end)?(?:capture|case|comment|for|form|if|paginate|raw|style|tablerow|unless)|continue|cycle|decrement|echo|else|elsif|in|include|increment|limit|liquid|offset|range|render|reversed|section|when|with)\b/,
      object: /\b(?:address|all_country_option_tags|article|block|blog|cart|checkout|collection|color|country|country_option_tags|currency|current_page|current_tags|customer|customer_address|date|discount_allocation|discount_application|external_video|filter|filter_value|font|forloop|fulfillment|generic_file|gift_card|group|handle|image|line_item|link|linklist|localization|location|measurement|media|metafield|model|model_source|order|page|page_description|page_image|page_title|part|policy|product|product_option|recommendations|request|robots|routes|rule|script|search|selling_plan|selling_plan_allocation|selling_plan_group|shipping_method|shop|shop_locale|sitemap|store_availability|tax_line|template|theme|transaction|unit_price_measurement|user_agent|variant|video|video_source)\b/,
      function: [{
        pattern: /(\|\s*)\w+/,
        lookbehind: !0,
        alias: "filter"
      }, {
        // array functions
        pattern: /(\.\s*)(?:first|last|size)/,
        lookbehind: !0
      }],
      boolean: /\b(?:false|nil|true)\b/,
      range: {
        pattern: /\.\./,
        alias: "operator"
      },
      // https://github.com/Shopify/liquid/blob/698f5e0d967423e013f6169d9111bd969bd78337/lib/liquid/lexer.rb#L21
      number: /\b\d+(?:\.\d+)?\b/,
      operator: /[!=]=|<>|[<>]=?|[|?:=-]|\b(?:and|contains(?=\s)|or)\b/,
      punctuation: /[.,\[\]()]/,
      empty: {
        pattern: /\bempty\b/,
        alias: "keyword"
      }
    }, r.hooks.add("before-tokenize", function(a) {
      var o = /\{%\s*comment\s*%\}[\s\S]*?\{%\s*endcomment\s*%\}|\{(?:%[\s\S]*?%|\{\{[\s\S]*?\}\}|\{[\s\S]*?\})\}/g, u = !1;
      r.languages["markup-templating"].buildPlaceholders(a, "liquid", o, function(c) {
        var d = /^\{%-?\s*(\w+)/.exec(c);
        if (d) {
          var g = d[1];
          if (g === "raw" && !u)
            return u = !0, !0;
          if (g === "endraw")
            return u = !1, !0;
        }
        return !u;
      });
    }), r.hooks.add("after-tokenize", function(a) {
      r.languages["markup-templating"].tokenizePlaceholders(a, "liquid");
    });
  }
  return liquid_1;
}
var lisp_1, hasRequiredLisp;
function requireLisp() {
  if (hasRequiredLisp) return lisp_1;
  hasRequiredLisp = 1, lisp_1 = e, e.displayName = "lisp", e.aliases = [];
  function e(t) {
    (function(r) {
      function a(C) {
        return RegExp(/(\()/.source + "(?:" + C + ")" + /(?=[\s\)])/.source);
      }
      function o(C) {
        return RegExp(/([\s([])/.source + "(?:" + C + ")" + /(?=[\s)])/.source);
      }
      var u = /(?!\d)[-+*/~!@$%^=<>{}\w]+/.source, c = "&" + u, d = "(\\()", g = "(?=\\))", b = "(?=\\s)", _ = /(?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\))*\))*/.source, y = {
        // Three or four semicolons are considered a heading.
        // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html
        heading: {
          pattern: /;;;.*/,
          alias: ["comment", "title"]
        },
        comment: /;.*/,
        string: {
          pattern: /"(?:[^"\\]|\\.)*"/,
          greedy: !0,
          inside: {
            argument: /[-A-Z]+(?=[.,\s])/,
            symbol: RegExp("`" + u + "'")
          }
        },
        "quoted-symbol": {
          pattern: RegExp("#?'" + u),
          alias: ["variable", "symbol"]
        },
        "lisp-property": {
          pattern: RegExp(":" + u),
          alias: "property"
        },
        splice: {
          pattern: RegExp(",@?" + u),
          alias: ["symbol", "variable"]
        },
        keyword: [{
          pattern: RegExp(d + "(?:and|(?:cl-)?letf|cl-loop|cond|cons|error|if|(?:lexical-)?let\\*?|message|not|null|or|provide|require|setq|unless|use-package|when|while)" + b),
          lookbehind: !0
        }, {
          pattern: RegExp(d + "(?:append|by|collect|concat|do|finally|for|in|return)" + b),
          lookbehind: !0
        }],
        declare: {
          pattern: a(/declare/.source),
          lookbehind: !0,
          alias: "keyword"
        },
        interactive: {
          pattern: a(/interactive/.source),
          lookbehind: !0,
          alias: "keyword"
        },
        boolean: {
          pattern: o(/nil|t/.source),
          lookbehind: !0
        },
        number: {
          pattern: o(/[-+]?\d+(?:\.\d*)?/.source),
          lookbehind: !0
        },
        defvar: {
          pattern: RegExp(d + "def(?:const|custom|group|var)\\s+" + u),
          lookbehind: !0,
          inside: {
            keyword: /^def[a-z]+/,
            variable: RegExp(u)
          }
        },
        defun: {
          pattern: RegExp(d + /(?:cl-)?(?:defmacro|defun\*?)\s+/.source + u + /\s+\(/.source + _ + /\)/.source),
          lookbehind: !0,
          greedy: !0,
          inside: {
            keyword: /^(?:cl-)?def\S+/,
            // See below, this property needs to be defined later so that it can
            // reference the language object.
            arguments: null,
            function: {
              pattern: RegExp("(^\\s)" + u),
              lookbehind: !0
            },
            punctuation: /[()]/
          }
        },
        lambda: {
          pattern: RegExp(d + "lambda\\s+\\(\\s*(?:&?" + u + "(?:\\s+&?" + u + ")*\\s*)?\\)"),
          lookbehind: !0,
          greedy: !0,
          inside: {
            keyword: /^lambda/,
            // See below, this property needs to be defined later so that it can
            // reference the language object.
            arguments: null,
            punctuation: /[()]/
          }
        },
        car: {
          pattern: RegExp(d + u),
          lookbehind: !0
        },
        punctuation: [
          // open paren, brackets, and close paren
          /(?:['`,]?\(|[)\[\]])/,
          // cons
          {
            pattern: /(\s)\.(?=\s)/,
            lookbehind: !0
          }
        ]
      }, A = {
        "lisp-marker": RegExp(c),
        varform: {
          pattern: RegExp(/\(/.source + u + /\s+(?=\S)/.source + _ + /\)/.source),
          inside: y
        },
        argument: {
          pattern: RegExp(/(^|[\s(])/.source + u),
          lookbehind: !0,
          alias: "variable"
        },
        rest: y
      }, E = "\\S+(?:\\s+\\S+)*", v = {
        pattern: RegExp(d + _ + g),
        lookbehind: !0,
        inside: {
          "rest-vars": {
            pattern: RegExp("&(?:body|rest)\\s+" + E),
            inside: A
          },
          "other-marker-vars": {
            pattern: RegExp("&(?:aux|optional)\\s+" + E),
            inside: A
          },
          keys: {
            pattern: RegExp("&key\\s+" + E + "(?:\\s+&allow-other-keys)?"),
            inside: A
          },
          argument: {
            pattern: RegExp(u),
            alias: "variable"
          },
          punctuation: /[()]/
        }
      };
      y.lambda.inside.arguments = v, y.defun.inside.arguments = r.util.clone(v), y.defun.inside.arguments.inside.sublist = v, r.languages.lisp = y, r.languages.elisp = y, r.languages.emacs = y, r.languages["emacs-lisp"] = y;
    })(t);
  }
  return lisp_1;
}
var livescript_1, hasRequiredLivescript;
function requireLivescript() {
  if (hasRequiredLivescript) return livescript_1;
  hasRequiredLivescript = 1, livescript_1 = e, e.displayName = "livescript", e.aliases = [];
  function e(t) {
    t.languages.livescript = {
      comment: [{
        pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
        lookbehind: !0
      }, {
        pattern: /(^|[^\\])#.*/,
        lookbehind: !0
      }],
      "interpolated-string": {
        /* Look-behind and look-ahead prevents wrong behavior of the greedy pattern
         * forcing it to match """-quoted string when it would otherwise match "-quoted first. */
        pattern: /(^|[^"])("""|")(?:\\[\s\S]|(?!\2)[^\\])*\2(?!")/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          variable: {
            pattern: /(^|[^\\])#[a-z_](?:-?[a-z]|[\d_])*/m,
            lookbehind: !0
          },
          interpolation: {
            pattern: /(^|[^\\])#\{[^}]+\}/m,
            lookbehind: !0,
            inside: {
              "interpolation-punctuation": {
                pattern: /^#\{|\}$/,
                alias: "variable"
              }
              // See rest below
            }
          },
          string: /[\s\S]+/
        }
      },
      string: [{
        pattern: /('''|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,
        greedy: !0
      }, {
        pattern: /<\[[\s\S]*?\]>/,
        greedy: !0
      }, /\\[^\s,;\])}]+/],
      regex: [{
        pattern: /\/\/(?:\[[^\r\n\]]*\]|\\.|(?!\/\/)[^\\\[])+\/\/[gimyu]{0,5}/,
        greedy: !0,
        inside: {
          comment: {
            pattern: /(^|[^\\])#.*/,
            lookbehind: !0
          }
        }
      }, {
        pattern: /\/(?:\[[^\r\n\]]*\]|\\.|[^/\\\r\n\[])+\/[gimyu]{0,5}/,
        greedy: !0
      }],
      keyword: {
        pattern: /(^|(?!-).)\b(?:break|case|catch|class|const|continue|default|do|else|extends|fallthrough|finally|for(?: ever)?|function|if|implements|it|let|loop|new|null|otherwise|own|return|super|switch|that|then|this|throw|try|unless|until|var|void|when|while|yield)(?!-)\b/m,
        lookbehind: !0
      },
      "keyword-operator": {
        pattern: /(^|[^-])\b(?:(?:delete|require|typeof)!|(?:and|by|delete|export|from|import(?: all)?|in|instanceof|is(?: not|nt)?|not|of|or|til|to|typeof|with|xor)(?!-)\b)/m,
        lookbehind: !0,
        alias: "operator"
      },
      boolean: {
        pattern: /(^|[^-])\b(?:false|no|off|on|true|yes)(?!-)\b/m,
        lookbehind: !0
      },
      argument: {
        // Don't match .&. nor &&
        pattern: /(^|(?!\.&\.)[^&])&(?!&)\d*/m,
        lookbehind: !0,
        alias: "variable"
      },
      number: /\b(?:\d+~[\da-z]+|\d[\d_]*(?:\.\d[\d_]*)?(?:[a-z]\w*)?)/i,
      identifier: /[a-z_](?:-?[a-z]|[\d_])*/i,
      operator: [
        // Spaced .
        {
          pattern: /( )\.(?= )/,
          lookbehind: !0
        },
        // Full list, in order:
        // .= .~ .. ...
        // .&. .^. .<<. .>>. .>>>.
        // := :: ::=
        // &&
        // || |>
        // < << <<< <<<<
        // <- <-- <-! <--!
        // <~ <~~ <~! <~~!
        // <| <= <?
        // > >> >= >?
        // - -- -> -->
        // + ++
        // @ @@
        // % %%
        // * **
        // ! != !~=
        // !~> !~~>
        // !-> !-->
        // ~ ~> ~~> ~=
        // = ==
        // ^ ^^
        // / ?
        /\.(?:[=~]|\.\.?)|\.(?:[&|^]|<<|>>>?)\.|:(?:=|:=?)|&&|\|[|>]|<(?:<<?<?|--?!?|~~?!?|[|=?])?|>[>=?]?|-(?:->?|>)?|\+\+?|@@?|%%?|\*\*?|!(?:~?=|--?>|~?~>)?|~(?:~?>|=)?|==?|\^\^?|[\/?]/
      ],
      punctuation: /[(){}\[\]|.,:;`]/
    }, t.languages.livescript["interpolated-string"].inside.interpolation.inside.rest = t.languages.livescript;
  }
  return livescript_1;
}
var llvm_1, hasRequiredLlvm;
function requireLlvm() {
  if (hasRequiredLlvm) return llvm_1;
  hasRequiredLlvm = 1, llvm_1 = e, e.displayName = "llvm", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.llvm = {
        comment: /;.*/,
        string: {
          pattern: /"[^"]*"/,
          greedy: !0
        },
        boolean: /\b(?:false|true)\b/,
        variable: /[%@!#](?:(?!\d)(?:[-$.\w]|\\[a-f\d]{2})+|\d+)/i,
        label: /(?!\d)(?:[-$.\w]|\\[a-f\d]{2})+:/i,
        type: {
          pattern: /\b(?:double|float|fp128|half|i[1-9]\d*|label|metadata|ppc_fp128|token|void|x86_fp80|x86_mmx)\b/,
          alias: "class-name"
        },
        keyword: /\b[a-z_][a-z_0-9]*\b/,
        number: /[+-]?\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b|\b0x[\dA-Fa-f]+\b|\b0xK[\dA-Fa-f]{20}\b|\b0x[ML][\dA-Fa-f]{32}\b|\b0xH[\dA-Fa-f]{4}\b/,
        punctuation: /[{}[\];(),.!*=<>]/
      };
    })(t);
  }
  return llvm_1;
}
var log_1, hasRequiredLog;
function requireLog() {
  if (hasRequiredLog) return log_1;
  hasRequiredLog = 1, log_1 = e, e.displayName = "log", e.aliases = [];
  function e(t) {
    t.languages.log = {
      string: {
        // Single-quoted strings must not be confused with plain text. E.g. Can't isn't Susan's Chris' toy
        pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?![st] | \w)(?:[^'\\\r\n]|\\.)*'/,
        greedy: !0
      },
      exception: {
        pattern: /(^|[^\w.])[a-z][\w.]*(?:Error|Exception):.*(?:(?:\r\n?|\n)[ \t]*(?:at[ \t].+|\.{3}.*|Caused by:.*))+(?:(?:\r\n?|\n)[ \t]*\.\.\. .*)?/,
        lookbehind: !0,
        greedy: !0,
        alias: ["javastacktrace", "language-javastacktrace"],
        inside: t.languages.javastacktrace || {
          keyword: /\bat\b/,
          function: /[a-z_][\w$]*(?=\()/,
          punctuation: /[.:()]/
        }
      },
      level: [{
        pattern: /\b(?:ALERT|CRIT|CRITICAL|EMERG|EMERGENCY|ERR|ERROR|FAILURE|FATAL|SEVERE)\b/,
        alias: ["error", "important"]
      }, {
        pattern: /\b(?:WARN|WARNING|WRN)\b/,
        alias: ["warning", "important"]
      }, {
        pattern: /\b(?:DISPLAY|INF|INFO|NOTICE|STATUS)\b/,
        alias: ["info", "keyword"]
      }, {
        pattern: /\b(?:DBG|DEBUG|FINE)\b/,
        alias: ["debug", "keyword"]
      }, {
        pattern: /\b(?:FINER|FINEST|TRACE|TRC|VERBOSE|VRB)\b/,
        alias: ["trace", "comment"]
      }],
      property: {
        pattern: /((?:^|[\]|])[ \t]*)[a-z_](?:[\w-]|\b\/\b)*(?:[. ]\(?\w(?:[\w-]|\b\/\b)*\)?)*:(?=\s)/im,
        lookbehind: !0
      },
      separator: {
        pattern: /(^|[^-+])-{3,}|={3,}|\*{3,}|- - /m,
        lookbehind: !0,
        alias: "comment"
      },
      url: /\b(?:file|ftp|https?):\/\/[^\s|,;'"]*[^\s|,;'">.]/,
      email: {
        pattern: /(^|\s)[-\w+.]+@[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)+(?=\s)/,
        lookbehind: !0,
        alias: "url"
      },
      "ip-address": {
        pattern: /\b(?:\d{1,3}(?:\.\d{1,3}){3})\b/,
        alias: "constant"
      },
      "mac-address": {
        pattern: /\b[a-f0-9]{2}(?::[a-f0-9]{2}){5}\b/i,
        alias: "constant"
      },
      domain: {
        pattern: /(^|\s)[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)*\.[a-z][a-z0-9-]+(?=\s)/,
        lookbehind: !0,
        alias: "constant"
      },
      uuid: {
        pattern: /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/i,
        alias: "constant"
      },
      hash: {
        pattern: /\b(?:[a-f0-9]{32}){1,2}\b/i,
        alias: "constant"
      },
      "file-path": {
        pattern: /\b[a-z]:[\\/][^\s|,;:(){}\[\]"']+|(^|[\s:\[\](>|])\.{0,2}\/\w[^\s|,;:(){}\[\]"']*/i,
        lookbehind: !0,
        greedy: !0,
        alias: "string"
      },
      date: {
        pattern: RegExp(/\b\d{4}[-/]\d{2}[-/]\d{2}(?:T(?=\d{1,2}:)|(?=\s\d{1,2}:))/.source + "|" + /\b\d{1,4}[-/ ](?:\d{1,2}|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)[-/ ]\d{2,4}T?\b/.source + "|" + /\b(?:(?:Fri|Mon|Sat|Sun|Thu|Tue|Wed)(?:\s{1,2}(?:Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep))?|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)\s{1,2}\d{1,2}\b/.source, "i"),
        alias: "number"
      },
      time: {
        pattern: /\b\d{1,2}:\d{1,2}:\d{1,2}(?:[.,:]\d+)?(?:\s?[+-]\d{2}:?\d{2}|Z)?\b/,
        alias: "number"
      },
      boolean: /\b(?:false|null|true)\b/i,
      number: {
        pattern: /(^|[^.\w])(?:0x[a-f0-9]+|0o[0-7]+|0b[01]+|v?\d[\da-f]*(?:\.\d+)*(?:e[+-]?\d+)?[a-z]{0,3}\b)\b(?!\.\w)/i,
        lookbehind: !0
      },
      operator: /[;:?<=>~/@!$%&+\-|^(){}*#]/,
      punctuation: /[\[\].,]/
    };
  }
  return log_1;
}
var lolcode_1, hasRequiredLolcode;
function requireLolcode() {
  if (hasRequiredLolcode) return lolcode_1;
  hasRequiredLolcode = 1, lolcode_1 = e, e.displayName = "lolcode", e.aliases = [];
  function e(t) {
    t.languages.lolcode = {
      comment: [/\bOBTW\s[\s\S]*?\sTLDR\b/, /\bBTW.+/],
      string: {
        pattern: /"(?::.|[^":])*"/,
        inside: {
          variable: /:\{[^}]+\}/,
          symbol: [/:\([a-f\d]+\)/i, /:\[[^\]]+\]/, /:[)>o":]/]
        },
        greedy: !0
      },
      number: /(?:\B-)?(?:\b\d+(?:\.\d*)?|\B\.\d+)/,
      symbol: {
        pattern: /(^|\s)(?:A )?(?:BUKKIT|NOOB|NUMBAR|NUMBR|TROOF|YARN)(?=\s|,|$)/,
        lookbehind: !0,
        inside: {
          keyword: /A(?=\s)/
        }
      },
      label: {
        pattern: /((?:^|\s)(?:IM IN YR|IM OUTTA YR) )[a-zA-Z]\w*/,
        lookbehind: !0,
        alias: "string"
      },
      function: {
        pattern: /((?:^|\s)(?:HOW IZ I|I IZ|IZ) )[a-zA-Z]\w*/,
        lookbehind: !0
      },
      keyword: [{
        pattern: /(^|\s)(?:AN|FOUND YR|GIMMEH|GTFO|HAI|HAS A|HOW IZ I|I HAS A|I IZ|IF U SAY SO|IM IN YR|IM OUTTA YR|IS NOW(?: A)?|ITZ(?: A)?|IZ|KTHX|KTHXBYE|LIEK(?: A)?|MAEK|MEBBE|MKAY|NERFIN|NO WAI|O HAI IM|O RLY\?|OIC|OMG|OMGWTF|R|SMOOSH|SRS|TIL|UPPIN|VISIBLE|WILE|WTF\?|YA RLY|YR)(?=\s|,|$)/,
        lookbehind: !0
      }, /'Z(?=\s|,|$)/],
      boolean: {
        pattern: /(^|\s)(?:FAIL|WIN)(?=\s|,|$)/,
        lookbehind: !0
      },
      variable: {
        pattern: /(^|\s)IT(?=\s|,|$)/,
        lookbehind: !0
      },
      operator: {
        pattern: /(^|\s)(?:NOT|BOTH SAEM|DIFFRINT|(?:ALL|ANY|BIGGR|BOTH|DIFF|EITHER|MOD|PRODUKT|QUOSHUNT|SMALLR|SUM|WON) OF)(?=\s|,|$)/,
        lookbehind: !0
      },
      punctuation: /\.{3}||,|!/
    };
  }
  return lolcode_1;
}
var magma_1, hasRequiredMagma;
function requireMagma() {
  if (hasRequiredMagma) return magma_1;
  hasRequiredMagma = 1, magma_1 = e, e.displayName = "magma", e.aliases = [];
  function e(t) {
    t.languages.magma = {
      output: {
        pattern: /^(>.*(?:\r(?:\n|(?!\n))|\n))(?!>)(?:.+|(?:\r(?:\n|(?!\n))|\n)(?!>).*)(?:(?:\r(?:\n|(?!\n))|\n)(?!>).*)*/m,
        lookbehind: !0,
        greedy: !0
      },
      comment: {
        pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
        greedy: !0
      },
      string: {
        pattern: /(^|[^\\"])"(?:[^\r\n\\"]|\\.)*"/,
        lookbehind: !0,
        greedy: !0
      },
      // http://magma.maths.usyd.edu.au/magma/handbook/text/82
      keyword: /\b(?:_|adj|and|assert|assert2|assert3|assigned|break|by|case|cat|catch|clear|cmpeq|cmpne|continue|declare|default|delete|diff|div|do|elif|else|end|eq|error|eval|exists|exit|for|forall|forward|fprintf|freeze|function|ge|gt|if|iload|import|in|intrinsic|is|join|le|load|local|lt|meet|mod|ne|not|notadj|notin|notsubset|or|print|printf|procedure|quit|random|read|readi|repeat|require|requirege|requirerange|restore|return|save|sdiff|select|subset|then|time|to|try|until|vprint|vprintf|vtime|when|where|while|xor)\b/,
      boolean: /\b(?:false|true)\b/,
      generator: {
        pattern: /\b[a-z_]\w*(?=\s*<)/i,
        alias: "class-name"
      },
      function: /\b[a-z_]\w*(?=\s*\()/i,
      number: {
        pattern: /(^|[^\w.]|\.\.)(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?:_[a-z]?)?(?=$|[^\w.]|\.\.)/,
        lookbehind: !0
      },
      operator: /->|[-+*/^~!|#=]|:=|\.\./,
      punctuation: /[()[\]{}<>,;.:]/
    };
  }
  return magma_1;
}
var makefile_1, hasRequiredMakefile;
function requireMakefile() {
  if (hasRequiredMakefile) return makefile_1;
  hasRequiredMakefile = 1, makefile_1 = e, e.displayName = "makefile", e.aliases = [];
  function e(t) {
    t.languages.makefile = {
      comment: {
        pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
        lookbehind: !0
      },
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      "builtin-target": {
        pattern: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
        alias: "builtin"
      },
      target: {
        pattern: /^(?:[^:=\s]|[ \t]+(?![\s:]))+(?=\s*:(?!=))/m,
        alias: "symbol",
        inside: {
          variable: /\$+(?:(?!\$)[^(){}:#=\s]+|(?=[({]))/
        }
      },
      variable: /\$+(?:(?!\$)[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
      // Directives
      keyword: /-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
      function: {
        pattern: /(\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \t])/,
        lookbehind: !0
      },
      operator: /(?:::|[?:+!])?=|[|@]/,
      punctuation: /[:;(){}]/
    };
  }
  return makefile_1;
}
var markdown_1, hasRequiredMarkdown;
function requireMarkdown() {
  if (hasRequiredMarkdown) return markdown_1;
  hasRequiredMarkdown = 1, markdown_1 = e, e.displayName = "markdown", e.aliases = ["md"];
  function e(t) {
    (function(r) {
      var a = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
      function o(A) {
        return A = A.replace(/<inner>/g, function() {
          return a;
        }), RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + A + ")");
      }
      var u = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source, c = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
        return u;
      }), d = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
      r.languages.markdown = r.languages.extend("markup", {}), r.languages.insertBefore("markdown", "prolog", {
        "front-matter-block": {
          pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
          lookbehind: !0,
          greedy: !0,
          inside: {
            punctuation: /^---|---$/,
            "front-matter": {
              pattern: /\S+(?:\s+\S+)*/,
              alias: ["yaml", "language-yaml"],
              inside: r.languages.yaml
            }
          }
        },
        blockquote: {
          // > ...
          pattern: /^>(?:[\t ]*>)*/m,
          alias: "punctuation"
        },
        table: {
          pattern: RegExp("^" + c + d + "(?:" + c + ")*", "m"),
          inside: {
            "table-data-rows": {
              pattern: RegExp("^(" + c + d + ")(?:" + c + ")*$"),
              lookbehind: !0,
              inside: {
                "table-data": {
                  pattern: RegExp(u),
                  inside: r.languages.markdown
                },
                punctuation: /\|/
              }
            },
            "table-line": {
              pattern: RegExp("^(" + c + ")" + d + "$"),
              lookbehind: !0,
              inside: {
                punctuation: /\||:?-{3,}:?/
              }
            },
            "table-header-row": {
              pattern: RegExp("^" + c + "$"),
              inside: {
                "table-header": {
                  pattern: RegExp(u),
                  alias: "important",
                  inside: r.languages.markdown
                },
                punctuation: /\|/
              }
            }
          }
        },
        code: [{
          // Prefixed by 4 spaces or 1 tab and preceded by an empty line
          pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
          lookbehind: !0,
          alias: "keyword"
        }, {
          // ```optional language
          // code block
          // ```
          pattern: /^```[\s\S]*?^```$/m,
          greedy: !0,
          inside: {
            "code-block": {
              pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
              lookbehind: !0
            },
            "code-language": {
              pattern: /^(```).+/,
              lookbehind: !0
            },
            punctuation: /```/
          }
        }],
        title: [{
          // title 1
          // =======
          // title 2
          // -------
          pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
          alias: "important",
          inside: {
            punctuation: /==+$|--+$/
          }
        }, {
          // # title 1
          // ###### title 6
          pattern: /(^\s*)#.+/m,
          lookbehind: !0,
          alias: "important",
          inside: {
            punctuation: /^#+|#+$/
          }
        }],
        hr: {
          // ***
          // ---
          // * * *
          // -----------
          pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
          lookbehind: !0,
          alias: "punctuation"
        },
        list: {
          // * item
          // + item
          // - item
          // 1. item
          pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
          lookbehind: !0,
          alias: "punctuation"
        },
        "url-reference": {
          // [id]: http://example.com "Optional title"
          // [id]: http://example.com 'Optional title'
          // [id]: http://example.com (Optional title)
          // [id]: <http://example.com> "Optional title"
          pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
          inside: {
            variable: {
              pattern: /^(!?\[)[^\]]+/,
              lookbehind: !0
            },
            string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
            punctuation: /^[\[\]!:]|[<>]/
          },
          alias: "url"
        },
        bold: {
          // **strong**
          // __strong__
          // allow one nested instance of italic text using the same delimiter
          pattern: o(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
          lookbehind: !0,
          greedy: !0,
          inside: {
            content: {
              pattern: /(^..)[\s\S]+(?=..$)/,
              lookbehind: !0,
              inside: {}
              // see below
            },
            punctuation: /\*\*|__/
          }
        },
        italic: {
          // *em*
          // _em_
          // allow one nested instance of bold text using the same delimiter
          pattern: o(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
          lookbehind: !0,
          greedy: !0,
          inside: {
            content: {
              pattern: /(^.)[\s\S]+(?=.$)/,
              lookbehind: !0,
              inside: {}
              // see below
            },
            punctuation: /[*_]/
          }
        },
        strike: {
          // ~~strike through~~
          // ~strike~
          // eslint-disable-next-line regexp/strict
          pattern: o(/(~~?)(?:(?!~)<inner>)+\2/.source),
          lookbehind: !0,
          greedy: !0,
          inside: {
            content: {
              pattern: /(^~~?)[\s\S]+(?=\1$)/,
              lookbehind: !0,
              inside: {}
              // see below
            },
            punctuation: /~~?/
          }
        },
        "code-snippet": {
          // `code`
          // ``code``
          pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
          lookbehind: !0,
          greedy: !0,
          alias: ["code", "keyword"]
        },
        url: {
          // [example](http://example.com "Optional title")
          // [example][id]
          // [example] [id]
          pattern: o(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
          lookbehind: !0,
          greedy: !0,
          inside: {
            operator: /^!/,
            content: {
              pattern: /(^\[)[^\]]+(?=\])/,
              lookbehind: !0,
              inside: {}
              // see below
            },
            variable: {
              pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
              lookbehind: !0
            },
            url: {
              pattern: /(^\]\()[^\s)]+/,
              lookbehind: !0
            },
            string: {
              pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
              lookbehind: !0
            }
          }
        }
      }), ["url", "bold", "italic", "strike"].forEach(function(A) {
        ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(E) {
          A !== E && (r.languages.markdown[A].inside.content.inside[E] = r.languages.markdown[E]);
        });
      }), r.hooks.add("after-tokenize", function(A) {
        if (A.language !== "markdown" && A.language !== "md")
          return;
        function E(v) {
          if (!(!v || typeof v == "string"))
            for (var C = 0, R = v.length; C < R; C++) {
              var I = v[C];
              if (I.type !== "code") {
                E(I.content);
                continue;
              }
              var w = I.content[1], N = I.content[3];
              if (w && N && w.type === "code-language" && N.type === "code-block" && typeof w.content == "string") {
                var F = w.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
                F = (/[a-z][\w-]*/i.exec(F) || [""])[0].toLowerCase();
                var M = "language-" + F;
                N.alias ? typeof N.alias == "string" ? N.alias = [N.alias, M] : N.alias.push(M) : N.alias = [M];
              }
            }
        }
        E(A.tokens);
      }), r.hooks.add("wrap", function(A) {
        if (A.type === "code-block") {
          for (var E = "", v = 0, C = A.classes.length; v < C; v++) {
            var R = A.classes[v], I = /language-(.+)/.exec(R);
            if (I) {
              E = I[1];
              break;
            }
          }
          var w = r.languages[E];
          if (w)
            A.content = r.highlight(y(A.content.value), w, E);
          else if (E && E !== "none" && r.plugins.autoloader) {
            var N = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
            A.attributes.id = N, r.plugins.autoloader.loadLanguages(E, function() {
              var F = document.getElementById(N);
              F && (F.innerHTML = r.highlight(F.textContent, r.languages[E], E));
            });
          }
        }
      });
      var g = RegExp(r.languages.markup.tag.pattern.source, "gi"), b = {
        amp: "&",
        lt: "<",
        gt: ">",
        quot: '"'
      }, _ = String.fromCodePoint || String.fromCharCode;
      function y(A) {
        var E = A.replace(g, "");
        return E = E.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(v, C) {
          if (C = C.toLowerCase(), C[0] === "#") {
            var R;
            return C[1] === "x" ? R = parseInt(C.slice(2), 16) : R = Number(C.slice(1)), _(R);
          } else {
            var I = b[C];
            return I || v;
          }
        }), E;
      }
      r.languages.md = r.languages.markdown;
    })(t);
  }
  return markdown_1;
}
var matlab_1, hasRequiredMatlab;
function requireMatlab() {
  if (hasRequiredMatlab) return matlab_1;
  hasRequiredMatlab = 1, matlab_1 = e, e.displayName = "matlab", e.aliases = [];
  function e(t) {
    t.languages.matlab = {
      comment: [/%\{[\s\S]*?\}%/, /%.+/],
      string: {
        pattern: /\B'(?:''|[^'\r\n])*'/,
        greedy: !0
      },
      // FIXME We could handle imaginary numbers as a whole
      number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+)?(?:[ij])?|\b[ij]\b/,
      keyword: /\b(?:NaN|break|case|catch|continue|else|elseif|end|for|function|if|inf|otherwise|parfor|pause|pi|return|switch|try|while)\b/,
      function: /\b(?!\d)\w+(?=\s*\()/,
      operator: /\.?[*^\/\\']|[+\-:@]|[<>=~]=?|&&?|\|\|?/,
      punctuation: /\.{3}|[.,;\[\](){}!]/
    };
  }
  return matlab_1;
}
var maxscript_1, hasRequiredMaxscript;
function requireMaxscript() {
  if (hasRequiredMaxscript) return maxscript_1;
  hasRequiredMaxscript = 1, maxscript_1 = e, e.displayName = "maxscript", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = /\b(?:about|and|animate|as|at|attributes|by|case|catch|collect|continue|coordsys|do|else|exit|fn|for|from|function|global|if|in|local|macroscript|mapped|max|not|of|off|on|or|parameters|persistent|plugin|rcmenu|return|rollout|set|struct|then|throw|to|tool|try|undo|utility|when|where|while|with)\b/i;
      r.languages.maxscript = {
        comment: {
          pattern: /\/\*[\s\S]*?(?:\*\/|$)|--.*/,
          greedy: !0
        },
        string: {
          pattern: /(^|[^"\\@])(?:"(?:[^"\\]|\\[\s\S])*"|@"[^"]*")/,
          lookbehind: !0,
          greedy: !0
        },
        path: {
          pattern: /\$(?:[\w/\\.*?]|'[^']*')*/,
          greedy: !0,
          alias: "string"
        },
        "function-call": {
          pattern: RegExp("((?:" + // start of line
          (/^/.source + "|" + // operators and other language constructs
          /[;=<>+\-*/^({\[]/.source + "|" + // keywords as part of statements
          /\b(?:and|by|case|catch|collect|do|else|if|in|not|or|return|then|to|try|where|while|with)\b/.source) + ")[ 	]*)(?!" + a.source + ")" + /[a-z_]\w*\b/.source + "(?=[ 	]*(?:" + // variable
          ("(?!" + a.source + ")" + /[a-z_]/.source + "|" + // number
          /\d|-\.?\d/.source + "|" + // other expressions or literals
          /[({'"$@#?]/.source) + "))", "im"),
          lookbehind: !0,
          greedy: !0,
          alias: "function"
        },
        "function-definition": {
          pattern: /(\b(?:fn|function)\s+)\w+\b/i,
          lookbehind: !0,
          alias: "function"
        },
        argument: {
          pattern: /\b[a-z_]\w*(?=:)/i,
          alias: "attr-name"
        },
        keyword: a,
        boolean: /\b(?:false|true)\b/,
        time: {
          pattern: /(^|[^\w.])(?:(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eEdD][+-]\d+|[LP])?[msft])+|\d+:\d+(?:\.\d*)?)(?![\w.:])/,
          lookbehind: !0,
          alias: "number"
        },
        number: [{
          pattern: /(^|[^\w.])(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eEdD][+-]\d+|[LP])?|0x[a-fA-F0-9]+)(?![\w.:])/,
          lookbehind: !0
        }, /\b(?:e|pi)\b/],
        constant: /\b(?:dontcollect|ok|silentValue|undefined|unsupplied)\b/,
        color: {
          pattern: /\b(?:black|blue|brown|gray|green|orange|red|white|yellow)\b/i,
          alias: "constant"
        },
        operator: /[-+*/<>=!]=?|[&^?]|#(?!\()/,
        punctuation: /[()\[\]{}.:,;]|#(?=\()|\\$/m
      };
    })(t);
  }
  return maxscript_1;
}
var mel_1, hasRequiredMel;
function requireMel() {
  if (hasRequiredMel) return mel_1;
  hasRequiredMel = 1, mel_1 = e, e.displayName = "mel", e.aliases = [];
  function e(t) {
    t.languages.mel = {
      comment: /\/\/.*/,
      code: {
        pattern: /`(?:\\.|[^\\`\r\n])*`/,
        greedy: !0,
        alias: "italic",
        inside: {
          delimiter: {
            pattern: /^`|`$/,
            alias: "punctuation"
          }
          // See rest below
        }
      },
      string: {
        pattern: /"(?:\\.|[^\\"\r\n])*"/,
        greedy: !0
      },
      variable: /\$\w+/,
      number: /\b0x[\da-fA-F]+\b|\b\d+(?:\.\d*)?|\B\.\d+/,
      flag: {
        pattern: /-[^\d\W]\w*/,
        alias: "operator"
      },
      keyword: /\b(?:break|case|continue|default|do|else|float|for|global|if|in|int|matrix|proc|return|string|switch|vector|while)\b/,
      function: /\b\w+(?=\()|\b(?:CBG|HfAddAttractorToAS|HfAssignAS|HfBuildEqualMap|HfBuildFurFiles|HfBuildFurImages|HfCancelAFR|HfConnectASToHF|HfCreateAttractor|HfDeleteAS|HfEditAS|HfPerformCreateAS|HfRemoveAttractorFromAS|HfSelectAttached|HfSelectAttractors|HfUnAssignAS|Mayatomr|about|abs|addAttr|addAttributeEditorNodeHelp|addDynamic|addNewShelfTab|addPP|addPanelCategory|addPrefixToName|advanceToNextDrivenKey|affectedNet|affects|aimConstraint|air|alias|aliasAttr|align|alignCtx|alignCurve|alignSurface|allViewFit|ambientLight|angle|angleBetween|animCone|animCurveEditor|animDisplay|animView|annotate|appendStringArray|applicationName|applyAttrPreset|applyTake|arcLenDimContext|arcLengthDimension|arclen|arrayMapper|art3dPaintCtx|artAttrCtx|artAttrPaintVertexCtx|artAttrSkinPaintCtx|artAttrTool|artBuildPaintMenu|artFluidAttrCtx|artPuttyCtx|artSelectCtx|artSetPaintCtx|artUserPaintCtx|assignCommand|assignInputDevice|assignViewportFactories|attachCurve|attachDeviceAttr|attachSurface|attrColorSliderGrp|attrCompatibility|attrControlGrp|attrEnumOptionMenu|attrEnumOptionMenuGrp|attrFieldGrp|attrFieldSliderGrp|attrNavigationControlGrp|attrPresetEditWin|attributeExists|attributeInfo|attributeMenu|attributeQuery|autoKeyframe|autoPlace|bakeClip|bakeFluidShading|bakePartialHistory|bakeResults|bakeSimulation|basename|basenameEx|batchRender|bessel|bevel|bevelPlus|binMembership|bindSkin|blend2|blendShape|blendShapeEditor|blendShapePanel|blendTwoAttr|blindDataType|boneLattice|boundary|boxDollyCtx|boxZoomCtx|bufferCurve|buildBookmarkMenu|buildKeyframeMenu|button|buttonManip|cacheFile|cacheFileCombine|cacheFileMerge|cacheFileTrack|camera|cameraView|canCreateManip|canvas|capitalizeString|catch|catchQuiet|ceil|changeSubdivComponentDisplayLevel|changeSubdivRegion|channelBox|character|characterMap|characterOutlineEditor|characterize|chdir|checkBox|checkBoxGrp|checkDefaultRenderGlobals|choice|circle|circularFillet|clamp|clear|clearCache|clip|clipEditor|clipEditorCurrentTimeCtx|clipSchedule|clipSchedulerOutliner|clipTrimBefore|closeCurve|closeSurface|cluster|cmdFileOutput|cmdScrollFieldExecuter|cmdScrollFieldReporter|cmdShell|coarsenSubdivSelectionList|collision|color|colorAtPoint|colorEditor|colorIndex|colorIndexSliderGrp|colorSliderButtonGrp|colorSliderGrp|columnLayout|commandEcho|commandLine|commandPort|compactHairSystem|componentEditor|compositingInterop|computePolysetVolume|condition|cone|confirmDialog|connectAttr|connectControl|connectDynamic|connectJoint|connectionInfo|constrain|constrainValue|constructionHistory|container|containsMultibyte|contextInfo|control|convertFromOldLayers|convertIffToPsd|convertLightmap|convertSolidTx|convertTessellation|convertUnit|copyArray|copyFlexor|copyKey|copySkinWeights|cos|cpButton|cpCache|cpClothSet|cpCollision|cpConstraint|cpConvClothToMesh|cpForces|cpGetSolverAttr|cpPanel|cpProperty|cpRigidCollisionFilter|cpSeam|cpSetEdit|cpSetSolverAttr|cpSolver|cpSolverTypes|cpTool|cpUpdateClothUVs|createDisplayLayer|createDrawCtx|createEditor|createLayeredPsdFile|createMotionField|createNewShelf|createNode|createRenderLayer|createSubdivRegion|cross|crossProduct|ctxAbort|ctxCompletion|ctxEditMode|ctxTraverse|currentCtx|currentTime|currentTimeCtx|currentUnit|curve|curveAddPtCtx|curveCVCtx|curveEPCtx|curveEditorCtx|curveIntersect|curveMoveEPCtx|curveOnSurface|curveSketchCtx|cutKey|cycleCheck|cylinder|dagPose|date|defaultLightListCheckBox|defaultNavigation|defineDataServer|defineVirtualDevice|deformer|deg_to_rad|delete|deleteAttr|deleteShadingGroupsAndMaterials|deleteShelfTab|deleteUI|deleteUnusedBrushes|delrandstr|detachCurve|detachDeviceAttr|detachSurface|deviceEditor|devicePanel|dgInfo|dgdirty|dgeval|dgtimer|dimWhen|directKeyCtx|directionalLight|dirmap|dirname|disable|disconnectAttr|disconnectJoint|diskCache|displacementToPoly|displayAffected|displayColor|displayCull|displayLevelOfDetail|displayPref|displayRGBColor|displaySmoothness|displayStats|displayString|displaySurface|distanceDimContext|distanceDimension|doBlur|dolly|dollyCtx|dopeSheetEditor|dot|dotProduct|doubleProfileBirailSurface|drag|dragAttrContext|draggerContext|dropoffLocator|duplicate|duplicateCurve|duplicateSurface|dynCache|dynControl|dynExport|dynExpression|dynGlobals|dynPaintEditor|dynParticleCtx|dynPref|dynRelEdPanel|dynRelEditor|dynamicLoad|editAttrLimits|editDisplayLayerGlobals|editDisplayLayerMembers|editRenderLayerAdjustment|editRenderLayerGlobals|editRenderLayerMembers|editor|editorTemplate|effector|emit|emitter|enableDevice|encodeString|endString|endsWith|env|equivalent|equivalentTol|erf|error|eval|evalDeferred|evalEcho|event|exactWorldBoundingBox|exclusiveLightCheckBox|exec|executeForEachObject|exists|exp|expression|expressionEditorListen|extendCurve|extendSurface|extrude|fcheck|fclose|feof|fflush|fgetline|fgetword|file|fileBrowserDialog|fileDialog|fileExtension|fileInfo|filetest|filletCurve|filter|filterCurve|filterExpand|filterStudioImport|findAllIntersections|findAnimCurves|findKeyframe|findMenuItem|findRelatedSkinCluster|finder|firstParentOf|fitBspline|flexor|floatEq|floatField|floatFieldGrp|floatScrollBar|floatSlider|floatSlider2|floatSliderButtonGrp|floatSliderGrp|floor|flow|fluidCacheInfo|fluidEmitter|fluidVoxelInfo|flushUndo|fmod|fontDialog|fopen|formLayout|format|fprint|frameLayout|fread|freeFormFillet|frewind|fromNativePath|fwrite|gamma|gauss|geometryConstraint|getApplicationVersionAsFloat|getAttr|getClassification|getDefaultBrush|getFileList|getFluidAttr|getInputDeviceRange|getMayaPanelTypes|getModifiers|getPanel|getParticleAttr|getPluginResource|getenv|getpid|glRender|glRenderEditor|globalStitch|gmatch|goal|gotoBindPose|grabColor|gradientControl|gradientControlNoAttr|graphDollyCtx|graphSelectContext|graphTrackCtx|gravity|grid|gridLayout|group|groupObjectsByName|hardenPointCurve|hardware|hardwareRenderPanel|headsUpDisplay|headsUpMessage|help|helpLine|hermite|hide|hilite|hitTest|hotBox|hotkey|hotkeyCheck|hsv_to_rgb|hudButton|hudSlider|hudSliderButton|hwReflectionMap|hwRender|hwRenderLoad|hyperGraph|hyperPanel|hyperShade|hypot|iconTextButton|iconTextCheckBox|iconTextRadioButton|iconTextRadioCollection|iconTextScrollList|iconTextStaticLabel|ikHandle|ikHandleCtx|ikHandleDisplayScale|ikSolver|ikSplineHandleCtx|ikSystem|ikSystemInfo|ikfkDisplayMethod|illustratorCurves|image|imfPlugins|inheritTransform|insertJoint|insertJointCtx|insertKeyCtx|insertKnotCurve|insertKnotSurface|instance|instanceable|instancer|intField|intFieldGrp|intScrollBar|intSlider|intSliderGrp|interToUI|internalVar|intersect|iprEngine|isAnimCurve|isConnected|isDirty|isParentOf|isSameObject|isTrue|isValidObjectName|isValidString|isValidUiName|isolateSelect|itemFilter|itemFilterAttr|itemFilterRender|itemFilterType|joint|jointCluster|jointCtx|jointDisplayScale|jointLattice|keyTangent|keyframe|keyframeOutliner|keyframeRegionCurrentTimeCtx|keyframeRegionDirectKeyCtx|keyframeRegionDollyCtx|keyframeRegionInsertKeyCtx|keyframeRegionMoveKeyCtx|keyframeRegionScaleKeyCtx|keyframeRegionSelectKeyCtx|keyframeRegionSetKeyCtx|keyframeRegionTrackCtx|keyframeStats|lassoContext|lattice|latticeDeformKeyCtx|launch|launchImageEditor|layerButton|layeredShaderPort|layeredTexturePort|layout|layoutDialog|lightList|lightListEditor|lightListPanel|lightlink|lineIntersection|linearPrecision|linstep|listAnimatable|listAttr|listCameras|listConnections|listDeviceAttachments|listHistory|listInputDeviceAxes|listInputDeviceButtons|listInputDevices|listMenuAnnotation|listNodeTypes|listPanelCategories|listRelatives|listSets|listTransforms|listUnselected|listerEditor|loadFluid|loadNewShelf|loadPlugin|loadPluginLanguageResources|loadPrefObjects|localizedPanelLabel|lockNode|loft|log|longNameOf|lookThru|ls|lsThroughFilter|lsType|lsUI|mag|makeIdentity|makeLive|makePaintable|makeRoll|makeSingleSurface|makeTubeOn|makebot|manipMoveContext|manipMoveLimitsCtx|manipOptions|manipRotateContext|manipRotateLimitsCtx|manipScaleContext|manipScaleLimitsCtx|marker|match|max|memory|menu|menuBarLayout|menuEditor|menuItem|menuItemToShelf|menuSet|menuSetPref|messageLine|min|minimizeApp|mirrorJoint|modelCurrentTimeCtx|modelEditor|modelPanel|mouse|movIn|movOut|move|moveIKtoFK|moveKeyCtx|moveVertexAlongDirection|multiProfileBirailSurface|mute|nParticle|nameCommand|nameField|namespace|namespaceInfo|newPanelItems|newton|nodeCast|nodeIconButton|nodeOutliner|nodePreset|nodeType|noise|nonLinear|normalConstraint|normalize|nurbsBoolean|nurbsCopyUVSet|nurbsCube|nurbsEditUV|nurbsPlane|nurbsSelect|nurbsSquare|nurbsToPoly|nurbsToPolygonsPref|nurbsToSubdiv|nurbsToSubdivPref|nurbsUVSet|nurbsViewDirectionVector|objExists|objectCenter|objectLayer|objectType|objectTypeUI|obsoleteProc|oceanNurbsPreviewPlane|offsetCurve|offsetCurveOnSurface|offsetSurface|openGLExtension|openMayaPref|optionMenu|optionMenuGrp|optionVar|orbit|orbitCtx|orientConstraint|outlinerEditor|outlinerPanel|overrideModifier|paintEffectsDisplay|pairBlend|palettePort|paneLayout|panel|panelConfiguration|panelHistory|paramDimContext|paramDimension|paramLocator|parent|parentConstraint|particle|particleExists|particleInstancer|particleRenderInfo|partition|pasteKey|pathAnimation|pause|pclose|percent|performanceOptions|pfxstrokes|pickWalk|picture|pixelMove|planarSrf|plane|play|playbackOptions|playblast|plugAttr|plugNode|pluginInfo|pluginResourceUtil|pointConstraint|pointCurveConstraint|pointLight|pointMatrixMult|pointOnCurve|pointOnSurface|pointPosition|poleVectorConstraint|polyAppend|polyAppendFacetCtx|polyAppendVertex|polyAutoProjection|polyAverageNormal|polyAverageVertex|polyBevel|polyBlendColor|polyBlindData|polyBoolOp|polyBridgeEdge|polyCacheMonitor|polyCheck|polyChipOff|polyClipboard|polyCloseBorder|polyCollapseEdge|polyCollapseFacet|polyColorBlindData|polyColorDel|polyColorPerVertex|polyColorSet|polyCompare|polyCone|polyCopyUV|polyCrease|polyCreaseCtx|polyCreateFacet|polyCreateFacetCtx|polyCube|polyCut|polyCutCtx|polyCylinder|polyCylindricalProjection|polyDelEdge|polyDelFacet|polyDelVertex|polyDuplicateAndConnect|polyDuplicateEdge|polyEditUV|polyEditUVShell|polyEvaluate|polyExtrudeEdge|polyExtrudeFacet|polyExtrudeVertex|polyFlipEdge|polyFlipUV|polyForceUV|polyGeoSampler|polyHelix|polyInfo|polyInstallAction|polyLayoutUV|polyListComponentConversion|polyMapCut|polyMapDel|polyMapSew|polyMapSewMove|polyMergeEdge|polyMergeEdgeCtx|polyMergeFacet|polyMergeFacetCtx|polyMergeUV|polyMergeVertex|polyMirrorFace|polyMoveEdge|polyMoveFacet|polyMoveFacetUV|polyMoveUV|polyMoveVertex|polyNormal|polyNormalPerVertex|polyNormalizeUV|polyOptUvs|polyOptions|polyOutput|polyPipe|polyPlanarProjection|polyPlane|polyPlatonicSolid|polyPoke|polyPrimitive|polyPrism|polyProjection|polyPyramid|polyQuad|polyQueryBlindData|polyReduce|polySelect|polySelectConstraint|polySelectConstraintMonitor|polySelectCtx|polySelectEditCtx|polySeparate|polySetToFaceNormal|polySewEdge|polyShortestPathCtx|polySmooth|polySoftEdge|polySphere|polySphericalProjection|polySplit|polySplitCtx|polySplitEdge|polySplitRing|polySplitVertex|polyStraightenUVBorder|polySubdivideEdge|polySubdivideFacet|polyToSubdiv|polyTorus|polyTransfer|polyTriangulate|polyUVSet|polyUnite|polyWedgeFace|popen|popupMenu|pose|pow|preloadRefEd|print|progressBar|progressWindow|projFileViewer|projectCurve|projectTangent|projectionContext|projectionManip|promptDialog|propModCtx|propMove|psdChannelOutliner|psdEditTextureFile|psdExport|psdTextureFile|putenv|pwd|python|querySubdiv|quit|rad_to_deg|radial|radioButton|radioButtonGrp|radioCollection|radioMenuItemCollection|rampColorPort|rand|randomizeFollicles|randstate|rangeControl|readTake|rebuildCurve|rebuildSurface|recordAttr|recordDevice|redo|reference|referenceEdit|referenceQuery|refineSubdivSelectionList|refresh|refreshAE|registerPluginResource|rehash|reloadImage|removeJoint|removeMultiInstance|removePanelCategory|rename|renameAttr|renameSelectionList|renameUI|render|renderGlobalsNode|renderInfo|renderLayerButton|renderLayerParent|renderLayerPostProcess|renderLayerUnparent|renderManip|renderPartition|renderQualityNode|renderSettings|renderThumbnailUpdate|renderWindowEditor|renderWindowSelectContext|renderer|reorder|reorderDeformers|requires|reroot|resampleFluid|resetAE|resetPfxToPolyCamera|resetTool|resolutionNode|retarget|reverseCurve|reverseSurface|revolve|rgb_to_hsv|rigidBody|rigidSolver|roll|rollCtx|rootOf|rot|rotate|rotationInterpolation|roundConstantRadius|rowColumnLayout|rowLayout|runTimeCommand|runup|sampleImage|saveAllShelves|saveAttrPreset|saveFluid|saveImage|saveInitialState|saveMenu|savePrefObjects|savePrefs|saveShelf|saveToolSettings|scale|scaleBrushBrightness|scaleComponents|scaleConstraint|scaleKey|scaleKeyCtx|sceneEditor|sceneUIReplacement|scmh|scriptCtx|scriptEditorInfo|scriptJob|scriptNode|scriptTable|scriptToShelf|scriptedPanel|scriptedPanelType|scrollField|scrollLayout|sculpt|searchPathArray|seed|selLoadSettings|select|selectContext|selectCurveCV|selectKey|selectKeyCtx|selectKeyframeRegionCtx|selectMode|selectPref|selectPriority|selectType|selectedNodes|selectionConnection|separator|setAttr|setAttrEnumResource|setAttrMapping|setAttrNiceNameResource|setConstraintRestPosition|setDefaultShadingGroup|setDrivenKeyframe|setDynamic|setEditCtx|setEditor|setFluidAttr|setFocus|setInfinity|setInputDeviceMapping|setKeyCtx|setKeyPath|setKeyframe|setKeyframeBlendshapeTargetWts|setMenuMode|setNodeNiceNameResource|setNodeTypeFlag|setParent|setParticleAttr|setPfxToPolyCamera|setPluginResource|setProject|setStampDensity|setStartupMessage|setState|setToolTo|setUITemplate|setXformManip|sets|shadingConnection|shadingGeometryRelCtx|shadingLightRelCtx|shadingNetworkCompare|shadingNode|shapeCompare|shelfButton|shelfLayout|shelfTabLayout|shellField|shortNameOf|showHelp|showHidden|showManipCtx|showSelectionInTitle|showShadingGroupAttrEditor|showWindow|sign|simplify|sin|singleProfileBirailSurface|size|sizeBytes|skinCluster|skinPercent|smoothCurve|smoothTangentSurface|smoothstep|snap2to2|snapKey|snapMode|snapTogetherCtx|snapshot|soft|softMod|softModCtx|sort|sound|soundControl|source|spaceLocator|sphere|sphrand|spotLight|spotLightPreviewPort|spreadSheetEditor|spring|sqrt|squareSurface|srtContext|stackTrace|startString|startsWith|stitchAndExplodeShell|stitchSurface|stitchSurfacePoints|strcmp|stringArrayCatenate|stringArrayContains|stringArrayCount|stringArrayInsertAtIndex|stringArrayIntersector|stringArrayRemove|stringArrayRemoveAtIndex|stringArrayRemoveDuplicates|stringArrayRemoveExact|stringArrayToString|stringToStringArray|strip|stripPrefixFromName|stroke|subdAutoProjection|subdCleanTopology|subdCollapse|subdDuplicateAndConnect|subdEditUV|subdListComponentConversion|subdMapCut|subdMapSewMove|subdMatchTopology|subdMirror|subdToBlind|subdToPoly|subdTransferUVsToCache|subdiv|subdivCrease|subdivDisplaySmoothness|substitute|substituteAllString|substituteGeometry|substring|surface|surfaceSampler|surfaceShaderList|swatchDisplayPort|switchTable|symbolButton|symbolCheckBox|sysFile|system|tabLayout|tan|tangentConstraint|texLatticeDeformContext|texManipContext|texMoveContext|texMoveUVShellContext|texRotateContext|texScaleContext|texSelectContext|texSelectShortestPathCtx|texSmudgeUVContext|texWinToolCtx|text|textCurves|textField|textFieldButtonGrp|textFieldGrp|textManip|textScrollList|textToShelf|textureDisplacePlane|textureHairColor|texturePlacementContext|textureWindow|threadCount|threePointArcCtx|timeControl|timePort|timerX|toNativePath|toggle|toggleAxis|toggleWindowVisibility|tokenize|tokenizeList|tolerance|tolower|toolButton|toolCollection|toolDropped|toolHasOptions|toolPropertyWindow|torus|toupper|trace|track|trackCtx|transferAttributes|transformCompare|transformLimits|translator|trim|trunc|truncateFluidCache|truncateHairCache|tumble|tumbleCtx|turbulence|twoPointArcCtx|uiRes|uiTemplate|unassignInputDevice|undo|undoInfo|ungroup|uniform|unit|unloadPlugin|untangleUV|untitledFileName|untrim|upAxis|updateAE|userCtx|uvLink|uvSnapshot|validateShelfName|vectorize|view2dToolCtx|viewCamera|viewClipPlane|viewFit|viewHeadOn|viewLookAt|viewManip|viewPlace|viewSet|visor|volumeAxis|vortex|waitCursor|warning|webBrowser|webBrowserPrefs|whatIs|window|windowPref|wire|wireContext|workspace|wrinkle|wrinkleContext|writeTake|xbmLangPathList|xform)\b/,
      operator: [/\+[+=]?|-[-=]?|&&|\|\||[<>]=|[*\/!=]=?|[%^]/, {
        // We don't want to match <<
        pattern: /(^|[^<])<(?!<)/,
        lookbehind: !0
      }, {
        // We don't want to match >>
        pattern: /(^|[^>])>(?!>)/,
        lookbehind: !0
      }],
      punctuation: /<<|>>|[.,:;?\[\](){}]/
    }, t.languages.mel.code.inside.rest = t.languages.mel;
  }
  return mel_1;
}
var mermaid_1, hasRequiredMermaid;
function requireMermaid() {
  if (hasRequiredMermaid) return mermaid_1;
  hasRequiredMermaid = 1, mermaid_1 = e, e.displayName = "mermaid", e.aliases = [];
  function e(t) {
    t.languages.mermaid = {
      comment: {
        pattern: /%%.*/,
        greedy: !0
      },
      style: {
        pattern: /^([ \t]*(?:classDef|linkStyle|style)[ \t]+[\w$-]+[ \t]+)\w.*[^\s;]/m,
        lookbehind: !0,
        inside: {
          property: /\b\w[\w-]*(?=[ \t]*:)/,
          operator: /:/,
          punctuation: /,/
        }
      },
      "inter-arrow-label": {
        pattern: /([^<>ox.=-])(?:-[-.]|==)(?![<>ox.=-])[ \t]*(?:"[^"\r\n]*"|[^\s".=-](?:[^\r\n.=-]*[^\s.=-])?)[ \t]*(?:\.+->?|--+[->]|==+[=>])(?![<>ox.=-])/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          arrow: {
            pattern: /(?:\.+->?|--+[->]|==+[=>])$/,
            alias: "operator"
          },
          label: {
            pattern: /^([\s\S]{2}[ \t]*)\S(?:[\s\S]*\S)?/,
            lookbehind: !0,
            alias: "property"
          },
          "arrow-head": {
            pattern: /^\S+/,
            alias: ["arrow", "operator"]
          }
        }
      },
      arrow: [
        // This might look complex but it really isn't.
        // There are many possible arrows (see tests) and it's impossible to fit all of them into one pattern. The
        // problem is that we only have one lookbehind per pattern. However, we cannot disallow too many arrow
        // characters in the one lookbehind because that would create too many false negatives. So we have to split the
        // arrows into different patterns.
        {
          // ER diagram
          pattern: /(^|[^{}|o.-])[|}][|o](?:--|\.\.)[|o][|{](?![{}|o.-])/,
          lookbehind: !0,
          alias: "operator"
        },
        {
          // flow chart
          // (?:==+|--+|-\.*-)
          pattern: /(^|[^<>ox.=-])(?:[<ox](?:==+|--+|-\.*-)[>ox]?|(?:==+|--+|-\.*-)[>ox]|===+|---+|-\.+-)(?![<>ox.=-])/,
          lookbehind: !0,
          alias: "operator"
        },
        {
          // sequence diagram
          pattern: /(^|[^<>()x-])(?:--?(?:>>|[x>)])(?![<>()x])|(?:<<|[x<(])--?(?!-))/,
          lookbehind: !0,
          alias: "operator"
        },
        {
          // class diagram
          pattern: /(^|[^<>|*o.-])(?:[*o]--|--[*o]|<\|?(?:--|\.\.)|(?:--|\.\.)\|?>|--|\.\.)(?![<>|*o.-])/,
          lookbehind: !0,
          alias: "operator"
        }
      ],
      label: {
        pattern: /(^|[^|<])\|(?:[^\r\n"|]|"[^"\r\n]*")+\|/,
        lookbehind: !0,
        greedy: !0,
        alias: "property"
      },
      text: {
        pattern: /(?:[(\[{]+|\b>)(?:[^\r\n"()\[\]{}]|"[^"\r\n]*")+(?:[)\]}]+|>)/,
        alias: "string"
      },
      string: {
        pattern: /"[^"\r\n]*"/,
        greedy: !0
      },
      annotation: {
        pattern: /<<(?:abstract|choice|enumeration|fork|interface|join|service)>>|\[\[(?:choice|fork|join)\]\]/i,
        alias: "important"
      },
      keyword: [
        // This language has both case-sensitive and case-insensitive keywords
        {
          pattern: /(^[ \t]*)(?:action|callback|class|classDef|classDiagram|click|direction|erDiagram|flowchart|gantt|gitGraph|graph|journey|link|linkStyle|pie|requirementDiagram|sequenceDiagram|stateDiagram|stateDiagram-v2|style|subgraph)(?![\w$-])/m,
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^[ \t]*)(?:activate|alt|and|as|autonumber|deactivate|else|end(?:[ \t]+note)?|loop|opt|par|participant|rect|state|note[ \t]+(?:over|(?:left|right)[ \t]+of))(?![\w$-])/im,
          lookbehind: !0,
          greedy: !0
        }
      ],
      entity: /#[a-z0-9]+;/,
      operator: {
        pattern: /(\w[ \t]*)&(?=[ \t]*\w)|:::|:/,
        lookbehind: !0
      },
      punctuation: /[(){};]/
    };
  }
  return mermaid_1;
}
var mizar_1, hasRequiredMizar;
function requireMizar() {
  if (hasRequiredMizar) return mizar_1;
  hasRequiredMizar = 1, mizar_1 = e, e.displayName = "mizar", e.aliases = [];
  function e(t) {
    t.languages.mizar = {
      comment: /::.+/,
      keyword: /@proof\b|\b(?:according|aggregate|all|and|antonym|are|as|associativity|assume|asymmetry|attr|be|begin|being|by|canceled|case|cases|clusters?|coherence|commutativity|compatibility|connectedness|consider|consistency|constructors|contradiction|correctness|def|deffunc|define|definitions?|defpred|do|does|end|environ|equals|ex|exactly|existence|for|from|func|given|hence|hereby|holds|idempotence|identity|iff?|implies|involutiveness|irreflexivity|is|it|let|means|mode|non|not|notations?|now|of|or|otherwise|over|per|pred|prefix|projectivity|proof|provided|qua|reconsider|redefine|reduce|reducibility|reflexivity|registrations?|requirements|reserve|sch|schemes?|section|selector|set|sethood|st|struct|such|suppose|symmetry|synonym|take|that|the|then|theorems?|thesis|thus|to|transitivity|uniqueness|vocabular(?:ies|y)|when|where|with|wrt)\b/,
      parameter: {
        pattern: /\$(?:10|\d)/,
        alias: "variable"
      },
      variable: /\b\w+(?=:)/,
      number: /(?:\b|-)\d+\b/,
      operator: /\.\.\.|->|&|\.?=/,
      punctuation: /\(#|#\)|[,:;\[\](){}]/
    };
  }
  return mizar_1;
}
var mongodb_1, hasRequiredMongodb;
function requireMongodb() {
  if (hasRequiredMongodb) return mongodb_1;
  hasRequiredMongodb = 1, mongodb_1 = e, e.displayName = "mongodb", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = [
        // query and projection
        "$eq",
        "$gt",
        "$gte",
        "$in",
        "$lt",
        "$lte",
        "$ne",
        "$nin",
        "$and",
        "$not",
        "$nor",
        "$or",
        "$exists",
        "$type",
        "$expr",
        "$jsonSchema",
        "$mod",
        "$regex",
        "$text",
        "$where",
        "$geoIntersects",
        "$geoWithin",
        "$near",
        "$nearSphere",
        "$all",
        "$elemMatch",
        "$size",
        "$bitsAllClear",
        "$bitsAllSet",
        "$bitsAnyClear",
        "$bitsAnySet",
        "$comment",
        "$elemMatch",
        "$meta",
        "$slice",
        // update
        "$currentDate",
        "$inc",
        "$min",
        "$max",
        "$mul",
        "$rename",
        "$set",
        "$setOnInsert",
        "$unset",
        "$addToSet",
        "$pop",
        "$pull",
        "$push",
        "$pullAll",
        "$each",
        "$position",
        "$slice",
        "$sort",
        "$bit",
        // aggregation pipeline stages
        "$addFields",
        "$bucket",
        "$bucketAuto",
        "$collStats",
        "$count",
        "$currentOp",
        "$facet",
        "$geoNear",
        "$graphLookup",
        "$group",
        "$indexStats",
        "$limit",
        "$listLocalSessions",
        "$listSessions",
        "$lookup",
        "$match",
        "$merge",
        "$out",
        "$planCacheStats",
        "$project",
        "$redact",
        "$replaceRoot",
        "$replaceWith",
        "$sample",
        "$set",
        "$skip",
        "$sort",
        "$sortByCount",
        "$unionWith",
        "$unset",
        "$unwind",
        "$setWindowFields",
        // aggregation pipeline operators
        "$abs",
        "$accumulator",
        "$acos",
        "$acosh",
        "$add",
        "$addToSet",
        "$allElementsTrue",
        "$and",
        "$anyElementTrue",
        "$arrayElemAt",
        "$arrayToObject",
        "$asin",
        "$asinh",
        "$atan",
        "$atan2",
        "$atanh",
        "$avg",
        "$binarySize",
        "$bsonSize",
        "$ceil",
        "$cmp",
        "$concat",
        "$concatArrays",
        "$cond",
        "$convert",
        "$cos",
        "$dateFromParts",
        "$dateToParts",
        "$dateFromString",
        "$dateToString",
        "$dayOfMonth",
        "$dayOfWeek",
        "$dayOfYear",
        "$degreesToRadians",
        "$divide",
        "$eq",
        "$exp",
        "$filter",
        "$first",
        "$floor",
        "$function",
        "$gt",
        "$gte",
        "$hour",
        "$ifNull",
        "$in",
        "$indexOfArray",
        "$indexOfBytes",
        "$indexOfCP",
        "$isArray",
        "$isNumber",
        "$isoDayOfWeek",
        "$isoWeek",
        "$isoWeekYear",
        "$last",
        "$last",
        "$let",
        "$literal",
        "$ln",
        "$log",
        "$log10",
        "$lt",
        "$lte",
        "$ltrim",
        "$map",
        "$max",
        "$mergeObjects",
        "$meta",
        "$min",
        "$millisecond",
        "$minute",
        "$mod",
        "$month",
        "$multiply",
        "$ne",
        "$not",
        "$objectToArray",
        "$or",
        "$pow",
        "$push",
        "$radiansToDegrees",
        "$range",
        "$reduce",
        "$regexFind",
        "$regexFindAll",
        "$regexMatch",
        "$replaceOne",
        "$replaceAll",
        "$reverseArray",
        "$round",
        "$rtrim",
        "$second",
        "$setDifference",
        "$setEquals",
        "$setIntersection",
        "$setIsSubset",
        "$setUnion",
        "$size",
        "$sin",
        "$slice",
        "$split",
        "$sqrt",
        "$stdDevPop",
        "$stdDevSamp",
        "$strcasecmp",
        "$strLenBytes",
        "$strLenCP",
        "$substr",
        "$substrBytes",
        "$substrCP",
        "$subtract",
        "$sum",
        "$switch",
        "$tan",
        "$toBool",
        "$toDate",
        "$toDecimal",
        "$toDouble",
        "$toInt",
        "$toLong",
        "$toObjectId",
        "$toString",
        "$toLower",
        "$toUpper",
        "$trim",
        "$trunc",
        "$type",
        "$week",
        "$year",
        "$zip",
        "$count",
        "$dateAdd",
        "$dateDiff",
        "$dateSubtract",
        "$dateTrunc",
        "$getField",
        "$rand",
        "$sampleRate",
        "$setField",
        "$unsetField",
        // aggregation pipeline query modifiers
        "$comment",
        "$explain",
        "$hint",
        "$max",
        "$maxTimeMS",
        "$min",
        "$orderby",
        "$query",
        "$returnKey",
        "$showDiskLoc",
        "$natural"
      ], o = ["ObjectId", "Code", "BinData", "DBRef", "Timestamp", "NumberLong", "NumberDecimal", "MaxKey", "MinKey", "RegExp", "ISODate", "UUID"];
      a = a.map(function(c) {
        return c.replace("$", "\\$");
      });
      var u = "(?:" + a.join("|") + ")\\b";
      r.languages.mongodb = r.languages.extend("javascript", {}), r.languages.insertBefore("mongodb", "string", {
        property: {
          pattern: /(?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)(?=\s*:)/,
          greedy: !0,
          inside: {
            keyword: RegExp(`^(['"])?` + u + "(?:\\1)?$")
          }
        }
      }), r.languages.mongodb.string.inside = {
        url: {
          // url pattern
          pattern: /https?:\/\/[-\w@:%.+~#=]{1,256}\.[a-z0-9()]{1,6}\b[-\w()@:%+.~#?&/=]*/i,
          greedy: !0
        },
        entity: {
          // ipv4
          pattern: /\b(?:(?:[01]?\d\d?|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d\d?|2[0-4]\d|25[0-5])\b/,
          greedy: !0
        }
      }, r.languages.insertBefore("mongodb", "constant", {
        builtin: {
          pattern: RegExp("\\b(?:" + o.join("|") + ")\\b"),
          alias: "keyword"
        }
      });
    })(t);
  }
  return mongodb_1;
}
var monkey_1, hasRequiredMonkey;
function requireMonkey() {
  if (hasRequiredMonkey) return monkey_1;
  hasRequiredMonkey = 1, monkey_1 = e, e.displayName = "monkey", e.aliases = [];
  function e(t) {
    t.languages.monkey = {
      comment: {
        pattern: /^#Rem\s[\s\S]*?^#End|'.+/im,
        greedy: !0
      },
      string: {
        pattern: /"[^"\r\n]*"/,
        greedy: !0
      },
      preprocessor: {
        pattern: /(^[ \t]*)#.+/m,
        lookbehind: !0,
        greedy: !0,
        alias: "property"
      },
      function: /\b\w+(?=\()/,
      "type-char": {
        pattern: /\b[?%#$]/,
        alias: "class-name"
      },
      number: {
        pattern: /((?:\.\.)?)(?:(?:\b|\B-\.?|\B\.)\d+(?:(?!\.\.)\.\d*)?|\$[\da-f]+)/i,
        lookbehind: !0
      },
      keyword: /\b(?:Abstract|Array|Bool|Case|Catch|Class|Const|Continue|Default|Eachin|Else|ElseIf|End|EndIf|Exit|Extends|Extern|False|Field|Final|Float|For|Forever|Function|Global|If|Implements|Import|Inline|Int|Interface|Local|Method|Module|New|Next|Null|Object|Private|Property|Public|Repeat|Return|Select|Self|Step|Strict|String|Super|Then|Throw|To|True|Try|Until|Void|Wend|While)\b/i,
      operator: /\.\.|<[=>]?|>=?|:?=|(?:[+\-*\/&~|]|\b(?:Mod|Shl|Shr)\b)=?|\b(?:And|Not|Or)\b/i,
      punctuation: /[.,:;()\[\]]/
    };
  }
  return monkey_1;
}
var moonscript_1, hasRequiredMoonscript;
function requireMoonscript() {
  if (hasRequiredMoonscript) return moonscript_1;
  hasRequiredMoonscript = 1, moonscript_1 = e, e.displayName = "moonscript", e.aliases = ["moon"];
  function e(t) {
    t.languages.moonscript = {
      comment: /--.*/,
      string: [{
        pattern: /'[^']*'|\[(=*)\[[\s\S]*?\]\1\]/,
        greedy: !0
      }, {
        pattern: /"[^"]*"/,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /#\{[^{}]*\}/,
            inside: {
              moonscript: {
                pattern: /(^#\{)[\s\S]+(?=\})/,
                lookbehind: !0,
                inside: null
                // see beow
              },
              "interpolation-punctuation": {
                pattern: /#\{|\}/,
                alias: "punctuation"
              }
            }
          }
        }
      }],
      "class-name": [
        {
          pattern: /(\b(?:class|extends)[ \t]+)\w+/,
          lookbehind: !0
        },
        // class-like names start with a capital letter
        /\b[A-Z]\w*/
      ],
      keyword: /\b(?:class|continue|do|else|elseif|export|extends|for|from|if|import|in|local|nil|return|self|super|switch|then|unless|using|when|while|with)\b/,
      variable: /@@?\w*/,
      property: {
        pattern: /\b(?!\d)\w+(?=:)|(:)(?!\d)\w+/,
        lookbehind: !0
      },
      function: {
        pattern: /\b(?:_G|_VERSION|assert|collectgarbage|coroutine\.(?:create|resume|running|status|wrap|yield)|debug\.(?:debug|getfenv|gethook|getinfo|getlocal|getmetatable|getregistry|getupvalue|setfenv|sethook|setlocal|setmetatable|setupvalue|traceback)|dofile|error|getfenv|getmetatable|io\.(?:close|flush|input|lines|open|output|popen|read|stderr|stdin|stdout|tmpfile|type|write)|ipairs|load|loadfile|loadstring|math\.(?:abs|acos|asin|atan|atan2|ceil|cos|cosh|deg|exp|floor|fmod|frexp|ldexp|log|log10|max|min|modf|pi|pow|rad|random|randomseed|sin|sinh|sqrt|tan|tanh)|module|next|os\.(?:clock|date|difftime|execute|exit|getenv|remove|rename|setlocale|time|tmpname)|package\.(?:cpath|loaded|loadlib|path|preload|seeall)|pairs|pcall|print|rawequal|rawget|rawset|require|select|setfenv|setmetatable|string\.(?:byte|char|dump|find|format|gmatch|gsub|len|lower|match|rep|reverse|sub|upper)|table\.(?:concat|insert|maxn|remove|sort)|tonumber|tostring|type|unpack|xpcall)\b/,
        inside: {
          punctuation: /\./
        }
      },
      boolean: /\b(?:false|true)\b/,
      number: /(?:\B\.\d+|\b\d+\.\d+|\b\d+(?=[eE]))(?:[eE][-+]?\d+)?\b|\b(?:0x[a-fA-F\d]+|\d+)(?:U?LL)?\b/,
      operator: /\.{3}|[-=]>|~=|(?:[-+*/%<>!=]|\.\.)=?|[:#^]|\b(?:and|or)\b=?|\b(?:not)\b/,
      punctuation: /[.,()[\]{}\\]/
    }, t.languages.moonscript.string[1].inside.interpolation.inside.moonscript.inside = t.languages.moonscript, t.languages.moon = t.languages.moonscript;
  }
  return moonscript_1;
}
var n1ql_1, hasRequiredN1ql;
function requireN1ql() {
  if (hasRequiredN1ql) return n1ql_1;
  hasRequiredN1ql = 1, n1ql_1 = e, e.displayName = "n1ql", e.aliases = [];
  function e(t) {
    t.languages.n1ql = {
      comment: {
        pattern: /\/\*[\s\S]*?(?:$|\*\/)|--.*/,
        greedy: !0
      },
      string: {
        pattern: /(["'])(?:\\[\s\S]|(?!\1)[^\\]|\1\1)*\1/,
        greedy: !0
      },
      identifier: {
        pattern: /`(?:\\[\s\S]|[^\\`]|``)*`/,
        greedy: !0
      },
      parameter: /\$[\w.]+/,
      // https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/reservedwords.html#n1ql-reserved-words
      keyword: /\b(?:ADVISE|ALL|ALTER|ANALYZE|AS|ASC|AT|BEGIN|BINARY|BOOLEAN|BREAK|BUCKET|BUILD|BY|CALL|CAST|CLUSTER|COLLATE|COLLECTION|COMMIT|COMMITTED|CONNECT|CONTINUE|CORRELATE|CORRELATED|COVER|CREATE|CURRENT|DATABASE|DATASET|DATASTORE|DECLARE|DECREMENT|DELETE|DERIVED|DESC|DESCRIBE|DISTINCT|DO|DROP|EACH|ELEMENT|EXCEPT|EXCLUDE|EXECUTE|EXPLAIN|FETCH|FILTER|FLATTEN|FLUSH|FOLLOWING|FOR|FORCE|FROM|FTS|FUNCTION|GOLANG|GRANT|GROUP|GROUPS|GSI|HASH|HAVING|IF|IGNORE|ILIKE|INCLUDE|INCREMENT|INDEX|INFER|INLINE|INNER|INSERT|INTERSECT|INTO|IS|ISOLATION|JAVASCRIPT|JOIN|KEY|KEYS|KEYSPACE|KNOWN|LANGUAGE|LAST|LEFT|LET|LETTING|LEVEL|LIMIT|LSM|MAP|MAPPING|MATCHED|MATERIALIZED|MERGE|MINUS|MISSING|NAMESPACE|NEST|NL|NO|NTH_VALUE|NULL|NULLS|NUMBER|OBJECT|OFFSET|ON|OPTION|OPTIONS|ORDER|OTHERS|OUTER|OVER|PARSE|PARTITION|PASSWORD|PATH|POOL|PRECEDING|PREPARE|PRIMARY|PRIVATE|PRIVILEGE|PROBE|PROCEDURE|PUBLIC|RANGE|RAW|REALM|REDUCE|RENAME|RESPECT|RETURN|RETURNING|REVOKE|RIGHT|ROLE|ROLLBACK|ROW|ROWS|SATISFIES|SAVEPOINT|SCHEMA|SCOPE|SELECT|SELF|SEMI|SET|SHOW|SOME|START|STATISTICS|STRING|SYSTEM|TIES|TO|TRAN|TRANSACTION|TRIGGER|TRUNCATE|UNBOUNDED|UNDER|UNION|UNIQUE|UNKNOWN|UNNEST|UNSET|UPDATE|UPSERT|USE|USER|USING|VALIDATE|VALUE|VALUES|VIA|VIEW|WHERE|WHILE|WINDOW|WITH|WORK|XOR)\b/i,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      boolean: /\b(?:FALSE|TRUE)\b/i,
      number: /(?:\b\d+\.|\B\.)\d+e[+\-]?\d+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
      operator: /[-+*\/%]|!=|==?|\|\||<[>=]?|>=?|\b(?:AND|ANY|ARRAY|BETWEEN|CASE|ELSE|END|EVERY|EXISTS|FIRST|IN|LIKE|NOT|OR|THEN|VALUED|WHEN|WITHIN)\b/i,
      punctuation: /[;[\](),.{}:]/
    };
  }
  return n1ql_1;
}
var n4js_1, hasRequiredN4js;
function requireN4js() {
  if (hasRequiredN4js) return n4js_1;
  hasRequiredN4js = 1, n4js_1 = e, e.displayName = "n4js", e.aliases = ["n4jsd"];
  function e(t) {
    t.languages.n4js = t.languages.extend("javascript", {
      // Keywords from N4JS language spec: https://numberfour.github.io/n4js/spec/N4JSSpec.html
      keyword: /\b(?:Array|any|boolean|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|module|new|null|number|package|private|protected|public|return|set|static|string|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/
    }), t.languages.insertBefore("n4js", "constant", {
      // Annotations in N4JS spec: https://numberfour.github.io/n4js/spec/N4JSSpec.html#_annotations
      annotation: {
        pattern: /@+\w+/,
        alias: "operator"
      }
    }), t.languages.n4jsd = t.languages.n4js;
  }
  return n4js_1;
}
var nand2tetrisHdl_1, hasRequiredNand2tetrisHdl;
function requireNand2tetrisHdl() {
  if (hasRequiredNand2tetrisHdl) return nand2tetrisHdl_1;
  hasRequiredNand2tetrisHdl = 1, nand2tetrisHdl_1 = e, e.displayName = "nand2tetrisHdl", e.aliases = [];
  function e(t) {
    t.languages["nand2tetris-hdl"] = {
      comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
      keyword: /\b(?:BUILTIN|CHIP|CLOCKED|IN|OUT|PARTS)\b/,
      boolean: /\b(?:false|true)\b/,
      function: /\b[A-Za-z][A-Za-z0-9]*(?=\()/,
      number: /\b\d+\b/,
      operator: /=|\.\./,
      punctuation: /[{}[\];(),:]/
    };
  }
  return nand2tetrisHdl_1;
}
var naniscript_1, hasRequiredNaniscript;
function requireNaniscript() {
  if (hasRequiredNaniscript) return naniscript_1;
  hasRequiredNaniscript = 1, naniscript_1 = e, e.displayName = "naniscript", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = /\{[^\r\n\[\]{}]*\}/, o = {
        "quoted-string": {
          pattern: /"(?:[^"\\]|\\.)*"/,
          alias: "operator"
        },
        "command-param-id": {
          pattern: /(\s)\w+:/,
          lookbehind: !0,
          alias: "property"
        },
        "command-param-value": [{
          pattern: a,
          alias: "selector"
        }, {
          pattern: /([\t ])\S+/,
          lookbehind: !0,
          greedy: !0,
          alias: "operator"
        }, {
          pattern: /\S(?:.*\S)?/,
          alias: "operator"
        }]
      };
      r.languages.naniscript = {
        // ; ...
        comment: {
          pattern: /^([\t ]*);.*/m,
          lookbehind: !0
        },
        // > ...
        // Define is a control line starting with '>' followed by a word, a space and a text.
        define: {
          pattern: /^>.+/m,
          alias: "tag",
          inside: {
            value: {
              pattern: /(^>\w+[\t ]+)(?!\s)[^{}\r\n]+/,
              lookbehind: !0,
              alias: "operator"
            },
            key: {
              pattern: /(^>)\w+/,
              lookbehind: !0
            }
          }
        },
        // # ...
        label: {
          pattern: /^([\t ]*)#[\t ]*\w+[\t ]*$/m,
          lookbehind: !0,
          alias: "regex"
        },
        command: {
          pattern: /^([\t ]*)@\w+(?=[\t ]|$).*/m,
          lookbehind: !0,
          alias: "function",
          inside: {
            "command-name": /^@\w+/,
            expression: {
              pattern: a,
              greedy: !0,
              alias: "selector"
            },
            "command-params": {
              pattern: /\s*\S[\s\S]*/,
              inside: o
            }
          }
        },
        // Generic is any line that doesn't start with operators: ;>#@
        "generic-text": {
          pattern: /(^[ \t]*)[^#@>;\s].*/m,
          lookbehind: !0,
          alias: "punctuation",
          inside: {
            // \{ ... \} ... \[ ... \] ... \"
            "escaped-char": /\\[{}\[\]"]/,
            expression: {
              pattern: a,
              greedy: !0,
              alias: "selector"
            },
            "inline-command": {
              pattern: /\[[\t ]*\w[^\r\n\[\]]*\]/,
              greedy: !0,
              alias: "function",
              inside: {
                "command-params": {
                  pattern: /(^\[[\t ]*\w+\b)[\s\S]+(?=\]$)/,
                  lookbehind: !0,
                  inside: o
                },
                "command-param-name": {
                  pattern: /^(\[[\t ]*)\w+/,
                  lookbehind: !0,
                  alias: "name"
                },
                "start-stop-char": /[\[\]]/
              }
            }
          }
        }
      }, r.languages.nani = r.languages.naniscript, r.hooks.add("after-tokenize", function(d) {
        var g = d.tokens;
        g.forEach(function(b) {
          if (typeof b != "string" && b.type === "generic-text") {
            var _ = c(b);
            u(_) || (b.type = "bad-line", b.content = _);
          }
        });
      });
      function u(d) {
        for (var g = "[]{}", b = [], _ = 0; _ < d.length; _++) {
          var y = d[_], A = g.indexOf(y);
          if (A !== -1) {
            if (A % 2 === 0)
              b.push(A + 1);
            else if (b.pop() !== A)
              return !1;
          }
        }
        return b.length === 0;
      }
      function c(d) {
        return typeof d == "string" ? d : Array.isArray(d) ? d.map(c).join("") : c(d.content);
      }
    })(t);
  }
  return naniscript_1;
}
var nasm_1, hasRequiredNasm;
function requireNasm() {
  if (hasRequiredNasm) return nasm_1;
  hasRequiredNasm = 1, nasm_1 = e, e.displayName = "nasm", e.aliases = [];
  function e(t) {
    t.languages.nasm = {
      comment: /;.*$/m,
      string: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
      label: {
        pattern: /(^\s*)[A-Za-z._?$][\w.?$@~#]*:/m,
        lookbehind: !0,
        alias: "function"
      },
      keyword: [/\[?BITS (?:16|32|64)\]?/, {
        pattern: /(^\s*)section\s*[a-z.]+:?/im,
        lookbehind: !0
      }, /(?:extern|global)[^;\r\n]*/i, /(?:CPU|DEFAULT|FLOAT).*$/m],
      register: {
        pattern: /\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|di|si|sp)|[cdefgs]s)\b/i,
        alias: "variable"
      },
      number: /(?:\b|(?=\$))(?:0[hx](?:\.[\da-f]+|[\da-f]+(?:\.[\da-f]+)?)(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|(?:\d+(?:\.\d+)?|\.\d+)(?:\.?e[+-]?\d+)?[dt]?)\b/i,
      operator: /[\[\]*+\-\/%<>=&|$!]/
    };
  }
  return nasm_1;
}
var neon_1, hasRequiredNeon;
function requireNeon() {
  if (hasRequiredNeon) return neon_1;
  hasRequiredNeon = 1, neon_1 = e, e.displayName = "neon", e.aliases = [];
  function e(t) {
    t.languages.neon = {
      comment: {
        pattern: /#.*/,
        greedy: !0
      },
      datetime: {
        pattern: /(^|[[{(=:,\s])\d\d\d\d-\d\d?-\d\d?(?:(?:[Tt]| +)\d\d?:\d\d:\d\d(?:\.\d*)? *(?:Z|[-+]\d\d?(?::?\d\d)?)?)?(?=$|[\]}),\s])/,
        lookbehind: !0,
        alias: "number"
      },
      key: {
        pattern: /(^|[[{(,\s])[^,:=[\]{}()'"\s]+(?=\s*:(?:$|[\]}),\s])|\s*=)/,
        lookbehind: !0,
        alias: "atrule"
      },
      number: {
        pattern: /(^|[[{(=:,\s])[+-]?(?:0x[\da-fA-F]+|0o[0-7]+|0b[01]+|(?:\d+(?:\.\d*)?|\.?\d+)(?:[eE][+-]?\d+)?)(?=$|[\]}),:=\s])/,
        lookbehind: !0
      },
      boolean: {
        pattern: /(^|[[{(=:,\s])(?:false|no|true|yes)(?=$|[\]}),:=\s])/i,
        lookbehind: !0
      },
      null: {
        pattern: /(^|[[{(=:,\s])(?:null)(?=$|[\]}),:=\s])/i,
        lookbehind: !0,
        alias: "keyword"
      },
      string: {
        pattern: /(^|[[{(=:,\s])(?:('''|""")\r?\n(?:(?:[^\r\n]|\r?\n(?![\t ]*\2))*\r?\n)?[\t ]*\2|'[^'\r\n]*'|"(?:\\.|[^\\"\r\n])*")/,
        lookbehind: !0,
        greedy: !0
      },
      literal: {
        pattern: /(^|[[{(=:,\s])(?:[^#"',:=[\]{}()\s`-]|[:-][^"',=[\]{}()\s])(?:[^,:=\]})(\s]|:(?![\s,\]})]|$)|[ \t]+[^#,:=\]})(\s])*/,
        lookbehind: !0,
        alias: "string"
      },
      punctuation: /[,:=[\]{}()-]/
    };
  }
  return neon_1;
}
var nevod_1, hasRequiredNevod;
function requireNevod() {
  if (hasRequiredNevod) return nevod_1;
  hasRequiredNevod = 1, nevod_1 = e, e.displayName = "nevod", e.aliases = [];
  function e(t) {
    t.languages.nevod = {
      comment: /\/\/.*|(?:\/\*[\s\S]*?(?:\*\/|$))/,
      string: {
        pattern: /(?:"(?:""|[^"])*"(?!")|'(?:''|[^'])*'(?!'))!?\*?/,
        greedy: !0,
        inside: {
          "string-attrs": /!$|!\*$|\*$/
        }
      },
      namespace: {
        pattern: /(@namespace\s+)[a-zA-Z0-9\-.]+(?=\s*\{)/,
        lookbehind: !0
      },
      pattern: {
        pattern: /(@pattern\s+)?#?[a-zA-Z0-9\-.]+(?:\s*\(\s*(?:~\s*)?[a-zA-Z0-9\-.]+\s*(?:,\s*(?:~\s*)?[a-zA-Z0-9\-.]*)*\))?(?=\s*=)/,
        lookbehind: !0,
        inside: {
          "pattern-name": {
            pattern: /^#?[a-zA-Z0-9\-.]+/,
            alias: "class-name"
          },
          fields: {
            pattern: /\(.*\)/,
            inside: {
              "field-name": {
                pattern: /[a-zA-Z0-9\-.]+/,
                alias: "variable"
              },
              punctuation: /[,()]/,
              operator: {
                pattern: /~/,
                alias: "field-hidden-mark"
              }
            }
          }
        }
      },
      search: {
        pattern: /(@search\s+|#)[a-zA-Z0-9\-.]+(?:\.\*)?(?=\s*;)/,
        alias: "function",
        lookbehind: !0
      },
      keyword: /@(?:having|inside|namespace|outside|pattern|require|search|where)\b/,
      "standard-pattern": {
        pattern: /\b(?:Alpha|AlphaNum|Any|Blank|End|LineBreak|Num|NumAlpha|Punct|Space|Start|Symbol|Word|WordBreak)\b(?:\([a-zA-Z0-9\-.,\s+]*\))?/,
        inside: {
          "standard-pattern-name": {
            pattern: /^[a-zA-Z0-9\-.]+/,
            alias: "builtin"
          },
          quantifier: {
            pattern: /\b\d+(?:\s*\+|\s*-\s*\d+)?(?!\w)/,
            alias: "number"
          },
          "standard-pattern-attr": {
            pattern: /[a-zA-Z0-9\-.]+/,
            alias: "builtin"
          },
          punctuation: /[,()]/
        }
      },
      quantifier: {
        pattern: /\b\d+(?:\s*\+|\s*-\s*\d+)?(?!\w)/,
        alias: "number"
      },
      operator: [{
        pattern: /=/,
        alias: "pattern-def"
      }, {
        pattern: /&/,
        alias: "conjunction"
      }, {
        pattern: /~/,
        alias: "exception"
      }, {
        pattern: /\?/,
        alias: "optionality"
      }, {
        pattern: /[[\]]/,
        alias: "repetition"
      }, {
        pattern: /[{}]/,
        alias: "variation"
      }, {
        pattern: /[+_]/,
        alias: "sequence"
      }, {
        pattern: /\.{2,3}/,
        alias: "span"
      }],
      "field-capture": [{
        pattern: /([a-zA-Z0-9\-.]+\s*\()\s*[a-zA-Z0-9\-.]+\s*:\s*[a-zA-Z0-9\-.]+(?:\s*,\s*[a-zA-Z0-9\-.]+\s*:\s*[a-zA-Z0-9\-.]+)*(?=\s*\))/,
        lookbehind: !0,
        inside: {
          "field-name": {
            pattern: /[a-zA-Z0-9\-.]+/,
            alias: "variable"
          },
          colon: /:/
        }
      }, {
        pattern: /[a-zA-Z0-9\-.]+\s*:/,
        inside: {
          "field-name": {
            pattern: /[a-zA-Z0-9\-.]+/,
            alias: "variable"
          },
          colon: /:/
        }
      }],
      punctuation: /[:;,()]/,
      name: /[a-zA-Z0-9\-.]+/
    };
  }
  return nevod_1;
}
var nginx_1, hasRequiredNginx;
function requireNginx() {
  if (hasRequiredNginx) return nginx_1;
  hasRequiredNginx = 1, nginx_1 = e, e.displayName = "nginx", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = /\$(?:\w[a-z\d]*(?:_[^\x00-\x1F\s"'\\()$]*)?|\{[^}\s"'\\]+\})/i;
      r.languages.nginx = {
        comment: {
          pattern: /(^|[\s{};])#.*/,
          lookbehind: !0,
          greedy: !0
        },
        directive: {
          pattern: /(^|\s)\w(?:[^;{}"'\\\s]|\\.|"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'|\s+(?:#.*(?!.)|(?![#\s])))*?(?=\s*[;{])/,
          lookbehind: !0,
          greedy: !0,
          inside: {
            string: {
              pattern: /((?:^|[^\\])(?:\\\\)*)(?:"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')/,
              lookbehind: !0,
              greedy: !0,
              inside: {
                escape: {
                  pattern: /\\["'\\nrt]/,
                  alias: "entity"
                },
                variable: a
              }
            },
            comment: {
              pattern: /(\s)#.*/,
              lookbehind: !0,
              greedy: !0
            },
            keyword: {
              pattern: /^\S+/,
              greedy: !0
            },
            // other patterns
            boolean: {
              pattern: /(\s)(?:off|on)(?!\S)/,
              lookbehind: !0
            },
            number: {
              pattern: /(\s)\d+[a-z]*(?!\S)/i,
              lookbehind: !0
            },
            variable: a
          }
        },
        punctuation: /[{};]/
      };
    })(t);
  }
  return nginx_1;
}
var nim_1, hasRequiredNim;
function requireNim() {
  if (hasRequiredNim) return nim_1;
  hasRequiredNim = 1, nim_1 = e, e.displayName = "nim", e.aliases = [];
  function e(t) {
    t.languages.nim = {
      comment: {
        pattern: /#.*/,
        greedy: !0
      },
      string: {
        // Double-quoted strings can be prefixed by an identifier (Generalized raw string literals)
        pattern: /(?:\b(?!\d)(?:\w|\\x[89a-fA-F][0-9a-fA-F])+)?(?:"""[\s\S]*?"""(?!")|"(?:\\[\s\S]|""|[^"\\])*")/,
        greedy: !0
      },
      char: {
        // Character literals are handled specifically to prevent issues with numeric type suffixes
        pattern: /'(?:\\(?:\d+|x[\da-fA-F]{0,2}|.)|[^'])'/,
        greedy: !0
      },
      function: {
        pattern: /(?:(?!\d)(?:\w|\\x[89a-fA-F][0-9a-fA-F])+|`[^`\r\n]+`)\*?(?:\[[^\]]+\])?(?=\s*\()/,
        greedy: !0,
        inside: {
          operator: /\*$/
        }
      },
      // We don't want to highlight operators (and anything really) inside backticks
      identifier: {
        pattern: /`[^`\r\n]+`/,
        greedy: !0,
        inside: {
          punctuation: /`/
        }
      },
      // The negative look ahead prevents wrong highlighting of the .. operator
      number: /\b(?:0[xXoObB][\da-fA-F_]+|\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:[eE][+-]?\d[\d_]*)?)(?:'?[iuf]\d*)?/,
      keyword: /\b(?:addr|as|asm|atomic|bind|block|break|case|cast|concept|const|continue|converter|defer|discard|distinct|do|elif|else|end|enum|except|export|finally|for|from|func|generic|if|import|include|interface|iterator|let|macro|method|mixin|nil|object|out|proc|ptr|raise|ref|return|static|template|try|tuple|type|using|var|when|while|with|without|yield)\b/,
      operator: {
        // Look behind and look ahead prevent wrong highlighting of punctuations [. .] {. .} (. .)
        // but allow the slice operator .. to take precedence over them
        // One can define his own operators in Nim so all combination of operators might be an operator.
        pattern: /(^|[({\[](?=\.\.)|(?![({\[]\.).)(?:(?:[=+\-*\/<>@$~&%|!?^:\\]|\.\.|\.(?![)}\]]))+|\b(?:and|div|in|is|isnot|mod|not|notin|of|or|shl|shr|xor)\b)/m,
        lookbehind: !0
      },
      punctuation: /[({\[]\.|\.[)}\]]|[`(){}\[\],:]/
    };
  }
  return nim_1;
}
var nix_1, hasRequiredNix;
function requireNix() {
  if (hasRequiredNix) return nix_1;
  hasRequiredNix = 1, nix_1 = e, e.displayName = "nix", e.aliases = [];
  function e(t) {
    t.languages.nix = {
      comment: {
        pattern: /\/\*[\s\S]*?\*\/|#.*/,
        greedy: !0
      },
      string: {
        pattern: /"(?:[^"\\]|\\[\s\S])*"|''(?:(?!'')[\s\S]|''(?:'|\\|\$\{))*''/,
        greedy: !0,
        inside: {
          interpolation: {
            // The lookbehind ensures the ${} is not preceded by \ or ''
            pattern: /(^|(?:^|(?!'').)[^\\])\$\{(?:[^{}]|\{[^}]*\})*\}/,
            lookbehind: !0,
            inside: null
            // see below
          }
        }
      },
      url: [/\b(?:[a-z]{3,7}:\/\/)[\w\-+%~\/.:#=?&]+/, {
        pattern: /([^\/])(?:[\w\-+%~.:#=?&]*(?!\/\/)[\w\-+%~\/.:#=?&])?(?!\/\/)\/[\w\-+%~\/.:#=?&]*/,
        lookbehind: !0
      }],
      antiquotation: {
        pattern: /\$(?=\{)/,
        alias: "important"
      },
      number: /\b\d+\b/,
      keyword: /\b(?:assert|builtins|else|if|in|inherit|let|null|or|then|with)\b/,
      function: /\b(?:abort|add|all|any|attrNames|attrValues|baseNameOf|compareVersions|concatLists|currentSystem|deepSeq|derivation|dirOf|div|elem(?:At)?|fetch(?:Tarball|url)|filter(?:Source)?|fromJSON|genList|getAttr|getEnv|hasAttr|hashString|head|import|intersectAttrs|is(?:Attrs|Bool|Function|Int|List|Null|String)|length|lessThan|listToAttrs|map|mul|parseDrvName|pathExists|read(?:Dir|File)|removeAttrs|replaceStrings|seq|sort|stringLength|sub(?:string)?|tail|throw|to(?:File|JSON|Path|String|XML)|trace|typeOf)\b|\bfoldl'\B/,
      boolean: /\b(?:false|true)\b/,
      operator: /[=!<>]=?|\+\+?|\|\||&&|\/\/|->?|[?@]/,
      punctuation: /[{}()[\].,:;]/
    }, t.languages.nix.string.inside.interpolation.inside = t.languages.nix;
  }
  return nix_1;
}
var nsis_1, hasRequiredNsis;
function requireNsis() {
  if (hasRequiredNsis) return nsis_1;
  hasRequiredNsis = 1, nsis_1 = e, e.displayName = "nsis", e.aliases = [];
  function e(t) {
    t.languages.nsis = {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|[#;].*)/,
        lookbehind: !0,
        greedy: !0
      },
      string: {
        pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      keyword: {
        pattern: /(^[\t ]*)(?:Abort|Add(?:BrandingImage|Size)|AdvSplash|Allow(?:RootDirInstall|SkipFiles)|AutoCloseWindow|BG(?:Font|Gradient|Image)|Banner|BrandingText|BringToFront|CRCCheck|Call(?:InstDLL)?|Caption|ChangeUI|CheckBitmap|ClearErrors|CompletedText|ComponentText|CopyFiles|Create(?:Directory|Font|ShortCut)|Delete(?:INISec|INIStr|RegKey|RegValue)?|Detail(?:Print|sButtonText)|Dialer|Dir(?:Text|Var|Verify)|EnableWindow|Enum(?:RegKey|RegValue)|Exch|Exec(?:Shell(?:Wait)?|Wait)?|ExpandEnvStrings|File(?:BufSize|Close|ErrorText|Open|Read|ReadByte|ReadUTF16LE|ReadWord|Seek|Write|WriteByte|WriteUTF16LE|WriteWord)?|Find(?:Close|First|Next|Window)|FlushINI|Get(?:CurInstType|CurrentAddress|DLLVersion(?:Local)?|DlgItem|ErrorLevel|FileTime(?:Local)?|FullPathName|Function(?:Address|End)?|InstDirError|LabelAddress|TempFileName)|Goto|HideWindow|Icon|If(?:Abort|Errors|FileExists|RebootFlag|Silent)|InitPluginsDir|InstProgressFlags|Inst(?:Type(?:GetText|SetText)?)|Install(?:ButtonText|Colors|Dir(?:RegKey)?)|Int(?:64|Ptr)?CmpU?|Int(?:64)?Fmt|Int(?:Ptr)?Op|IsWindow|Lang(?:DLL|String)|License(?:BkColor|Data|ForceSelection|LangString|Text)|LoadLanguageFile|LockWindow|Log(?:Set|Text)|Manifest(?:DPIAware|SupportedOS)|Math|MessageBox|MiscButtonText|NSISdl|Name|Nop|OutFile|PE(?:DllCharacteristics|SubsysVer)|Page(?:Callbacks)?|Pop|Push|Quit|RMDir|Read(?:EnvStr|INIStr|RegDWORD|RegStr)|Reboot|RegDLL|Rename|RequestExecutionLevel|ReserveFile|Return|SearchPath|Section(?:End|GetFlags|GetInstTypes|GetSize|GetText|Group|In|SetFlags|SetInstTypes|SetSize|SetText)?|SendMessage|Set(?:AutoClose|BrandingImage|Compress|Compressor(?:DictSize)?|CtlColors|CurInstType|DatablockOptimize|DateSave|Details(?:Print|View)|ErrorLevel|Errors|FileAttributes|Font|OutPath|Overwrite|PluginUnload|RebootFlag|RegView|ShellVarContext|Silent)|Show(?:InstDetails|UninstDetails|Window)|Silent(?:Install|UnInstall)|Sleep|SpaceTexts|Splash|StartMenu|Str(?:CmpS?|Cpy|Len)|SubCaption|System|UnRegDLL|Unicode|UninstPage|Uninstall(?:ButtonText|Caption|Icon|SubCaption|Text)|UserInfo|VI(?:AddVersionKey|FileVersion|ProductVersion)|VPatch|Var|WindowIcon|Write(?:INIStr|Reg(?:Bin|DWORD|ExpandStr|MultiStr|None|Str)|Uninstaller)|XPStyle|ns(?:Dialogs|Exec))\b/m,
        lookbehind: !0
      },
      property: /\b(?:ARCHIVE|FILE_(?:ATTRIBUTE_ARCHIVE|ATTRIBUTE_NORMAL|ATTRIBUTE_OFFLINE|ATTRIBUTE_READONLY|ATTRIBUTE_SYSTEM|ATTRIBUTE_TEMPORARY)|HK(?:(?:CR|CU|LM)(?:32|64)?|DD|PD|U)|HKEY_(?:CLASSES_ROOT|CURRENT_CONFIG|CURRENT_USER|DYN_DATA|LOCAL_MACHINE|PERFORMANCE_DATA|USERS)|ID(?:ABORT|CANCEL|IGNORE|NO|OK|RETRY|YES)|MB_(?:ABORTRETRYIGNORE|DEFBUTTON1|DEFBUTTON2|DEFBUTTON3|DEFBUTTON4|ICONEXCLAMATION|ICONINFORMATION|ICONQUESTION|ICONSTOP|OK|OKCANCEL|RETRYCANCEL|RIGHT|RTLREADING|SETFOREGROUND|TOPMOST|USERICON|YESNO)|NORMAL|OFFLINE|READONLY|SHCTX|SHELL_CONTEXT|SYSTEM|TEMPORARY|admin|all|auto|both|colored|false|force|hide|highest|lastused|leave|listonly|none|normal|notset|off|on|open|print|show|silent|silentlog|smooth|textonly|true|user)\b/,
      constant: /\$\{[!\w\.:\^-]+\}|\$\([!\w\.:\^-]+\)/,
      variable: /\$\w[\w\.]*/,
      number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
      operator: /--?|\+\+?|<=?|>=?|==?=?|&&?|\|\|?|[?*\/~^%]/,
      punctuation: /[{}[\];(),.:]/,
      important: {
        pattern: /(^[\t ]*)!(?:addincludedir|addplugindir|appendfile|cd|define|delfile|echo|else|endif|error|execute|finalize|getdllversion|gettlbversion|if|ifdef|ifmacrodef|ifmacrondef|ifndef|include|insertmacro|macro|macroend|makensis|packhdr|pragma|searchparse|searchreplace|system|tempfile|undef|verbose|warning)\b/im,
        lookbehind: !0
      }
    };
  }
  return nsis_1;
}
var objectivec_1, hasRequiredObjectivec;
function requireObjectivec() {
  if (hasRequiredObjectivec) return objectivec_1;
  hasRequiredObjectivec = 1;
  var e = requireC();
  objectivec_1 = t, t.displayName = "objectivec", t.aliases = ["objc"];
  function t(r) {
    r.register(e), r.languages.objectivec = r.languages.extend("c", {
      string: {
        pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
        greedy: !0
      },
      keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
      operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
    }), delete r.languages.objectivec["class-name"], r.languages.objc = r.languages.objectivec;
  }
  return objectivec_1;
}
var ocaml_1, hasRequiredOcaml;
function requireOcaml() {
  if (hasRequiredOcaml) return ocaml_1;
  hasRequiredOcaml = 1, ocaml_1 = e, e.displayName = "ocaml", e.aliases = [];
  function e(t) {
    t.languages.ocaml = {
      comment: {
        pattern: /\(\*[\s\S]*?\*\)/,
        greedy: !0
      },
      char: {
        pattern: /'(?:[^\\\r\n']|\\(?:.|[ox]?[0-9a-f]{1,3}))'/i,
        greedy: !0
      },
      string: [{
        pattern: /"(?:\\(?:[\s\S]|\r\n)|[^\\\r\n"])*"/,
        greedy: !0
      }, {
        pattern: /\{([a-z_]*)\|[\s\S]*?\|\1\}/,
        greedy: !0
      }],
      number: [
        // binary and octal
        /\b(?:0b[01][01_]*|0o[0-7][0-7_]*)\b/i,
        // hexadecimal
        /\b0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]*)?(?:p[+-]?\d[\d_]*)?(?!\w)/i,
        // decimal
        /\b\d[\d_]*(?:\.[\d_]*)?(?:e[+-]?\d[\d_]*)?(?!\w)/i
      ],
      directive: {
        pattern: /\B#\w+/,
        alias: "property"
      },
      label: {
        pattern: /\B~\w+/,
        alias: "property"
      },
      "type-variable": {
        pattern: /\B'\w+/,
        alias: "function"
      },
      variant: {
        pattern: /`\w+/,
        alias: "symbol"
      },
      // For the list of keywords and operators,
      // see: http://caml.inria.fr/pub/docs/manual-ocaml/lex.html#sec84
      keyword: /\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\b/,
      boolean: /\b(?:false|true)\b/,
      "operator-like-punctuation": {
        pattern: /\[[<>|]|[>|]\]|\{<|>\}/,
        alias: "punctuation"
      },
      // Custom operators are allowed
      operator: /\.[.~]|:[=>]|[=<>@^|&+\-*\/$%!?~][!$%&*+\-.\/:<=>?@^|~]*|\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\b/,
      punctuation: /;;|::|[(){}\[\].,:;#]|\b_\b/
    };
  }
  return ocaml_1;
}
var opencl_1, hasRequiredOpencl;
function requireOpencl() {
  if (hasRequiredOpencl) return opencl_1;
  hasRequiredOpencl = 1;
  var e = requireC();
  opencl_1 = t, t.displayName = "opencl", t.aliases = [];
  function t(r) {
    r.register(e), function(a) {
      a.languages.opencl = a.languages.extend("c", {
        // Extracted from the official specs (2.0) and http://streamcomputing.eu/downloads/?opencl.lang (opencl-keywords, opencl-types) and http://sourceforge.net/tracker/?func=detail&aid=2957794&group_id=95717&atid=612384 (Words2, partly Words3)
        keyword: /\b(?:(?:__)?(?:constant|global|kernel|local|private|read_only|read_write|write_only)|__attribute__|auto|(?:bool|u?(?:char|int|long|short)|half|quad)(?:2|3|4|8|16)?|break|case|complex|const|continue|(?:double|float)(?:16(?:x(?:1|2|4|8|16))?|1x(?:1|2|4|8|16)|2(?:x(?:1|2|4|8|16))?|3|4(?:x(?:1|2|4|8|16))?|8(?:x(?:1|2|4|8|16))?)?|default|do|else|enum|extern|for|goto|if|imaginary|inline|packed|pipe|register|restrict|return|signed|sizeof|static|struct|switch|typedef|uniform|union|unsigned|void|volatile|while)\b/,
        // Extracted from http://streamcomputing.eu/downloads/?opencl.lang (opencl-const)
        // Math Constants: https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/mathConstants.html
        // Macros and Limits: https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/macroLimits.html
        number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[fuhl]{0,4}/i,
        boolean: /\b(?:false|true)\b/,
        "constant-opencl-kernel": {
          pattern: /\b(?:CHAR_(?:BIT|MAX|MIN)|CLK_(?:ADDRESS_(?:CLAMP(?:_TO_EDGE)?|NONE|REPEAT)|FILTER_(?:LINEAR|NEAREST)|(?:GLOBAL|LOCAL)_MEM_FENCE|NORMALIZED_COORDS_(?:FALSE|TRUE))|CL_(?:BGRA|(?:HALF_)?FLOAT|INTENSITY|LUMINANCE|A?R?G?B?[Ax]?|(?:(?:UN)?SIGNED|[US]NORM)_(?:INT(?:8|16|32))|UNORM_(?:INT_101010|SHORT_(?:555|565)))|(?:DBL|FLT|HALF)_(?:DIG|EPSILON|(?:MAX|MIN)(?:(?:_10)?_EXP)?|MANT_DIG)|FLT_RADIX|HUGE_VALF?|(?:INT|LONG|SCHAR|SHRT)_(?:MAX|MIN)|INFINITY|MAXFLOAT|M_(?:[12]_PI|2_SQRTPI|E|LN(?:2|10)|LOG(?:2|10)E?|PI(?:_[24])?|SQRT(?:1_2|2))(?:_F|_H)?|NAN|(?:UCHAR|UINT|ULONG|USHRT)_MAX)\b/,
          alias: "constant"
        }
      }), a.languages.insertBefore("opencl", "class-name", {
        // https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/scalarDataTypes.html
        // https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/otherDataTypes.html
        "builtin-type": {
          pattern: /\b(?:_cl_(?:command_queue|context|device_id|event|kernel|mem|platform_id|program|sampler)|cl_(?:image_format|mem_fence_flags)|clk_event_t|event_t|image(?:1d_(?:array_|buffer_)?t|2d_(?:array_(?:depth_|msaa_depth_|msaa_)?|depth_|msaa_depth_|msaa_)?t|3d_t)|intptr_t|ndrange_t|ptrdiff_t|queue_t|reserve_id_t|sampler_t|size_t|uintptr_t)\b/,
          alias: "keyword"
        }
      });
      var o = {
        // Extracted from http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-types and opencl-host)
        "type-opencl-host": {
          pattern: /\b(?:cl_(?:GLenum|GLint|GLuin|addressing_mode|bitfield|bool|buffer_create_type|build_status|channel_(?:order|type)|(?:u?(?:char|int|long|short)|double|float)(?:2|3|4|8|16)?|command_(?:queue(?:_info|_properties)?|type)|context(?:_info|_properties)?|device_(?:exec_capabilities|fp_config|id|info|local_mem_type|mem_cache_type|type)|(?:event|sampler)(?:_info)?|filter_mode|half|image_info|kernel(?:_info|_work_group_info)?|map_flags|mem(?:_flags|_info|_object_type)?|platform_(?:id|info)|profiling_info|program(?:_build_info|_info)?))\b/,
          alias: "keyword"
        },
        "boolean-opencl-host": {
          pattern: /\bCL_(?:FALSE|TRUE)\b/,
          alias: "boolean"
        },
        // Extracted from cl.h (2.0) and http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-const)
        "constant-opencl-host": {
          pattern: /\bCL_(?:A|ABGR|ADDRESS_(?:CLAMP(?:_TO_EDGE)?|MIRRORED_REPEAT|NONE|REPEAT)|ARGB|BGRA|BLOCKING|BUFFER_CREATE_TYPE_REGION|BUILD_(?:ERROR|IN_PROGRESS|NONE|PROGRAM_FAILURE|SUCCESS)|COMMAND_(?:ACQUIRE_GL_OBJECTS|BARRIER|COPY_(?:BUFFER(?:_RECT|_TO_IMAGE)?|IMAGE(?:_TO_BUFFER)?)|FILL_(?:BUFFER|IMAGE)|MAP(?:_BUFFER|_IMAGE)|MARKER|MIGRATE(?:_SVM)?_MEM_OBJECTS|NATIVE_KERNEL|NDRANGE_KERNEL|READ_(?:BUFFER(?:_RECT)?|IMAGE)|RELEASE_GL_OBJECTS|SVM_(?:FREE|MAP|MEMCPY|MEMFILL|UNMAP)|TASK|UNMAP_MEM_OBJECT|USER|WRITE_(?:BUFFER(?:_RECT)?|IMAGE))|COMPILER_NOT_AVAILABLE|COMPILE_PROGRAM_FAILURE|COMPLETE|CONTEXT_(?:DEVICES|INTEROP_USER_SYNC|NUM_DEVICES|PLATFORM|PROPERTIES|REFERENCE_COUNT)|DEPTH(?:_STENCIL)?|DEVICE_(?:ADDRESS_BITS|AFFINITY_DOMAIN_(?:L[1-4]_CACHE|NEXT_PARTITIONABLE|NUMA)|AVAILABLE|BUILT_IN_KERNELS|COMPILER_AVAILABLE|DOUBLE_FP_CONFIG|ENDIAN_LITTLE|ERROR_CORRECTION_SUPPORT|EXECUTION_CAPABILITIES|EXTENSIONS|GLOBAL_(?:MEM_(?:CACHELINE_SIZE|CACHE_SIZE|CACHE_TYPE|SIZE)|VARIABLE_PREFERRED_TOTAL_SIZE)|HOST_UNIFIED_MEMORY|IL_VERSION|IMAGE(?:2D_MAX_(?:HEIGHT|WIDTH)|3D_MAX_(?:DEPTH|HEIGHT|WIDTH)|_BASE_ADDRESS_ALIGNMENT|_MAX_ARRAY_SIZE|_MAX_BUFFER_SIZE|_PITCH_ALIGNMENT|_SUPPORT)|LINKER_AVAILABLE|LOCAL_MEM_SIZE|LOCAL_MEM_TYPE|MAX_(?:CLOCK_FREQUENCY|COMPUTE_UNITS|CONSTANT_ARGS|CONSTANT_BUFFER_SIZE|GLOBAL_VARIABLE_SIZE|MEM_ALLOC_SIZE|NUM_SUB_GROUPS|ON_DEVICE_(?:EVENTS|QUEUES)|PARAMETER_SIZE|PIPE_ARGS|READ_IMAGE_ARGS|READ_WRITE_IMAGE_ARGS|SAMPLERS|WORK_GROUP_SIZE|WORK_ITEM_DIMENSIONS|WORK_ITEM_SIZES|WRITE_IMAGE_ARGS)|MEM_BASE_ADDR_ALIGN|MIN_DATA_TYPE_ALIGN_SIZE|NAME|NATIVE_VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT)|NOT_(?:AVAILABLE|FOUND)|OPENCL_C_VERSION|PARENT_DEVICE|PARTITION_(?:AFFINITY_DOMAIN|BY_AFFINITY_DOMAIN|BY_COUNTS|BY_COUNTS_LIST_END|EQUALLY|FAILED|MAX_SUB_DEVICES|PROPERTIES|TYPE)|PIPE_MAX_(?:ACTIVE_RESERVATIONS|PACKET_SIZE)|PLATFORM|PREFERRED_(?:GLOBAL_ATOMIC_ALIGNMENT|INTEROP_USER_SYNC|LOCAL_ATOMIC_ALIGNMENT|PLATFORM_ATOMIC_ALIGNMENT|VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT))|PRINTF_BUFFER_SIZE|PROFILE|PROFILING_TIMER_RESOLUTION|QUEUE_(?:ON_(?:DEVICE_(?:MAX_SIZE|PREFERRED_SIZE|PROPERTIES)|HOST_PROPERTIES)|PROPERTIES)|REFERENCE_COUNT|SINGLE_FP_CONFIG|SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS|SVM_(?:ATOMICS|CAPABILITIES|COARSE_GRAIN_BUFFER|FINE_GRAIN_BUFFER|FINE_GRAIN_SYSTEM)|TYPE(?:_ACCELERATOR|_ALL|_CPU|_CUSTOM|_DEFAULT|_GPU)?|VENDOR(?:_ID)?|VERSION)|DRIVER_VERSION|EVENT_(?:COMMAND_(?:EXECUTION_STATUS|QUEUE|TYPE)|CONTEXT|REFERENCE_COUNT)|EXEC_(?:KERNEL|NATIVE_KERNEL|STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST)|FILTER_(?:LINEAR|NEAREST)|FLOAT|FP_(?:CORRECTLY_ROUNDED_DIVIDE_SQRT|DENORM|FMA|INF_NAN|ROUND_TO_INF|ROUND_TO_NEAREST|ROUND_TO_ZERO|SOFT_FLOAT)|GLOBAL|HALF_FLOAT|IMAGE_(?:ARRAY_SIZE|BUFFER|DEPTH|ELEMENT_SIZE|FORMAT|FORMAT_MISMATCH|FORMAT_NOT_SUPPORTED|HEIGHT|NUM_MIP_LEVELS|NUM_SAMPLES|ROW_PITCH|SLICE_PITCH|WIDTH)|INTENSITY|INVALID_(?:ARG_INDEX|ARG_SIZE|ARG_VALUE|BINARY|BUFFER_SIZE|BUILD_OPTIONS|COMMAND_QUEUE|COMPILER_OPTIONS|CONTEXT|DEVICE|DEVICE_PARTITION_COUNT|DEVICE_QUEUE|DEVICE_TYPE|EVENT|EVENT_WAIT_LIST|GLOBAL_OFFSET|GLOBAL_WORK_SIZE|GL_OBJECT|HOST_PTR|IMAGE_DESCRIPTOR|IMAGE_FORMAT_DESCRIPTOR|IMAGE_SIZE|KERNEL|KERNEL_ARGS|KERNEL_DEFINITION|KERNEL_NAME|LINKER_OPTIONS|MEM_OBJECT|MIP_LEVEL|OPERATION|PIPE_SIZE|PLATFORM|PROGRAM|PROGRAM_EXECUTABLE|PROPERTY|QUEUE_PROPERTIES|SAMPLER|VALUE|WORK_DIMENSION|WORK_GROUP_SIZE|WORK_ITEM_SIZE)|KERNEL_(?:ARG_(?:ACCESS_(?:NONE|QUALIFIER|READ_ONLY|READ_WRITE|WRITE_ONLY)|ADDRESS_(?:CONSTANT|GLOBAL|LOCAL|PRIVATE|QUALIFIER)|INFO_NOT_AVAILABLE|NAME|TYPE_(?:CONST|NAME|NONE|PIPE|QUALIFIER|RESTRICT|VOLATILE))|ATTRIBUTES|COMPILE_NUM_SUB_GROUPS|COMPILE_WORK_GROUP_SIZE|CONTEXT|EXEC_INFO_SVM_FINE_GRAIN_SYSTEM|EXEC_INFO_SVM_PTRS|FUNCTION_NAME|GLOBAL_WORK_SIZE|LOCAL_MEM_SIZE|LOCAL_SIZE_FOR_SUB_GROUP_COUNT|MAX_NUM_SUB_GROUPS|MAX_SUB_GROUP_SIZE_FOR_NDRANGE|NUM_ARGS|PREFERRED_WORK_GROUP_SIZE_MULTIPLE|PRIVATE_MEM_SIZE|PROGRAM|REFERENCE_COUNT|SUB_GROUP_COUNT_FOR_NDRANGE|WORK_GROUP_SIZE)|LINKER_NOT_AVAILABLE|LINK_PROGRAM_FAILURE|LOCAL|LUMINANCE|MAP_(?:FAILURE|READ|WRITE|WRITE_INVALIDATE_REGION)|MEM_(?:ALLOC_HOST_PTR|ASSOCIATED_MEMOBJECT|CONTEXT|COPY_HOST_PTR|COPY_OVERLAP|FLAGS|HOST_NO_ACCESS|HOST_PTR|HOST_READ_ONLY|HOST_WRITE_ONLY|KERNEL_READ_AND_WRITE|MAP_COUNT|OBJECT_(?:ALLOCATION_FAILURE|BUFFER|IMAGE1D|IMAGE1D_ARRAY|IMAGE1D_BUFFER|IMAGE2D|IMAGE2D_ARRAY|IMAGE3D|PIPE)|OFFSET|READ_ONLY|READ_WRITE|REFERENCE_COUNT|SIZE|SVM_ATOMICS|SVM_FINE_GRAIN_BUFFER|TYPE|USES_SVM_POINTER|USE_HOST_PTR|WRITE_ONLY)|MIGRATE_MEM_OBJECT_(?:CONTENT_UNDEFINED|HOST)|MISALIGNED_SUB_BUFFER_OFFSET|NONE|NON_BLOCKING|OUT_OF_(?:HOST_MEMORY|RESOURCES)|PIPE_(?:MAX_PACKETS|PACKET_SIZE)|PLATFORM_(?:EXTENSIONS|HOST_TIMER_RESOLUTION|NAME|PROFILE|VENDOR|VERSION)|PROFILING_(?:COMMAND_(?:COMPLETE|END|QUEUED|START|SUBMIT)|INFO_NOT_AVAILABLE)|PROGRAM_(?:BINARIES|BINARY_SIZES|BINARY_TYPE(?:_COMPILED_OBJECT|_EXECUTABLE|_LIBRARY|_NONE)?|BUILD_(?:GLOBAL_VARIABLE_TOTAL_SIZE|LOG|OPTIONS|STATUS)|CONTEXT|DEVICES|IL|KERNEL_NAMES|NUM_DEVICES|NUM_KERNELS|REFERENCE_COUNT|SOURCE)|QUEUED|QUEUE_(?:CONTEXT|DEVICE|DEVICE_DEFAULT|ON_DEVICE|ON_DEVICE_DEFAULT|OUT_OF_ORDER_EXEC_MODE_ENABLE|PROFILING_ENABLE|PROPERTIES|REFERENCE_COUNT|SIZE)|R|RA|READ_(?:ONLY|WRITE)_CACHE|RG|RGB|RGBA|RGBx|RGx|RUNNING|Rx|SAMPLER_(?:ADDRESSING_MODE|CONTEXT|FILTER_MODE|LOD_MAX|LOD_MIN|MIP_FILTER_MODE|NORMALIZED_COORDS|REFERENCE_COUNT)|(?:UN)?SIGNED_INT(?:8|16|32)|SNORM_INT(?:8|16)|SUBMITTED|SUCCESS|UNORM_INT(?:8|16|24|_101010|_101010_2)|UNORM_SHORT_(?:555|565)|VERSION_(?:1_0|1_1|1_2|2_0|2_1)|sBGRA|sRGB|sRGBA|sRGBx)\b/,
          alias: "constant"
        },
        // Extracted from cl.h (2.0) and http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-host)
        "function-opencl-host": {
          pattern: /\bcl(?:BuildProgram|CloneKernel|CompileProgram|Create(?:Buffer|CommandQueue(?:WithProperties)?|Context|ContextFromType|Image|Image2D|Image3D|Kernel|KernelsInProgram|Pipe|ProgramWith(?:Binary|BuiltInKernels|IL|Source)|Sampler|SamplerWithProperties|SubBuffer|SubDevices|UserEvent)|Enqueue(?:(?:Barrier|Marker)(?:WithWaitList)?|Copy(?:Buffer(?:Rect|ToImage)?|Image(?:ToBuffer)?)|(?:Fill|Map)(?:Buffer|Image)|MigrateMemObjects|NDRangeKernel|NativeKernel|(?:Read|Write)(?:Buffer(?:Rect)?|Image)|SVM(?:Free|Map|MemFill|Memcpy|MigrateMem|Unmap)|Task|UnmapMemObject|WaitForEvents)|Finish|Flush|Get(?:CommandQueueInfo|ContextInfo|Device(?:AndHostTimer|IDs|Info)|Event(?:Profiling)?Info|ExtensionFunctionAddress(?:ForPlatform)?|HostTimer|ImageInfo|Kernel(?:ArgInfo|Info|SubGroupInfo|WorkGroupInfo)|MemObjectInfo|PipeInfo|Platform(?:IDs|Info)|Program(?:Build)?Info|SamplerInfo|SupportedImageFormats)|LinkProgram|(?:Release|Retain)(?:CommandQueue|Context|Device|Event|Kernel|MemObject|Program|Sampler)|SVM(?:Alloc|Free)|Set(?:CommandQueueProperty|DefaultDeviceCommandQueue|EventCallback|Kernel|Kernel(?:Arg(?:SVMPointer)?|ExecInfo)|MemObjectDestructorCallback|UserEventStatus)|Unload(?:Platform)?Compiler|WaitForEvents)\b/,
          alias: "function"
        }
      };
      a.languages.insertBefore("c", "keyword", o), a.languages.cpp && (o["type-opencl-host-cpp"] = {
        pattern: /\b(?:Buffer|BufferGL|BufferRenderGL|CommandQueue|Context|Device|DeviceCommandQueue|EnqueueArgs|Event|Image|Image1D|Image1DArray|Image1DBuffer|Image2D|Image2DArray|Image2DGL|Image3D|Image3DGL|ImageFormat|ImageGL|Kernel|KernelFunctor|LocalSpaceArg|Memory|NDRange|Pipe|Platform|Program|SVMAllocator|SVMTraitAtomic|SVMTraitCoarse|SVMTraitFine|SVMTraitReadOnly|SVMTraitReadWrite|SVMTraitWriteOnly|Sampler|UserEvent)\b/,
        alias: "keyword"
      }, a.languages.insertBefore("cpp", "keyword", o));
    }(r);
  }
  return opencl_1;
}
var openqasm_1, hasRequiredOpenqasm;
function requireOpenqasm() {
  if (hasRequiredOpenqasm) return openqasm_1;
  hasRequiredOpenqasm = 1, openqasm_1 = e, e.displayName = "openqasm", e.aliases = ["qasm"];
  function e(t) {
    t.languages.openqasm = {
      comment: /\/\*[\s\S]*?\*\/|\/\/.*/,
      string: {
        pattern: /"[^"\r\n\t]*"|'[^'\r\n\t]*'/,
        greedy: !0
      },
      keyword: /\b(?:CX|OPENQASM|U|barrier|boxas|boxto|break|const|continue|ctrl|def|defcal|defcalgrammar|delay|else|end|for|gate|gphase|if|in|include|inv|kernel|lengthof|let|measure|pow|reset|return|rotary|stretchinf|while)\b|#pragma\b/,
      "class-name": /\b(?:angle|bit|bool|creg|fixed|float|int|length|qreg|qubit|stretch|uint)\b/,
      function: /\b(?:cos|exp|ln|popcount|rotl|rotr|sin|sqrt|tan)\b(?=\s*\()/,
      constant: /\b(?:euler|pi|tau)\b|||/,
      number: {
        pattern: /(^|[^.\w$])(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?(?:dt|ns|us|s|ms|s)?/i,
        lookbehind: !0
      },
      operator: /->|>>=?|<<=?|&&|\|\||\+\+|--|[!=<>&|~^+\-*/%]=?|@/,
      punctuation: /[(){}\[\];,:.]/
    }, t.languages.qasm = t.languages.openqasm;
  }
  return openqasm_1;
}
var oz_1, hasRequiredOz;
function requireOz() {
  if (hasRequiredOz) return oz_1;
  hasRequiredOz = 1, oz_1 = e, e.displayName = "oz", e.aliases = [];
  function e(t) {
    t.languages.oz = {
      comment: {
        pattern: /\/\*[\s\S]*?\*\/|%.*/,
        greedy: !0
      },
      string: {
        pattern: /"(?:[^"\\]|\\[\s\S])*"/,
        greedy: !0
      },
      atom: {
        pattern: /'(?:[^'\\]|\\[\s\S])*'/,
        greedy: !0,
        alias: "builtin"
      },
      keyword: /\$|\[\]|\b(?:_|at|attr|case|catch|choice|class|cond|declare|define|dis|else(?:case|if)?|end|export|fail|false|feat|finally|from|fun|functor|if|import|in|local|lock|meth|nil|not|of|or|prepare|proc|prop|raise|require|self|skip|then|thread|true|try|unit)\b/,
      function: [/\b[a-z][A-Za-z\d]*(?=\()/, {
        pattern: /(\{)[A-Z][A-Za-z\d]*\b/,
        lookbehind: !0
      }],
      number: /\b(?:0[bx][\da-f]+|\d+(?:\.\d*)?(?:e~?\d+)?)\b|&(?:[^\\]|\\(?:\d{3}|.))/i,
      variable: /`(?:[^`\\]|\\.)+`/,
      "attr-name": /\b\w+(?=[ \t]*:(?![:=]))/,
      operator: /:(?:=|::?)|<[-:=]?|=(?:=|<?:?)|>=?:?|\\=:?|!!?|[|#+\-*\/,~^@]|\b(?:andthen|div|mod|orelse)\b/,
      punctuation: /[\[\](){}.:;?]/
    };
  }
  return oz_1;
}
var parigp_1, hasRequiredParigp;
function requireParigp() {
  if (hasRequiredParigp) return parigp_1;
  hasRequiredParigp = 1, parigp_1 = e, e.displayName = "parigp", e.aliases = [];
  function e(t) {
    t.languages.parigp = {
      comment: /\/\*[\s\S]*?\*\/|\\\\.*/,
      string: {
        pattern: /"(?:[^"\\\r\n]|\\.)*"/,
        greedy: !0
      },
      // PARI/GP does not care about white spaces at all
      // so let's process the keywords to build an appropriate regexp
      // (e.g. "b *r *e *a *k", etc.)
      keyword: function() {
        var r = ["breakpoint", "break", "dbg_down", "dbg_err", "dbg_up", "dbg_x", "forcomposite", "fordiv", "forell", "forpart", "forprime", "forstep", "forsubgroup", "forvec", "for", "iferr", "if", "local", "my", "next", "return", "until", "while"];
        return r = r.map(function(a) {
          return a.split("").join(" *");
        }).join("|"), RegExp("\\b(?:" + r + ")\\b");
      }(),
      function: /\b\w(?:[\w ]*\w)?(?= *\()/,
      number: {
        // The lookbehind and the negative lookahead prevent from breaking the .. operator
        pattern: /((?:\. *\. *)?)(?:\b\d(?: *\d)*(?: *(?!\. *\.)\.(?: *\d)*)?|\. *\d(?: *\d)*)(?: *e *(?:[+-] *)?\d(?: *\d)*)?/i,
        lookbehind: !0
      },
      operator: /\. *\.|[*\/!](?: *=)?|%(?: *=|(?: *#)?(?: *')*)?|\+(?: *[+=])?|-(?: *[-=>])?|<(?: *>|(?: *<)?(?: *=)?)?|>(?: *>)?(?: *=)?|=(?: *=){0,2}|\\(?: *\/)?(?: *=)?|&(?: *&)?|\| *\||['#~^]/,
      punctuation: /[\[\]{}().,:;|]/
    };
  }
  return parigp_1;
}
var parser_1, hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return parser_1;
  hasRequiredParser = 1, parser_1 = e, e.displayName = "parser", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = r.languages.parser = r.languages.extend("markup", {
        keyword: {
          pattern: /(^|[^^])(?:\^(?:case|eval|for|if|switch|throw)\b|@(?:BASE|CLASS|GET(?:_DEFAULT)?|OPTIONS|SET_DEFAULT|USE)\b)/,
          lookbehind: !0
        },
        variable: {
          pattern: /(^|[^^])\B\$(?:\w+|(?=[.{]))(?:(?:\.|::?)\w+)*(?:\.|::?)?/,
          lookbehind: !0,
          inside: {
            punctuation: /\.|:+/
          }
        },
        function: {
          pattern: /(^|[^^])\B[@^]\w+(?:(?:\.|::?)\w+)*(?:\.|::?)?/,
          lookbehind: !0,
          inside: {
            keyword: {
              pattern: /(^@)(?:GET_|SET_)/,
              lookbehind: !0
            },
            punctuation: /\.|:+/
          }
        },
        escape: {
          pattern: /\^(?:[$^;@()\[\]{}"':]|#[a-f\d]*)/i,
          alias: "builtin"
        },
        punctuation: /[\[\](){};]/
      });
      a = r.languages.insertBefore("parser", "keyword", {
        "parser-comment": {
          pattern: /(\s)#.*/,
          lookbehind: !0,
          alias: "comment"
        },
        expression: {
          // Allow for 3 levels of depth
          pattern: /(^|[^^])\((?:[^()]|\((?:[^()]|\((?:[^()])*\))*\))*\)/,
          greedy: !0,
          lookbehind: !0,
          inside: {
            string: {
              pattern: /(^|[^^])(["'])(?:(?!\2)[^^]|\^[\s\S])*\2/,
              lookbehind: !0
            },
            keyword: a.keyword,
            variable: a.variable,
            function: a.function,
            boolean: /\b(?:false|true)\b/,
            number: /\b(?:0x[a-f\d]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?)\b/i,
            escape: a.escape,
            operator: /[~+*\/\\%]|!(?:\|\|?|=)?|&&?|\|\|?|==|<[<=]?|>[>=]?|-[fd]?|\b(?:def|eq|ge|gt|in|is|le|lt|ne)\b/,
            punctuation: a.punctuation
          }
        }
      }), r.languages.insertBefore("inside", "punctuation", {
        expression: a.expression,
        keyword: a.keyword,
        variable: a.variable,
        function: a.function,
        escape: a.escape,
        "parser-punctuation": {
          pattern: a.punctuation,
          alias: "punctuation"
        }
      }, a.tag.inside["attr-value"]);
    })(t);
  }
  return parser_1;
}
var pascal_1, hasRequiredPascal;
function requirePascal() {
  if (hasRequiredPascal) return pascal_1;
  hasRequiredPascal = 1, pascal_1 = e, e.displayName = "pascal", e.aliases = ["objectpascal"];
  function e(t) {
    t.languages.pascal = {
      directive: {
        pattern: /\{\$[\s\S]*?\}/,
        greedy: !0,
        alias: ["marco", "property"]
      },
      comment: {
        pattern: /\(\*[\s\S]*?\*\)|\{[\s\S]*?\}|\/\/.*/,
        greedy: !0
      },
      string: {
        pattern: /(?:'(?:''|[^'\r\n])*'(?!')|#[&$%]?[a-f\d]+)+|\^[a-z]/i,
        greedy: !0
      },
      asm: {
        pattern: /(\basm\b)[\s\S]+?(?=\bend\s*[;[])/i,
        lookbehind: !0,
        greedy: !0,
        inside: null
        // see below
      },
      keyword: [{
        // Turbo Pascal
        pattern: /(^|[^&])\b(?:absolute|array|asm|begin|case|const|constructor|destructor|do|downto|else|end|file|for|function|goto|if|implementation|inherited|inline|interface|label|nil|object|of|operator|packed|procedure|program|record|reintroduce|repeat|self|set|string|then|to|type|unit|until|uses|var|while|with)\b/i,
        lookbehind: !0
      }, {
        // Free Pascal
        pattern: /(^|[^&])\b(?:dispose|exit|false|new|true)\b/i,
        lookbehind: !0
      }, {
        // Object Pascal
        pattern: /(^|[^&])\b(?:class|dispinterface|except|exports|finalization|finally|initialization|inline|library|on|out|packed|property|raise|resourcestring|threadvar|try)\b/i,
        lookbehind: !0
      }, {
        // Modifiers
        pattern: /(^|[^&])\b(?:absolute|abstract|alias|assembler|bitpacked|break|cdecl|continue|cppdecl|cvar|default|deprecated|dynamic|enumerator|experimental|export|external|far|far16|forward|generic|helper|implements|index|interrupt|iochecks|local|message|name|near|nodefault|noreturn|nostackframe|oldfpccall|otherwise|overload|override|pascal|platform|private|protected|public|published|read|register|reintroduce|result|safecall|saveregisters|softfloat|specialize|static|stdcall|stored|strict|unaligned|unimplemented|varargs|virtual|write)\b/i,
        lookbehind: !0
      }],
      number: [
        // Hexadecimal, octal and binary
        /(?:[&%]\d+|\$[a-f\d]+)/i,
        // Decimal
        /\b\d+(?:\.\d+)?(?:e[+-]?\d+)?/i
      ],
      operator: [/\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=]/, {
        pattern: /(^|[^&])\b(?:and|as|div|exclude|in|include|is|mod|not|or|shl|shr|xor)\b/,
        lookbehind: !0
      }],
      punctuation: /\(\.|\.\)|[()\[\]:;,.]/
    }, t.languages.pascal.asm.inside = t.languages.extend("pascal", {
      asm: void 0,
      keyword: void 0,
      operator: void 0
    }), t.languages.objectpascal = t.languages.pascal;
  }
  return pascal_1;
}
var pascaligo_1, hasRequiredPascaligo;
function requirePascaligo() {
  if (hasRequiredPascaligo) return pascaligo_1;
  hasRequiredPascaligo = 1, pascaligo_1 = e, e.displayName = "pascaligo", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = /\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\)/.source, o = /(?:\b\w+(?:<braces>)?|<braces>)/.source.replace(/<braces>/g, function() {
        return a;
      }), u = r.languages.pascaligo = {
        comment: /\(\*[\s\S]+?\*\)|\/\/.*/,
        string: {
          pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1|\^[a-z]/i,
          greedy: !0
        },
        "class-name": [{
          pattern: RegExp(/(\btype\s+\w+\s+is\s+)<type>/.source.replace(/<type>/g, function() {
            return o;
          }), "i"),
          lookbehind: !0,
          inside: null
          // see below
        }, {
          pattern: RegExp(/<type>(?=\s+is\b)/.source.replace(/<type>/g, function() {
            return o;
          }), "i"),
          inside: null
          // see below
        }, {
          pattern: RegExp(/(:\s*)<type>/.source.replace(/<type>/g, function() {
            return o;
          })),
          lookbehind: !0,
          inside: null
          // see below
        }],
        keyword: {
          pattern: /(^|[^&])\b(?:begin|block|case|const|else|end|fail|for|from|function|if|is|nil|of|remove|return|skip|then|type|var|while|with)\b/i,
          lookbehind: !0
        },
        boolean: {
          pattern: /(^|[^&])\b(?:False|True)\b/i,
          lookbehind: !0
        },
        builtin: {
          pattern: /(^|[^&])\b(?:bool|int|list|map|nat|record|string|unit)\b/i,
          lookbehind: !0
        },
        function: /\b\w+(?=\s*\()/,
        number: [
          // Hexadecimal, octal and binary
          /%[01]+|&[0-7]+|\$[a-f\d]+/i,
          // Decimal
          /\b\d+(?:\.\d+)?(?:e[+-]?\d+)?(?:mtz|n)?/i
        ],
        operator: /->|=\/=|\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=|]|\b(?:and|mod|or)\b/,
        punctuation: /\(\.|\.\)|[()\[\]:;,.{}]/
      }, c = ["comment", "keyword", "builtin", "operator", "punctuation"].reduce(function(d, g) {
        return d[g] = u[g], d;
      }, {});
      u["class-name"].forEach(function(d) {
        d.inside = c;
      });
    })(t);
  }
  return pascaligo_1;
}
var pcaxis_1, hasRequiredPcaxis;
function requirePcaxis() {
  if (hasRequiredPcaxis) return pcaxis_1;
  hasRequiredPcaxis = 1, pcaxis_1 = e, e.displayName = "pcaxis", e.aliases = ["px"];
  function e(t) {
    t.languages.pcaxis = {
      string: /"[^"]*"/,
      keyword: {
        pattern: /((?:^|;)\s*)[-A-Z\d]+(?:\s*\[[-\w]+\])?(?:\s*\("[^"]*"(?:,\s*"[^"]*")*\))?(?=\s*=)/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          keyword: /^[-A-Z\d]+/,
          language: {
            pattern: /^(\s*)\[[-\w]+\]/,
            lookbehind: !0,
            inside: {
              punctuation: /^\[|\]$/,
              property: /[-\w]+/
            }
          },
          "sub-key": {
            pattern: /^(\s*)\S[\s\S]*/,
            lookbehind: !0,
            inside: {
              parameter: {
                pattern: /"[^"]*"/,
                alias: "property"
              },
              punctuation: /^\(|\)$|,/
            }
          }
        }
      },
      operator: /=/,
      tlist: {
        pattern: /TLIST\s*\(\s*\w+(?:(?:\s*,\s*"[^"]*")+|\s*,\s*"[^"]*"-"[^"]*")?\s*\)/,
        greedy: !0,
        inside: {
          function: /^TLIST/,
          property: {
            pattern: /^(\s*\(\s*)\w+/,
            lookbehind: !0
          },
          string: /"[^"]*"/,
          punctuation: /[(),]/,
          operator: /-/
        }
      },
      punctuation: /[;,]/,
      number: {
        pattern: /(^|\s)\d+(?:\.\d+)?(?!\S)/,
        lookbehind: !0
      },
      boolean: /NO|YES/
    }, t.languages.px = t.languages.pcaxis;
  }
  return pcaxis_1;
}
var peoplecode_1, hasRequiredPeoplecode;
function requirePeoplecode() {
  if (hasRequiredPeoplecode) return peoplecode_1;
  hasRequiredPeoplecode = 1, peoplecode_1 = e, e.displayName = "peoplecode", e.aliases = ["pcode"];
  function e(t) {
    t.languages.peoplecode = {
      comment: RegExp([
        // C-style multiline comments
        /\/\*[\s\S]*?\*\//.source,
        // REM comments
        /\bREM[^;]*;/.source,
        // Nested <* *> comments
        /<\*(?:[^<*]|\*(?!>)|<(?!\*)|<\*(?:(?!\*>)[\s\S])*\*>)*\*>/.source,
        // /+ +/ comments
        /\/\+[\s\S]*?\+\//.source
      ].join("|")),
      string: {
        pattern: /'(?:''|[^'\r\n])*'(?!')|"(?:""|[^"\r\n])*"(?!")/,
        greedy: !0
      },
      variable: /%\w+/,
      "function-definition": {
        pattern: /((?:^|[^\w-])(?:function|method)\s+)\w+/i,
        lookbehind: !0,
        alias: "function"
      },
      "class-name": {
        pattern: /((?:^|[^-\w])(?:as|catch|class|component|create|extends|global|implements|instance|local|of|property|returns)\s+)\w+(?::\w+)*/i,
        lookbehind: !0,
        inside: {
          punctuation: /:/
        }
      },
      keyword: /\b(?:abstract|alias|as|catch|class|component|constant|create|declare|else|end-(?:class|evaluate|for|function|get|if|method|set|try|while)|evaluate|extends|for|function|get|global|if|implements|import|instance|library|local|method|null|of|out|peopleCode|private|program|property|protected|readonly|ref|repeat|returns?|set|step|then|throw|to|try|until|value|when(?:-other)?|while)\b/i,
      "operator-keyword": {
        pattern: /\b(?:and|not|or)\b/i,
        alias: "operator"
      },
      function: /[_a-z]\w*(?=\s*\()/i,
      boolean: /\b(?:false|true)\b/i,
      number: /\b\d+(?:\.\d+)?\b/,
      operator: /<>|[<>]=?|!=|\*\*|[-+*/|=@]/,
      punctuation: /[:.;,()[\]]/
    }, t.languages.pcode = t.languages.peoplecode;
  }
  return peoplecode_1;
}
var perl_1, hasRequiredPerl;
function requirePerl() {
  if (hasRequiredPerl) return perl_1;
  hasRequiredPerl = 1, perl_1 = e, e.displayName = "perl", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = /(?:\((?:[^()\\]|\\[\s\S])*\)|\{(?:[^{}\\]|\\[\s\S])*\}|\[(?:[^[\]\\]|\\[\s\S])*\]|<(?:[^<>\\]|\\[\s\S])*>)/.source;
      r.languages.perl = {
        comment: [{
          // POD
          pattern: /(^\s*)=\w[\s\S]*?=cut.*/m,
          lookbehind: !0,
          greedy: !0
        }, {
          pattern: /(^|[^\\$])#.*/,
          lookbehind: !0,
          greedy: !0
        }],
        // TODO Could be nice to handle Heredoc too.
        string: [
          {
            pattern: RegExp(/\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
              // q/.../
              /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
              // q a...a
              // eslint-disable-next-line regexp/strict
              /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
              // q(...)
              // q{...}
              // q[...]
              // q<...>
              a
            ].join("|") + ")"),
            greedy: !0
          },
          // "...", `...`
          {
            pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/,
            greedy: !0
          },
          // '...'
          // FIXME Multi-line single-quoted strings are not supported as they would break variables containing '
          {
            pattern: /'(?:[^'\\\r\n]|\\.)*'/,
            greedy: !0
          }
        ],
        regex: [
          {
            pattern: RegExp(/\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
              // m/.../
              /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
              // m a...a
              // eslint-disable-next-line regexp/strict
              /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
              // m(...)
              // m{...}
              // m[...]
              // m<...>
              a
            ].join("|") + ")" + /[msixpodualngc]*/.source),
            greedy: !0
          },
          // The lookbehinds prevent -s from breaking
          {
            pattern: RegExp(/(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
              // s/.../.../
              // eslint-disable-next-line regexp/strict
              /([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
              // s a...a...a
              // eslint-disable-next-line regexp/strict
              /([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/.source,
              // s(...)(...)
              // s{...}{...}
              // s[...][...]
              // s<...><...>
              // s(...)[...]
              a + /\s*/.source + a
            ].join("|") + ")" + /[msixpodualngcer]*/.source),
            lookbehind: !0,
            greedy: !0
          },
          // /.../
          // The look-ahead tries to prevent two divisions on
          // the same line from being highlighted as regex.
          // This does not support multi-line regex.
          {
            pattern: /\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\b))/,
            greedy: !0
          }
        ],
        // FIXME Not sure about the handling of ::, ', and #
        variable: [
          // ${^POSTMATCH}
          /[&*$@%]\{\^[A-Z]+\}/,
          // $^V
          /[&*$@%]\^[A-Z_]/,
          // ${...}
          /[&*$@%]#?(?=\{)/,
          // $foo
          /[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+(?![\w$]))+(?:::)*/,
          // $1
          /[&*$@%]\d+/,
          // $_, @_, %!
          // The negative lookahead prevents from breaking the %= operator
          /(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
        ],
        filehandle: {
          // <>, <FOO>, _
          pattern: /<(?![<=])\S*?>|\b_\b/,
          alias: "symbol"
        },
        "v-string": {
          // v1.2, 1.2.3
          pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
          alias: "string"
        },
        function: {
          pattern: /(\bsub[ \t]+)\w+/,
          lookbehind: !0
        },
        keyword: /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
        number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
        operator: /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\b/,
        punctuation: /[{}[\];(),:]/
      };
    })(t);
  }
  return perl_1;
}
var phpExtras_1, hasRequiredPhpExtras;
function requirePhpExtras() {
  if (hasRequiredPhpExtras) return phpExtras_1;
  hasRequiredPhpExtras = 1;
  var e = requirePhp();
  phpExtras_1 = t, t.displayName = "phpExtras", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.insertBefore("php", "variable", {
      this: {
        pattern: /\$this\b/,
        alias: "keyword"
      },
      global: /\$(?:GLOBALS|HTTP_RAW_POST_DATA|_(?:COOKIE|ENV|FILES|GET|POST|REQUEST|SERVER|SESSION)|argc|argv|http_response_header|php_errormsg)\b/,
      scope: {
        pattern: /\b[\w\\]+::/,
        inside: {
          keyword: /\b(?:parent|self|static)\b/,
          punctuation: /::|\\/
        }
      }
    });
  }
  return phpExtras_1;
}
var phpdoc_1, hasRequiredPhpdoc;
function requirePhpdoc() {
  if (hasRequiredPhpdoc) return phpdoc_1;
  hasRequiredPhpdoc = 1;
  var e = requirePhp(), t = requireJavadoclike();
  phpdoc_1 = r, r.displayName = "phpdoc", r.aliases = [];
  function r(a) {
    a.register(e), a.register(t), function(o) {
      var u = /(?:\b[a-zA-Z]\w*|[|\\[\]])+/.source;
      o.languages.phpdoc = o.languages.extend("javadoclike", {
        parameter: {
          pattern: RegExp("(@(?:global|param|property(?:-read|-write)?|var)\\s+(?:" + u + "\\s+)?)\\$\\w+"),
          lookbehind: !0
        }
      }), o.languages.insertBefore("phpdoc", "keyword", {
        "class-name": [{
          pattern: RegExp("(@(?:global|package|param|property(?:-read|-write)?|return|subpackage|throws|var)\\s+)" + u),
          lookbehind: !0,
          inside: {
            keyword: /\b(?:array|bool|boolean|callback|double|false|float|int|integer|mixed|null|object|resource|self|string|true|void)\b/,
            punctuation: /[|\\[\]()]/
          }
        }]
      }), o.languages.javadoclike.addSupport("php", o.languages.phpdoc);
    }(a);
  }
  return phpdoc_1;
}
var plsql_1, hasRequiredPlsql;
function requirePlsql() {
  if (hasRequiredPlsql) return plsql_1;
  hasRequiredPlsql = 1;
  var e = requireSql();
  plsql_1 = t, t.displayName = "plsql", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.plsql = r.languages.extend("sql", {
      comment: {
        pattern: /\/\*[\s\S]*?\*\/|--.*/,
        greedy: !0
      },
      // https://docs.oracle.com/en/database/oracle/oracle-database/21/lnpls/plsql-reserved-words-keywords.html
      keyword: /\b(?:A|ACCESSIBLE|ADD|AGENT|AGGREGATE|ALL|ALTER|AND|ANY|ARRAY|AS|ASC|AT|ATTRIBUTE|AUTHID|AVG|BEGIN|BETWEEN|BFILE_BASE|BINARY|BLOB_BASE|BLOCK|BODY|BOTH|BOUND|BULK|BY|BYTE|C|CALL|CALLING|CASCADE|CASE|CHAR|CHARACTER|CHARSET|CHARSETFORM|CHARSETID|CHAR_BASE|CHECK|CLOB_BASE|CLONE|CLOSE|CLUSTER|CLUSTERS|COLAUTH|COLLECT|COLUMNS|COMMENT|COMMIT|COMMITTED|COMPILED|COMPRESS|CONNECT|CONSTANT|CONSTRUCTOR|CONTEXT|CONTINUE|CONVERT|COUNT|CRASH|CREATE|CREDENTIAL|CURRENT|CURSOR|CUSTOMDATUM|DANGLING|DATA|DATE|DATE_BASE|DAY|DECLARE|DEFAULT|DEFINE|DELETE|DESC|DETERMINISTIC|DIRECTORY|DISTINCT|DOUBLE|DROP|DURATION|ELEMENT|ELSE|ELSIF|EMPTY|END|ESCAPE|EXCEPT|EXCEPTION|EXCEPTIONS|EXCLUSIVE|EXECUTE|EXISTS|EXIT|EXTERNAL|FETCH|FINAL|FIRST|FIXED|FLOAT|FOR|FORALL|FORCE|FROM|FUNCTION|GENERAL|GOTO|GRANT|GROUP|HASH|HAVING|HEAP|HIDDEN|HOUR|IDENTIFIED|IF|IMMEDIATE|IMMUTABLE|IN|INCLUDING|INDEX|INDEXES|INDICATOR|INDICES|INFINITE|INSERT|INSTANTIABLE|INT|INTERFACE|INTERSECT|INTERVAL|INTO|INVALIDATE|IS|ISOLATION|JAVA|LANGUAGE|LARGE|LEADING|LENGTH|LEVEL|LIBRARY|LIKE|LIKE2|LIKE4|LIKEC|LIMIT|LIMITED|LOCAL|LOCK|LONG|LOOP|MAP|MAX|MAXLEN|MEMBER|MERGE|MIN|MINUS|MINUTE|MOD|MODE|MODIFY|MONTH|MULTISET|MUTABLE|NAME|NAN|NATIONAL|NATIVE|NCHAR|NEW|NOCOMPRESS|NOCOPY|NOT|NOWAIT|NULL|NUMBER_BASE|OBJECT|OCICOLL|OCIDATE|OCIDATETIME|OCIDURATION|OCIINTERVAL|OCILOBLOCATOR|OCINUMBER|OCIRAW|OCIREF|OCIREFCURSOR|OCIROWID|OCISTRING|OCITYPE|OF|OLD|ON|ONLY|OPAQUE|OPEN|OPERATOR|OPTION|OR|ORACLE|ORADATA|ORDER|ORGANIZATION|ORLANY|ORLVARY|OTHERS|OUT|OVERLAPS|OVERRIDING|PACKAGE|PARALLEL_ENABLE|PARAMETER|PARAMETERS|PARENT|PARTITION|PASCAL|PERSISTABLE|PIPE|PIPELINED|PLUGGABLE|POLYMORPHIC|PRAGMA|PRECISION|PRIOR|PRIVATE|PROCEDURE|PUBLIC|RAISE|RANGE|RAW|READ|RECORD|REF|REFERENCE|RELIES_ON|REM|REMAINDER|RENAME|RESOURCE|RESULT|RESULT_CACHE|RETURN|RETURNING|REVERSE|REVOKE|ROLLBACK|ROW|SAMPLE|SAVE|SAVEPOINT|SB1|SB2|SB4|SECOND|SEGMENT|SELECT|SELF|SEPARATE|SEQUENCE|SERIALIZABLE|SET|SHARE|SHORT|SIZE|SIZE_T|SOME|SPARSE|SQL|SQLCODE|SQLDATA|SQLNAME|SQLSTATE|STANDARD|START|STATIC|STDDEV|STORED|STRING|STRUCT|STYLE|SUBMULTISET|SUBPARTITION|SUBSTITUTABLE|SUBTYPE|SUM|SYNONYM|TABAUTH|TABLE|TDO|THE|THEN|TIME|TIMESTAMP|TIMEZONE_ABBR|TIMEZONE_HOUR|TIMEZONE_MINUTE|TIMEZONE_REGION|TO|TRAILING|TRANSACTION|TRANSACTIONAL|TRUSTED|TYPE|UB1|UB2|UB4|UNDER|UNION|UNIQUE|UNPLUG|UNSIGNED|UNTRUSTED|UPDATE|USE|USING|VALIST|VALUE|VALUES|VARIABLE|VARIANCE|VARRAY|VARYING|VIEW|VIEWS|VOID|WHEN|WHERE|WHILE|WITH|WORK|WRAPPED|WRITE|YEAR|ZONE)\b/i,
      // https://docs.oracle.com/en/database/oracle/oracle-database/21/lnpls/plsql-language-fundamentals.html#GUID-96A42F7C-7A71-4B90-8255-CA9C8BD9722E
      operator: /:=?|=>|[<>^~!]=|\.\.|\|\||\*\*|[-+*/%<>=@]/
    }), r.languages.insertBefore("plsql", "operator", {
      label: {
        pattern: /<<\s*\w+\s*>>/,
        alias: "symbol"
      }
    });
  }
  return plsql_1;
}
var powerquery_1, hasRequiredPowerquery;
function requirePowerquery() {
  if (hasRequiredPowerquery) return powerquery_1;
  hasRequiredPowerquery = 1, powerquery_1 = e, e.displayName = "powerquery", e.aliases = [];
  function e(t) {
    t.languages.powerquery = {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
        lookbehind: !0,
        greedy: !0
      },
      "quoted-identifier": {
        pattern: /#"(?:[^"\r\n]|"")*"(?!")/,
        greedy: !0
      },
      string: {
        pattern: /(?:#!)?"(?:[^"\r\n]|"")*"(?!")/,
        greedy: !0
      },
      constant: [/\bDay\.(?:Friday|Monday|Saturday|Sunday|Thursday|Tuesday|Wednesday)\b/, /\bTraceLevel\.(?:Critical|Error|Information|Verbose|Warning)\b/, /\bOccurrence\.(?:All|First|Last)\b/, /\bOrder\.(?:Ascending|Descending)\b/, /\bRoundingMode\.(?:AwayFromZero|Down|ToEven|TowardZero|Up)\b/, /\bMissingField\.(?:Error|Ignore|UseNull)\b/, /\bQuoteStyle\.(?:Csv|None)\b/, /\bJoinKind\.(?:FullOuter|Inner|LeftAnti|LeftOuter|RightAnti|RightOuter)\b/, /\bGroupKind\.(?:Global|Local)\b/, /\bExtraValues\.(?:Error|Ignore|List)\b/, /\bJoinAlgorithm\.(?:Dynamic|LeftHash|LeftIndex|PairwiseHash|RightHash|RightIndex|SortMerge)\b/, /\bJoinSide\.(?:Left|Right)\b/, /\bPrecision\.(?:Decimal|Double)\b/, /\bRelativePosition\.From(?:End|Start)\b/, /\bTextEncoding\.(?:Ascii|BigEndianUnicode|Unicode|Utf16|Utf8|Windows)\b/, /\b(?:Any|Binary|Date|DateTime|DateTimeZone|Duration|Function|Int16|Int32|Int64|Int8|List|Logical|None|Number|Record|Table|Text|Time)\.Type\b/, /\bnull\b/],
      boolean: /\b(?:false|true)\b/,
      keyword: /\b(?:and|as|each|else|error|if|in|is|let|meta|not|nullable|optional|or|otherwise|section|shared|then|try|type)\b|#(?:binary|date|datetime|datetimezone|duration|infinity|nan|sections|shared|table|time)\b/,
      function: {
        pattern: /(^|[^#\w.])[a-z_][\w.]*(?=\s*\()/i,
        lookbehind: !0
      },
      "data-type": {
        pattern: /\b(?:any|anynonnull|binary|date|datetime|datetimezone|duration|function|list|logical|none|number|record|table|text|time)\b/,
        alias: "class-name"
      },
      number: {
        pattern: /\b0x[\da-f]+\b|(?:[+-]?(?:\b\d+\.)?\b\d+|[+-]\.\d+|(^|[^.])\B\.\d+)(?:e[+-]?\d+)?\b/i,
        lookbehind: !0
      },
      operator: /[-+*\/&?@^]|<(?:=>?|>)?|>=?|=>?|\.\.\.?/,
      punctuation: /[,;\[\](){}]/
    }, t.languages.pq = t.languages.powerquery, t.languages.mscript = t.languages.powerquery;
  }
  return powerquery_1;
}
var powershell_1, hasRequiredPowershell;
function requirePowershell() {
  if (hasRequiredPowershell) return powershell_1;
  hasRequiredPowershell = 1, powershell_1 = e, e.displayName = "powershell", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = r.languages.powershell = {
        comment: [{
          pattern: /(^|[^`])<#[\s\S]*?#>/,
          lookbehind: !0
        }, {
          pattern: /(^|[^`])#.*/,
          lookbehind: !0
        }],
        string: [{
          pattern: /"(?:`[\s\S]|[^`"])*"/,
          greedy: !0,
          inside: null
          // see below
        }, {
          pattern: /'(?:[^']|'')*'/,
          greedy: !0
        }],
        // Matches name spaces as well as casts, attribute decorators. Force starting with letter to avoid matching array indices
        // Supports two levels of nested brackets (e.g. `[OutputType([System.Collections.Generic.List[int]])]`)
        namespace: /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
        boolean: /\$(?:false|true)\b/i,
        variable: /\$\w+\b/,
        // Cmdlets and aliases. Aliases should come last, otherwise "write" gets preferred over "write-host" for example
        // Get-Command | ?{ $_.ModuleName -match "Microsoft.PowerShell.(Util|Core|Management)" }
        // Get-Alias | ?{ $_.ReferencedCommand.Module.Name -match "Microsoft.PowerShell.(Util|Core|Management)" }
        function: [/\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i, /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i],
        // per http://technet.microsoft.com/en-us/library/hh847744.aspx
        keyword: /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
        operator: {
          pattern: /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
          lookbehind: !0
        },
        punctuation: /[|{}[\];(),.]/
      };
      a.string[0].inside = {
        function: {
          // Allow for one level of nesting
          pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
          lookbehind: !0,
          inside: a
        },
        boolean: a.boolean,
        variable: a.variable
      };
    })(t);
  }
  return powershell_1;
}
var processing_1, hasRequiredProcessing;
function requireProcessing() {
  if (hasRequiredProcessing) return processing_1;
  hasRequiredProcessing = 1, processing_1 = e, e.displayName = "processing", e.aliases = [];
  function e(t) {
    t.languages.processing = t.languages.extend("clike", {
      keyword: /\b(?:break|case|catch|class|continue|default|else|extends|final|for|if|implements|import|new|null|private|public|return|static|super|switch|this|try|void|while)\b/,
      // Spaces are allowed between function name and parenthesis
      function: /\b\w+(?=\s*\()/,
      operator: /<[<=]?|>[>=]?|&&?|\|\|?|[%?]|[!=+\-*\/]=?/
    }), t.languages.insertBefore("processing", "number", {
      // Special case: XML is a type
      constant: /\b(?!XML\b)[A-Z][A-Z\d_]+\b/,
      type: {
        pattern: /\b(?:boolean|byte|char|color|double|float|int|[A-Z]\w*)\b/,
        alias: "class-name"
      }
    });
  }
  return processing_1;
}
var prolog_1, hasRequiredProlog;
function requireProlog() {
  if (hasRequiredProlog) return prolog_1;
  hasRequiredProlog = 1, prolog_1 = e, e.displayName = "prolog", e.aliases = [];
  function e(t) {
    t.languages.prolog = {
      // Syntax depends on the implementation
      comment: {
        pattern: /\/\*[\s\S]*?\*\/|%.*/,
        greedy: !0
      },
      // Depending on the implementation, strings may allow escaped newlines and quote-escape
      string: {
        pattern: /(["'])(?:\1\1|\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1(?!\1)/,
        greedy: !0
      },
      builtin: /\b(?:fx|fy|xf[xy]?|yfx?)\b/,
      // FIXME: Should we list all null-ary predicates (not followed by a parenthesis) like halt, trace, etc.?
      function: /\b[a-z]\w*(?:(?=\()|\/\d+)/,
      number: /\b\d+(?:\.\d*)?/,
      // Custom operators are allowed
      operator: /[:\\=><\-?*@\/;+^|!$.]+|\b(?:is|mod|not|xor)\b/,
      punctuation: /[(){}\[\],]/
    };
  }
  return prolog_1;
}
var promql_1, hasRequiredPromql;
function requirePromql() {
  if (hasRequiredPromql) return promql_1;
  hasRequiredPromql = 1, promql_1 = e, e.displayName = "promql", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = ["sum", "min", "max", "avg", "group", "stddev", "stdvar", "count", "count_values", "bottomk", "topk", "quantile"], o = ["on", "ignoring", "group_right", "group_left", "by", "without"], u = ["offset"], c = a.concat(o, u);
      r.languages.promql = {
        comment: {
          pattern: /(^[ \t]*)#.*/m,
          lookbehind: !0
        },
        "vector-match": {
          // Match the comma-separated label lists inside vector matching:
          pattern: new RegExp("((?:" + o.join("|") + ")\\s*)\\([^)]*\\)"),
          lookbehind: !0,
          inside: {
            "label-key": {
              pattern: /\b[^,]+\b/,
              alias: "attr-name"
            },
            punctuation: /[(),]/
          }
        },
        "context-labels": {
          pattern: /\{[^{}]*\}/,
          inside: {
            "label-key": {
              pattern: /\b[a-z_]\w*(?=\s*(?:=|![=~]))/,
              alias: "attr-name"
            },
            "label-value": {
              pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
              greedy: !0,
              alias: "attr-value"
            },
            punctuation: /\{|\}|=~?|![=~]|,/
          }
        },
        "context-range": [{
          pattern: /\[[\w\s:]+\]/,
          // [1m]
          inside: {
            punctuation: /\[|\]|:/,
            "range-duration": {
              pattern: /\b(?:\d+(?:[smhdwy]|ms))+\b/i,
              alias: "number"
            }
          }
        }, {
          pattern: /(\boffset\s+)\w+/,
          // offset 1m
          lookbehind: !0,
          inside: {
            "range-duration": {
              pattern: /\b(?:\d+(?:[smhdwy]|ms))+\b/i,
              alias: "number"
            }
          }
        }],
        keyword: new RegExp("\\b(?:" + c.join("|") + ")\\b", "i"),
        function: /\b[a-z_]\w*(?=\s*\()/i,
        number: /[-+]?(?:(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e[-+]?\d+)?\b|\b(?:0x[0-9a-f]+|nan|inf)\b)/i,
        operator: /[\^*/%+-]|==|!=|<=|<|>=|>|\b(?:and|or|unless)\b/i,
        punctuation: /[{};()`,.[\]]/
      };
    })(t);
  }
  return promql_1;
}
var properties_1, hasRequiredProperties;
function requireProperties() {
  if (hasRequiredProperties) return properties_1;
  hasRequiredProperties = 1, properties_1 = e, e.displayName = "properties", e.aliases = [];
  function e(t) {
    t.languages.properties = {
      comment: /^[ \t]*[#!].*$/m,
      "attr-value": {
        pattern: /(^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+(?: *[=:] *(?! )| ))(?:\\(?:\r\n|[\s\S])|[^\\\r\n])+/m,
        lookbehind: !0
      },
      "attr-name": /^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+(?= *[=:]| )/m,
      punctuation: /[=:]/
    };
  }
  return properties_1;
}
var protobuf_1, hasRequiredProtobuf;
function requireProtobuf() {
  if (hasRequiredProtobuf) return protobuf_1;
  hasRequiredProtobuf = 1, protobuf_1 = e, e.displayName = "protobuf", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = /\b(?:bool|bytes|double|s?fixed(?:32|64)|float|[su]?int(?:32|64)|string)\b/;
      r.languages.protobuf = r.languages.extend("clike", {
        "class-name": [{
          pattern: /(\b(?:enum|extend|message|service)\s+)[A-Za-z_]\w*(?=\s*\{)/,
          lookbehind: !0
        }, {
          pattern: /(\b(?:rpc\s+\w+|returns)\s*\(\s*(?:stream\s+)?)\.?[A-Za-z_]\w*(?:\.[A-Za-z_]\w*)*(?=\s*\))/,
          lookbehind: !0
        }],
        keyword: /\b(?:enum|extend|extensions|import|message|oneof|option|optional|package|public|repeated|required|reserved|returns|rpc(?=\s+\w)|service|stream|syntax|to)\b(?!\s*=\s*\d)/,
        function: /\b[a-z_]\w*(?=\s*\()/i
      }), r.languages.insertBefore("protobuf", "operator", {
        map: {
          pattern: /\bmap<\s*[\w.]+\s*,\s*[\w.]+\s*>(?=\s+[a-z_]\w*\s*[=;])/i,
          alias: "class-name",
          inside: {
            punctuation: /[<>.,]/,
            builtin: a
          }
        },
        builtin: a,
        "positional-class-name": {
          pattern: /(?:\b|\B\.)[a-z_]\w*(?:\.[a-z_]\w*)*(?=\s+[a-z_]\w*\s*[=;])/i,
          alias: "class-name",
          inside: {
            punctuation: /\./
          }
        },
        annotation: {
          pattern: /(\[\s*)[a-z_]\w*(?=\s*=)/i,
          lookbehind: !0
        }
      });
    })(t);
  }
  return protobuf_1;
}
var psl_1, hasRequiredPsl;
function requirePsl() {
  if (hasRequiredPsl) return psl_1;
  hasRequiredPsl = 1, psl_1 = e, e.displayName = "psl", e.aliases = [];
  function e(t) {
    t.languages.psl = {
      comment: {
        pattern: /#.*/,
        greedy: !0
      },
      string: {
        pattern: /"(?:\\.|[^\\"])*"/,
        greedy: !0,
        inside: {
          symbol: /\\[ntrbA-Z"\\]/
        }
      },
      "heredoc-string": {
        pattern: /<<<([a-zA-Z_]\w*)[\r\n](?:.*[\r\n])*?\1\b/,
        alias: "string",
        greedy: !0
      },
      keyword: /\b(?:__multi|__single|case|default|do|else|elsif|exit|export|for|foreach|function|if|last|line|local|next|requires|return|switch|until|while|word)\b/,
      constant: /\b(?:ALARM|CHART_ADD_GRAPH|CHART_DELETE_GRAPH|CHART_DESTROY|CHART_LOAD|CHART_PRINT|EOF|OFFLINE|OK|PSL_PROF_LOG|R_CHECK_HORIZ|R_CHECK_VERT|R_CLICKER|R_COLUMN|R_FRAME|R_ICON|R_LABEL|R_LABEL_CENTER|R_LIST_MULTIPLE|R_LIST_MULTIPLE_ND|R_LIST_SINGLE|R_LIST_SINGLE_ND|R_MENU|R_POPUP|R_POPUP_SCROLLED|R_RADIO_HORIZ|R_RADIO_VERT|R_ROW|R_SCALE_HORIZ|R_SCALE_VERT|R_SEP_HORIZ|R_SEP_VERT|R_SPINNER|R_TEXT_FIELD|R_TEXT_FIELD_LABEL|R_TOGGLE|TRIM_LEADING|TRIM_LEADING_AND_TRAILING|TRIM_REDUNDANT|TRIM_TRAILING|VOID|WARN)\b/,
      boolean: /\b(?:FALSE|False|NO|No|TRUE|True|YES|Yes|false|no|true|yes)\b/,
      variable: /\b(?:PslDebug|errno|exit_status)\b/,
      builtin: {
        pattern: /\b(?:PslExecute|PslFunctionCall|PslFunctionExists|PslSetOptions|_snmp_debug|acos|add_diary|annotate|annotate_get|ascii_to_ebcdic|asctime|asin|atan|atexit|batch_set|blackout|cat|ceil|chan_exists|change_state|close|code_cvt|cond_signal|cond_wait|console_type|convert_base|convert_date|convert_locale_date|cos|cosh|create|date|dcget_text|destroy|destroy_lock|dget_text|difference|dump_hist|ebcdic_to_ascii|encrypt|event_archive|event_catalog_get|event_check|event_query|event_range_manage|event_range_query|event_report|event_schedule|event_trigger|event_trigger2|execute|exists|exp|fabs|file|floor|fmod|fopen|fseek|ftell|full_discovery|get|get_chan_info|get_ranges|get_text|get_vars|getenv|gethostinfo|getpid|getpname|grep|history|history_get_retention|in_transition|index|int|internal|intersection|is_var|isnumber|join|kill|length|lines|lock|lock_info|log|log10|loge|matchline|msg_check|msg_get_format|msg_get_severity|msg_printf|msg_sprintf|ntharg|nthargf|nthline|nthlinef|num_bytes|num_consoles|pconfig|popen|poplines|pow|print|printf|proc_exists|process|random|read|readln|refresh_parameters|remote_check|remote_close|remote_event_query|remote_event_trigger|remote_file_send|remote_open|remove|replace|rindex|sec_check_priv|sec_store_get|sec_store_set|set|set_alarm_ranges|set_locale|share|sin|sinh|sleep|snmp_agent_config|snmp_agent_start|snmp_agent_stop|snmp_close|snmp_config|snmp_get|snmp_get_next|snmp_h_get|snmp_h_get_next|snmp_h_set|snmp_open|snmp_set|snmp_trap_ignore|snmp_trap_listen|snmp_trap_raise_std_trap|snmp_trap_receive|snmp_trap_register_im|snmp_trap_send|snmp_walk|sopen|sort|splitline|sprintf|sqrt|srandom|str_repeat|strcasecmp|subset|substr|system|tail|tan|tanh|text_domain|time|tmpnam|tolower|toupper|trace_psl_process|trim|union|unique|unlock|unset|va_arg|va_start|write)\b/,
        alias: "builtin-function"
      },
      "foreach-variable": {
        pattern: /(\bforeach\s+(?:(?:\w+\b|"(?:\\.|[^\\"])*")\s+){0,2})[_a-zA-Z]\w*(?=\s*\()/,
        lookbehind: !0,
        greedy: !0
      },
      function: /\b[_a-z]\w*\b(?=\s*\()/i,
      number: /\b(?:0x[0-9a-f]+|\d+(?:\.\d+)?)\b/i,
      operator: /--|\+\+|&&=?|\|\|=?|<<=?|>>=?|[=!]~|[-+*/%&|^!=<>]=?|\.|[:?]/,
      punctuation: /[(){}\[\];,]/
    };
  }
  return psl_1;
}
var pug_1, hasRequiredPug;
function requirePug() {
  if (hasRequiredPug) return pug_1;
  hasRequiredPug = 1, pug_1 = e, e.displayName = "pug", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.pug = {
        // Multiline stuff should appear before the rest
        // This handles both single-line and multi-line comments
        comment: {
          pattern: /(^([\t ]*))\/\/.*(?:(?:\r?\n|\r)\2[\t ].+)*/m,
          lookbehind: !0
        },
        // All the tag-related part is in lookbehind
        // so that it can be highlighted by the "tag" pattern
        "multiline-script": {
          pattern: /(^([\t ]*)script\b.*\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
          lookbehind: !0,
          inside: r.languages.javascript
        },
        // See at the end of the file for known filters
        filter: {
          pattern: /(^([\t ]*)):.+(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
          lookbehind: !0,
          inside: {
            "filter-name": {
              pattern: /^:[\w-]+/,
              alias: "variable"
            },
            text: /\S[\s\S]*/
          }
        },
        "multiline-plain-text": {
          pattern: /(^([\t ]*)[\w\-#.]+\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
          lookbehind: !0
        },
        markup: {
          pattern: /(^[\t ]*)<.+/m,
          lookbehind: !0,
          inside: r.languages.markup
        },
        doctype: {
          pattern: /((?:^|\n)[\t ]*)doctype(?: .+)?/,
          lookbehind: !0
        },
        // This handle all conditional and loop keywords
        "flow-control": {
          pattern: /(^[\t ]*)(?:case|default|each|else|if|unless|when|while)\b(?: .+)?/m,
          lookbehind: !0,
          inside: {
            each: {
              pattern: /^each .+? in\b/,
              inside: {
                keyword: /\b(?:each|in)\b/,
                punctuation: /,/
              }
            },
            branch: {
              pattern: /^(?:case|default|else|if|unless|when|while)\b/,
              alias: "keyword"
            },
            rest: r.languages.javascript
          }
        },
        keyword: {
          pattern: /(^[\t ]*)(?:append|block|extends|include|prepend)\b.+/m,
          lookbehind: !0
        },
        mixin: [
          // Declaration
          {
            pattern: /(^[\t ]*)mixin .+/m,
            lookbehind: !0,
            inside: {
              keyword: /^mixin/,
              function: /\w+(?=\s*\(|\s*$)/,
              punctuation: /[(),.]/
            }
          },
          // Usage
          {
            pattern: /(^[\t ]*)\+.+/m,
            lookbehind: !0,
            inside: {
              name: {
                pattern: /^\+\w+/,
                alias: "function"
              },
              rest: r.languages.javascript
            }
          }
        ],
        script: {
          pattern: /(^[\t ]*script(?:(?:&[^(]+)?\([^)]+\))*[\t ]).+/m,
          lookbehind: !0,
          inside: r.languages.javascript
        },
        "plain-text": {
          pattern: /(^[\t ]*(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?[\t ]).+/m,
          lookbehind: !0
        },
        tag: {
          pattern: /(^[\t ]*)(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?:?/m,
          lookbehind: !0,
          inside: {
            attributes: [{
              pattern: /&[^(]+\([^)]+\)/,
              inside: r.languages.javascript
            }, {
              pattern: /\([^)]+\)/,
              inside: {
                "attr-value": {
                  pattern: /(=\s*(?!\s))(?:\{[^}]*\}|[^,)\r\n]+)/,
                  lookbehind: !0,
                  inside: r.languages.javascript
                },
                "attr-name": /[\w-]+(?=\s*!?=|\s*[,)])/,
                punctuation: /[!=(),]+/
              }
            }],
            punctuation: /:/,
            "attr-id": /#[\w\-]+/,
            "attr-class": /\.[\w\-]+/
          }
        },
        code: [{
          pattern: /(^[\t ]*(?:-|!?=)).+/m,
          lookbehind: !0,
          inside: r.languages.javascript
        }],
        punctuation: /[.\-!=|]+/
      };
      for (var a = /(^([\t ]*)):<filter_name>(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/.source, o = [{
        filter: "atpl",
        language: "twig"
      }, {
        filter: "coffee",
        language: "coffeescript"
      }, "ejs", "handlebars", "less", "livescript", "markdown", {
        filter: "sass",
        language: "scss"
      }, "stylus"], u = {}, c = 0, d = o.length; c < d; c++) {
        var g = o[c];
        g = typeof g == "string" ? {
          filter: g,
          language: g
        } : g, r.languages[g.language] && (u["filter-" + g.filter] = {
          pattern: RegExp(a.replace("<filter_name>", function() {
            return g.filter;
          }), "m"),
          lookbehind: !0,
          inside: {
            "filter-name": {
              pattern: /^:[\w-]+/,
              alias: "variable"
            },
            text: {
              pattern: /\S[\s\S]*/,
              alias: [g.language, "language-" + g.language],
              inside: r.languages[g.language]
            }
          }
        });
      }
      r.languages.insertBefore("pug", "filter", u);
    })(t);
  }
  return pug_1;
}
var puppet_1, hasRequiredPuppet;
function requirePuppet() {
  if (hasRequiredPuppet) return puppet_1;
  hasRequiredPuppet = 1, puppet_1 = e, e.displayName = "puppet", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.puppet = {
        heredoc: [
          // Matches the content of a quoted heredoc string (subject to interpolation)
          {
            pattern: /(@\("([^"\r\n\/):]+)"(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r(?!\n)))*?[ \t]*(?:\|[ \t]*)?(?:-[ \t]*)?\2/,
            lookbehind: !0,
            alias: "string",
            inside: {
              // Matches the end tag
              punctuation: /(?=\S).*\S(?= *$)/
              // See interpolation below
            }
          },
          // Matches the content of an unquoted heredoc string (no interpolation)
          {
            pattern: /(@\(([^"\r\n\/):]+)(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r(?!\n)))*?[ \t]*(?:\|[ \t]*)?(?:-[ \t]*)?\2/,
            lookbehind: !0,
            greedy: !0,
            alias: "string",
            inside: {
              // Matches the end tag
              punctuation: /(?=\S).*\S(?= *$)/
            }
          },
          // Matches the start tag of heredoc strings
          {
            pattern: /@\("?(?:[^"\r\n\/):]+)"?(?:\/[nrts$uL]*)?\)/,
            alias: "string",
            inside: {
              punctuation: {
                pattern: /(\().+?(?=\))/,
                lookbehind: !0
              }
            }
          }
        ],
        "multiline-comment": {
          pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
          lookbehind: !0,
          greedy: !0,
          alias: "comment"
        },
        regex: {
          // Must be prefixed with the keyword "node" or a non-word char
          pattern: /((?:\bnode\s+|[~=\(\[\{,]\s*|[=+]>\s*|^\s*))\/(?:[^\/\\]|\\[\s\S])+\/(?:[imx]+\b|\B)/,
          lookbehind: !0,
          greedy: !0,
          inside: {
            // Extended regexes must have the x flag. They can contain single-line comments.
            "extended-regex": {
              pattern: /^\/(?:[^\/\\]|\\[\s\S])+\/[im]*x[im]*$/,
              inside: {
                comment: /#.*/
              }
            }
          }
        },
        comment: {
          pattern: /(^|[^\\])#.*/,
          lookbehind: !0,
          greedy: !0
        },
        string: {
          // Allow for one nested level of double quotes inside interpolation
          pattern: /(["'])(?:\$\{(?:[^'"}]|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}|\$(?!\{)|(?!\1)[^\\$]|\\[\s\S])*\1/,
          greedy: !0,
          inside: {
            "double-quoted": {
              pattern: /^"[\s\S]*"$/,
              inside: {
                // See interpolation below
              }
            }
          }
        },
        variable: {
          pattern: /\$(?:::)?\w+(?:::\w+)*/,
          inside: {
            punctuation: /::/
          }
        },
        "attr-name": /(?:\b\w+|\*)(?=\s*=>)/,
        function: [{
          pattern: /(\.)(?!\d)\w+/,
          lookbehind: !0
        }, /\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\b|\b(?!\d)\w+(?=\()/],
        number: /\b(?:0x[a-f\d]+|\d+(?:\.\d+)?(?:e-?\d+)?)\b/i,
        boolean: /\b(?:false|true)\b/,
        // Includes words reserved for future use
        keyword: /\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\b/,
        datatype: {
          pattern: /\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\b/,
          alias: "symbol"
        },
        operator: /=[=~>]?|![=~]?|<(?:<\|?|[=~|-])?|>[>=]?|->?|~>|\|>?>?|[*\/%+?]|\b(?:and|in|or)\b/,
        punctuation: /[\[\]{}().,;]|:+/
      };
      var a = [{
        // Allow for one nested level of braces inside interpolation
        pattern: /(^|[^\\])\$\{(?:[^'"{}]|\{[^}]*\}|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}/,
        lookbehind: !0,
        inside: {
          "short-variable": {
            // Negative look-ahead prevent wrong highlighting of functions
            pattern: /(^\$\{)(?!\w+\()(?:::)?\w+(?:::\w+)*/,
            lookbehind: !0,
            alias: "variable",
            inside: {
              punctuation: /::/
            }
          },
          delimiter: {
            pattern: /^\$/,
            alias: "variable"
          },
          rest: r.languages.puppet
        }
      }, {
        pattern: /(^|[^\\])\$(?:::)?\w+(?:::\w+)*/,
        lookbehind: !0,
        alias: "variable",
        inside: {
          punctuation: /::/
        }
      }];
      r.languages.puppet.heredoc[0].inside.interpolation = a, r.languages.puppet.string.inside["double-quoted"].inside.interpolation = a;
    })(t);
  }
  return puppet_1;
}
var pure_1, hasRequiredPure;
function requirePure() {
  if (hasRequiredPure) return pure_1;
  hasRequiredPure = 1, pure_1 = e, e.displayName = "pure", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.pure = {
        comment: [{
          pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
          lookbehind: !0
        }, {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0
        }, /#!.+/],
        "inline-lang": {
          pattern: /%<[\s\S]+?%>/,
          greedy: !0,
          inside: {
            lang: {
              pattern: /(^%< *)-\*-.+?-\*-/,
              lookbehind: !0,
              alias: "comment"
            },
            delimiter: {
              pattern: /^%<.*|%>$/,
              alias: "punctuation"
            }
          }
        },
        string: {
          pattern: /"(?:\\.|[^"\\\r\n])*"/,
          greedy: !0
        },
        number: {
          // The look-behind prevents wrong highlighting of the .. operator
          pattern: /((?:\.\.)?)(?:\b(?:inf|nan)\b|\b0x[\da-f]+|(?:\b(?:0b)?\d+(?:\.\d+)?|\B\.\d+)(?:e[+-]?\d+)?L?)/i,
          lookbehind: !0
        },
        keyword: /\b(?:NULL|ans|break|bt|case|catch|cd|clear|const|def|del|dump|else|end|exit|extern|false|force|help|if|infix[lr]?|interface|let|ls|mem|namespace|nonfix|of|otherwise|outfix|override|postfix|prefix|private|public|pwd|quit|run|save|show|stats|then|throw|trace|true|type|underride|using|when|with)\b/,
        function: /\b(?:abs|add_(?:addr|constdef|(?:fundef|interface|macdef|typedef)(?:_at)?|vardef)|all|any|applp?|arity|bigintp?|blob(?:_crc|_size|p)?|boolp?|byte_c?string(?:_pointer)?|byte_(?:matrix|pointer)|calloc|cat|catmap|ceil|char[ps]?|check_ptrtag|chr|clear_sentry|clearsym|closurep?|cmatrixp?|cols?|colcat(?:map)?|colmap|colrev|colvector(?:p|seq)?|complex(?:_float_(?:matrix|pointer)|_matrix(?:_view)?|_pointer|p)?|conj|cookedp?|cst|cstring(?:_(?:dup|list|vector))?|curry3?|cyclen?|del_(?:constdef|fundef|interface|macdef|typedef|vardef)|delete|diag(?:mat)?|dim|dmatrixp?|do|double(?:_matrix(?:_view)?|_pointer|p)?|dowith3?|drop|dropwhile|eval(?:cmd)?|exactp|filter|fix|fixity|flip|float(?:_matrix|_pointer)|floor|fold[lr]1?|frac|free|funp?|functionp?|gcd|get(?:_(?:byte|constdef|double|float|fundef|int(?:64)?|interface(?:_typedef)?|long|macdef|pointer|ptrtag|sentry|short|string|typedef|vardef))?|globsym|hash|head|id|im|imatrixp?|index|inexactp|infp|init|insert|int(?:_matrix(?:_view)?|_pointer|p)?|int64_(?:matrix|pointer)|integerp?|iteraten?|iterwhile|join|keys?|lambdap?|last(?:err(?:pos)?)?|lcd|list[2p]?|listmap|make_ptrtag|malloc|map|matcat|matrixp?|max|member|min|nanp|nargs|nmatrixp?|null|numberp?|ord|pack(?:ed)?|pointer(?:_cast|_tag|_type|p)?|pow|pred|ptrtag|put(?:_(?:byte|double|float|int(?:64)?|long|pointer|short|string))?|rationalp?|re|realp?|realloc|recordp?|redim|reduce(?:_with)?|refp?|repeatn?|reverse|rlistp?|round|rows?|rowcat(?:map)?|rowmap|rowrev|rowvector(?:p|seq)?|same|scan[lr]1?|sentry|sgn|short_(?:matrix|pointer)|slice|smatrixp?|sort|split|str|strcat|stream|stride|string(?:_(?:dup|list|vector)|p)?|subdiag(?:mat)?|submat|subseq2?|substr|succ|supdiag(?:mat)?|symbolp?|tail|take|takewhile|thunkp?|transpose|trunc|tuplep?|typep|ubyte|uint(?:64)?|ulong|uncurry3?|unref|unzip3?|update|ushort|vals?|varp?|vector(?:p|seq)?|void|zip3?|zipwith3?)\b/,
        special: {
          pattern: /\b__[a-z]+__\b/i,
          alias: "builtin"
        },
        // Any combination of operator chars can be an operator
        // eslint-disable-next-line no-misleading-character-class
        operator: /(?:[!"#$%&'*+,\-.\/:<=>?@\\^`|~\u00a1-\u00bf\u00d7-\u00f7\u20d0-\u2bff]|\b_+\b)+|\b(?:and|div|mod|not|or)\b/,
        // FIXME: How can we prevent | and , to be highlighted as operator when they are used alone?
        punctuation: /[(){}\[\];,|]/
      };
      var a = ["c", {
        lang: "c++",
        alias: "cpp"
      }, "fortran"], o = /%< *-\*- *<lang>\d* *-\*-[\s\S]+?%>/.source;
      a.forEach(function(u) {
        var c = u;
        if (typeof u != "string" && (c = u.alias, u = u.lang), r.languages[c]) {
          var d = {};
          d["inline-lang-" + c] = {
            pattern: RegExp(o.replace("<lang>", u.replace(/([.+*?\/\\(){}\[\]])/g, "\\$1")), "i"),
            inside: r.util.clone(r.languages.pure["inline-lang"].inside)
          }, d["inline-lang-" + c].inside.rest = r.util.clone(r.languages[c]), r.languages.insertBefore("pure", "inline-lang", d);
        }
      }), r.languages.c && (r.languages.pure["inline-lang"].inside.rest = r.util.clone(r.languages.c));
    })(t);
  }
  return pure_1;
}
var purebasic_1, hasRequiredPurebasic;
function requirePurebasic() {
  if (hasRequiredPurebasic) return purebasic_1;
  hasRequiredPurebasic = 1, purebasic_1 = e, e.displayName = "purebasic", e.aliases = [];
  function e(t) {
    t.languages.purebasic = t.languages.extend("clike", {
      comment: /;.*/,
      keyword: /\b(?:align|and|as|break|calldebugger|case|compilercase|compilerdefault|compilerelse|compilerelseif|compilerendif|compilerendselect|compilererror|compilerif|compilerselect|continue|data|datasection|debug|debuglevel|declare|declarec|declarecdll|declaredll|declaremodule|default|define|dim|disableasm|disabledebugger|disableexplicit|else|elseif|enableasm|enabledebugger|enableexplicit|end|enddatasection|enddeclaremodule|endenumeration|endif|endimport|endinterface|endmacro|endmodule|endprocedure|endselect|endstructure|endstructureunion|endwith|enumeration|extends|fakereturn|for|foreach|forever|global|gosub|goto|if|import|importc|includebinary|includefile|includepath|interface|macro|module|newlist|newmap|next|not|or|procedure|procedurec|procedurecdll|proceduredll|procedurereturn|protected|prototype|prototypec|read|redim|repeat|restore|return|runtime|select|shared|static|step|structure|structureunion|swap|threaded|to|until|wend|while|with|xincludefile|xor)\b/i,
      function: /\b\w+(?:\.\w+)?\s*(?=\()/,
      number: /(?:\$[\da-f]+|\b-?(?:\d+(?:\.\d+)?|\.\d+)(?:e[+-]?\d+)?)\b/i,
      operator: /(?:@\*?|\?|\*)\w+|-[>-]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|?\||[~^%?*/@]/
    }), t.languages.insertBefore("purebasic", "keyword", {
      tag: /#\w+\$?/,
      asm: {
        pattern: /(^[\t ]*)!.*/m,
        lookbehind: !0,
        alias: "tag",
        inside: {
          comment: /;.*/,
          string: {
            pattern: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
            greedy: !0
          },
          // Anonymous label references, i.e.: jmp @b
          "label-reference-anonymous": {
            pattern: /(!\s*j[a-z]+\s+)@[fb]/i,
            lookbehind: !0,
            alias: "fasm-label"
          },
          // Named label reference, i.e.: jne label1
          "label-reference-addressed": {
            pattern: /(!\s*j[a-z]+\s+)[A-Z._?$@][\w.?$@~#]*/i,
            lookbehind: !0,
            alias: "fasm-label"
          },
          keyword: [/\b(?:extern|global)\b[^;\r\n]*/i, /\b(?:CPU|DEFAULT|FLOAT)\b.*/],
          function: {
            pattern: /^([\t ]*!\s*)[\da-z]+(?=\s|$)/im,
            lookbehind: !0
          },
          "function-inline": {
            pattern: /(:\s*)[\da-z]+(?=\s)/i,
            lookbehind: !0,
            alias: "function"
          },
          label: {
            pattern: /^([\t ]*!\s*)[A-Za-z._?$@][\w.?$@~#]*(?=:)/m,
            lookbehind: !0,
            alias: "fasm-label"
          },
          register: /\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|di|si|sp)|[cdefgs]s|mm\d+)\b/i,
          number: /(?:\b|-|(?=\$))(?:0[hx](?:[\da-f]*\.)?[\da-f]+(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|(?:\d+(?:\.\d+)?|\.\d+)(?:\.?e[+-]?\d+)?[dt]?)\b/i,
          operator: /[\[\]*+\-/%<>=&|$!,.:]/
        }
      }
    }), delete t.languages.purebasic["class-name"], delete t.languages.purebasic.boolean, t.languages.pbfasm = t.languages.purebasic;
  }
  return purebasic_1;
}
var purescript_1, hasRequiredPurescript;
function requirePurescript() {
  if (hasRequiredPurescript) return purescript_1;
  hasRequiredPurescript = 1;
  var e = requireHaskell();
  purescript_1 = t, t.displayName = "purescript", t.aliases = ["purs"];
  function t(r) {
    r.register(e), r.languages.purescript = r.languages.extend("haskell", {
      keyword: /\b(?:ado|case|class|data|derive|do|else|forall|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\b|/,
      "import-statement": {
        // The imported or hidden names are not included in this import
        // statement. This is because we want to highlight those exactly like
        // we do for the names in the program.
        pattern: /(^[\t ]*)import\s+[A-Z][\w']*(?:\.[A-Z][\w']*)*(?:\s+as\s+[A-Z][\w']*(?:\.[A-Z][\w']*)*)?(?:\s+hiding\b)?/m,
        lookbehind: !0,
        inside: {
          keyword: /\b(?:as|hiding|import)\b/,
          punctuation: /\./
        }
      },
      // These are builtin functions only. Constructors are highlighted later as a constant.
      builtin: /\b(?:absurd|add|ap|append|apply|between|bind|bottom|clamp|compare|comparing|compose|conj|const|degree|discard|disj|div|eq|flap|flip|gcd|identity|ifM|join|lcm|liftA1|liftM1|map|max|mempty|min|mod|mul|negate|not|notEq|one|otherwise|recip|show|sub|top|unit|unless|unlessM|void|when|whenM|zero)\b/,
      operator: [
        // Infix operators
        r.languages.haskell.operator[0],
        // ASCII operators
        r.languages.haskell.operator[2],
        // All UTF16 Unicode operator symbols
        // This regex is equivalent to /(?=[\x80-\uFFFF])[\p{gc=Math_Symbol}\p{gc=Currency_Symbol}\p{Modifier_Symbol}\p{Other_Symbol}]/u
        // See https://github.com/PrismJS/prism/issues/3006 for more details.
        /[\xa2-\xa6\xa8\xa9\xac\xae-\xb1\xb4\xb8\xd7\xf7\u02c2-\u02c5\u02d2-\u02df\u02e5-\u02eb\u02ed\u02ef-\u02ff\u0375\u0384\u0385\u03f6\u0482\u058d-\u058f\u0606-\u0608\u060b\u060e\u060f\u06de\u06e9\u06fd\u06fe\u07f6\u07fe\u07ff\u09f2\u09f3\u09fa\u09fb\u0af1\u0b70\u0bf3-\u0bfa\u0c7f\u0d4f\u0d79\u0e3f\u0f01-\u0f03\u0f13\u0f15-\u0f17\u0f1a-\u0f1f\u0f34\u0f36\u0f38\u0fbe-\u0fc5\u0fc7-\u0fcc\u0fce\u0fcf\u0fd5-\u0fd8\u109e\u109f\u1390-\u1399\u166d\u17db\u1940\u19de-\u19ff\u1b61-\u1b6a\u1b74-\u1b7c\u1fbd\u1fbf-\u1fc1\u1fcd-\u1fcf\u1fdd-\u1fdf\u1fed-\u1fef\u1ffd\u1ffe\u2044\u2052\u207a-\u207c\u208a-\u208c\u20a0-\u20bf\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211e-\u2123\u2125\u2127\u2129\u212e\u213a\u213b\u2140-\u2144\u214a-\u214d\u214f\u218a\u218b\u2190-\u2307\u230c-\u2328\u232b-\u2426\u2440-\u244a\u249c-\u24e9\u2500-\u2767\u2794-\u27c4\u27c7-\u27e5\u27f0-\u2982\u2999-\u29d7\u29dc-\u29fb\u29fe-\u2b73\u2b76-\u2b95\u2b97-\u2bff\u2ce5-\u2cea\u2e50\u2e51\u2e80-\u2e99\u2e9b-\u2ef3\u2f00-\u2fd5\u2ff0-\u2ffb\u3004\u3012\u3013\u3020\u3036\u3037\u303e\u303f\u309b\u309c\u3190\u3191\u3196-\u319f\u31c0-\u31e3\u3200-\u321e\u322a-\u3247\u3250\u3260-\u327f\u328a-\u32b0\u32c0-\u33ff\u4dc0-\u4dff\ua490-\ua4c6\ua700-\ua716\ua720\ua721\ua789\ua78a\ua828-\ua82b\ua836-\ua839\uaa77-\uaa79\uab5b\uab6a\uab6b\ufb29\ufbb2-\ufbc1\ufdfc\ufdfd\ufe62\ufe64-\ufe66\ufe69\uff04\uff0b\uff1c-\uff1e\uff3e\uff40\uff5c\uff5e\uffe0-\uffe6\uffe8-\uffee\ufffc\ufffd]/
      ]
    }), r.languages.purs = r.languages.purescript;
  }
  return purescript_1;
}
var python_1, hasRequiredPython;
function requirePython() {
  if (hasRequiredPython) return python_1;
  hasRequiredPython = 1, python_1 = e, e.displayName = "python", e.aliases = ["py"];
  function e(t) {
    t.languages.python = {
      comment: {
        pattern: /(^|[^\\])#.*/,
        lookbehind: !0,
        greedy: !0
      },
      "string-interpolation": {
        pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
        greedy: !0,
        inside: {
          interpolation: {
            // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
            pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
            lookbehind: !0,
            inside: {
              "format-spec": {
                pattern: /(:)[^:(){}]+(?=\}$)/,
                lookbehind: !0
              },
              "conversion-option": {
                pattern: /![sra](?=[:}]$)/,
                alias: "punctuation"
              },
              rest: null
            }
          },
          string: /[\s\S]+/
        }
      },
      "triple-quoted-string": {
        pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
        greedy: !0,
        alias: "string"
      },
      string: {
        pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
        greedy: !0
      },
      function: {
        pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
        lookbehind: !0
      },
      "class-name": {
        pattern: /(\bclass\s+)\w+/i,
        lookbehind: !0
      },
      decorator: {
        pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
        lookbehind: !0,
        alias: ["annotation", "punctuation"],
        inside: {
          punctuation: /\./
        }
      },
      keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
      builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
      boolean: /\b(?:False|None|True)\b/,
      number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
      operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
      punctuation: /[{}[\];(),.:]/
    }, t.languages.python["string-interpolation"].inside.interpolation.inside.rest = t.languages.python, t.languages.py = t.languages.python;
  }
  return python_1;
}
var q_1, hasRequiredQ;
function requireQ() {
  if (hasRequiredQ) return q_1;
  hasRequiredQ = 1, q_1 = e, e.displayName = "q", e.aliases = [];
  function e(t) {
    t.languages.q = {
      string: /"(?:\\.|[^"\\\r\n])*"/,
      comment: [
        // From http://code.kx.com/wiki/Reference/Slash:
        // When / is following a space (or a right parenthesis, bracket, or brace), it is ignored with the rest of the line.
        {
          pattern: /([\t )\]}])\/.*/,
          lookbehind: !0,
          greedy: !0
        },
        // From http://code.kx.com/wiki/Reference/Slash:
        // A line which has / as its first character and contains at least one other non-whitespace character is a whole-line comment and is ignored entirely.
        // A / on a line by itself begins a multiline comment which is terminated by the next \ on a line by itself.
        // If a / is not matched by a \, the multiline comment is unterminated and continues to end of file.
        // The / and \ must be the first char on the line, but may be followed by any amount of whitespace.
        {
          pattern: /(^|\r?\n|\r)\/[\t ]*(?:(?:\r?\n|\r)(?:.*(?:\r?\n|\r(?!\n)))*?(?:\\(?=[\t ]*(?:\r?\n|\r))|$)|\S.*)/,
          lookbehind: !0,
          greedy: !0
        },
        // From http://code.kx.com/wiki/Reference/Slash:
        // A \ on a line by itself with no preceding matching / will comment to end of file.
        {
          pattern: /^\\[\t ]*(?:\r?\n|\r)[\s\S]+/m,
          greedy: !0
        },
        {
          pattern: /^#!.+/m,
          greedy: !0
        }
      ],
      symbol: /`(?::\S+|[\w.]*)/,
      datetime: {
        pattern: /0N[mdzuvt]|0W[dtz]|\d{4}\.\d\d(?:m|\.\d\d(?:T(?:\d\d(?::\d\d(?::\d\d(?:[.:]\d\d\d)?)?)?)?)?[dz]?)|\d\d:\d\d(?::\d\d(?:[.:]\d\d\d)?)?[uvt]?/,
        alias: "number"
      },
      // The negative look-ahead prevents bad highlighting
      // of verbs 0: and 1:
      number: /\b(?![01]:)(?:0N[hje]?|0W[hj]?|0[wn]|0x[\da-fA-F]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?[hjfeb]?)/,
      keyword: /\\\w+\b|\b(?:abs|acos|aj0?|all|and|any|asc|asin|asof|atan|attr|avgs?|binr?|by|ceiling|cols|cor|cos|count|cov|cross|csv|cut|delete|deltas|desc|dev|differ|distinct|div|do|dsave|ej|enlist|eval|except|exec|exit|exp|fby|fills|first|fkeys|flip|floor|from|get|getenv|group|gtime|hclose|hcount|hdel|hopen|hsym|iasc|identity|idesc|if|ij|in|insert|inter|inv|keys?|last|like|list|ljf?|load|log|lower|lsq|ltime|ltrim|mavg|maxs?|mcount|md5|mdev|med|meta|mins?|mmax|mmin|mmu|mod|msum|neg|next|not|null|or|over|parse|peach|pj|plist|prds?|prev|prior|rand|rank|ratios|raze|read0|read1|reciprocal|reval|reverse|rload|rotate|rsave|rtrim|save|scan|scov|sdev|select|set|setenv|show|signum|sin|sqrt|ssr?|string|sublist|sums?|sv|svar|system|tables|tan|til|trim|txf|type|uj|ungroup|union|update|upper|upsert|value|var|views?|vs|wavg|where|while|within|wj1?|wsum|ww|xasc|xbar|xcols?|xdesc|xexp|xgroup|xkey|xlog|xprev|xrank)\b/,
      adverb: {
        pattern: /['\/\\]:?|\beach\b/,
        alias: "function"
      },
      verb: {
        pattern: /(?:\B\.\B|\b[01]:|<[=>]?|>=?|[:+\-*%,!?~=|$&#@^]):?|\b_\b:?/,
        alias: "operator"
      },
      punctuation: /[(){}\[\];.]/
    };
  }
  return q_1;
}
var qml_1, hasRequiredQml;
function requireQml() {
  if (hasRequiredQml) return qml_1;
  hasRequiredQml = 1, qml_1 = e, e.displayName = "qml", e.aliases = [];
  function e(t) {
    (function(r) {
      for (var a = /"(?:\\.|[^\\"\r\n])*"|'(?:\\.|[^\\'\r\n])*'/.source, o = /\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))*\*\//.source, u = /(?:[^\\()[\]{}"'/]|<string>|\/(?![*/])|<comment>|\(<expr>*\)|\[<expr>*\]|\{<expr>*\}|\\[\s\S])/.source.replace(/<string>/g, function() {
        return a;
      }).replace(/<comment>/g, function() {
        return o;
      }), c = 0; c < 2; c++)
        u = u.replace(/<expr>/g, function() {
          return u;
        });
      u = u.replace(/<expr>/g, "[^\\s\\S]"), r.languages.qml = {
        comment: {
          pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
          greedy: !0
        },
        "javascript-function": {
          pattern: RegExp(/((?:^|;)[ \t]*)function\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*\(<js>*\)\s*\{<js>*\}/.source.replace(/<js>/g, function() {
            return u;
          }), "m"),
          lookbehind: !0,
          greedy: !0,
          alias: "language-javascript",
          inside: r.languages.javascript
        },
        "class-name": {
          pattern: /((?:^|[:;])[ \t]*)(?!\d)\w+(?=[ \t]*\{|[ \t]+on\b)/m,
          lookbehind: !0
        },
        property: [{
          pattern: /((?:^|[;{])[ \t]*)(?!\d)\w+(?:\.\w+)*(?=[ \t]*:)/m,
          lookbehind: !0
        }, {
          pattern: /((?:^|[;{])[ \t]*)property[ \t]+(?!\d)\w+(?:\.\w+)*[ \t]+(?!\d)\w+(?:\.\w+)*(?=[ \t]*:)/m,
          lookbehind: !0,
          inside: {
            keyword: /^property/,
            property: /\w+(?:\.\w+)*/
          }
        }],
        "javascript-expression": {
          pattern: RegExp(/(:[ \t]*)(?![\s;}[])(?:(?!$|[;}])<js>)+/.source.replace(/<js>/g, function() {
            return u;
          }), "m"),
          lookbehind: !0,
          greedy: !0,
          alias: "language-javascript",
          inside: r.languages.javascript
        },
        string: {
          pattern: /"(?:\\.|[^\\"\r\n])*"/,
          greedy: !0
        },
        keyword: /\b(?:as|import|on)\b/,
        punctuation: /[{}[\]:;,]/
      };
    })(t);
  }
  return qml_1;
}
var qore_1, hasRequiredQore;
function requireQore() {
  if (hasRequiredQore) return qore_1;
  hasRequiredQore = 1, qore_1 = e, e.displayName = "qore", e.aliases = [];
  function e(t) {
    t.languages.qore = t.languages.extend("clike", {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:\/\/|#).*)/,
        lookbehind: !0
      },
      // Overridden to allow unescaped multi-line strings
      string: {
        pattern: /("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,
        greedy: !0
      },
      keyword: /\b(?:abstract|any|assert|binary|bool|boolean|break|byte|case|catch|char|class|code|const|continue|data|default|do|double|else|enum|extends|final|finally|float|for|goto|hash|if|implements|import|inherits|instanceof|int|interface|long|my|native|new|nothing|null|object|our|own|private|reference|rethrow|return|short|soft(?:bool|date|float|int|list|number|string)|static|strictfp|string|sub|super|switch|synchronized|this|throw|throws|transient|try|void|volatile|while)\b/,
      boolean: /\b(?:false|true)\b/i,
      function: /\$?\b(?!\d)\w+(?=\()/,
      number: /\b(?:0b[01]+|0x(?:[\da-f]*\.)?[\da-fp\-]+|(?:\d+(?:\.\d+)?|\.\d+)(?:e\d+)?[df]|(?:\d+(?:\.\d+)?|\.\d+))\b/i,
      operator: {
        pattern: /(^|[^.])(?:\+[+=]?|-[-=]?|[!=](?:==?|~)?|>>?=?|<(?:=>?|<=?)?|&[&=]?|\|[|=]?|[*\/%^]=?|[~?])/,
        lookbehind: !0
      },
      variable: /\$(?!\d)\w+\b/
    });
  }
  return qore_1;
}
var qsharp_1, hasRequiredQsharp;
function requireQsharp() {
  if (hasRequiredQsharp) return qsharp_1;
  hasRequiredQsharp = 1, qsharp_1 = e, e.displayName = "qsharp", e.aliases = ["qs"];
  function e(t) {
    (function(r) {
      function a(v, C) {
        return v.replace(/<<(\d+)>>/g, function(R, I) {
          return "(?:" + C[+I] + ")";
        });
      }
      function o(v, C, R) {
        return RegExp(a(v, C), "");
      }
      function u(v, C) {
        for (var R = 0; R < C; R++)
          v = v.replace(/<<self>>/g, function() {
            return "(?:" + v + ")";
          });
        return v.replace(/<<self>>/g, "[^\\s\\S]");
      }
      var c = {
        // keywords which represent a return or variable type
        type: "Adj BigInt Bool Ctl Double false Int One Pauli PauliI PauliX PauliY PauliZ Qubit Range Result String true Unit Zero",
        // all other keywords
        other: "Adjoint adjoint apply as auto body borrow borrowing Controlled controlled distribute elif else fail fixup for function if in internal intrinsic invert is let mutable namespace new newtype open operation repeat return self set until use using while within"
      };
      function d(v) {
        return "\\b(?:" + v.trim().replace(/ /g, "|") + ")\\b";
      }
      var g = RegExp(d(c.type + " " + c.other)), b = /\b[A-Za-z_]\w*\b/.source, _ = a(/<<0>>(?:\s*\.\s*<<0>>)*/.source, [b]), y = {
        keyword: g,
        punctuation: /[<>()?,.:[\]]/
      }, A = /"(?:\\.|[^\\"])*"/.source;
      r.languages.qsharp = r.languages.extend("clike", {
        comment: /\/\/.*/,
        string: [{
          pattern: o(/(^|[^$\\])<<0>>/.source, [A]),
          lookbehind: !0,
          greedy: !0
        }],
        "class-name": [{
          // open Microsoft.Quantum.Canon;
          // open Microsoft.Quantum.Canon as CN;
          pattern: o(/(\b(?:as|open)\s+)<<0>>(?=\s*(?:;|as\b))/.source, [_]),
          lookbehind: !0,
          inside: y
        }, {
          // namespace Quantum.App1;
          pattern: o(/(\bnamespace\s+)<<0>>(?=\s*\{)/.source, [_]),
          lookbehind: !0,
          inside: y
        }],
        keyword: g,
        number: /(?:\b0(?:x[\da-f]+|b[01]+|o[0-7]+)|(?:\B\.\d+|\b\d+(?:\.\d*)?)(?:e[-+]?\d+)?)l?\b/i,
        operator: /\band=|\bor=|\band\b|\bnot\b|\bor\b|<[-=]|[-=]>|>>>=?|<<<=?|\^\^\^=?|\|\|\|=?|&&&=?|w\/=?|~~~|[*\/+\-^=!%]=?/,
        punctuation: /::|[{}[\];(),.:]/
      }), r.languages.insertBefore("qsharp", "number", {
        range: {
          pattern: /\.\./,
          alias: "operator"
        }
      });
      var E = u(a(/\{(?:[^"{}]|<<0>>|<<self>>)*\}/.source, [A]), 2);
      r.languages.insertBefore("qsharp", "string", {
        "interpolation-string": {
          pattern: o(/\$"(?:\\.|<<0>>|[^\\"{])*"/.source, [E]),
          greedy: !0,
          inside: {
            interpolation: {
              pattern: o(/((?:^|[^\\])(?:\\\\)*)<<0>>/.source, [E]),
              lookbehind: !0,
              inside: {
                punctuation: /^\{|\}$/,
                expression: {
                  pattern: /[\s\S]+/,
                  alias: "language-qsharp",
                  inside: r.languages.qsharp
                }
              }
            },
            string: /[\s\S]+/
          }
        }
      });
    })(t), t.languages.qs = t.languages.qsharp;
  }
  return qsharp_1;
}
var r_1, hasRequiredR;
function requireR() {
  if (hasRequiredR) return r_1;
  hasRequiredR = 1, r_1 = e, e.displayName = "r", e.aliases = [];
  function e(t) {
    t.languages.r = {
      comment: /#.*/,
      string: {
        pattern: /(['"])(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      "percent-operator": {
        // Includes user-defined operators
        // and %%, %*%, %/%, %in%, %o%, %x%
        pattern: /%[^%\s]*%/,
        alias: "operator"
      },
      boolean: /\b(?:FALSE|TRUE)\b/,
      ellipsis: /\.\.(?:\.|\d+)/,
      number: [/\b(?:Inf|NaN)\b/, /(?:\b0x[\dA-Fa-f]+(?:\.\d*)?|\b\d+(?:\.\d*)?|\B\.\d+)(?:[EePp][+-]?\d+)?[iL]?/],
      keyword: /\b(?:NA|NA_character_|NA_complex_|NA_integer_|NA_real_|NULL|break|else|for|function|if|in|next|repeat|while)\b/,
      operator: /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\|\|?|[+*\/^$@~]/,
      punctuation: /[(){}\[\],;]/
    };
  }
  return r_1;
}
var racket_1, hasRequiredRacket;
function requireRacket() {
  if (hasRequiredRacket) return racket_1;
  hasRequiredRacket = 1;
  var e = requireScheme();
  racket_1 = t, t.displayName = "racket", t.aliases = ["rkt"];
  function t(r) {
    r.register(e), r.languages.racket = r.languages.extend("scheme", {
      "lambda-parameter": {
        // the racket lambda syntax is a lot more complex, so we won't even attempt to capture it.
        // this will just prevent false positives of the `function` pattern
        pattern: /([(\[]lambda\s+[(\[])[^()\[\]'\s]+/,
        lookbehind: !0
      }
    }), r.languages.insertBefore("racket", "string", {
      lang: {
        pattern: /^#lang.+/m,
        greedy: !0,
        alias: "keyword"
      }
    }), r.languages.rkt = r.languages.racket;
  }
  return racket_1;
}
var reason_1, hasRequiredReason;
function requireReason() {
  if (hasRequiredReason) return reason_1;
  hasRequiredReason = 1, reason_1 = e, e.displayName = "reason", e.aliases = [];
  function e(t) {
    t.languages.reason = t.languages.extend("clike", {
      string: {
        pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
        greedy: !0
      },
      // 'class-name' must be matched *after* 'constructor' defined below
      "class-name": /\b[A-Z]\w*/,
      keyword: /\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/,
      operator: /\.{3}|:[:=]|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/
    }), t.languages.insertBefore("reason", "class-name", {
      char: {
        pattern: /'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/,
        greedy: !0
      },
      // Negative look-ahead prevents from matching things like String.capitalize
      constructor: /\b[A-Z]\w*\b(?!\s*\.)/,
      label: {
        pattern: /\b[a-z]\w*(?=::)/,
        alias: "symbol"
      }
    }), delete t.languages.reason.function;
  }
  return reason_1;
}
var regex_1, hasRequiredRegex;
function requireRegex() {
  if (hasRequiredRegex) return regex_1;
  hasRequiredRegex = 1, regex_1 = e, e.displayName = "regex", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = {
        pattern: /\\[\\(){}[\]^$+*?|.]/,
        alias: "escape"
      }, o = /\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/, u = {
        pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i,
        alias: "class-name"
      }, c = {
        pattern: /\\[wsd]|\\p\{[^{}]+\}/i,
        alias: "class-name"
      }, d = "(?:[^\\\\-]|" + o.source + ")", g = RegExp(d + "-" + d), b = {
        pattern: /(<|')[^<>']+(?=[>']$)/,
        lookbehind: !0,
        alias: "variable"
      };
      r.languages.regex = {
        "char-class": {
          pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/,
          lookbehind: !0,
          inside: {
            "char-class-negation": {
              pattern: /(^\[)\^/,
              lookbehind: !0,
              alias: "operator"
            },
            "char-class-punctuation": {
              pattern: /^\[|\]$/,
              alias: "punctuation"
            },
            range: {
              pattern: g,
              inside: {
                escape: o,
                "range-punctuation": {
                  pattern: /-/,
                  alias: "operator"
                }
              }
            },
            "special-escape": a,
            "char-set": c,
            escape: o
          }
        },
        "special-escape": a,
        "char-set": u,
        backreference: [{
          // a backreference which is not an octal escape
          pattern: /\\(?![123][0-7]{2})[1-9]/,
          alias: "keyword"
        }, {
          pattern: /\\k<[^<>']+>/,
          alias: "keyword",
          inside: {
            "group-name": b
          }
        }],
        anchor: {
          pattern: /[$^]|\\[ABbGZz]/,
          alias: "function"
        },
        escape: o,
        group: [{
          // https://docs.oracle.com/javase/10/docs/api/java/util/regex/Pattern.html
          // https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference?view=netframework-4.7.2#grouping-constructs
          // (), (?<name>), (?'name'), (?>), (?:), (?=), (?!), (?<=), (?<!), (?is-m), (?i-m:)
          pattern: /\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,
          alias: "punctuation",
          inside: {
            "group-name": b
          }
        }, {
          pattern: /\)/,
          alias: "punctuation"
        }],
        quantifier: {
          pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/,
          alias: "number"
        },
        alternation: {
          pattern: /\|/,
          alias: "keyword"
        }
      };
    })(t);
  }
  return regex_1;
}
var rego_1, hasRequiredRego;
function requireRego() {
  if (hasRequiredRego) return rego_1;
  hasRequiredRego = 1, rego_1 = e, e.displayName = "rego", e.aliases = [];
  function e(t) {
    t.languages.rego = {
      comment: /#.*/,
      property: {
        pattern: /(^|[^\\.])(?:"(?:\\.|[^\\"\r\n])*"|`[^`]*`|\b[a-z_]\w*\b)(?=\s*:(?!=))/i,
        lookbehind: !0,
        greedy: !0
      },
      string: {
        pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"|`[^`]*`/,
        lookbehind: !0,
        greedy: !0
      },
      keyword: /\b(?:as|default|else|import|not|null|package|set(?=\s*\()|some|with)\b/,
      boolean: /\b(?:false|true)\b/,
      function: {
        pattern: /\b[a-z_]\w*\b(?:\s*\.\s*\b[a-z_]\w*\b)*(?=\s*\()/i,
        inside: {
          namespace: /\b\w+\b(?=\s*\.)/,
          punctuation: /\./
        }
      },
      number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
      operator: /[-+*/%|&]|[<>:=]=?|!=|\b_\b/,
      punctuation: /[,;.\[\]{}()]/
    };
  }
  return rego_1;
}
var renpy_1, hasRequiredRenpy;
function requireRenpy() {
  if (hasRequiredRenpy) return renpy_1;
  hasRequiredRenpy = 1, renpy_1 = e, e.displayName = "renpy", e.aliases = ["rpy"];
  function e(t) {
    t.languages.renpy = {
      comment: {
        pattern: /(^|[^\\])#.+/,
        lookbehind: !0
      },
      string: {
        pattern: /("""|''')[\s\S]+?\1|("|')(?:\\.|(?!\2)[^\\])*\2|(?:^#?(?:(?:[0-9a-fA-F]){3}|[0-9a-fA-F]{6})$)/m,
        greedy: !0
      },
      function: /\b[a-z_]\w*(?=\()/i,
      property: /\b(?:Update|UpdateVersion|action|activate_sound|adv_nvl_transition|after_load_transition|align|alpha|alt|anchor|antialias|area|auto|background|bar_invert|bar_resizing|bar_vertical|black_color|bold|bottom_bar|bottom_gutter|bottom_margin|bottom_padding|box_reverse|box_wrap|can_update|caret|child|color|crop|default_afm_enable|default_afm_time|default_fullscreen|default_text_cps|developer|directory_name|drag_handle|drag_joined|drag_name|drag_raise|draggable|dragged|drop_shadow|drop_shadow_color|droppable|dropped|easein|easeout|edgescroll|end_game_transition|end_splash_transition|enter_replay_transition|enter_sound|enter_transition|enter_yesno_transition|executable_name|exit_replay_transition|exit_sound|exit_transition|exit_yesno_transition|fadein|fadeout|first_indent|first_spacing|fit_first|focus|focus_mask|font|foreground|game_main_transition|get_installed_packages|google_play_key|google_play_salt|ground|has_music|has_sound|has_voice|height|help|hinting|hover|hover_background|hover_color|hover_sound|hovered|hyperlink_functions|idle|idle_color|image_style|include_update|insensitive|insensitive_background|insensitive_color|inside|intra_transition|italic|justify|kerning|keyboard_focus|language|layer_clipping|layers|layout|left_bar|left_gutter|left_margin|left_padding|length|line_leading|line_overlap_split|line_spacing|linear|main_game_transition|main_menu_music|maximum|min_width|minimum|minwidth|modal|mouse|mousewheel|name|narrator_menu|newline_indent|nvl_adv_transition|offset|order_reverse|outlines|overlay_functions|pos|position|prefix|radius|range|rest_indent|right_bar|right_gutter|right_margin|right_padding|rotate|rotate_pad|ruby_style|sample_sound|save_directory|say_attribute_transition|screen_height|screen_width|scrollbars|selected_hover|selected_hover_color|selected_idle|selected_idle_color|selected_insensitive|show_side_image|show_two_window|side_spacing|side_xpos|side_ypos|size|size_group|slow_cps|slow_cps_multiplier|spacing|strikethrough|subpixel|text_align|text_style|text_xpos|text_y_fudge|text_ypos|thumb|thumb_offset|thumb_shadow|thumbnail_height|thumbnail_width|time|top_bar|top_gutter|top_margin|top_padding|translations|underline|unscrollable|update|value|version|version_name|version_tuple|vertical|width|window_hide_transition|window_icon|window_left_padding|window_show_transition|window_title|windows_icon|xadjustment|xalign|xanchor|xanchoraround|xaround|xcenter|xfill|xinitial|xmargin|xmaximum|xminimum|xoffset|xofsset|xpadding|xpos|xsize|xzoom|yadjustment|yalign|yanchor|yanchoraround|yaround|ycenter|yfill|yinitial|ymargin|ymaximum|yminimum|yoffset|ypadding|ypos|ysize|ysizexysize|yzoom|zoom|zorder)\b/,
      tag: /\b(?:bar|block|button|buttoscreenn|drag|draggroup|fixed|frame|grid|[hv]box|hotbar|hotspot|image|imagebutton|imagemap|input|key|label|menu|mm_menu_frame|mousearea|nvl|parallel|screen|self|side|tag|text|textbutton|timer|vbar|viewport|window)\b|\$/,
      keyword: /\b(?:None|add|adjustment|alignaround|allow|angle|animation|around|as|assert|behind|box_layout|break|build|cache|call|center|changed|child_size|choice|circles|class|clear|clicked|clipping|clockwise|config|contains|continue|corner1|corner2|counterclockwise|def|default|define|del|delay|disabled|disabled_text|dissolve|elif|else|event|except|exclude|exec|expression|fade|finally|for|from|function|global|gm_root|has|hide|id|if|import|in|init|is|jump|knot|lambda|left|less_rounded|mm_root|movie|music|null|on|onlayer|pass|pause|persistent|play|print|python|queue|raise|random|renpy|repeat|return|right|rounded_window|scene|scope|set|show|slow|slow_abortable|slow_done|sound|stop|store|style|style_group|substitute|suffix|theme|transform|transform_anchor|transpose|try|ui|unhovered|updater|use|voice|while|widget|widget_hover|widget_selected|widget_text|yield)\b/,
      boolean: /\b(?:[Ff]alse|[Tt]rue)\b/,
      number: /(?:\b(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?)|\B\.\d+)(?:e[+-]?\d+)?j?/i,
      operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:and|at|not|or|with)\b/,
      punctuation: /[{}[\];(),.:]/
    }, t.languages.rpy = t.languages.renpy;
  }
  return renpy_1;
}
var rest_1, hasRequiredRest;
function requireRest() {
  if (hasRequiredRest) return rest_1;
  hasRequiredRest = 1, rest_1 = e, e.displayName = "rest", e.aliases = [];
  function e(t) {
    t.languages.rest = {
      table: [{
        pattern: /(^[\t ]*)(?:\+[=-]+)+\+(?:\r?\n|\r)(?:\1[+|].+[+|](?:\r?\n|\r))+\1(?:\+[=-]+)+\+/m,
        lookbehind: !0,
        inside: {
          punctuation: /\||(?:\+[=-]+)+\+/
        }
      }, {
        pattern: /(^[\t ]*)=+ [ =]*=(?:(?:\r?\n|\r)\1.+)+(?:\r?\n|\r)\1=+ [ =]*=(?=(?:\r?\n|\r){2}|\s*$)/m,
        lookbehind: !0,
        inside: {
          punctuation: /[=-]+/
        }
      }],
      // Directive-like patterns
      "substitution-def": {
        pattern: /(^[\t ]*\.\. )\|(?:[^|\s](?:[^|]*[^|\s])?)\| [^:]+::/m,
        lookbehind: !0,
        inside: {
          substitution: {
            pattern: /^\|(?:[^|\s]|[^|\s][^|]*[^|\s])\|/,
            alias: "attr-value",
            inside: {
              punctuation: /^\||\|$/
            }
          },
          directive: {
            pattern: /( )(?! )[^:]+::/,
            lookbehind: !0,
            alias: "function",
            inside: {
              punctuation: /::$/
            }
          }
        }
      },
      "link-target": [{
        pattern: /(^[\t ]*\.\. )\[[^\]]+\]/m,
        lookbehind: !0,
        alias: "string",
        inside: {
          punctuation: /^\[|\]$/
        }
      }, {
        pattern: /(^[\t ]*\.\. )_(?:`[^`]+`|(?:[^:\\]|\\.)+):/m,
        lookbehind: !0,
        alias: "string",
        inside: {
          punctuation: /^_|:$/
        }
      }],
      directive: {
        pattern: /(^[\t ]*\.\. )[^:]+::/m,
        lookbehind: !0,
        alias: "function",
        inside: {
          punctuation: /::$/
        }
      },
      comment: {
        // The two alternatives try to prevent highlighting of blank comments
        pattern: /(^[\t ]*\.\.)(?:(?: .+)?(?:(?:\r?\n|\r).+)+| .+)(?=(?:\r?\n|\r){2}|$)/m,
        lookbehind: !0
      },
      title: [
        // Overlined and underlined
        {
          pattern: /^(([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+)(?:\r?\n|\r).+(?:\r?\n|\r)\1$/m,
          inside: {
            punctuation: /^[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+|[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,
            important: /.+/
          }
        },
        // Underlined only
        {
          pattern: /(^|(?:\r?\n|\r){2}).+(?:\r?\n|\r)([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+(?=\r?\n|\r|$)/,
          lookbehind: !0,
          inside: {
            punctuation: /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,
            important: /.+/
          }
        }
      ],
      hr: {
        pattern: /((?:\r?\n|\r){2})([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2{3,}(?=(?:\r?\n|\r){2})/,
        lookbehind: !0,
        alias: "punctuation"
      },
      field: {
        pattern: /(^[\t ]*):[^:\r\n]+:(?= )/m,
        lookbehind: !0,
        alias: "attr-name"
      },
      "command-line-option": {
        pattern: /(^[\t ]*)(?:[+-][a-z\d]|(?:--|\/)[a-z\d-]+)(?:[ =](?:[a-z][\w-]*|<[^<>]+>))?(?:, (?:[+-][a-z\d]|(?:--|\/)[a-z\d-]+)(?:[ =](?:[a-z][\w-]*|<[^<>]+>))?)*(?=(?:\r?\n|\r)? {2,}\S)/im,
        lookbehind: !0,
        alias: "symbol"
      },
      "literal-block": {
        pattern: /::(?:\r?\n|\r){2}([ \t]+)(?![ \t]).+(?:(?:\r?\n|\r)\1.+)*/,
        inside: {
          "literal-block-punctuation": {
            pattern: /^::/,
            alias: "punctuation"
          }
        }
      },
      "quoted-literal-block": {
        pattern: /::(?:\r?\n|\r){2}([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]).*(?:(?:\r?\n|\r)\1.*)*/,
        inside: {
          "literal-block-punctuation": {
            pattern: /^(?:::|([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\1*)/m,
            alias: "punctuation"
          }
        }
      },
      "list-bullet": {
        pattern: /(^[\t ]*)(?:[*+\-]|\(?(?:\d+|[a-z]|[ivxdclm]+)\)|(?:\d+|[a-z]|[ivxdclm]+)\.)(?= )/im,
        lookbehind: !0,
        alias: "punctuation"
      },
      "doctest-block": {
        pattern: /(^[\t ]*)>>> .+(?:(?:\r?\n|\r).+)*/m,
        lookbehind: !0,
        inside: {
          punctuation: /^>>>/
        }
      },
      inline: [{
        pattern: /(^|[\s\-:\/'"<(\[{])(?::[^:]+:`.*?`|`.*?`:[^:]+:|(\*\*?|``?|\|)(?!\s)(?:(?!\2).)*\S\2(?=[\s\-.,:;!?\\\/'")\]}]|$))/m,
        lookbehind: !0,
        inside: {
          bold: {
            pattern: /(^\*\*).+(?=\*\*$)/,
            lookbehind: !0
          },
          italic: {
            pattern: /(^\*).+(?=\*$)/,
            lookbehind: !0
          },
          "inline-literal": {
            pattern: /(^``).+(?=``$)/,
            lookbehind: !0,
            alias: "symbol"
          },
          role: {
            pattern: /^:[^:]+:|:[^:]+:$/,
            alias: "function",
            inside: {
              punctuation: /^:|:$/
            }
          },
          "interpreted-text": {
            pattern: /(^`).+(?=`$)/,
            lookbehind: !0,
            alias: "attr-value"
          },
          substitution: {
            pattern: /(^\|).+(?=\|$)/,
            lookbehind: !0,
            alias: "attr-value"
          },
          punctuation: /\*\*?|``?|\|/
        }
      }],
      link: [{
        pattern: /\[[^\[\]]+\]_(?=[\s\-.,:;!?\\\/'")\]}]|$)/,
        alias: "string",
        inside: {
          punctuation: /^\[|\]_$/
        }
      }, {
        pattern: /(?:\b[a-z\d]+(?:[_.:+][a-z\d]+)*_?_|`[^`]+`_?_|_`[^`]+`)(?=[\s\-.,:;!?\\\/'")\]}]|$)/i,
        alias: "string",
        inside: {
          punctuation: /^_?`|`$|`?_?_$/
        }
      }],
      // Line block start,
      // quote attribution,
      // explicit markup start,
      // and anonymous hyperlink target shortcut (__)
      punctuation: {
        pattern: /(^[\t ]*)(?:\|(?= |$)|(?:---?||\.\.|__)(?= )|\.\.$)/m,
        lookbehind: !0
      }
    };
  }
  return rest_1;
}
var rip_1, hasRequiredRip;
function requireRip() {
  if (hasRequiredRip) return rip_1;
  hasRequiredRip = 1, rip_1 = e, e.displayName = "rip", e.aliases = [];
  function e(t) {
    t.languages.rip = {
      comment: {
        pattern: /#.*/,
        greedy: !0
      },
      char: {
        pattern: /\B`[^\s`'",.:;#\/\\()<>\[\]{}]\b/,
        greedy: !0
      },
      string: {
        pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      regex: {
        pattern: /(^|[^/])\/(?!\/)(?:\[[^\n\r\]]*\]|\\.|[^/\\\r\n\[])+\/(?=\s*(?:$|[\r\n,.;})]))/,
        lookbehind: !0,
        greedy: !0
      },
      keyword: /(?:=>|->)|\b(?:case|catch|class|else|exit|finally|if|raise|return|switch|try)\b/,
      builtin: /@|\bSystem\b/,
      boolean: /\b(?:false|true)\b/,
      date: /\b\d{4}-\d{2}-\d{2}\b/,
      time: /\b\d{2}:\d{2}:\d{2}\b/,
      datetime: /\b\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\b/,
      symbol: /:[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/,
      number: /[+-]?\b(?:\d+\.\d+|\d+)\b/,
      punctuation: /(?:\.{2,3})|[`,.:;=\/\\()<>\[\]{}]/,
      reference: /[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/
    };
  }
  return rip_1;
}
var roboconf_1, hasRequiredRoboconf;
function requireRoboconf() {
  if (hasRequiredRoboconf) return roboconf_1;
  hasRequiredRoboconf = 1, roboconf_1 = e, e.displayName = "roboconf", e.aliases = [];
  function e(t) {
    t.languages.roboconf = {
      comment: /#.*/,
      keyword: {
        pattern: /(^|\s)(?:(?:external|import)\b|(?:facet|instance of)(?=[ \t]+[\w-]+[ \t]*\{))/,
        lookbehind: !0
      },
      component: {
        pattern: /[\w-]+(?=[ \t]*\{)/,
        alias: "variable"
      },
      property: /[\w.-]+(?=[ \t]*:)/,
      value: {
        pattern: /(=[ \t]*(?![ \t]))[^,;]+/,
        lookbehind: !0,
        alias: "attr-value"
      },
      optional: {
        pattern: /\(optional\)/,
        alias: "builtin"
      },
      wildcard: {
        pattern: /(\.)\*/,
        lookbehind: !0,
        alias: "operator"
      },
      punctuation: /[{},.;:=]/
    };
  }
  return roboconf_1;
}
var robotframework_1, hasRequiredRobotframework;
function requireRobotframework() {
  if (hasRequiredRobotframework) return robotframework_1;
  hasRequiredRobotframework = 1, robotframework_1 = e, e.displayName = "robotframework", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = {
        pattern: /(^[ \t]*| {2}|\t)#.*/m,
        lookbehind: !0,
        greedy: !0
      }, o = {
        pattern: /((?:^|[^\\])(?:\\{2})*)[$@&%]\{(?:[^{}\r\n]|\{[^{}\r\n]*\})*\}/,
        lookbehind: !0,
        inside: {
          punctuation: /^[$@&%]\{|\}$/
        }
      };
      function u(b, _) {
        var y = {};
        y["section-header"] = {
          pattern: /^ ?\*{3}.+?\*{3}/,
          alias: "keyword"
        };
        for (var A in _)
          y[A] = _[A];
        return y.tag = {
          pattern: /([\r\n](?: {2}|\t)[ \t]*)\[[-\w]+\]/,
          lookbehind: !0,
          inside: {
            punctuation: /\[|\]/
          }
        }, y.variable = o, y.comment = a, {
          pattern: RegExp(/^ ?\*{3}[ \t]*<name>[ \t]*\*{3}(?:.|[\r\n](?!\*{3}))*/.source.replace(/<name>/g, function() {
            return b;
          }), "im"),
          alias: "section",
          inside: y
        };
      }
      var c = {
        pattern: /(\[Documentation\](?: {2}|\t)[ \t]*)(?![ \t]|#)(?:.|(?:\r\n?|\n)[ \t]*\.{3})+/,
        lookbehind: !0,
        alias: "string"
      }, d = {
        pattern: /([\r\n] ?)(?!#)(?:\S(?:[ \t]\S)*)+/,
        lookbehind: !0,
        alias: "function",
        inside: {
          variable: o
        }
      }, g = {
        pattern: /([\r\n](?: {2}|\t)[ \t]*)(?!\[|\.{3}|#)(?:\S(?:[ \t]\S)*)+/,
        lookbehind: !0,
        inside: {
          variable: o
        }
      };
      r.languages.robotframework = {
        settings: u("Settings", {
          documentation: {
            pattern: /([\r\n] ?Documentation(?: {2}|\t)[ \t]*)(?![ \t]|#)(?:.|(?:\r\n?|\n)[ \t]*\.{3})+/,
            lookbehind: !0,
            alias: "string"
          },
          property: {
            pattern: /([\r\n] ?)(?!\.{3}|#)(?:\S(?:[ \t]\S)*)+/,
            lookbehind: !0
          }
        }),
        variables: u("Variables"),
        "test-cases": u("Test Cases", {
          "test-name": d,
          documentation: c,
          property: g
        }),
        keywords: u("Keywords", {
          "keyword-name": d,
          documentation: c,
          property: g
        }),
        tasks: u("Tasks", {
          "task-name": d,
          documentation: c,
          property: g
        }),
        comment: a
      }, r.languages.robot = r.languages.robotframework;
    })(t);
  }
  return robotframework_1;
}
var rust_1, hasRequiredRust;
function requireRust() {
  if (hasRequiredRust) return rust_1;
  hasRequiredRust = 1, rust_1 = e, e.displayName = "rust", e.aliases = [];
  function e(t) {
    (function(r) {
      for (var a = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source, o = 0; o < 2; o++)
        a = a.replace(/<self>/g, function() {
          return a;
        });
      a = a.replace(/<self>/g, function() {
        return /[^\s\S]/.source;
      }), r.languages.rust = {
        comment: [{
          pattern: RegExp(/(^|[^\\])/.source + a),
          lookbehind: !0,
          greedy: !0
        }, {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }],
        string: {
          pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
          greedy: !0
        },
        char: {
          pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
          greedy: !0
        },
        attribute: {
          pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
          greedy: !0,
          alias: "attr-name",
          inside: {
            string: null
            // see below
          }
        },
        // Closure params should not be confused with bitwise OR |
        "closure-params": {
          pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
          lookbehind: !0,
          greedy: !0,
          inside: {
            "closure-punctuation": {
              pattern: /^\||\|$/,
              alias: "punctuation"
            },
            rest: null
            // see below
          }
        },
        "lifetime-annotation": {
          pattern: /'\w+/,
          alias: "symbol"
        },
        "fragment-specifier": {
          pattern: /(\$\w+:)[a-z]+/,
          lookbehind: !0,
          alias: "punctuation"
        },
        variable: /\$\w+/,
        "function-definition": {
          pattern: /(\bfn\s+)\w+/,
          lookbehind: !0,
          alias: "function"
        },
        "type-definition": {
          pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
          lookbehind: !0,
          alias: "class-name"
        },
        "module-declaration": [{
          pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
          lookbehind: !0,
          alias: "namespace"
        }, {
          pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
          lookbehind: !0,
          alias: "namespace",
          inside: {
            punctuation: /::/
          }
        }],
        keyword: [
          // https://github.com/rust-lang/reference/blob/master/src/keywords.md
          /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
          // primitives and str
          // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
          /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
        ],
        // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
        // and Rust's naming conventions recommend snake_case anyway.
        // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
        function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
        macro: {
          pattern: /\b\w+!/,
          alias: "property"
        },
        constant: /\b[A-Z_][A-Z_\d]+\b/,
        "class-name": /\b[A-Z]\w*\b/,
        namespace: {
          pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
          inside: {
            punctuation: /::/
          }
        },
        // Hex, oct, bin, dec numbers with visual separators and type suffix
        number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
        boolean: /\b(?:false|true)\b/,
        punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
        operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
      }, r.languages.rust["closure-params"].inside.rest = r.languages.rust, r.languages.rust.attribute.inside.string = r.languages.rust.string;
    })(t);
  }
  return rust_1;
}
var sas_1, hasRequiredSas;
function requireSas() {
  if (hasRequiredSas) return sas_1;
  hasRequiredSas = 1, sas_1 = e, e.displayName = "sas", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = /(?:"(?:""|[^"])*"(?!")|'(?:''|[^'])*'(?!'))/.source, o = /\b(?:\d[\da-f]*x|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i, u = {
        pattern: RegExp(a + "[bx]"),
        alias: "number"
      }, c = {
        pattern: /&[a-z_]\w*/i
      }, d = {
        pattern: /((?:^|\s|=|\())%(?:ABORT|BY|CMS|COPY|DISPLAY|DO|ELSE|END|EVAL|GLOBAL|GO|GOTO|IF|INC|INCLUDE|INDEX|INPUT|KTRIM|LENGTH|LET|LIST|LOCAL|PUT|QKTRIM|QSCAN|QSUBSTR|QSYSFUNC|QUPCASE|RETURN|RUN|SCAN|SUBSTR|SUPERQ|SYMDEL|SYMEXIST|SYMGLOBL|SYMLOCAL|SYSCALL|SYSEVALF|SYSEXEC|SYSFUNC|SYSGET|SYSRPUT|THEN|TO|TSO|UNQUOTE|UNTIL|UPCASE|WHILE|WINDOW)\b/i,
        lookbehind: !0,
        alias: "keyword"
      }, g = {
        pattern: /(^|\s)(?:proc\s+\w+|data(?!=)|quit|run)\b/i,
        alias: "keyword",
        lookbehind: !0
      }, b = [/\/\*[\s\S]*?\*\//, {
        pattern: /(^[ \t]*|;\s*)\*[^;]*;/m,
        lookbehind: !0
      }], _ = {
        pattern: RegExp(a),
        greedy: !0
      }, y = /[$%@.(){}\[\];,\\]/, A = {
        pattern: /%?\b\w+(?=\()/,
        alias: "keyword"
      }, E = {
        function: A,
        "arg-value": {
          pattern: /(=\s*)[A-Z\.]+/i,
          lookbehind: !0
        },
        operator: /=/,
        "macro-variable": c,
        arg: {
          pattern: /[A-Z]+/i,
          alias: "keyword"
        },
        number: o,
        "numeric-constant": u,
        punctuation: y,
        string: _
      }, v = {
        pattern: /\b(?:format|put)\b=?[\w'$.]+/i,
        inside: {
          keyword: /^(?:format|put)(?==)/i,
          equals: /=/,
          format: {
            pattern: /(?:\w|\$\d)+\.\d?/,
            alias: "number"
          }
        }
      }, C = {
        pattern: /\b(?:format|put)\s+[\w']+(?:\s+[$.\w]+)+(?=;)/i,
        inside: {
          keyword: /^(?:format|put)/i,
          format: {
            pattern: /[\w$]+\.\d?/,
            alias: "number"
          }
        }
      }, R = {
        pattern: /((?:^|\s)=?)(?:catname|checkpoint execute_always|dm|endsas|filename|footnote|%include|libname|%list|lock|missing|options|page|resetline|%run|sasfile|skip|sysecho|title\d?)\b/i,
        lookbehind: !0,
        alias: "keyword"
      }, I = {
        pattern: /(^|\s)(?:submit(?:\s+(?:load|norun|parseonly))?|endsubmit)\b/i,
        lookbehind: !0,
        alias: "keyword"
      }, w = /aStore|accessControl|aggregation|audio|autotune|bayesianNetClassifier|bioMedImage|boolRule|builtins|cardinality|cdm|clustering|conditionalRandomFields|configuration|copula|countreg|dataDiscovery|dataPreprocess|dataSciencePilot|dataStep|decisionTree|deduplication|deepLearn|deepNeural|deepRnn|ds2|ecm|entityRes|espCluster|explainModel|factmac|fastKnn|fcmpact|fedSql|freqTab|gVarCluster|gam|gleam|graphSemiSupLearn|hiddenMarkovModel|hyperGroup|ica|image|iml|kernalPca|langModel|ldaTopic|loadStreams|mbc|mixed|mlTools|modelPublishing|network|neuralNet|nmf|nonParametricBayes|nonlinear|optNetwork|optimization|panel|pca|percentile|phreg|pls|qkb|qlim|quantreg|recommend|regression|reinforcementLearn|robustPca|ruleMining|sampling|sandwich|sccasl|search(?:Analytics)?|sentimentAnalysis|sequence|session(?:Prop)?|severity|simSystem|simple|smartData|sparkEmbeddedProcess|sparseML|spatialreg|spc|stabilityMonitoring|svDataDescription|svm|table|text(?:Filters|Frequency|Mining|Parse|Rule(?:Develop|Score)|Topic|Util)|timeData|transpose|tsInfo|tsReconcile|uniTimeSeries|varReduce/.source, N = {
        pattern: RegExp(/(^|\s)(?:action\s+)?(?:<act>)\.[a-z]+\b[^;]+/.source.replace(/<act>/g, function() {
          return w;
        }), "i"),
        lookbehind: !0,
        inside: {
          keyword: RegExp(/(?:<act>)\.[a-z]+\b/.source.replace(/<act>/g, function() {
            return w;
          }), "i"),
          action: {
            pattern: /(?:action)/i,
            alias: "keyword"
          },
          comment: b,
          function: A,
          "arg-value": E["arg-value"],
          operator: E.operator,
          argument: E.arg,
          number: o,
          "numeric-constant": u,
          punctuation: y,
          string: _
        }
      }, F = {
        pattern: /((?:^|\s)=?)(?:after|analysis|and|array|barchart|barwidth|begingraph|by|call|cas|cbarline|cfill|class(?:lev)?|close|column|computed?|contains|continue|data(?==)|define|delete|describe|document|do\s+over|do|dol|drop|dul|else|end(?:comp|source)?|entryTitle|eval(?:uate)?|exec(?:ute)?|exit|file(?:name)?|fill(?:attrs)?|flist|fnc|function(?:list)?|global|goto|group(?:by)?|headline|headskip|histogram|if|infile|keep|keylabel|keyword|label|layout|leave|legendlabel|length|libname|loadactionset|merge|midpoints|_?null_|name|noobs|nowd|ods|options|or|otherwise|out(?:put)?|over(?:lay)?|plot|print|put|raise|ranexp|rannor|rbreak|retain|return|select|session|sessref|set|source|statgraph|sum|summarize|table|temp|terminate|then\s+do|then|title\d?|to|var|when|where|xaxisopts|y2axisopts|yaxisopts)\b/i,
        lookbehind: !0
      };
      r.languages.sas = {
        datalines: {
          pattern: /^([ \t]*)(?:cards|(?:data)?lines);[\s\S]+?^[ \t]*;/im,
          lookbehind: !0,
          alias: "string",
          inside: {
            keyword: {
              pattern: /^(?:cards|(?:data)?lines)/i
            },
            punctuation: /;/
          }
        },
        "proc-sql": {
          pattern: /(^proc\s+(?:fed)?sql(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
          lookbehind: !0,
          inside: {
            sql: {
              pattern: RegExp(/^[ \t]*(?:select|alter\s+table|(?:create|describe|drop)\s+(?:index|table(?:\s+constraints)?|view)|create\s+unique\s+index|insert\s+into|update)(?:<str>|[^;"'])+;/.source.replace(/<str>/g, function() {
                return a;
              }), "im"),
              alias: "language-sql",
              inside: r.languages.sql
            },
            "global-statements": R,
            "sql-statements": {
              pattern: /(^|\s)(?:disconnect\s+from|begin|commit|exec(?:ute)?|reset|rollback|validate)\b/i,
              lookbehind: !0,
              alias: "keyword"
            },
            number: o,
            "numeric-constant": u,
            punctuation: y,
            string: _
          }
        },
        "proc-groovy": {
          pattern: /(^proc\s+groovy(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
          lookbehind: !0,
          inside: {
            comment: b,
            groovy: {
              pattern: RegExp(/(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(/<str>/g, function() {
                return a;
              }), "im"),
              lookbehind: !0,
              alias: "language-groovy",
              inside: r.languages.groovy
            },
            keyword: F,
            "submit-statement": I,
            "global-statements": R,
            number: o,
            "numeric-constant": u,
            punctuation: y,
            string: _
          }
        },
        "proc-lua": {
          pattern: /(^proc\s+lua(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
          lookbehind: !0,
          inside: {
            comment: b,
            lua: {
              pattern: RegExp(/(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(/<str>/g, function() {
                return a;
              }), "im"),
              lookbehind: !0,
              alias: "language-lua",
              inside: r.languages.lua
            },
            keyword: F,
            "submit-statement": I,
            "global-statements": R,
            number: o,
            "numeric-constant": u,
            punctuation: y,
            string: _
          }
        },
        "proc-cas": {
          pattern: /(^proc\s+cas(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|quit|data);|(?![\s\S]))/im,
          lookbehind: !0,
          inside: {
            comment: b,
            "statement-var": {
              pattern: /((?:^|\s)=?)saveresult\s[^;]+/im,
              lookbehind: !0,
              inside: {
                statement: {
                  pattern: /^saveresult\s+\S+/i,
                  inside: {
                    keyword: /^(?:saveresult)/i
                  }
                },
                rest: E
              }
            },
            "cas-actions": N,
            statement: {
              pattern: /((?:^|\s)=?)(?:default|(?:un)?set|on|output|upload)[^;]+/im,
              lookbehind: !0,
              inside: E
            },
            step: g,
            keyword: F,
            function: A,
            format: v,
            altformat: C,
            "global-statements": R,
            number: o,
            "numeric-constant": u,
            punctuation: y,
            string: _
          }
        },
        "proc-args": {
          pattern: RegExp(/(^proc\s+\w+\s+)(?!\s)(?:[^;"']|<str>)+;/.source.replace(/<str>/g, function() {
            return a;
          }), "im"),
          lookbehind: !0,
          inside: E
        },
        /*Special keywords within macros*/
        "macro-keyword": d,
        "macro-variable": c,
        "macro-string-functions": {
          pattern: /((?:^|\s|=))%(?:BQUOTE|NRBQUOTE|NRQUOTE|NRSTR|QUOTE|STR)\(.*?(?:[^%]\))/i,
          lookbehind: !0,
          inside: {
            function: {
              pattern: /%(?:BQUOTE|NRBQUOTE|NRQUOTE|NRSTR|QUOTE|STR)/i,
              alias: "keyword"
            },
            "macro-keyword": d,
            "macro-variable": c,
            "escaped-char": {
              pattern: /%['"()<>=^~;,#]/
            },
            punctuation: y
          }
        },
        "macro-declaration": {
          pattern: /^%macro[^;]+(?=;)/im,
          inside: {
            keyword: /%macro/i
          }
        },
        "macro-end": {
          pattern: /^%mend[^;]+(?=;)/im,
          inside: {
            keyword: /%mend/i
          }
        },
        /*%_zscore(headcir, _lhc, _mhc, _shc, headcz, headcpct, _Fheadcz); */
        macro: {
          pattern: /%_\w+(?=\()/,
          alias: "keyword"
        },
        input: {
          pattern: /\binput\s[-\w\s/*.$&]+;/i,
          inside: {
            input: {
              alias: "keyword",
              pattern: /^input/i
            },
            comment: b,
            number: o,
            "numeric-constant": u
          }
        },
        "options-args": {
          pattern: /(^options)[-'"|/\\<>*+=:()\w\s]*(?=;)/im,
          lookbehind: !0,
          inside: E
        },
        "cas-actions": N,
        comment: b,
        function: A,
        format: v,
        altformat: C,
        "numeric-constant": u,
        datetime: {
          // '1jan2013'd, '9:25:19pm't, '18jan2003:9:27:05am'dt
          pattern: RegExp(a + "(?:dt?|t)"),
          alias: "number"
        },
        string: _,
        step: g,
        keyword: F,
        // In SAS Studio syntax highlighting, these operators are styled like keywords
        "operator-keyword": {
          pattern: /\b(?:eq|ge|gt|in|le|lt|ne|not)\b/i,
          alias: "operator"
        },
        // Decimal (1.2e23), hexadecimal (0c1x)
        number: o,
        operator: /\*\*?|\|\|?|!!?|?|<[>=]?|>[<=]?|[-+\/=&]|[~^]=?/,
        punctuation: y
      };
    })(t);
  }
  return sas_1;
}
var sass_1, hasRequiredSass;
function requireSass() {
  if (hasRequiredSass) return sass_1;
  hasRequiredSass = 1, sass_1 = e, e.displayName = "sass", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.sass = r.languages.extend("css", {
        // Sass comments don't need to be closed, only indented
        comment: {
          pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t].+)*/m,
          lookbehind: !0,
          greedy: !0
        }
      }), r.languages.insertBefore("sass", "atrule", {
        // We want to consume the whole line
        "atrule-line": {
          // Includes support for = and + shortcuts
          pattern: /^(?:[ \t]*)[@+=].+/m,
          greedy: !0,
          inside: {
            atrule: /(?:@[\w-]+|[+=])/
          }
        }
      }), delete r.languages.sass.atrule;
      var a = /\$[-\w]+|#\{\$[-\w]+\}/, o = [/[+*\/%]|[=!]=|<=?|>=?|\b(?:and|not|or)\b/, {
        pattern: /(\s)-(?=\s)/,
        lookbehind: !0
      }];
      r.languages.insertBefore("sass", "property", {
        // We want to consume the whole line
        "variable-line": {
          pattern: /^[ \t]*\$.+/m,
          greedy: !0,
          inside: {
            punctuation: /:/,
            variable: a,
            operator: o
          }
        },
        // We want to consume the whole line
        "property-line": {
          pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s].*)/m,
          greedy: !0,
          inside: {
            property: [/[^:\s]+(?=\s*:)/, {
              pattern: /(:)[^:\s]+/,
              lookbehind: !0
            }],
            punctuation: /:/,
            variable: a,
            operator: o,
            important: r.languages.sass.important
          }
        }
      }), delete r.languages.sass.property, delete r.languages.sass.important, r.languages.insertBefore("sass", "punctuation", {
        selector: {
          pattern: /^([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/m,
          lookbehind: !0,
          greedy: !0
        }
      });
    })(t);
  }
  return sass_1;
}
var scala_1, hasRequiredScala;
function requireScala() {
  if (hasRequiredScala) return scala_1;
  hasRequiredScala = 1;
  var e = requireJava();
  scala_1 = t, t.displayName = "scala", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.scala = r.languages.extend("java", {
      "triple-quoted-string": {
        pattern: /"""[\s\S]*?"""/,
        greedy: !0,
        alias: "string"
      },
      string: {
        pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      keyword: /<-|=>|\b(?:abstract|case|catch|class|def|do|else|extends|final|finally|for|forSome|if|implicit|import|lazy|match|new|null|object|override|package|private|protected|return|sealed|self|super|this|throw|trait|try|type|val|var|while|with|yield)\b/,
      number: /\b0x(?:[\da-f]*\.)?[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e\d+)?[dfl]?/i,
      builtin: /\b(?:Any|AnyRef|AnyVal|Boolean|Byte|Char|Double|Float|Int|Long|Nothing|Short|String|Unit)\b/,
      symbol: /'[^\d\s\\]\w*/
    }), r.languages.insertBefore("scala", "triple-quoted-string", {
      "string-interpolation": {
        pattern: /\b[a-z]\w*(?:"""(?:[^$]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*?"""|"(?:[^$"\r\n]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*")/i,
        greedy: !0,
        inside: {
          id: {
            pattern: /^\w+/,
            greedy: !0,
            alias: "function"
          },
          escape: {
            pattern: /\\\$"|\$[$"]/,
            greedy: !0,
            alias: "symbol"
          },
          interpolation: {
            pattern: /\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
            greedy: !0,
            inside: {
              punctuation: /^\$\{?|\}$/,
              expression: {
                pattern: /[\s\S]+/,
                inside: r.languages.scala
              }
            }
          },
          string: /[\s\S]+/
        }
      }
    }), delete r.languages.scala["class-name"], delete r.languages.scala.function;
  }
  return scala_1;
}
var scss_1, hasRequiredScss;
function requireScss() {
  if (hasRequiredScss) return scss_1;
  hasRequiredScss = 1, scss_1 = e, e.displayName = "scss", e.aliases = [];
  function e(t) {
    t.languages.scss = t.languages.extend("css", {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
        lookbehind: !0
      },
      atrule: {
        pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
        inside: {
          rule: /@[\w-]+/
          // See rest below
        }
      },
      // url, compassified
      url: /(?:[-a-z]+-)?url(?=\()/i,
      // CSS selector regex is not appropriate for Sass
      // since there can be lot more things (var, @ directive, nesting..)
      // a selector must start at the end of a property or after a brace (end of other rules or nesting)
      // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable
      // the end of a selector is found when there is no rules in it ( {} or {\s}) or if there is a property (because an interpolated var
      // can "pass" as a selector- e.g: proper#{$erty})
      // this one was hard to do, so please be careful if you edit this one :)
      selector: {
        // Initial look-ahead is used to prevent matching of blank selectors
        pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
        inside: {
          parent: {
            pattern: /&/,
            alias: "important"
          },
          placeholder: /%[-\w]+/,
          variable: /\$[-\w]+|#\{\$[-\w]+\}/
        }
      },
      property: {
        pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
        inside: {
          variable: /\$[-\w]+|#\{\$[-\w]+\}/
        }
      }
    }), t.languages.insertBefore("scss", "atrule", {
      keyword: [/@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i, {
        pattern: /( )(?:from|through)(?= )/,
        lookbehind: !0
      }]
    }), t.languages.insertBefore("scss", "important", {
      // var and interpolated vars
      variable: /\$[-\w]+|#\{\$[-\w]+\}/
    }), t.languages.insertBefore("scss", "function", {
      "module-modifier": {
        pattern: /\b(?:as|hide|show|with)\b/i,
        alias: "keyword"
      },
      placeholder: {
        pattern: /%[-\w]+/,
        alias: "selector"
      },
      statement: {
        pattern: /\B!(?:default|optional)\b/i,
        alias: "keyword"
      },
      boolean: /\b(?:false|true)\b/,
      null: {
        pattern: /\bnull\b/,
        alias: "keyword"
      },
      operator: {
        pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
        lookbehind: !0
      }
    }), t.languages.scss.atrule.inside.rest = t.languages.scss;
  }
  return scss_1;
}
var shellSession_1, hasRequiredShellSession;
function requireShellSession() {
  if (hasRequiredShellSession) return shellSession_1;
  hasRequiredShellSession = 1;
  var e = requireBash();
  shellSession_1 = t, t.displayName = "shellSession", t.aliases = [];
  function t(r) {
    r.register(e), function(a) {
      var o = [
        // normal string
        /"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/.source,
        /'[^']*'/.source,
        /\$'(?:[^'\\]|\\[\s\S])*'/.source,
        // here doc
        // 2 capturing groups
        /<<-?\s*(["']?)(\w+)\1\s[\s\S]*?[\r\n]\2/.source
      ].join("|");
      a.languages["shell-session"] = {
        command: {
          pattern: RegExp(
            // user info
            /^/.source + "(?:" + // <user> ":" ( <path> )?
            (/[^\s@:$#%*!/\\]+@[^\r\n@:$#%*!/\\]+(?::[^\0-\x1F$#%*?"<>:;|]+)?/.source + "|" + // <path>
            // Since the path pattern is quite general, we will require it to start with a special character to
            // prevent false positives.
            /[/~.][^\0-\x1F$#%*?"<>@:;|]*/.source) + ")?" + // shell symbol
            /[$#%](?=\s)/.source + // bash command
            /(?:[^\\\r\n \t'"<$]|[ \t](?:(?!#)|#.*$)|\\(?:[^\r]|\r\n?)|\$(?!')|<(?!<)|<<str>>)+/.source.replace(/<<str>>/g, function() {
              return o;
            }),
            "m"
          ),
          greedy: !0,
          inside: {
            info: {
              // foo@bar:~/files$ exit
              // foo@bar$ exit
              // ~/files$ exit
              pattern: /^[^#$%]+/,
              alias: "punctuation",
              inside: {
                user: /^[^\s@:$#%*!/\\]+@[^\r\n@:$#%*!/\\]+/,
                punctuation: /:/,
                path: /[\s\S]+/
              }
            },
            bash: {
              pattern: /(^[$#%]\s*)\S[\s\S]*/,
              lookbehind: !0,
              alias: "language-bash",
              inside: a.languages.bash
            },
            "shell-symbol": {
              pattern: /^[$#%]/,
              alias: "important"
            }
          }
        },
        output: /.(?:.*(?:[\r\n]|.$))*/
      }, a.languages["sh-session"] = a.languages.shellsession = a.languages["shell-session"];
    }(r);
  }
  return shellSession_1;
}
var smali_1, hasRequiredSmali;
function requireSmali() {
  if (hasRequiredSmali) return smali_1;
  hasRequiredSmali = 1, smali_1 = e, e.displayName = "smali", e.aliases = [];
  function e(t) {
    t.languages.smali = {
      comment: /#.*/,
      string: {
        pattern: /"(?:[^\r\n\\"]|\\.)*"|'(?:[^\r\n\\']|\\(?:.|u[\da-fA-F]{4}))'/,
        greedy: !0
      },
      "class-name": {
        pattern: /(^|[^L])L(?:(?:\w+|`[^`\r\n]*`)\/)*(?:[\w$]+|`[^`\r\n]*`)(?=\s*;)/,
        lookbehind: !0,
        inside: {
          "class-name": {
            pattern: /(^L|\/)(?:[\w$]+|`[^`\r\n]*`)$/,
            lookbehind: !0
          },
          namespace: {
            pattern: /^(L)(?:(?:\w+|`[^`\r\n]*`)\/)+/,
            lookbehind: !0,
            inside: {
              punctuation: /\//
            }
          },
          builtin: /^L/
        }
      },
      builtin: [{
        // Reference: https://github.com/JesusFreke/smali/wiki/TypesMethodsAndFields#types
        pattern: /([();\[])[BCDFIJSVZ]+/,
        lookbehind: !0
      }, {
        // e.g. .field mWifiOnUid:I
        pattern: /([\w$>]:)[BCDFIJSVZ]/,
        lookbehind: !0
      }],
      keyword: [{
        pattern: /(\.end\s+)[\w-]+/,
        lookbehind: !0
      }, {
        pattern: /(^|[^\w.-])\.(?!\d)[\w-]+/,
        lookbehind: !0
      }, {
        pattern: /(^|[^\w.-])(?:abstract|annotation|bridge|constructor|enum|final|interface|private|protected|public|runtime|static|synthetic|system|transient)(?![\w.-])/,
        lookbehind: !0
      }],
      function: {
        pattern: /(^|[^\w.-])(?:\w+|<[\w$-]+>)(?=\()/,
        lookbehind: !0
      },
      field: {
        pattern: /[\w$]+(?=:)/,
        alias: "variable"
      },
      register: {
        pattern: /(^|[^\w.-])[vp]\d(?![\w.-])/,
        lookbehind: !0,
        alias: "variable"
      },
      boolean: {
        pattern: /(^|[^\w.-])(?:false|true)(?![\w.-])/,
        lookbehind: !0
      },
      number: {
        pattern: /(^|[^/\w.-])-?(?:NAN|INFINITY|0x(?:[\dA-F]+(?:\.[\dA-F]*)?|\.[\dA-F]+)(?:p[+-]?[\dA-F]+)?|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)[dflst]?(?![\w.-])/i,
        lookbehind: !0
      },
      label: {
        pattern: /(:)\w+/,
        lookbehind: !0,
        alias: "property"
      },
      operator: /->|\.\.|[\[=]/,
      punctuation: /[{}(),;:]/
    };
  }
  return smali_1;
}
var smalltalk_1, hasRequiredSmalltalk;
function requireSmalltalk() {
  if (hasRequiredSmalltalk) return smalltalk_1;
  hasRequiredSmalltalk = 1, smalltalk_1 = e, e.displayName = "smalltalk", e.aliases = [];
  function e(t) {
    t.languages.smalltalk = {
      comment: {
        pattern: /"(?:""|[^"])*"/,
        greedy: !0
      },
      char: {
        pattern: /\$./,
        greedy: !0
      },
      string: {
        pattern: /'(?:''|[^'])*'/,
        greedy: !0
      },
      symbol: /#[\da-z]+|#(?:-|([+\/\\*~<>=@%|&?!])\1?)|#(?=\()/i,
      "block-arguments": {
        pattern: /(\[\s*):[^\[|]*\|/,
        lookbehind: !0,
        inside: {
          variable: /:[\da-z]+/i,
          punctuation: /\|/
        }
      },
      "temporary-variables": {
        pattern: /\|[^|]+\|/,
        inside: {
          variable: /[\da-z]+/i,
          punctuation: /\|/
        }
      },
      keyword: /\b(?:new|nil|self|super)\b/,
      boolean: /\b(?:false|true)\b/,
      number: [/\d+r-?[\dA-Z]+(?:\.[\dA-Z]+)?(?:e-?\d+)?/, /\b\d+(?:\.\d+)?(?:e-?\d+)?/],
      operator: /[<=]=?|:=|~[~=]|\/\/?|\\\\|>[>=]?|[!^+\-*&|,@]/,
      punctuation: /[.;:?\[\](){}]/
    };
  }
  return smalltalk_1;
}
var smarty_1, hasRequiredSmarty;
function requireSmarty() {
  if (hasRequiredSmarty) return smarty_1;
  hasRequiredSmarty = 1;
  var e = requireMarkupTemplating();
  smarty_1 = t, t.displayName = "smarty", t.aliases = [];
  function t(r) {
    r.register(e), function(a) {
      a.languages.smarty = {
        comment: {
          pattern: /^\{\*[\s\S]*?\*\}/,
          greedy: !0
        },
        "embedded-php": {
          pattern: /^\{php\}[\s\S]*?\{\/php\}/,
          greedy: !0,
          inside: {
            smarty: {
              pattern: /^\{php\}|\{\/php\}$/,
              inside: null
              // see below
            },
            php: {
              pattern: /[\s\S]+/,
              alias: "language-php",
              inside: a.languages.php
            }
          }
        },
        string: [{
          pattern: /"(?:\\.|[^"\\\r\n])*"/,
          greedy: !0,
          inside: {
            interpolation: {
              pattern: /\{[^{}]*\}|`[^`]*`/,
              inside: {
                "interpolation-punctuation": {
                  pattern: /^[{`]|[`}]$/,
                  alias: "punctuation"
                },
                expression: {
                  pattern: /[\s\S]+/,
                  inside: null
                  // see below
                }
              }
            },
            variable: /\$\w+/
          }
        }, {
          pattern: /'(?:\\.|[^'\\\r\n])*'/,
          greedy: !0
        }],
        keyword: {
          pattern: /(^\{\/?)[a-z_]\w*\b(?!\()/i,
          lookbehind: !0,
          greedy: !0
        },
        delimiter: {
          pattern: /^\{\/?|\}$/,
          greedy: !0,
          alias: "punctuation"
        },
        number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
        variable: [/\$(?!\d)\w+/, /#(?!\d)\w+#/, {
          pattern: /(\.|->|\w\s*=)(?!\d)\w+\b(?!\()/,
          lookbehind: !0
        }, {
          pattern: /(\[)(?!\d)\w+(?=\])/,
          lookbehind: !0
        }],
        function: {
          pattern: /(\|\s*)@?[a-z_]\w*|\b[a-z_]\w*(?=\()/i,
          lookbehind: !0
        },
        "attr-name": /\b[a-z_]\w*(?=\s*=)/i,
        boolean: /\b(?:false|no|off|on|true|yes)\b/,
        punctuation: /[\[\](){}.,:`]|->/,
        operator: [/[+\-*\/%]|==?=?|[!<>]=?|&&|\|\|?/, /\bis\s+(?:not\s+)?(?:div|even|odd)(?:\s+by)?\b/, /\b(?:and|eq|gt?e|gt|lt?e|lt|mod|neq?|not|or)\b/]
      }, a.languages.smarty["embedded-php"].inside.smarty.inside = a.languages.smarty, a.languages.smarty.string[0].inside.interpolation.inside.expression.inside = a.languages.smarty;
      var o = /"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'/, u = RegExp(
        // comments
        /\{\*[\s\S]*?\*\}/.source + "|" + // php tags
        /\{php\}[\s\S]*?\{\/php\}/.source + "|" + // smarty blocks
        /\{(?:[^{}"']|<str>|\{(?:[^{}"']|<str>|\{(?:[^{}"']|<str>)*\})*\})*\}/.source.replace(/<str>/g, function() {
          return o.source;
        }),
        "g"
      );
      a.hooks.add("before-tokenize", function(c) {
        var d = "{literal}", g = "{/literal}", b = !1;
        a.languages["markup-templating"].buildPlaceholders(c, "smarty", u, function(_) {
          return _ === g && (b = !1), b ? !1 : (_ === d && (b = !0), !0);
        });
      }), a.hooks.add("after-tokenize", function(c) {
        a.languages["markup-templating"].tokenizePlaceholders(c, "smarty");
      });
    }(r);
  }
  return smarty_1;
}
var sml_1, hasRequiredSml;
function requireSml() {
  if (hasRequiredSml) return sml_1;
  hasRequiredSml = 1, sml_1 = e, e.displayName = "sml", e.aliases = ["smlnj"];
  function e(t) {
    (function(r) {
      var a = /\b(?:abstype|and|andalso|as|case|datatype|do|else|end|eqtype|exception|fn|fun|functor|handle|if|in|include|infix|infixr|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\b/i;
      r.languages.sml = {
        // allow one level of nesting
        comment: /\(\*(?:[^*(]|\*(?!\))|\((?!\*)|\(\*(?:[^*(]|\*(?!\))|\((?!\*))*\*\))*\*\)/,
        string: {
          pattern: /#?"(?:[^"\\]|\\.)*"/,
          greedy: !0
        },
        "class-name": [{
          // This is only an approximation since the real grammar is context-free
          //
          // Why the main loop so complex?
          // The main loop is approximately the same as /(?:\s*(?:[*,]|->)\s*<TERMINAL>)*/ which is, obviously, a lot
          // simpler. The difference is that if a comma is the last iteration of the loop, then the terminal must be
          // followed by a long identifier.
          pattern: RegExp(/((?:^|[^:]):\s*)<TERMINAL>(?:\s*(?:(?:\*|->)\s*<TERMINAL>|,\s*<TERMINAL>(?:(?=<NOT-LAST>)|(?!<NOT-LAST>)\s+<LONG-ID>)))*/.source.replace(/<NOT-LAST>/g, function() {
            return /\s*(?:[*,]|->)/.source;
          }).replace(/<TERMINAL>/g, function() {
            return /(?:'[\w']*|<LONG-ID>|\((?:[^()]|\([^()]*\))*\)|\{(?:[^{}]|\{[^{}]*\})*\})(?:\s+<LONG-ID>)*/.source;
          }).replace(/<LONG-ID>/g, function() {
            return /(?!<KEYWORD>)[a-z\d_][\w'.]*/.source;
          }).replace(/<KEYWORD>/g, function() {
            return a.source;
          }), "i"),
          lookbehind: !0,
          greedy: !0,
          inside: null
          // see below
        }, {
          pattern: /((?:^|[^\w'])(?:datatype|exception|functor|signature|structure|type)\s+)[a-z_][\w'.]*/i,
          lookbehind: !0
        }],
        function: {
          pattern: /((?:^|[^\w'])fun\s+)[a-z_][\w'.]*/i,
          lookbehind: !0
        },
        keyword: a,
        variable: {
          pattern: /(^|[^\w'])'[\w']*/,
          lookbehind: !0
        },
        number: /~?\b(?:\d+(?:\.\d+)?(?:e~?\d+)?|0x[\da-f]+)\b/i,
        word: {
          pattern: /\b0w(?:\d+|x[\da-f]+)\b/i,
          alias: "constant"
        },
        boolean: /\b(?:false|true)\b/i,
        operator: /\.\.\.|:[>=:]|=>?|->|[<>]=?|[!+\-*/^#|@~]/,
        punctuation: /[(){}\[\].:,;]/
      }, r.languages.sml["class-name"][0].inside = r.languages.sml, r.languages.smlnj = r.languages.sml;
    })(t);
  }
  return sml_1;
}
var solidity_1, hasRequiredSolidity;
function requireSolidity() {
  if (hasRequiredSolidity) return solidity_1;
  hasRequiredSolidity = 1, solidity_1 = e, e.displayName = "solidity", e.aliases = ["sol"];
  function e(t) {
    t.languages.solidity = t.languages.extend("clike", {
      "class-name": {
        pattern: /(\b(?:contract|enum|interface|library|new|struct|using)\s+)(?!\d)[\w$]+/,
        lookbehind: !0
      },
      keyword: /\b(?:_|anonymous|as|assembly|assert|break|calldata|case|constant|constructor|continue|contract|default|delete|do|else|emit|enum|event|external|for|from|function|if|import|indexed|inherited|interface|internal|is|let|library|mapping|memory|modifier|new|payable|pragma|private|public|pure|require|returns?|revert|selfdestruct|solidity|storage|struct|suicide|switch|this|throw|using|var|view|while)\b/,
      operator: /=>|->|:=|=:|\*\*|\+\+|--|\|\||&&|<<=?|>>=?|[-+*/%^&|<>!=]=?|[~?]/
    }), t.languages.insertBefore("solidity", "keyword", {
      builtin: /\b(?:address|bool|byte|u?int(?:8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?|string|bytes(?:[1-9]|[12]\d|3[0-2])?)\b/
    }), t.languages.insertBefore("solidity", "number", {
      version: {
        pattern: /([<>]=?|\^)\d+\.\d+\.\d+\b/,
        lookbehind: !0,
        alias: "number"
      }
    }), t.languages.sol = t.languages.solidity;
  }
  return solidity_1;
}
var solutionFile_1, hasRequiredSolutionFile;
function requireSolutionFile() {
  if (hasRequiredSolutionFile) return solutionFile_1;
  hasRequiredSolutionFile = 1, solutionFile_1 = e, e.displayName = "solutionFile", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = {
        // https://en.wikipedia.org/wiki/Universally_unique_identifier#Format
        pattern: /\{[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}\}/i,
        alias: "constant",
        inside: {
          punctuation: /[{}]/
        }
      };
      r.languages["solution-file"] = {
        comment: {
          pattern: /#.*/,
          greedy: !0
        },
        string: {
          pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
          greedy: !0,
          inside: {
            guid: a
          }
        },
        object: {
          // Foo
          //   Bar("abs") = 9
          //   EndBar
          //   Prop = TRUE
          // EndFoo
          pattern: /^([ \t]*)(?:([A-Z]\w*)\b(?=.*(?:\r\n?|\n)(?:\1[ \t].*(?:\r\n?|\n))*\1End\2(?=[ \t]*$))|End[A-Z]\w*(?=[ \t]*$))/m,
          lookbehind: !0,
          greedy: !0,
          alias: "keyword"
        },
        property: {
          pattern: /^([ \t]*)(?!\s)[^\r\n"#=()]*[^\s"#=()](?=\s*=)/m,
          lookbehind: !0,
          inside: {
            guid: a
          }
        },
        guid: a,
        number: /\b\d+(?:\.\d+)*\b/,
        boolean: /\b(?:FALSE|TRUE)\b/,
        operator: /=/,
        punctuation: /[(),]/
      }, r.languages.sln = r.languages["solution-file"];
    })(t);
  }
  return solutionFile_1;
}
var soy_1, hasRequiredSoy;
function requireSoy() {
  if (hasRequiredSoy) return soy_1;
  hasRequiredSoy = 1;
  var e = requireMarkupTemplating();
  soy_1 = t, t.displayName = "soy", t.aliases = [];
  function t(r) {
    r.register(e), function(a) {
      var o = /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, u = /\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b|\b0x[\dA-F]+\b/;
      a.languages.soy = {
        comment: [/\/\*[\s\S]*?\*\//, {
          pattern: /(\s)\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }],
        "command-arg": {
          pattern: /(\{+\/?\s*(?:alias|call|delcall|delpackage|deltemplate|namespace|template)\s+)\.?[\w.]+/,
          lookbehind: !0,
          alias: "string",
          inside: {
            punctuation: /\./
          }
        },
        parameter: {
          pattern: /(\{+\/?\s*@?param\??\s+)\.?[\w.]+/,
          lookbehind: !0,
          alias: "variable"
        },
        keyword: [{
          pattern: /(\{+\/?[^\S\r\n]*)(?:\\[nrt]|alias|call|case|css|default|delcall|delpackage|deltemplate|else(?:if)?|fallbackmsg|for(?:each)?|if(?:empty)?|lb|let|literal|msg|namespace|nil|@?param\??|rb|sp|switch|template|xid)/,
          lookbehind: !0
        }, /\b(?:any|as|attributes|bool|css|float|html|in|int|js|list|map|null|number|string|uri)\b/],
        delimiter: {
          pattern: /^\{+\/?|\/?\}+$/,
          alias: "punctuation"
        },
        property: /\w+(?==)/,
        variable: {
          pattern: /\$[^\W\d]\w*(?:\??(?:\.\w+|\[[^\]]+\]))*/,
          inside: {
            string: {
              pattern: o,
              greedy: !0
            },
            number: u,
            punctuation: /[\[\].?]/
          }
        },
        string: {
          pattern: o,
          greedy: !0
        },
        function: [/\w+(?=\()/, {
          pattern: /(\|[^\S\r\n]*)\w+/,
          lookbehind: !0
        }],
        boolean: /\b(?:false|true)\b/,
        number: u,
        operator: /\?:?|<=?|>=?|==?|!=|[+*/%-]|\b(?:and|not|or)\b/,
        punctuation: /[{}()\[\]|.,:]/
      }, a.hooks.add("before-tokenize", function(c) {
        var d = /\{\{.+?\}\}|\{.+?\}|\s\/\/.*|\/\*[\s\S]*?\*\//g, g = "{literal}", b = "{/literal}", _ = !1;
        a.languages["markup-templating"].buildPlaceholders(c, "soy", d, function(y) {
          return y === b && (_ = !1), _ ? !1 : (y === g && (_ = !0), !0);
        });
      }), a.hooks.add("after-tokenize", function(c) {
        a.languages["markup-templating"].tokenizePlaceholders(c, "soy");
      });
    }(r);
  }
  return soy_1;
}
var turtle_1, hasRequiredTurtle;
function requireTurtle() {
  if (hasRequiredTurtle) return turtle_1;
  hasRequiredTurtle = 1, turtle_1 = e, e.displayName = "turtle", e.aliases = [];
  function e(t) {
    t.languages.turtle = {
      comment: {
        pattern: /#.*/,
        greedy: !0
      },
      "multiline-string": {
        pattern: /"""(?:(?:""?)?(?:[^"\\]|\\.))*"""|'''(?:(?:''?)?(?:[^'\\]|\\.))*'''/,
        greedy: !0,
        alias: "string",
        inside: {
          comment: /#.*/
        }
      },
      string: {
        pattern: /"(?:[^\\"\r\n]|\\.)*"|'(?:[^\\'\r\n]|\\.)*'/,
        greedy: !0
      },
      url: {
        pattern: /<(?:[^\x00-\x20<>"{}|^`\\]|\\(?:u[\da-fA-F]{4}|U[\da-fA-F]{8}))*>/,
        greedy: !0,
        inside: {
          punctuation: /[<>]/
        }
      },
      function: {
        pattern: /(?:(?![-.\d\xB7])[-.\w\xB7\xC0-\uFFFD]+)?:(?:(?![-.])(?:[-.:\w\xC0-\uFFFD]|%[\da-f]{2}|\\.)+)?/i,
        inside: {
          "local-name": {
            pattern: /([^:]*:)[\s\S]+/,
            lookbehind: !0
          },
          prefix: {
            pattern: /[\s\S]+/,
            inside: {
              punctuation: /:/
            }
          }
        }
      },
      number: /[+-]?\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
      punctuation: /[{}.,;()[\]]|\^\^/,
      boolean: /\b(?:false|true)\b/,
      keyword: [/(?:\ba|@prefix|@base)\b|=/, /\b(?:base|graph|prefix)\b/i],
      tag: {
        pattern: /@[a-z]+(?:-[a-z\d]+)*/i,
        inside: {
          punctuation: /@/
        }
      }
    }, t.languages.trig = t.languages.turtle;
  }
  return turtle_1;
}
var sparql_1, hasRequiredSparql;
function requireSparql() {
  if (hasRequiredSparql) return sparql_1;
  hasRequiredSparql = 1;
  var e = requireTurtle();
  sparql_1 = t, t.displayName = "sparql", t.aliases = ["rq"];
  function t(r) {
    r.register(e), r.languages.sparql = r.languages.extend("turtle", {
      boolean: /\b(?:false|true)\b/i,
      variable: {
        pattern: /[?$]\w+/,
        greedy: !0
      }
    }), r.languages.insertBefore("sparql", "punctuation", {
      keyword: [/\b(?:A|ADD|ALL|AS|ASC|ASK|BNODE|BY|CLEAR|CONSTRUCT|COPY|CREATE|DATA|DEFAULT|DELETE|DESC|DESCRIBE|DISTINCT|DROP|EXISTS|FILTER|FROM|GROUP|HAVING|INSERT|INTO|LIMIT|LOAD|MINUS|MOVE|NAMED|NOT|NOW|OFFSET|OPTIONAL|ORDER|RAND|REDUCED|SELECT|SEPARATOR|SERVICE|SILENT|STRUUID|UNION|USING|UUID|VALUES|WHERE)\b/i, /\b(?:ABS|AVG|BIND|BOUND|CEIL|COALESCE|CONCAT|CONTAINS|COUNT|DATATYPE|DAY|ENCODE_FOR_URI|FLOOR|GROUP_CONCAT|HOURS|IF|IRI|isBLANK|isIRI|isLITERAL|isNUMERIC|isURI|LANG|LANGMATCHES|LCASE|MAX|MD5|MIN|MINUTES|MONTH|REGEX|REPLACE|ROUND|sameTerm|SAMPLE|SECONDS|SHA1|SHA256|SHA384|SHA512|STR|STRAFTER|STRBEFORE|STRDT|STRENDS|STRLANG|STRLEN|STRSTARTS|SUBSTR|SUM|TIMEZONE|TZ|UCASE|URI|YEAR)\b(?=\s*\()/i, /\b(?:BASE|GRAPH|PREFIX)\b/i]
    }), r.languages.rq = r.languages.sparql;
  }
  return sparql_1;
}
var splunkSpl_1, hasRequiredSplunkSpl;
function requireSplunkSpl() {
  if (hasRequiredSplunkSpl) return splunkSpl_1;
  hasRequiredSplunkSpl = 1, splunkSpl_1 = e, e.displayName = "splunkSpl", e.aliases = [];
  function e(t) {
    t.languages["splunk-spl"] = {
      comment: /`comment\("(?:\\.|[^\\"])*"\)`/,
      string: {
        pattern: /"(?:\\.|[^\\"])*"/,
        greedy: !0
      },
      // https://docs.splunk.com/Documentation/Splunk/7.3.0/SearchReference/ListOfSearchCommands
      keyword: /\b(?:abstract|accum|addcoltotals|addinfo|addtotals|analyzefields|anomalies|anomalousvalue|anomalydetection|append|appendcols|appendcsv|appendlookup|appendpipe|arules|associate|audit|autoregress|bin|bucket|bucketdir|chart|cluster|cofilter|collect|concurrency|contingency|convert|correlate|datamodel|dbinspect|dedup|delete|delta|diff|erex|eval|eventcount|eventstats|extract|fieldformat|fields|fieldsummary|filldown|fillnull|findtypes|folderize|foreach|format|from|gauge|gentimes|geom|geomfilter|geostats|head|highlight|history|iconify|input|inputcsv|inputlookup|iplocation|join|kmeans|kv|kvform|loadjob|localize|localop|lookup|makecontinuous|makemv|makeresults|map|mcollect|metadata|metasearch|meventcollect|mstats|multikv|multisearch|mvcombine|mvexpand|nomv|outlier|outputcsv|outputlookup|outputtext|overlap|pivot|predict|rangemap|rare|regex|relevancy|reltime|rename|replace|rest|return|reverse|rex|rtorder|run|savedsearch|script|scrub|search|searchtxn|selfjoin|sendemail|set|setfields|sichart|sirare|sistats|sitimechart|sitop|sort|spath|stats|strcat|streamstats|table|tags|tail|timechart|timewrap|top|transaction|transpose|trendline|tscollect|tstats|typeahead|typelearner|typer|union|uniq|untable|where|x11|xmlkv|xmlunescape|xpath|xyseries)\b/i,
      "operator-word": {
        pattern: /\b(?:and|as|by|not|or|xor)\b/i,
        alias: "operator"
      },
      function: /\b\w+(?=\s*\()/,
      property: /\b\w+(?=\s*=(?!=))/,
      date: {
        // MM/DD/YYYY(:HH:MM:SS)?
        pattern: /\b\d{1,2}\/\d{1,2}\/\d{1,4}(?:(?::\d{1,2}){3})?\b/,
        alias: "number"
      },
      number: /\b\d+(?:\.\d+)?\b/,
      boolean: /\b(?:f|false|t|true)\b/i,
      operator: /[<>=]=?|[-+*/%|]/,
      punctuation: /[()[\],]/
    };
  }
  return splunkSpl_1;
}
var sqf_1, hasRequiredSqf;
function requireSqf() {
  if (hasRequiredSqf) return sqf_1;
  hasRequiredSqf = 1, sqf_1 = e, e.displayName = "sqf", e.aliases = [];
  function e(t) {
    t.languages.sqf = t.languages.extend("clike", {
      string: {
        pattern: /"(?:(?:"")?[^"])*"(?!")|'(?:[^'])*'/,
        greedy: !0
      },
      keyword: /\b(?:breakOut|breakTo|call|case|catch|default|do|echo|else|execFSM|execVM|exitWith|for|forEach|forEachMember|forEachMemberAgent|forEachMemberTeam|from|goto|if|nil|preprocessFile|preprocessFileLineNumbers|private|scopeName|spawn|step|switch|then|throw|to|try|while|with)\b/i,
      boolean: /\b(?:false|true)\b/i,
      function: /\b(?:abs|accTime|acos|action|actionIDs|actionKeys|actionKeysImages|actionKeysNames|actionKeysNamesArray|actionName|actionParams|activateAddons|activatedAddons|activateKey|add3DENConnection|add3DENEventHandler|add3DENLayer|addAction|addBackpack|addBackpackCargo|addBackpackCargoGlobal|addBackpackGlobal|addCamShake|addCuratorAddons|addCuratorCameraArea|addCuratorEditableObjects|addCuratorEditingArea|addCuratorPoints|addEditorObject|addEventHandler|addForce|addForceGeneratorRTD|addGoggles|addGroupIcon|addHandgunItem|addHeadgear|addItem|addItemCargo|addItemCargoGlobal|addItemPool|addItemToBackpack|addItemToUniform|addItemToVest|addLiveStats|addMagazine|addMagazineAmmoCargo|addMagazineCargo|addMagazineCargoGlobal|addMagazineGlobal|addMagazinePool|addMagazines|addMagazineTurret|addMenu|addMenuItem|addMissionEventHandler|addMPEventHandler|addMusicEventHandler|addOwnedMine|addPlayerScores|addPrimaryWeaponItem|addPublicVariableEventHandler|addRating|addResources|addScore|addScoreSide|addSecondaryWeaponItem|addSwitchableUnit|addTeamMember|addToRemainsCollector|addTorque|addUniform|addVehicle|addVest|addWaypoint|addWeapon|addWeaponCargo|addWeaponCargoGlobal|addWeaponGlobal|addWeaponItem|addWeaponPool|addWeaponTurret|admin|agent|agents|AGLToASL|aimedAtTarget|aimPos|airDensityCurveRTD|airDensityRTD|airplaneThrottle|airportSide|AISFinishHeal|alive|all3DENEntities|allAirports|allControls|allCurators|allCutLayers|allDead|allDeadMen|allDisplays|allGroups|allMapMarkers|allMines|allMissionObjects|allow3DMode|allowCrewInImmobile|allowCuratorLogicIgnoreAreas|allowDamage|allowDammage|allowFileOperations|allowFleeing|allowGetIn|allowSprint|allPlayers|allSimpleObjects|allSites|allTurrets|allUnits|allUnitsUAV|allVariables|ammo|ammoOnPylon|animate|animateBay|animateDoor|animatePylon|animateSource|animationNames|animationPhase|animationSourcePhase|animationState|append|apply|armoryPoints|arrayIntersect|asin|ASLToAGL|ASLToATL|assert|assignAsCargo|assignAsCargoIndex|assignAsCommander|assignAsDriver|assignAsGunner|assignAsTurret|assignCurator|assignedCargo|assignedCommander|assignedDriver|assignedGunner|assignedItems|assignedTarget|assignedTeam|assignedVehicle|assignedVehicleRole|assignItem|assignTeam|assignToAirport|atan|atan2|atg|ATLToASL|attachedObject|attachedObjects|attachedTo|attachObject|attachTo|attackEnabled|backpack|backpackCargo|backpackContainer|backpackItems|backpackMagazines|backpackSpaceFor|behaviour|benchmark|binocular|blufor|boundingBox|boundingBoxReal|boundingCenter|briefingName|buildingExit|buildingPos|buldozer_EnableRoadDiag|buldozer_IsEnabledRoadDiag|buldozer_LoadNewRoads|buldozer_reloadOperMap|buttonAction|buttonSetAction|cadetMode|callExtension|camCommand|camCommit|camCommitPrepared|camCommitted|camConstuctionSetParams|camCreate|camDestroy|cameraEffect|cameraEffectEnableHUD|cameraInterest|cameraOn|cameraView|campaignConfigFile|camPreload|camPreloaded|camPrepareBank|camPrepareDir|camPrepareDive|camPrepareFocus|camPrepareFov|camPrepareFovRange|camPreparePos|camPrepareRelPos|camPrepareTarget|camSetBank|camSetDir|camSetDive|camSetFocus|camSetFov|camSetFovRange|camSetPos|camSetRelPos|camSetTarget|camTarget|camUseNVG|canAdd|canAddItemToBackpack|canAddItemToUniform|canAddItemToVest|cancelSimpleTaskDestination|canFire|canMove|canSlingLoad|canStand|canSuspend|canTriggerDynamicSimulation|canUnloadInCombat|canVehicleCargo|captive|captiveNum|cbChecked|cbSetChecked|ceil|channelEnabled|cheatsEnabled|checkAIFeature|checkVisibility|civilian|className|clear3DENAttribute|clear3DENInventory|clearAllItemsFromBackpack|clearBackpackCargo|clearBackpackCargoGlobal|clearForcesRTD|clearGroupIcons|clearItemCargo|clearItemCargoGlobal|clearItemPool|clearMagazineCargo|clearMagazineCargoGlobal|clearMagazinePool|clearOverlay|clearRadio|clearVehicleInit|clearWeaponCargo|clearWeaponCargoGlobal|clearWeaponPool|clientOwner|closeDialog|closeDisplay|closeOverlay|collapseObjectTree|collect3DENHistory|collectiveRTD|combatMode|commandArtilleryFire|commandChat|commander|commandFire|commandFollow|commandFSM|commandGetOut|commandingMenu|commandMove|commandRadio|commandStop|commandSuppressiveFire|commandTarget|commandWatch|comment|commitOverlay|compile|compileFinal|completedFSM|composeText|configClasses|configFile|configHierarchy|configName|configNull|configProperties|configSourceAddonList|configSourceMod|configSourceModList|confirmSensorTarget|connectTerminalToUAV|controlNull|controlsGroupCtrl|copyFromClipboard|copyToClipboard|copyWaypoints|cos|count|countEnemy|countFriendly|countSide|countType|countUnknown|create3DENComposition|create3DENEntity|createAgent|createCenter|createDialog|createDiaryLink|createDiaryRecord|createDiarySubject|createDisplay|createGearDialog|createGroup|createGuardedPoint|createLocation|createMarker|createMarkerLocal|createMenu|createMine|createMissionDisplay|createMPCampaignDisplay|createSimpleObject|createSimpleTask|createSite|createSoundSource|createTask|createTeam|createTrigger|createUnit|createVehicle|createVehicleCrew|createVehicleLocal|crew|ctAddHeader|ctAddRow|ctClear|ctCurSel|ctData|ctFindHeaderRows|ctFindRowHeader|ctHeaderControls|ctHeaderCount|ctRemoveHeaders|ctRemoveRows|ctrlActivate|ctrlAddEventHandler|ctrlAngle|ctrlAutoScrollDelay|ctrlAutoScrollRewind|ctrlAutoScrollSpeed|ctrlChecked|ctrlClassName|ctrlCommit|ctrlCommitted|ctrlCreate|ctrlDelete|ctrlEnable|ctrlEnabled|ctrlFade|ctrlHTMLLoaded|ctrlIDC|ctrlIDD|ctrlMapAnimAdd|ctrlMapAnimClear|ctrlMapAnimCommit|ctrlMapAnimDone|ctrlMapCursor|ctrlMapMouseOver|ctrlMapScale|ctrlMapScreenToWorld|ctrlMapWorldToScreen|ctrlModel|ctrlModelDirAndUp|ctrlModelScale|ctrlParent|ctrlParentControlsGroup|ctrlPosition|ctrlRemoveAllEventHandlers|ctrlRemoveEventHandler|ctrlScale|ctrlSetActiveColor|ctrlSetAngle|ctrlSetAutoScrollDelay|ctrlSetAutoScrollRewind|ctrlSetAutoScrollSpeed|ctrlSetBackgroundColor|ctrlSetChecked|ctrlSetDisabledColor|ctrlSetEventHandler|ctrlSetFade|ctrlSetFocus|ctrlSetFont|ctrlSetFontH1|ctrlSetFontH1B|ctrlSetFontH2|ctrlSetFontH2B|ctrlSetFontH3|ctrlSetFontH3B|ctrlSetFontH4|ctrlSetFontH4B|ctrlSetFontH5|ctrlSetFontH5B|ctrlSetFontH6|ctrlSetFontH6B|ctrlSetFontHeight|ctrlSetFontHeightH1|ctrlSetFontHeightH2|ctrlSetFontHeightH3|ctrlSetFontHeightH4|ctrlSetFontHeightH5|ctrlSetFontHeightH6|ctrlSetFontHeightSecondary|ctrlSetFontP|ctrlSetFontPB|ctrlSetFontSecondary|ctrlSetForegroundColor|ctrlSetModel|ctrlSetModelDirAndUp|ctrlSetModelScale|ctrlSetPixelPrecision|ctrlSetPosition|ctrlSetScale|ctrlSetStructuredText|ctrlSetText|ctrlSetTextColor|ctrlSetTextColorSecondary|ctrlSetTextSecondary|ctrlSetTooltip|ctrlSetTooltipColorBox|ctrlSetTooltipColorShade|ctrlSetTooltipColorText|ctrlShow|ctrlShown|ctrlText|ctrlTextHeight|ctrlTextSecondary|ctrlTextWidth|ctrlType|ctrlVisible|ctRowControls|ctRowCount|ctSetCurSel|ctSetData|ctSetHeaderTemplate|ctSetRowTemplate|ctSetValue|ctValue|curatorAddons|curatorCamera|curatorCameraArea|curatorCameraAreaCeiling|curatorCoef|curatorEditableObjects|curatorEditingArea|curatorEditingAreaType|curatorMouseOver|curatorPoints|curatorRegisteredObjects|curatorSelected|curatorWaypointCost|current3DENOperation|currentChannel|currentCommand|currentMagazine|currentMagazineDetail|currentMagazineDetailTurret|currentMagazineTurret|currentMuzzle|currentNamespace|currentTask|currentTasks|currentThrowable|currentVisionMode|currentWaypoint|currentWeapon|currentWeaponMode|currentWeaponTurret|currentZeroing|cursorObject|cursorTarget|customChat|customRadio|cutFadeOut|cutObj|cutRsc|cutText|damage|date|dateToNumber|daytime|deActivateKey|debriefingText|debugFSM|debugLog|deg|delete3DENEntities|deleteAt|deleteCenter|deleteCollection|deleteEditorObject|deleteGroup|deleteGroupWhenEmpty|deleteIdentity|deleteLocation|deleteMarker|deleteMarkerLocal|deleteRange|deleteResources|deleteSite|deleteStatus|deleteTeam|deleteVehicle|deleteVehicleCrew|deleteWaypoint|detach|detectedMines|diag_activeMissionFSMs|diag_activeScripts|diag_activeSQFScripts|diag_activeSQSScripts|diag_captureFrame|diag_captureFrameToFile|diag_captureSlowFrame|diag_codePerformance|diag_drawMode|diag_dynamicSimulationEnd|diag_enable|diag_enabled|diag_fps|diag_fpsMin|diag_frameNo|diag_lightNewLoad|diag_list|diag_log|diag_logSlowFrame|diag_mergeConfigFile|diag_recordTurretLimits|diag_setLightNew|diag_tickTime|diag_toggle|dialog|diarySubjectExists|didJIP|didJIPOwner|difficulty|difficultyEnabled|difficultyEnabledRTD|difficultyOption|direction|directSay|disableAI|disableCollisionWith|disableConversation|disableDebriefingStats|disableMapIndicators|disableNVGEquipment|disableRemoteSensors|disableSerialization|disableTIEquipment|disableUAVConnectability|disableUserInput|displayAddEventHandler|displayCtrl|displayNull|displayParent|displayRemoveAllEventHandlers|displayRemoveEventHandler|displaySetEventHandler|dissolveTeam|distance|distance2D|distanceSqr|distributionRegion|do3DENAction|doArtilleryFire|doFire|doFollow|doFSM|doGetOut|doMove|doorPhase|doStop|doSuppressiveFire|doTarget|doWatch|drawArrow|drawEllipse|drawIcon|drawIcon3D|drawLine|drawLine3D|drawLink|drawLocation|drawPolygon|drawRectangle|drawTriangle|driver|drop|dynamicSimulationDistance|dynamicSimulationDistanceCoef|dynamicSimulationEnabled|dynamicSimulationSystemEnabled|east|edit3DENMissionAttributes|editObject|editorSetEventHandler|effectiveCommander|emptyPositions|enableAI|enableAIFeature|enableAimPrecision|enableAttack|enableAudioFeature|enableAutoStartUpRTD|enableAutoTrimRTD|enableCamShake|enableCaustics|enableChannel|enableCollisionWith|enableCopilot|enableDebriefingStats|enableDiagLegend|enableDynamicSimulation|enableDynamicSimulationSystem|enableEndDialog|enableEngineArtillery|enableEnvironment|enableFatigue|enableGunLights|enableInfoPanelComponent|enableIRLasers|enableMimics|enablePersonTurret|enableRadio|enableReload|enableRopeAttach|enableSatNormalOnDetail|enableSaving|enableSentences|enableSimulation|enableSimulationGlobal|enableStamina|enableStressDamage|enableTeamSwitch|enableTraffic|enableUAVConnectability|enableUAVWaypoints|enableVehicleCargo|enableVehicleSensor|enableWeaponDisassembly|endl|endLoadingScreen|endMission|engineOn|enginesIsOnRTD|enginesPowerRTD|enginesRpmRTD|enginesTorqueRTD|entities|environmentEnabled|estimatedEndServerTime|estimatedTimeLeft|evalObjectArgument|everyBackpack|everyContainer|exec|execEditorScript|exp|expectedDestination|exportJIPMessages|eyeDirection|eyePos|face|faction|fadeMusic|fadeRadio|fadeSound|fadeSpeech|failMission|fillWeaponsFromPool|find|findCover|findDisplay|findEditorObject|findEmptyPosition|findEmptyPositionReady|findIf|findNearestEnemy|finishMissionInit|finite|fire|fireAtTarget|firstBackpack|flag|flagAnimationPhase|flagOwner|flagSide|flagTexture|fleeing|floor|flyInHeight|flyInHeightASL|fog|fogForecast|fogParams|forceAddUniform|forceAtPositionRTD|forcedMap|forceEnd|forceFlagTexture|forceFollowRoad|forceGeneratorRTD|forceMap|forceRespawn|forceSpeed|forceWalk|forceWeaponFire|forceWeatherChange|forgetTarget|format|formation|formationDirection|formationLeader|formationMembers|formationPosition|formationTask|formatText|formLeader|freeLook|fromEditor|fuel|fullCrew|gearIDCAmmoCount|gearSlotAmmoCount|gearSlotData|get3DENActionState|get3DENAttribute|get3DENCamera|get3DENConnections|get3DENEntity|get3DENEntityID|get3DENGrid|get3DENIconsVisible|get3DENLayerEntities|get3DENLinesVisible|get3DENMissionAttribute|get3DENMouseOver|get3DENSelected|getAimingCoef|getAllEnvSoundControllers|getAllHitPointsDamage|getAllOwnedMines|getAllSoundControllers|getAmmoCargo|getAnimAimPrecision|getAnimSpeedCoef|getArray|getArtilleryAmmo|getArtilleryComputerSettings|getArtilleryETA|getAssignedCuratorLogic|getAssignedCuratorUnit|getBackpackCargo|getBleedingRemaining|getBurningValue|getCameraViewDirection|getCargoIndex|getCenterOfMass|getClientState|getClientStateNumber|getCompatiblePylonMagazines|getConnectedUAV|getContainerMaxLoad|getCursorObjectParams|getCustomAimCoef|getDammage|getDescription|getDir|getDirVisual|getDLCAssetsUsage|getDLCAssetsUsageByName|getDLCs|getDLCUsageTime|getEditorCamera|getEditorMode|getEditorObjectScope|getElevationOffset|getEngineTargetRpmRTD|getEnvSoundController|getFatigue|getFieldManualStartPage|getForcedFlagTexture|getFriend|getFSMVariable|getFuelCargo|getGroupIcon|getGroupIconParams|getGroupIcons|getHideFrom|getHit|getHitIndex|getHitPointDamage|getItemCargo|getMagazineCargo|getMarkerColor|getMarkerPos|getMarkerSize|getMarkerType|getMass|getMissionConfig|getMissionConfigValue|getMissionDLCs|getMissionLayerEntities|getMissionLayers|getModelInfo|getMousePosition|getMusicPlayedTime|getNumber|getObjectArgument|getObjectChildren|getObjectDLC|getObjectMaterials|getObjectProxy|getObjectTextures|getObjectType|getObjectViewDistance|getOxygenRemaining|getPersonUsedDLCs|getPilotCameraDirection|getPilotCameraPosition|getPilotCameraRotation|getPilotCameraTarget|getPlateNumber|getPlayerChannel|getPlayerScores|getPlayerUID|getPlayerUIDOld|getPos|getPosASL|getPosASLVisual|getPosASLW|getPosATL|getPosATLVisual|getPosVisual|getPosWorld|getPylonMagazines|getRelDir|getRelPos|getRemoteSensorsDisabled|getRepairCargo|getResolution|getRotorBrakeRTD|getShadowDistance|getShotParents|getSlingLoad|getSoundController|getSoundControllerResult|getSpeed|getStamina|getStatValue|getSuppression|getTerrainGrid|getTerrainHeightASL|getText|getTotalDLCUsageTime|getTrimOffsetRTD|getUnitLoadout|getUnitTrait|getUserMFDText|getUserMFDValue|getVariable|getVehicleCargo|getWeaponCargo|getWeaponSway|getWingsOrientationRTD|getWingsPositionRTD|getWPPos|glanceAt|globalChat|globalRadio|goggles|group|groupChat|groupFromNetId|groupIconSelectable|groupIconsVisible|groupId|groupOwner|groupRadio|groupSelectedUnits|groupSelectUnit|grpNull|gunner|gusts|halt|handgunItems|handgunMagazine|handgunWeapon|handsHit|hasInterface|hasPilotCamera|hasWeapon|hcAllGroups|hcGroupParams|hcLeader|hcRemoveAllGroups|hcRemoveGroup|hcSelected|hcSelectGroup|hcSetGroup|hcShowBar|hcShownBar|headgear|hideBody|hideObject|hideObjectGlobal|hideSelection|hint|hintC|hintCadet|hintSilent|hmd|hostMission|htmlLoad|HUDMovementLevels|humidity|image|importAllGroups|importance|in|inArea|inAreaArray|incapacitatedState|independent|inflame|inflamed|infoPanel|infoPanelComponentEnabled|infoPanelComponents|infoPanels|inGameUISetEventHandler|inheritsFrom|initAmbientLife|inPolygon|inputAction|inRangeOfArtillery|insertEditorObject|intersect|is3DEN|is3DENMultiplayer|isAbleToBreathe|isAgent|isAimPrecisionEnabled|isArray|isAutoHoverOn|isAutonomous|isAutoStartUpEnabledRTD|isAutotest|isAutoTrimOnRTD|isBleeding|isBurning|isClass|isCollisionLightOn|isCopilotEnabled|isDamageAllowed|isDedicated|isDLCAvailable|isEngineOn|isEqualTo|isEqualType|isEqualTypeAll|isEqualTypeAny|isEqualTypeArray|isEqualTypeParams|isFilePatchingEnabled|isFlashlightOn|isFlatEmpty|isForcedWalk|isFormationLeader|isGroupDeletedWhenEmpty|isHidden|isInRemainsCollector|isInstructorFigureEnabled|isIRLaserOn|isKeyActive|isKindOf|isLaserOn|isLightOn|isLocalized|isManualFire|isMarkedForCollection|isMultiplayer|isMultiplayerSolo|isNil|isNull|isNumber|isObjectHidden|isObjectRTD|isOnRoad|isPipEnabled|isPlayer|isRealTime|isRemoteExecuted|isRemoteExecutedJIP|isServer|isShowing3DIcons|isSimpleObject|isSprintAllowed|isStaminaEnabled|isSteamMission|isStreamFriendlyUIEnabled|isStressDamageEnabled|isText|isTouchingGround|isTurnedOut|isTutHintsEnabled|isUAVConnectable|isUAVConnected|isUIContext|isUniformAllowed|isVehicleCargo|isVehicleRadarOn|isVehicleSensorEnabled|isWalking|isWeaponDeployed|isWeaponRested|itemCargo|items|itemsWithMagazines|join|joinAs|joinAsSilent|joinSilent|joinString|kbAddDatabase|kbAddDatabaseTargets|kbAddTopic|kbHasTopic|kbReact|kbRemoveTopic|kbTell|kbWasSaid|keyImage|keyName|knowsAbout|land|landAt|landResult|language|laserTarget|lbAdd|lbClear|lbColor|lbColorRight|lbCurSel|lbData|lbDelete|lbIsSelected|lbPicture|lbPictureRight|lbSelection|lbSetColor|lbSetColorRight|lbSetCurSel|lbSetData|lbSetPicture|lbSetPictureColor|lbSetPictureColorDisabled|lbSetPictureColorSelected|lbSetPictureRight|lbSetPictureRightColor|lbSetPictureRightColorDisabled|lbSetPictureRightColorSelected|lbSetSelectColor|lbSetSelectColorRight|lbSetSelected|lbSetText|lbSetTextRight|lbSetTooltip|lbSetValue|lbSize|lbSort|lbSortByValue|lbText|lbTextRight|lbValue|leader|leaderboardDeInit|leaderboardGetRows|leaderboardInit|leaderboardRequestRowsFriends|leaderboardRequestRowsGlobal|leaderboardRequestRowsGlobalAroundUser|leaderboardsRequestUploadScore|leaderboardsRequestUploadScoreKeepBest|leaderboardState|leaveVehicle|libraryCredits|libraryDisclaimers|lifeState|lightAttachObject|lightDetachObject|lightIsOn|lightnings|limitSpeed|linearConversion|lineBreak|lineIntersects|lineIntersectsObjs|lineIntersectsSurfaces|lineIntersectsWith|linkItem|list|listObjects|listRemoteTargets|listVehicleSensors|ln|lnbAddArray|lnbAddColumn|lnbAddRow|lnbClear|lnbColor|lnbColorRight|lnbCurSelRow|lnbData|lnbDeleteColumn|lnbDeleteRow|lnbGetColumnsPosition|lnbPicture|lnbPictureRight|lnbSetColor|lnbSetColorRight|lnbSetColumnsPos|lnbSetCurSelRow|lnbSetData|lnbSetPicture|lnbSetPictureColor|lnbSetPictureColorRight|lnbSetPictureColorSelected|lnbSetPictureColorSelectedRight|lnbSetPictureRight|lnbSetText|lnbSetTextRight|lnbSetValue|lnbSize|lnbSort|lnbSortByValue|lnbText|lnbTextRight|lnbValue|load|loadAbs|loadBackpack|loadFile|loadGame|loadIdentity|loadMagazine|loadOverlay|loadStatus|loadUniform|loadVest|local|localize|locationNull|locationPosition|lock|lockCameraTo|lockCargo|lockDriver|locked|lockedCargo|lockedDriver|lockedTurret|lockIdentity|lockTurret|lockWP|log|logEntities|logNetwork|logNetworkTerminate|lookAt|lookAtPos|magazineCargo|magazines|magazinesAllTurrets|magazinesAmmo|magazinesAmmoCargo|magazinesAmmoFull|magazinesDetail|magazinesDetailBackpack|magazinesDetailUniform|magazinesDetailVest|magazinesTurret|magazineTurretAmmo|mapAnimAdd|mapAnimClear|mapAnimCommit|mapAnimDone|mapCenterOnCamera|mapGridPosition|markAsFinishedOnSteam|markerAlpha|markerBrush|markerColor|markerDir|markerPos|markerShape|markerSize|markerText|markerType|max|members|menuAction|menuAdd|menuChecked|menuClear|menuCollapse|menuData|menuDelete|menuEnable|menuEnabled|menuExpand|menuHover|menuPicture|menuSetAction|menuSetCheck|menuSetData|menuSetPicture|menuSetValue|menuShortcut|menuShortcutText|menuSize|menuSort|menuText|menuURL|menuValue|min|mineActive|mineDetectedBy|missionConfigFile|missionDifficulty|missionName|missionNamespace|missionStart|missionVersion|modelToWorld|modelToWorldVisual|modelToWorldVisualWorld|modelToWorldWorld|modParams|moonIntensity|moonPhase|morale|move|move3DENCamera|moveInAny|moveInCargo|moveInCommander|moveInDriver|moveInGunner|moveInTurret|moveObjectToEnd|moveOut|moveTime|moveTo|moveToCompleted|moveToFailed|musicVolume|name|nameSound|nearEntities|nearestBuilding|nearestLocation|nearestLocations|nearestLocationWithDubbing|nearestObject|nearestObjects|nearestTerrainObjects|nearObjects|nearObjectsReady|nearRoads|nearSupplies|nearTargets|needReload|netId|netObjNull|newOverlay|nextMenuItemIndex|nextWeatherChange|nMenuItems|numberOfEnginesRTD|numberToDate|objectCurators|objectFromNetId|objectParent|objNull|objStatus|onBriefingGear|onBriefingGroup|onBriefingNotes|onBriefingPlan|onBriefingTeamSwitch|onCommandModeChanged|onDoubleClick|onEachFrame|onGroupIconClick|onGroupIconOverEnter|onGroupIconOverLeave|onHCGroupSelectionChanged|onMapSingleClick|onPlayerConnected|onPlayerDisconnected|onPreloadFinished|onPreloadStarted|onShowNewObject|onTeamSwitch|openCuratorInterface|openDLCPage|openDSInterface|openMap|openSteamApp|openYoutubeVideo|opfor|orderGetIn|overcast|overcastForecast|owner|param|params|parseNumber|parseSimpleArray|parseText|parsingNamespace|particlesQuality|pi|pickWeaponPool|pitch|pixelGrid|pixelGridBase|pixelGridNoUIScale|pixelH|pixelW|playableSlotsNumber|playableUnits|playAction|playActionNow|player|playerRespawnTime|playerSide|playersNumber|playGesture|playMission|playMove|playMoveNow|playMusic|playScriptedMission|playSound|playSound3D|position|positionCameraToWorld|posScreenToWorld|posWorldToScreen|ppEffectAdjust|ppEffectCommit|ppEffectCommitted|ppEffectCreate|ppEffectDestroy|ppEffectEnable|ppEffectEnabled|ppEffectForceInNVG|precision|preloadCamera|preloadObject|preloadSound|preloadTitleObj|preloadTitleRsc|primaryWeapon|primaryWeaponItems|primaryWeaponMagazine|priority|processDiaryLink|processInitCommands|productVersion|profileName|profileNamespace|profileNameSteam|progressLoadingScreen|progressPosition|progressSetPosition|publicVariable|publicVariableClient|publicVariableServer|pushBack|pushBackUnique|putWeaponPool|queryItemsPool|queryMagazinePool|queryWeaponPool|rad|radioChannelAdd|radioChannelCreate|radioChannelRemove|radioChannelSetCallSign|radioChannelSetLabel|radioVolume|rain|rainbow|random|rank|rankId|rating|rectangular|registeredTasks|registerTask|reload|reloadEnabled|remoteControl|remoteExec|remoteExecCall|remoteExecutedOwner|remove3DENConnection|remove3DENEventHandler|remove3DENLayer|removeAction|removeAll3DENEventHandlers|removeAllActions|removeAllAssignedItems|removeAllContainers|removeAllCuratorAddons|removeAllCuratorCameraAreas|removeAllCuratorEditingAreas|removeAllEventHandlers|removeAllHandgunItems|removeAllItems|removeAllItemsWithMagazines|removeAllMissionEventHandlers|removeAllMPEventHandlers|removeAllMusicEventHandlers|removeAllOwnedMines|removeAllPrimaryWeaponItems|removeAllWeapons|removeBackpack|removeBackpackGlobal|removeCuratorAddons|removeCuratorCameraArea|removeCuratorEditableObjects|removeCuratorEditingArea|removeDrawIcon|removeDrawLinks|removeEventHandler|removeFromRemainsCollector|removeGoggles|removeGroupIcon|removeHandgunItem|removeHeadgear|removeItem|removeItemFromBackpack|removeItemFromUniform|removeItemFromVest|removeItems|removeMagazine|removeMagazineGlobal|removeMagazines|removeMagazinesTurret|removeMagazineTurret|removeMenuItem|removeMissionEventHandler|removeMPEventHandler|removeMusicEventHandler|removeOwnedMine|removePrimaryWeaponItem|removeSecondaryWeaponItem|removeSimpleTask|removeSwitchableUnit|removeTeamMember|removeUniform|removeVest|removeWeapon|removeWeaponAttachmentCargo|removeWeaponCargo|removeWeaponGlobal|removeWeaponTurret|reportRemoteTarget|requiredVersion|resetCamShake|resetSubgroupDirection|resistance|resize|resources|respawnVehicle|restartEditorCamera|reveal|revealMine|reverse|reversedMouseY|roadAt|roadsConnectedTo|roleDescription|ropeAttachedObjects|ropeAttachedTo|ropeAttachEnabled|ropeAttachTo|ropeCreate|ropeCut|ropeDestroy|ropeDetach|ropeEndPosition|ropeLength|ropes|ropeUnwind|ropeUnwound|rotorsForcesRTD|rotorsRpmRTD|round|runInitScript|safeZoneH|safeZoneW|safeZoneWAbs|safeZoneX|safeZoneXAbs|safeZoneY|save3DENInventory|saveGame|saveIdentity|saveJoysticks|saveOverlay|saveProfileNamespace|saveStatus|saveVar|savingEnabled|say|say2D|say3D|score|scoreSide|screenshot|screenToWorld|scriptDone|scriptName|scriptNull|scudState|secondaryWeapon|secondaryWeaponItems|secondaryWeaponMagazine|select|selectBestPlaces|selectDiarySubject|selectedEditorObjects|selectEditorObject|selectionNames|selectionPosition|selectLeader|selectMax|selectMin|selectNoPlayer|selectPlayer|selectRandom|selectRandomWeighted|selectWeapon|selectWeaponTurret|sendAUMessage|sendSimpleCommand|sendTask|sendTaskResult|sendUDPMessage|serverCommand|serverCommandAvailable|serverCommandExecutable|serverName|serverTime|set|set3DENAttribute|set3DENAttributes|set3DENGrid|set3DENIconsVisible|set3DENLayer|set3DENLinesVisible|set3DENLogicType|set3DENMissionAttribute|set3DENMissionAttributes|set3DENModelsVisible|set3DENObjectType|set3DENSelected|setAccTime|setActualCollectiveRTD|setAirplaneThrottle|setAirportSide|setAmmo|setAmmoCargo|setAmmoOnPylon|setAnimSpeedCoef|setAperture|setApertureNew|setArmoryPoints|setAttributes|setAutonomous|setBehaviour|setBleedingRemaining|setBrakesRTD|setCameraInterest|setCamShakeDefParams|setCamShakeParams|setCamUseTI|setCaptive|setCenterOfMass|setCollisionLight|setCombatMode|setCompassOscillation|setConvoySeparation|setCuratorCameraAreaCeiling|setCuratorCoef|setCuratorEditingAreaType|setCuratorWaypointCost|setCurrentChannel|setCurrentTask|setCurrentWaypoint|setCustomAimCoef|setCustomWeightRTD|setDamage|setDammage|setDate|setDebriefingText|setDefaultCamera|setDestination|setDetailMapBlendPars|setDir|setDirection|setDrawIcon|setDriveOnPath|setDropInterval|setDynamicSimulationDistance|setDynamicSimulationDistanceCoef|setEditorMode|setEditorObjectScope|setEffectCondition|setEngineRpmRTD|setFace|setFaceAnimation|setFatigue|setFeatureType|setFlagAnimationPhase|setFlagOwner|setFlagSide|setFlagTexture|setFog|setForceGeneratorRTD|setFormation|setFormationTask|setFormDir|setFriend|setFromEditor|setFSMVariable|setFuel|setFuelCargo|setGroupIcon|setGroupIconParams|setGroupIconsSelectable|setGroupIconsVisible|setGroupId|setGroupIdGlobal|setGroupOwner|setGusts|setHideBehind|setHit|setHitIndex|setHitPointDamage|setHorizonParallaxCoef|setHUDMovementLevels|setIdentity|setImportance|setInfoPanel|setLeader|setLightAmbient|setLightAttenuation|setLightBrightness|setLightColor|setLightDayLight|setLightFlareMaxDistance|setLightFlareSize|setLightIntensity|setLightnings|setLightUseFlare|setLocalWindParams|setMagazineTurretAmmo|setMarkerAlpha|setMarkerAlphaLocal|setMarkerBrush|setMarkerBrushLocal|setMarkerColor|setMarkerColorLocal|setMarkerDir|setMarkerDirLocal|setMarkerPos|setMarkerPosLocal|setMarkerShape|setMarkerShapeLocal|setMarkerSize|setMarkerSizeLocal|setMarkerText|setMarkerTextLocal|setMarkerType|setMarkerTypeLocal|setMass|setMimic|setMousePosition|setMusicEffect|setMusicEventHandler|setName|setNameSound|setObjectArguments|setObjectMaterial|setObjectMaterialGlobal|setObjectProxy|setObjectTexture|setObjectTextureGlobal|setObjectViewDistance|setOvercast|setOwner|setOxygenRemaining|setParticleCircle|setParticleClass|setParticleFire|setParticleParams|setParticleRandom|setPilotCameraDirection|setPilotCameraRotation|setPilotCameraTarget|setPilotLight|setPiPEffect|setPitch|setPlateNumber|setPlayable|setPlayerRespawnTime|setPos|setPosASL|setPosASL2|setPosASLW|setPosATL|setPosition|setPosWorld|setPylonLoadOut|setPylonsPriority|setRadioMsg|setRain|setRainbow|setRandomLip|setRank|setRectangular|setRepairCargo|setRotorBrakeRTD|setShadowDistance|setShotParents|setSide|setSimpleTaskAlwaysVisible|setSimpleTaskCustomData|setSimpleTaskDescription|setSimpleTaskDestination|setSimpleTaskTarget|setSimpleTaskType|setSimulWeatherLayers|setSize|setSkill|setSlingLoad|setSoundEffect|setSpeaker|setSpeech|setSpeedMode|setStamina|setStaminaScheme|setStatValue|setSuppression|setSystemOfUnits|setTargetAge|setTaskMarkerOffset|setTaskResult|setTaskState|setTerrainGrid|setText|setTimeMultiplier|setTitleEffect|setToneMapping|setToneMappingParams|setTrafficDensity|setTrafficDistance|setTrafficGap|setTrafficSpeed|setTriggerActivation|setTriggerArea|setTriggerStatements|setTriggerText|setTriggerTimeout|setTriggerType|setType|setUnconscious|setUnitAbility|setUnitLoadout|setUnitPos|setUnitPosWeak|setUnitRank|setUnitRecoilCoefficient|setUnitTrait|setUnloadInCombat|setUserActionText|setUserMFDText|setUserMFDValue|setVariable|setVectorDir|setVectorDirAndUp|setVectorUp|setVehicleAmmo|setVehicleAmmoDef|setVehicleArmor|setVehicleCargo|setVehicleId|setVehicleInit|setVehicleLock|setVehiclePosition|setVehicleRadar|setVehicleReceiveRemoteTargets|setVehicleReportOwnPosition|setVehicleReportRemoteTargets|setVehicleTIPars|setVehicleVarName|setVelocity|setVelocityModelSpace|setVelocityTransformation|setViewDistance|setVisibleIfTreeCollapsed|setWantedRpmRTD|setWaves|setWaypointBehaviour|setWaypointCombatMode|setWaypointCompletionRadius|setWaypointDescription|setWaypointForceBehaviour|setWaypointFormation|setWaypointHousePosition|setWaypointLoiterRadius|setWaypointLoiterType|setWaypointName|setWaypointPosition|setWaypointScript|setWaypointSpeed|setWaypointStatements|setWaypointTimeout|setWaypointType|setWaypointVisible|setWeaponReloadingTime|setWind|setWindDir|setWindForce|setWindStr|setWingForceScaleRTD|setWPPos|show3DIcons|showChat|showCinemaBorder|showCommandingMenu|showCompass|showCuratorCompass|showGPS|showHUD|showLegend|showMap|shownArtilleryComputer|shownChat|shownCompass|shownCuratorCompass|showNewEditorObject|shownGPS|shownHUD|shownMap|shownPad|shownRadio|shownScoretable|shownUAVFeed|shownWarrant|shownWatch|showPad|showRadio|showScoretable|showSubtitles|showUAVFeed|showWarrant|showWatch|showWaypoint|showWaypoints|side|sideAmbientLife|sideChat|sideEmpty|sideEnemy|sideFriendly|sideLogic|sideRadio|sideUnknown|simpleTasks|simulationEnabled|simulCloudDensity|simulCloudOcclusion|simulInClouds|simulWeatherSync|sin|size|sizeOf|skill|skillFinal|skipTime|sleep|sliderPosition|sliderRange|sliderSetPosition|sliderSetRange|sliderSetSpeed|sliderSpeed|slingLoadAssistantShown|soldierMagazines|someAmmo|sort|soundVolume|speaker|speed|speedMode|splitString|sqrt|squadParams|stance|startLoadingScreen|stop|stopEngineRTD|stopped|str|sunOrMoon|supportInfo|suppressFor|surfaceIsWater|surfaceNormal|surfaceType|swimInDepth|switchableUnits|switchAction|switchCamera|switchGesture|switchLight|switchMove|synchronizedObjects|synchronizedTriggers|synchronizedWaypoints|synchronizeObjectsAdd|synchronizeObjectsRemove|synchronizeTrigger|synchronizeWaypoint|systemChat|systemOfUnits|tan|targetKnowledge|targets|targetsAggregate|targetsQuery|taskAlwaysVisible|taskChildren|taskCompleted|taskCustomData|taskDescription|taskDestination|taskHint|taskMarkerOffset|taskNull|taskParent|taskResult|taskState|taskType|teamMember|teamMemberNull|teamName|teams|teamSwitch|teamSwitchEnabled|teamType|terminate|terrainIntersect|terrainIntersectASL|terrainIntersectAtASL|text|textLog|textLogFormat|tg|time|timeMultiplier|titleCut|titleFadeOut|titleObj|titleRsc|titleText|toArray|toFixed|toLower|toString|toUpper|triggerActivated|triggerActivation|triggerArea|triggerAttachedVehicle|triggerAttachObject|triggerAttachVehicle|triggerDynamicSimulation|triggerStatements|triggerText|triggerTimeout|triggerTimeoutCurrent|triggerType|turretLocal|turretOwner|turretUnit|tvAdd|tvClear|tvCollapse|tvCollapseAll|tvCount|tvCurSel|tvData|tvDelete|tvExpand|tvExpandAll|tvPicture|tvPictureRight|tvSetColor|tvSetCurSel|tvSetData|tvSetPicture|tvSetPictureColor|tvSetPictureColorDisabled|tvSetPictureColorSelected|tvSetPictureRight|tvSetPictureRightColor|tvSetPictureRightColorDisabled|tvSetPictureRightColorSelected|tvSetSelectColor|tvSetText|tvSetTooltip|tvSetValue|tvSort|tvSortByValue|tvText|tvTooltip|tvValue|type|typeName|typeOf|UAVControl|uiNamespace|uiSleep|unassignCurator|unassignItem|unassignTeam|unassignVehicle|underwater|uniform|uniformContainer|uniformItems|uniformMagazines|unitAddons|unitAimPosition|unitAimPositionVisual|unitBackpack|unitIsUAV|unitPos|unitReady|unitRecoilCoefficient|units|unitsBelowHeight|unlinkItem|unlockAchievement|unregisterTask|updateDrawIcon|updateMenuItem|updateObjectTree|useAIOperMapObstructionTest|useAISteeringComponent|useAudioTimeForMoves|userInputDisabled|vectorAdd|vectorCos|vectorCrossProduct|vectorDiff|vectorDir|vectorDirVisual|vectorDistance|vectorDistanceSqr|vectorDotProduct|vectorFromTo|vectorMagnitude|vectorMagnitudeSqr|vectorModelToWorld|vectorModelToWorldVisual|vectorMultiply|vectorNormalized|vectorUp|vectorUpVisual|vectorWorldToModel|vectorWorldToModelVisual|vehicle|vehicleCargoEnabled|vehicleChat|vehicleRadio|vehicleReceiveRemoteTargets|vehicleReportOwnPosition|vehicleReportRemoteTargets|vehicles|vehicleVarName|velocity|velocityModelSpace|verifySignature|vest|vestContainer|vestItems|vestMagazines|viewDistance|visibleCompass|visibleGPS|visibleMap|visiblePosition|visiblePositionASL|visibleScoretable|visibleWatch|waitUntil|waves|waypointAttachedObject|waypointAttachedVehicle|waypointAttachObject|waypointAttachVehicle|waypointBehaviour|waypointCombatMode|waypointCompletionRadius|waypointDescription|waypointForceBehaviour|waypointFormation|waypointHousePosition|waypointLoiterRadius|waypointLoiterType|waypointName|waypointPosition|waypoints|waypointScript|waypointsEnabledUAV|waypointShow|waypointSpeed|waypointStatements|waypointTimeout|waypointTimeoutCurrent|waypointType|waypointVisible|weaponAccessories|weaponAccessoriesCargo|weaponCargo|weaponDirection|weaponInertia|weaponLowered|weapons|weaponsItems|weaponsItemsCargo|weaponState|weaponsTurret|weightRTD|west|WFSideText|wind|windDir|windRTD|windStr|wingsForcesRTD|worldName|worldSize|worldToModel|worldToModelVisual|worldToScreen)\b/i,
      number: /(?:\$|\b0x)[\da-f]+\b|(?:\B\.\d+|\b\d+(?:\.\d+)?)(?:e[+-]?\d+)?\b/i,
      operator: /##|>>|&&|\|\||[!=<>]=?|[-+*/%#^]|\b(?:and|mod|not|or)\b/i,
      "magic-variable": {
        pattern: /\b(?:this|thisList|thisTrigger|_exception|_fnc_scriptName|_fnc_scriptNameParent|_forEachIndex|_this|_thisEventHandler|_thisFSM|_thisScript|_x)\b/i,
        alias: "keyword"
      },
      constant: /\bDIK(?:_[a-z\d]+)+\b/i
    }), t.languages.insertBefore("sqf", "string", {
      macro: {
        pattern: /(^[ \t]*)#[a-z](?:[^\r\n\\]|\\(?:\r\n|[\s\S]))*/im,
        lookbehind: !0,
        greedy: !0,
        alias: "property",
        inside: {
          directive: {
            pattern: /#[a-z]+\b/i,
            alias: "keyword"
          },
          comment: t.languages.sqf.comment
        }
      }
    }), delete t.languages.sqf["class-name"];
  }
  return sqf_1;
}
var squirrel_1, hasRequiredSquirrel;
function requireSquirrel() {
  if (hasRequiredSquirrel) return squirrel_1;
  hasRequiredSquirrel = 1, squirrel_1 = e, e.displayName = "squirrel", e.aliases = [];
  function e(t) {
    t.languages.squirrel = t.languages.extend("clike", {
      comment: [t.languages.clike.comment[0], {
        pattern: /(^|[^\\:])(?:\/\/|#).*/,
        lookbehind: !0,
        greedy: !0
      }],
      string: {
        pattern: /(^|[^\\"'@])(?:@"(?:[^"]|"")*"(?!")|"(?:[^\\\r\n"]|\\.)*")/,
        lookbehind: !0,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:class|enum|extends|instanceof)\s+)\w+(?:\.\w+)*/,
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      },
      keyword: /\b(?:__FILE__|__LINE__|base|break|case|catch|class|clone|const|constructor|continue|default|delete|else|enum|extends|for|foreach|function|if|in|instanceof|local|null|resume|return|static|switch|this|throw|try|typeof|while|yield)\b/,
      number: /\b(?:0x[0-9a-fA-F]+|\d+(?:\.(?:\d+|[eE][+-]?\d+))?)\b/,
      operator: /\+\+|--|<=>|<[-<]|>>>?|&&?|\|\|?|[-+*/%!=<>]=?|[~^]|::?/,
      punctuation: /[(){}\[\],;.]/
    }), t.languages.insertBefore("squirrel", "string", {
      char: {
        pattern: /(^|[^\\"'])'(?:[^\\']|\\(?:[xuU][0-9a-fA-F]{0,8}|[\s\S]))'/,
        lookbehind: !0,
        greedy: !0
      }
    }), t.languages.insertBefore("squirrel", "operator", {
      "attribute-punctuation": {
        pattern: /<\/|\/>/,
        alias: "important"
      },
      lambda: {
        pattern: /@(?=\()/,
        alias: "operator"
      }
    });
  }
  return squirrel_1;
}
var stan_1, hasRequiredStan;
function requireStan() {
  if (hasRequiredStan) return stan_1;
  hasRequiredStan = 1, stan_1 = e, e.displayName = "stan", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = /\b(?:algebra_solver|algebra_solver_newton|integrate_1d|integrate_ode|integrate_ode_bdf|integrate_ode_rk45|map_rect|ode_(?:adams|bdf|ckrk|rk45)(?:_tol)?|ode_adjoint_tol_ctl|reduce_sum|reduce_sum_static)\b/;
      r.languages.stan = {
        comment: /\/\/.*|\/\*[\s\S]*?\*\/|#(?!include).*/,
        string: {
          // String literals can contain spaces and any printable ASCII characters except for " and \
          // https://mc-stan.org/docs/2_24/reference-manual/print-statements-section.html#string-literals
          pattern: /"[\x20\x21\x23-\x5B\x5D-\x7E]*"/,
          greedy: !0
        },
        directive: {
          pattern: /^([ \t]*)#include\b.*/m,
          lookbehind: !0,
          alias: "property"
        },
        "function-arg": {
          pattern: RegExp("(" + a.source + /\s*\(\s*/.source + ")" + /[a-zA-Z]\w*/.source),
          lookbehind: !0,
          alias: "function"
        },
        constraint: {
          pattern: /(\b(?:int|matrix|real|row_vector|vector)\s*)<[^<>]*>/,
          lookbehind: !0,
          inside: {
            expression: {
              pattern: /(=\s*)\S(?:\S|\s+(?!\s))*?(?=\s*(?:>$|,\s*\w+\s*=))/,
              lookbehind: !0,
              inside: null
              // see below
            },
            property: /\b[a-z]\w*(?=\s*=)/i,
            operator: /=/,
            punctuation: /^<|>$|,/
          }
        },
        keyword: [
          {
            pattern: /\bdata(?=\s*\{)|\b(?:functions|generated|model|parameters|quantities|transformed)\b/,
            alias: "program-block"
          },
          /\b(?:array|break|cholesky_factor_corr|cholesky_factor_cov|complex|continue|corr_matrix|cov_matrix|data|else|for|if|in|increment_log_prob|int|matrix|ordered|positive_ordered|print|real|reject|return|row_vector|simplex|target|unit_vector|vector|void|while)\b/,
          // these are functions that are known to take another function as their first argument.
          a
        ],
        function: /\b[a-z]\w*(?=\s*\()/i,
        number: /(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:E[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
        boolean: /\b(?:false|true)\b/,
        operator: /<-|\.[*/]=?|\|\|?|&&|[!=<>+\-*/]=?|['^%~?:]/,
        punctuation: /[()\[\]{},;]/
      }, r.languages.stan.constraint.inside.expression.inside = r.languages.stan;
    })(t);
  }
  return stan_1;
}
var stylus_1, hasRequiredStylus;
function requireStylus() {
  if (hasRequiredStylus) return stylus_1;
  hasRequiredStylus = 1, stylus_1 = e, e.displayName = "stylus", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = {
        pattern: /(\b\d+)(?:%|[a-z]+)/,
        lookbehind: !0
      }, o = {
        pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
        lookbehind: !0
      }, u = {
        comment: {
          pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
          lookbehind: !0
        },
        url: {
          pattern: /\burl\((["']?).*?\1\)/i,
          greedy: !0
        },
        string: {
          pattern: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
          greedy: !0
        },
        interpolation: null,
        // See below
        func: null,
        // See below
        important: /\B!(?:important|optional)\b/i,
        keyword: {
          pattern: /(^|\s+)(?:(?:else|for|if|return|unless)(?=\s|$)|@[\w-]+)/,
          lookbehind: !0
        },
        hexcode: /#[\da-f]{3,6}/i,
        color: [/\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\b/i, {
          pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
          inside: {
            unit: a,
            number: o,
            function: /[\w-]+(?=\()/,
            punctuation: /[(),]/
          }
        }],
        entity: /\\[\da-f]{1,8}/i,
        unit: a,
        boolean: /\b(?:false|true)\b/,
        operator: [
          // We want non-word chars around "-" because it is
          // accepted in property names.
          /~|[+!\/%<>?=]=?|[-:]=|\*[*=]?|\.{2,3}|&&|\|\||\B-\B|\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\b/
        ],
        number: o,
        punctuation: /[{}()\[\];:,]/
      };
      u.interpolation = {
        pattern: /\{[^\r\n}:]+\}/,
        alias: "variable",
        inside: {
          delimiter: {
            pattern: /^\{|\}$/,
            alias: "punctuation"
          },
          rest: u
        }
      }, u.func = {
        pattern: /[\w-]+\([^)]*\).*/,
        inside: {
          function: /^[^(]+/,
          rest: u
        }
      }, r.languages.stylus = {
        "atrule-declaration": {
          pattern: /(^[ \t]*)@.+/m,
          lookbehind: !0,
          inside: {
            atrule: /^@[\w-]+/,
            rest: u
          }
        },
        "variable-declaration": {
          pattern: /(^[ \t]*)[\w$-]+\s*.?=[ \t]*(?:\{[^{}]*\}|\S.*|$)/m,
          lookbehind: !0,
          inside: {
            variable: /^\S+/,
            rest: u
          }
        },
        statement: {
          pattern: /(^[ \t]*)(?:else|for|if|return|unless)[ \t].+/m,
          lookbehind: !0,
          inside: {
            keyword: /^\S+/,
            rest: u
          }
        },
        // A property/value pair cannot end with a comma or a brace
        // It cannot have indented content unless it ended with a semicolon
        "property-declaration": {
          pattern: /((?:^|\{)([ \t]*))(?:[\w-]|\{[^}\r\n]+\})+(?:\s*:\s*|[ \t]+)(?!\s)[^{\r\n]*(?:;|[^{\r\n,]$(?!(?:\r?\n|\r)(?:\{|\2[ \t])))/m,
          lookbehind: !0,
          inside: {
            property: {
              pattern: /^[^\s:]+/,
              inside: {
                interpolation: u.interpolation
              }
            },
            rest: u
          }
        },
        // A selector can contain parentheses only as part of a pseudo-element
        // It can span multiple lines.
        // It must end with a comma or an accolade or have indented content.
        selector: {
          pattern: /(^[ \t]*)(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)(?:(?:\r?\n|\r)(?:\1(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)))*(?:,$|\{|(?=(?:\r?\n|\r)(?:\{|\1[ \t])))/m,
          lookbehind: !0,
          inside: {
            interpolation: u.interpolation,
            comment: u.comment,
            punctuation: /[{},]/
          }
        },
        func: u.func,
        string: u.string,
        comment: {
          pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
          lookbehind: !0,
          greedy: !0
        },
        interpolation: u.interpolation,
        punctuation: /[{}()\[\];:.]/
      };
    })(t);
  }
  return stylus_1;
}
var swift_1, hasRequiredSwift;
function requireSwift() {
  if (hasRequiredSwift) return swift_1;
  hasRequiredSwift = 1, swift_1 = e, e.displayName = "swift", e.aliases = [];
  function e(t) {
    t.languages.swift = {
      comment: {
        // Nested comments are supported up to 2 levels
        pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
        lookbehind: !0,
        greedy: !0
      },
      "string-literal": [
        // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
        {
          pattern: RegExp(/(^|[^"#])/.source + "(?:" + // single-line string
          /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + // multi-line string
          /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source),
          lookbehind: !0,
          greedy: !0,
          inside: {
            interpolation: {
              pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
              lookbehind: !0,
              inside: null
              // see below
            },
            "interpolation-punctuation": {
              pattern: /^\)|\\\($/,
              alias: "punctuation"
            },
            punctuation: /\\(?=[\r\n])/,
            string: /[\s\S]+/
          }
        },
        {
          pattern: RegExp(/(^|[^"#])(#+)/.source + "(?:" + // single-line string
          /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + // multi-line string
          /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"),
          lookbehind: !0,
          greedy: !0,
          inside: {
            interpolation: {
              pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
              lookbehind: !0,
              inside: null
              // see below
            },
            "interpolation-punctuation": {
              pattern: /^\)|\\#+\($/,
              alias: "punctuation"
            },
            string: /[\s\S]+/
          }
        }
      ],
      directive: {
        // directives with conditions
        pattern: RegExp(/#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + // This regex is a little complex. It's equivalent to this:
        //   (?:![ \t]*)?(?:\b\w+\b(?:[ \t]*<round>)?|<round>)(?:[ \t]*(?:&&|\|\|))?
        // where <round> is a general parentheses expression.
        /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"),
        alias: "property",
        inside: {
          "directive-name": /^#\w+/,
          boolean: /\b(?:false|true)\b/,
          number: /\b\d+(?:\.\d+)*\b/,
          operator: /!|&&|\|\||[<>]=?/,
          punctuation: /[(),]/
        }
      },
      literal: {
        pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
        alias: "constant"
      },
      "other-directive": {
        pattern: /#\w+\b/,
        alias: "property"
      },
      attribute: {
        pattern: /@\w+/,
        alias: "atrule"
      },
      "function-definition": {
        pattern: /(\bfunc\s+)\w+/,
        lookbehind: !0,
        alias: "function"
      },
      label: {
        // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
        pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
        lookbehind: !0,
        alias: "important"
      },
      keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
      boolean: /\b(?:false|true)\b/,
      nil: {
        pattern: /\bnil\b/,
        alias: "constant"
      },
      "short-argument": /\$\d+\b/,
      omit: {
        pattern: /\b_\b/,
        alias: "keyword"
      },
      number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
      // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
      "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
      // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
      // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
      // This regex only supports ASCII operators.
      operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
      punctuation: /[{}[\]();,.:\\]/
    }, t.languages.swift["string-literal"].forEach(function(r) {
      r.inside.interpolation.inside = t.languages.swift;
    });
  }
  return swift_1;
}
var systemd_1, hasRequiredSystemd;
function requireSystemd() {
  if (hasRequiredSystemd) return systemd_1;
  hasRequiredSystemd = 1, systemd_1 = e, e.displayName = "systemd", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = {
        pattern: /^[;#].*/m,
        greedy: !0
      }, o = /"(?:[^\r\n"\\]|\\(?:[^\r]|\r\n?))*"(?!\S)/.source;
      r.languages.systemd = {
        comment: a,
        section: {
          pattern: /^\[[^\n\r\[\]]*\](?=[ \t]*$)/m,
          greedy: !0,
          inside: {
            punctuation: /^\[|\]$/,
            "section-name": {
              pattern: /[\s\S]+/,
              alias: "selector"
            }
          }
        },
        key: {
          pattern: /^[^\s=]+(?=[ \t]*=)/m,
          greedy: !0,
          alias: "attr-name"
        },
        value: {
          // This pattern is quite complex because of two properties:
          //  1) Quotes (strings) must be preceded by a space. Since we can't use lookbehinds, we have to "resolve"
          //     the lookbehind. You will see this in the main loop where spaces are handled separately.
          //  2) Line continuations.
          //     After line continuations, empty lines and comments are ignored so we have to consume them.
          pattern: RegExp(/(=[ \t]*(?!\s))/.source + // the value either starts with quotes or not
          "(?:" + o + `|(?=[^"\r
]))(?:` + (/[^\s\\]/.source + // handle spaces separately because of quotes
          '|[ 	]+(?:(?![ 	"])|' + o + ")|" + /\\[\r\n]+(?:[#;].*[\r\n]+)*(?![#;])/.source) + ")*"),
          lookbehind: !0,
          greedy: !0,
          alias: "attr-value",
          inside: {
            comment: a,
            quoted: {
              pattern: RegExp(/(^|\s)/.source + o),
              lookbehind: !0,
              greedy: !0
            },
            punctuation: /\\$/m,
            boolean: {
              pattern: /^(?:false|no|off|on|true|yes)$/,
              greedy: !0
            }
          }
        },
        punctuation: /=/
      };
    })(t);
  }
  return systemd_1;
}
var t4Templating_1, hasRequiredT4Templating;
function requireT4Templating() {
  if (hasRequiredT4Templating) return t4Templating_1;
  hasRequiredT4Templating = 1, t4Templating_1 = e, e.displayName = "t4Templating", e.aliases = [];
  function e(t) {
    (function(r) {
      function a(u, c, d) {
        return {
          pattern: RegExp("<#" + u + "[\\s\\S]*?#>"),
          alias: "block",
          inside: {
            delimiter: {
              pattern: RegExp("^<#" + u + "|#>$"),
              alias: "important"
            },
            content: {
              pattern: /[\s\S]+/,
              inside: c,
              alias: d
            }
          }
        };
      }
      function o(u) {
        var c = r.languages[u], d = "language-" + u;
        return {
          block: {
            pattern: /<#[\s\S]+?#>/,
            inside: {
              directive: a("@", {
                "attr-value": {
                  pattern: /=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/,
                  inside: {
                    punctuation: /^=|^["']|["']$/
                  }
                },
                keyword: /\b\w+(?=\s)/,
                "attr-name": /\b\w+/
              }),
              expression: a("=", c, d),
              "class-feature": a("\\+", c, d),
              standard: a("", c, d)
            }
          }
        };
      }
      r.languages["t4-templating"] = Object.defineProperty({}, "createT4", {
        value: o
      });
    })(t);
  }
  return t4Templating_1;
}
var t4Cs_1, hasRequiredT4Cs;
function requireT4Cs() {
  if (hasRequiredT4Cs) return t4Cs_1;
  hasRequiredT4Cs = 1;
  var e = requireT4Templating(), t = requireCsharp();
  t4Cs_1 = r, r.displayName = "t4Cs", r.aliases = [];
  function r(a) {
    a.register(e), a.register(t), a.languages.t4 = a.languages["t4-cs"] = a.languages["t4-templating"].createT4("csharp");
  }
  return t4Cs_1;
}
var vbnet_1, hasRequiredVbnet;
function requireVbnet() {
  if (hasRequiredVbnet) return vbnet_1;
  hasRequiredVbnet = 1;
  var e = requireBasic();
  vbnet_1 = t, t.displayName = "vbnet", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.vbnet = r.languages.extend("basic", {
      comment: [{
        pattern: /(?:!|REM\b).+/i,
        inside: {
          keyword: /^REM/i
        }
      }, {
        pattern: /(^|[^\\:])'.*/,
        lookbehind: !0,
        greedy: !0
      }],
      string: {
        pattern: /(^|[^"])"(?:""|[^"])*"(?!")/,
        lookbehind: !0,
        greedy: !0
      },
      keyword: /(?:\b(?:ADDHANDLER|ADDRESSOF|ALIAS|AND|ANDALSO|AS|BEEP|BLOAD|BOOLEAN|BSAVE|BYREF|BYTE|BYVAL|CALL(?: ABSOLUTE)?|CASE|CATCH|CBOOL|CBYTE|CCHAR|CDATE|CDBL|CDEC|CHAIN|CHAR|CHDIR|CINT|CLASS|CLEAR|CLNG|CLOSE|CLS|COBJ|COM|COMMON|CONST|CONTINUE|CSBYTE|CSHORT|CSNG|CSTR|CTYPE|CUINT|CULNG|CUSHORT|DATA|DATE|DECIMAL|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DEFAULT|DELEGATE|DIM|DIRECTCAST|DO|DOUBLE|ELSE|ELSEIF|END|ENUM|ENVIRON|ERASE|ERROR|EVENT|EXIT|FALSE|FIELD|FILES|FINALLY|FOR(?: EACH)?|FRIEND|FUNCTION|GET|GETTYPE|GETXMLNAMESPACE|GLOBAL|GOSUB|GOTO|HANDLES|IF|IMPLEMENTS|IMPORTS|IN|INHERITS|INPUT|INTEGER|INTERFACE|IOCTL|IS|ISNOT|KEY|KILL|LET|LIB|LIKE|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|ME|MKDIR|MOD|MODULE|MUSTINHERIT|MUSTOVERRIDE|MYBASE|MYCLASS|NAME|NAMESPACE|NARROWING|NEW|NEXT|NOT|NOTHING|NOTINHERITABLE|NOTOVERRIDABLE|OBJECT|OF|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPERATOR|OPTION(?: BASE)?|OPTIONAL|OR|ORELSE|OUT|OVERLOADS|OVERRIDABLE|OVERRIDES|PARAMARRAY|PARTIAL|POKE|PRIVATE|PROPERTY|PROTECTED|PUBLIC|PUT|RAISEEVENT|READ|READONLY|REDIM|REM|REMOVEHANDLER|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SBYTE|SELECT(?: CASE)?|SET|SHADOWS|SHARED|SHELL|SHORT|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|STRUCTURE|SUB|SWAP|SYNCLOCK|SYSTEM|THEN|THROW|TIMER|TO|TROFF|TRON|TRUE|TRY|TRYCAST|TYPE|TYPEOF|UINTEGER|ULONG|UNLOCK|UNTIL|USHORT|USING|VIEW PRINT|WAIT|WEND|WHEN|WHILE|WIDENING|WITH|WITHEVENTS|WRITE|WRITEONLY|XOR)|\B(?:#CONST|#ELSE|#ELSEIF|#END|#IF))(?:\$|\b)/i,
      punctuation: /[,;:(){}]/
    });
  }
  return vbnet_1;
}
var t4Vb_1, hasRequiredT4Vb;
function requireT4Vb() {
  if (hasRequiredT4Vb) return t4Vb_1;
  hasRequiredT4Vb = 1;
  var e = requireT4Templating(), t = requireVbnet();
  t4Vb_1 = r, r.displayName = "t4Vb", r.aliases = [];
  function r(a) {
    a.register(e), a.register(t), a.languages["t4-vb"] = a.languages["t4-templating"].createT4("vbnet");
  }
  return t4Vb_1;
}
var yaml_1, hasRequiredYaml;
function requireYaml() {
  if (hasRequiredYaml) return yaml_1;
  hasRequiredYaml = 1, yaml_1 = e, e.displayName = "yaml", e.aliases = ["yml"];
  function e(t) {
    (function(r) {
      var a = /[*&][^\s[\]{},]+/, o = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/, u = "(?:" + o.source + "(?:[ 	]+" + a.source + ")?|" + a.source + "(?:[ 	]+" + o.source + ")?)", c = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
        return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
      }), d = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
      function g(b, _) {
        _ = (_ || "").replace(/m/g, "") + "m";
        var y = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
          return u;
        }).replace(/<<value>>/g, function() {
          return b;
        });
        return RegExp(y, _);
      }
      r.languages.yaml = {
        scalar: {
          pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
            return u;
          })),
          lookbehind: !0,
          alias: "string"
        },
        comment: /#.*/,
        key: {
          pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
            return u;
          }).replace(/<<key>>/g, function() {
            return "(?:" + c + "|" + d + ")";
          })),
          lookbehind: !0,
          greedy: !0,
          alias: "atrule"
        },
        directive: {
          pattern: /(^[ \t]*)%.+/m,
          lookbehind: !0,
          alias: "important"
        },
        datetime: {
          pattern: g(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
          lookbehind: !0,
          alias: "number"
        },
        boolean: {
          pattern: g(/false|true/.source, "i"),
          lookbehind: !0,
          alias: "important"
        },
        null: {
          pattern: g(/null|~/.source, "i"),
          lookbehind: !0,
          alias: "important"
        },
        string: {
          pattern: g(d),
          lookbehind: !0,
          greedy: !0
        },
        number: {
          pattern: g(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
          lookbehind: !0
        },
        tag: o,
        important: a,
        punctuation: /---|[:[\]{}\-,|>?]|\.\.\./
      }, r.languages.yml = r.languages.yaml;
    })(t);
  }
  return yaml_1;
}
var tap_1, hasRequiredTap;
function requireTap() {
  if (hasRequiredTap) return tap_1;
  hasRequiredTap = 1;
  var e = requireYaml();
  tap_1 = t, t.displayName = "tap", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.tap = {
      fail: /not ok[^#{\n\r]*/,
      pass: /ok[^#{\n\r]*/,
      pragma: /pragma [+-][a-z]+/,
      bailout: /bail out!.*/i,
      version: /TAP version \d+/i,
      plan: /\b\d+\.\.\d+(?: +#.*)?/,
      subtest: {
        pattern: /# Subtest(?:: .*)?/,
        greedy: !0
      },
      punctuation: /[{}]/,
      directive: /#.*/,
      yamlish: {
        pattern: /(^[ \t]*)---[\s\S]*?[\r\n][ \t]*\.\.\.$/m,
        lookbehind: !0,
        inside: r.languages.yaml,
        alias: "language-yaml"
      }
    };
  }
  return tap_1;
}
var tcl_1, hasRequiredTcl;
function requireTcl() {
  if (hasRequiredTcl) return tcl_1;
  hasRequiredTcl = 1, tcl_1 = e, e.displayName = "tcl", e.aliases = [];
  function e(t) {
    t.languages.tcl = {
      comment: {
        pattern: /(^|[^\\])#.*/,
        lookbehind: !0
      },
      string: {
        pattern: /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"/,
        greedy: !0
      },
      variable: [{
        pattern: /(\$)(?:::)?(?:[a-zA-Z0-9]+::)*\w+/,
        lookbehind: !0
      }, {
        pattern: /(\$)\{[^}]+\}/,
        lookbehind: !0
      }, {
        pattern: /(^[\t ]*set[ \t]+)(?:::)?(?:[a-zA-Z0-9]+::)*\w+/m,
        lookbehind: !0
      }],
      function: {
        pattern: /(^[\t ]*proc[ \t]+)\S+/m,
        lookbehind: !0
      },
      builtin: [{
        pattern: /(^[\t ]*)(?:break|class|continue|error|eval|exit|for|foreach|if|proc|return|switch|while)\b/m,
        lookbehind: !0
      }, /\b(?:else|elseif)\b/],
      scope: {
        pattern: /(^[\t ]*)(?:global|upvar|variable)\b/m,
        lookbehind: !0,
        alias: "constant"
      },
      keyword: {
        pattern: /(^[\t ]*|\[)(?:Safe_Base|Tcl|after|append|apply|array|auto_(?:execok|import|load|mkindex|qualify|reset)|automkindex_old|bgerror|binary|catch|cd|chan|clock|close|concat|dde|dict|encoding|eof|exec|expr|fblocked|fconfigure|fcopy|file(?:event|name)?|flush|gets|glob|history|http|incr|info|interp|join|lappend|lassign|lindex|linsert|list|llength|load|lrange|lrepeat|lreplace|lreverse|lsearch|lset|lsort|math(?:func|op)|memory|msgcat|namespace|open|package|parray|pid|pkg_mkIndex|platform|puts|pwd|re_syntax|read|refchan|regexp|registry|regsub|rename|scan|seek|set|socket|source|split|string|subst|tcl(?:_endOfWord|_findLibrary|startOf(?:Next|Previous)Word|test|vars|wordBreak(?:After|Before))|tell|time|tm|trace|unknown|unload|unset|update|uplevel|vwait)\b/m,
        lookbehind: !0
      },
      operator: /!=?|\*\*?|==|&&?|\|\|?|<[=<]?|>[=>]?|[-+~\/%?^]|\b(?:eq|in|ne|ni)\b/,
      punctuation: /[{}()\[\]]/
    };
  }
  return tcl_1;
}
var textile_1, hasRequiredTextile;
function requireTextile() {
  if (hasRequiredTextile) return textile_1;
  hasRequiredTextile = 1, textile_1 = e, e.displayName = "textile", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = /\([^|()\n]+\)|\[[^\]\n]+\]|\{[^}\n]+\}/.source, o = /\)|\((?![^|()\n]+\))/.source;
      function u(A, E) {
        return RegExp(A.replace(/<MOD>/g, function() {
          return "(?:" + a + ")";
        }).replace(/<PAR>/g, function() {
          return "(?:" + o + ")";
        }), E || "");
      }
      var c = {
        css: {
          pattern: /\{[^{}]+\}/,
          inside: {
            rest: r.languages.css
          }
        },
        "class-id": {
          pattern: /(\()[^()]+(?=\))/,
          lookbehind: !0,
          alias: "attr-value"
        },
        lang: {
          pattern: /(\[)[^\[\]]+(?=\])/,
          lookbehind: !0,
          alias: "attr-value"
        },
        // Anything else is punctuation (the first pattern is for row/col spans inside tables)
        punctuation: /[\\\/]\d+|\S/
      }, d = r.languages.textile = r.languages.extend("markup", {
        phrase: {
          pattern: /(^|\r|\n)\S[\s\S]*?(?=$|\r?\n\r?\n|\r\r)/,
          lookbehind: !0,
          inside: {
            // h1. Header 1
            "block-tag": {
              pattern: u(/^[a-z]\w*(?:<MOD>|<PAR>|[<>=])*\./.source),
              inside: {
                modifier: {
                  pattern: u(/(^[a-z]\w*)(?:<MOD>|<PAR>|[<>=])+(?=\.)/.source),
                  lookbehind: !0,
                  inside: c
                },
                tag: /^[a-z]\w*/,
                punctuation: /\.$/
              }
            },
            // # List item
            // * List item
            list: {
              pattern: u(/^[*#]+<MOD>*\s+\S.*/.source, "m"),
              inside: {
                modifier: {
                  pattern: u(/(^[*#]+)<MOD>+/.source),
                  lookbehind: !0,
                  inside: c
                },
                punctuation: /^[*#]+/
              }
            },
            // | cell | cell | cell |
            table: {
              // Modifiers can be applied to the row: {color:red}.|1|2|3|
              // or the cell: |{color:red}.1|2|3|
              pattern: u(/^(?:(?:<MOD>|<PAR>|[<>=^~])+\.\s*)?(?:\|(?:(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+\.|(?!(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+\.))[^|]*)+\|/.source, "m"),
              inside: {
                modifier: {
                  // Modifiers for rows after the first one are
                  // preceded by a pipe and a line feed
                  pattern: u(/(^|\|(?:\r?\n|\r)?)(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+(?=\.)/.source),
                  lookbehind: !0,
                  inside: c
                },
                punctuation: /\||^\./
              }
            },
            inline: {
              // eslint-disable-next-line regexp/no-super-linear-backtracking
              pattern: u(/(^|[^a-zA-Z\d])(\*\*|__|\?\?|[*_%@+\-^~])<MOD>*.+?\2(?![a-zA-Z\d])/.source),
              lookbehind: !0,
              inside: {
                // Note: superscripts and subscripts are not handled specifically
                // *bold*, **bold**
                bold: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: u(/(^(\*\*?)<MOD>*).+?(?=\2)/.source),
                  lookbehind: !0
                },
                // _italic_, __italic__
                italic: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: u(/(^(__?)<MOD>*).+?(?=\2)/.source),
                  lookbehind: !0
                },
                // ??cite??
                cite: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: u(/(^\?\?<MOD>*).+?(?=\?\?)/.source),
                  lookbehind: !0,
                  alias: "string"
                },
                // @code@
                code: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: u(/(^@<MOD>*).+?(?=@)/.source),
                  lookbehind: !0,
                  alias: "keyword"
                },
                // +inserted+
                inserted: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: u(/(^\+<MOD>*).+?(?=\+)/.source),
                  lookbehind: !0
                },
                // -deleted-
                deleted: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: u(/(^-<MOD>*).+?(?=-)/.source),
                  lookbehind: !0
                },
                // %span%
                span: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: u(/(^%<MOD>*).+?(?=%)/.source),
                  lookbehind: !0
                },
                modifier: {
                  pattern: u(/(^\*\*|__|\?\?|[*_%@+\-^~])<MOD>+/.source),
                  lookbehind: !0,
                  inside: c
                },
                punctuation: /[*_%?@+\-^~]+/
              }
            },
            // [alias]http://example.com
            "link-ref": {
              pattern: /^\[[^\]]+\]\S+$/m,
              inside: {
                string: {
                  pattern: /(^\[)[^\]]+(?=\])/,
                  lookbehind: !0
                },
                url: {
                  pattern: /(^\])\S+$/,
                  lookbehind: !0
                },
                punctuation: /[\[\]]/
              }
            },
            // "text":http://example.com
            // "text":link-ref
            link: {
              // eslint-disable-next-line regexp/no-super-linear-backtracking
              pattern: u(/"<MOD>*[^"]+":.+?(?=[^\w/]?(?:\s|$))/.source),
              inside: {
                text: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: u(/(^"<MOD>*)[^"]+(?=")/.source),
                  lookbehind: !0
                },
                modifier: {
                  pattern: u(/(^")<MOD>+/.source),
                  lookbehind: !0,
                  inside: c
                },
                url: {
                  pattern: /(:).+/,
                  lookbehind: !0
                },
                punctuation: /[":]/
              }
            },
            // !image.jpg!
            // !image.jpg(Title)!:http://example.com
            image: {
              pattern: u(/!(?:<MOD>|<PAR>|[<>=])*(?![<>=])[^!\s()]+(?:\([^)]+\))?!(?::.+?(?=[^\w/]?(?:\s|$)))?/.source),
              inside: {
                source: {
                  pattern: u(/(^!(?:<MOD>|<PAR>|[<>=])*)(?![<>=])[^!\s()]+(?:\([^)]+\))?(?=!)/.source),
                  lookbehind: !0,
                  alias: "url"
                },
                modifier: {
                  pattern: u(/(^!)(?:<MOD>|<PAR>|[<>=])+/.source),
                  lookbehind: !0,
                  inside: c
                },
                url: {
                  pattern: /(:).+/,
                  lookbehind: !0
                },
                punctuation: /[!:]/
              }
            },
            // Footnote[1]
            footnote: {
              pattern: /\b\[\d+\]/,
              alias: "comment",
              inside: {
                punctuation: /\[|\]/
              }
            },
            // CSS(Cascading Style Sheet)
            acronym: {
              pattern: /\b[A-Z\d]+\([^)]+\)/,
              inside: {
                comment: {
                  pattern: /(\()[^()]+(?=\))/,
                  lookbehind: !0
                },
                punctuation: /[()]/
              }
            },
            // Prism(C)
            mark: {
              pattern: /\b\((?:C|R|TM)\)/,
              alias: "comment",
              inside: {
                punctuation: /[()]/
              }
            }
          }
        }
      }), g = d.phrase.inside, b = {
        inline: g.inline,
        link: g.link,
        image: g.image,
        footnote: g.footnote,
        acronym: g.acronym,
        mark: g.mark
      };
      d.tag.pattern = /<\/?(?!\d)[a-z0-9]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i;
      var _ = g.inline.inside;
      _.bold.inside = b, _.italic.inside = b, _.inserted.inside = b, _.deleted.inside = b, _.span.inside = b;
      var y = g.table.inside;
      y.inline = b.inline, y.link = b.link, y.image = b.image, y.footnote = b.footnote, y.acronym = b.acronym, y.mark = b.mark;
    })(t);
  }
  return textile_1;
}
var toml_1, hasRequiredToml;
function requireToml() {
  if (hasRequiredToml) return toml_1;
  hasRequiredToml = 1, toml_1 = e, e.displayName = "toml", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = /(?:[\w-]+|'[^'\n\r]*'|"(?:\\.|[^\\"\r\n])*")/.source;
      function o(u) {
        return u.replace(/__/g, function() {
          return a;
        });
      }
      r.languages.toml = {
        comment: {
          pattern: /#.*/,
          greedy: !0
        },
        table: {
          pattern: RegExp(o(/(^[\t ]*\[\s*(?:\[\s*)?)__(?:\s*\.\s*__)*(?=\s*\])/.source), "m"),
          lookbehind: !0,
          greedy: !0,
          alias: "class-name"
        },
        key: {
          pattern: RegExp(o(/(^[\t ]*|[{,]\s*)__(?:\s*\.\s*__)*(?=\s*=)/.source), "m"),
          lookbehind: !0,
          greedy: !0,
          alias: "property"
        },
        string: {
          pattern: /"""(?:\\[\s\S]|[^\\])*?"""|'''[\s\S]*?'''|'[^'\n\r]*'|"(?:\\.|[^\\"\r\n])*"/,
          greedy: !0
        },
        date: [{
          // Offset Date-Time, Local Date-Time, Local Date
          pattern: /\b\d{4}-\d{2}-\d{2}(?:[T\s]\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})?)?\b/i,
          alias: "number"
        }, {
          // Local Time
          pattern: /\b\d{2}:\d{2}:\d{2}(?:\.\d+)?\b/,
          alias: "number"
        }],
        number: /(?:\b0(?:x[\da-zA-Z]+(?:_[\da-zA-Z]+)*|o[0-7]+(?:_[0-7]+)*|b[10]+(?:_[10]+)*))\b|[-+]?\b\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?\b|[-+]?\b(?:inf|nan)\b/,
        boolean: /\b(?:false|true)\b/,
        punctuation: /[.,=[\]{}]/
      };
    })(t);
  }
  return toml_1;
}
var tremor_1, hasRequiredTremor;
function requireTremor() {
  if (hasRequiredTremor) return tremor_1;
  hasRequiredTremor = 1, tremor_1 = e, e.displayName = "tremor", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.tremor = {
        comment: {
          pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
          lookbehind: !0
        },
        "interpolated-string": null,
        // see below
        extractor: {
          pattern: /\b[a-z_]\w*\|(?:[^\r\n\\|]|\\(?:\r\n|[\s\S]))*\|/i,
          greedy: !0,
          inside: {
            regex: {
              pattern: /(^re)\|[\s\S]+/,
              lookbehind: !0
            },
            function: /^\w+/,
            value: /\|[\s\S]+/
          }
        },
        identifier: {
          pattern: /`[^`]*`/,
          greedy: !0
        },
        function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())\b/,
        keyword: /\b(?:args|as|by|case|config|connect|connector|const|copy|create|default|define|deploy|drop|each|emit|end|erase|event|flow|fn|for|from|group|having|insert|into|intrinsic|let|links|match|merge|mod|move|of|operator|patch|pipeline|recur|script|select|set|sliding|state|stream|to|tumbling|update|use|when|where|window|with)\b/,
        boolean: /\b(?:false|null|true)\b/i,
        number: /\b(?:0b[01_]*|0x[0-9a-fA-F_]*|\d[\d_]*(?:\.\d[\d_]*)?(?:[Ee][+-]?[\d_]+)?)\b/,
        "pattern-punctuation": {
          pattern: /%(?=[({[])/,
          alias: "punctuation"
        },
        operator: /[-+*\/%~!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?>?=?|(?:absent|and|not|or|present|xor)\b/,
        punctuation: /::|[;\[\]()\{\},.:]/
      };
      var a = /#\{(?:[^"{}]|\{[^{}]*\}|"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*")*\}/.source;
      r.languages.tremor["interpolated-string"] = {
        pattern: RegExp(/(^|[^\\])/.source + '(?:"""(?:' + /[^"\\#]|\\[\s\S]|"(?!"")|#(?!\{)/.source + "|" + a + ')*"""|"(?:' + /[^"\\\r\n#]|\\(?:\r\n|[\s\S])|#(?!\{)/.source + "|" + a + ')*")'),
        lookbehind: !0,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: RegExp(a),
            inside: {
              punctuation: /^#\{|\}$/,
              expression: {
                pattern: /[\s\S]+/,
                inside: r.languages.tremor
              }
            }
          },
          string: /[\s\S]+/
        }
      }, r.languages.troy = r.languages.tremor, r.languages.trickle = r.languages.tremor;
    })(t);
  }
  return tremor_1;
}
var tsx_1, hasRequiredTsx;
function requireTsx() {
  if (hasRequiredTsx) return tsx_1;
  hasRequiredTsx = 1;
  var e = requireJsx(), t = requireTypescript();
  tsx_1 = r, r.displayName = "tsx", r.aliases = [];
  function r(a) {
    a.register(e), a.register(t), function(o) {
      var u = o.util.clone(o.languages.typescript);
      o.languages.tsx = o.languages.extend("jsx", u), delete o.languages.tsx.parameter, delete o.languages.tsx["literal-property"];
      var c = o.languages.tsx.tag;
      c.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + c.pattern.source + ")", c.pattern.flags), c.lookbehind = !0;
    }(a);
  }
  return tsx_1;
}
var tt2_1, hasRequiredTt2;
function requireTt2() {
  if (hasRequiredTt2) return tt2_1;
  hasRequiredTt2 = 1;
  var e = requireMarkupTemplating();
  tt2_1 = t, t.displayName = "tt2", t.aliases = [];
  function t(r) {
    r.register(e), function(a) {
      a.languages.tt2 = a.languages.extend("clike", {
        comment: /#.*|\[%#[\s\S]*?%\]/,
        keyword: /\b(?:BLOCK|CALL|CASE|CATCH|CLEAR|DEBUG|DEFAULT|ELSE|ELSIF|END|FILTER|FINAL|FOREACH|GET|IF|IN|INCLUDE|INSERT|LAST|MACRO|META|NEXT|PERL|PROCESS|RAWPERL|RETURN|SET|STOP|SWITCH|TAGS|THROW|TRY|UNLESS|USE|WHILE|WRAPPER)\b/,
        punctuation: /[[\]{},()]/
      }), a.languages.insertBefore("tt2", "number", {
        operator: /=[>=]?|!=?|<=?|>=?|&&|\|\|?|\b(?:and|not|or)\b/,
        variable: {
          pattern: /\b[a-z]\w*(?:\s*\.\s*(?:\d+|\$?[a-z]\w*))*\b/i
        }
      }), a.languages.insertBefore("tt2", "keyword", {
        delimiter: {
          pattern: /^(?:\[%|%%)-?|-?%\]$/,
          alias: "punctuation"
        }
      }), a.languages.insertBefore("tt2", "string", {
        "single-quoted-string": {
          pattern: /'[^\\']*(?:\\[\s\S][^\\']*)*'/,
          greedy: !0,
          alias: "string"
        },
        "double-quoted-string": {
          pattern: /"[^\\"]*(?:\\[\s\S][^\\"]*)*"/,
          greedy: !0,
          alias: "string",
          inside: {
            variable: {
              pattern: /\$(?:[a-z]\w*(?:\.(?:\d+|\$?[a-z]\w*))*)/i
            }
          }
        }
      }), delete a.languages.tt2.string, a.hooks.add("before-tokenize", function(o) {
        var u = /\[%[\s\S]+?%\]/g;
        a.languages["markup-templating"].buildPlaceholders(o, "tt2", u);
      }), a.hooks.add("after-tokenize", function(o) {
        a.languages["markup-templating"].tokenizePlaceholders(o, "tt2");
      });
    }(r);
  }
  return tt2_1;
}
var twig_1, hasRequiredTwig;
function requireTwig() {
  if (hasRequiredTwig) return twig_1;
  hasRequiredTwig = 1;
  var e = requireMarkupTemplating();
  twig_1 = t, t.displayName = "twig", t.aliases = [];
  function t(r) {
    r.register(e), r.languages.twig = {
      comment: /^\{#[\s\S]*?#\}$/,
      "tag-name": {
        pattern: /(^\{%-?\s*)\w+/,
        lookbehind: !0,
        alias: "keyword"
      },
      delimiter: {
        pattern: /^\{[{%]-?|-?[%}]\}$/,
        alias: "punctuation"
      },
      string: {
        pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        inside: {
          punctuation: /^['"]|['"]$/
        }
      },
      keyword: /\b(?:even|if|odd)\b/,
      boolean: /\b(?:false|null|true)\b/,
      number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
      operator: [{
        pattern: /(\s)(?:and|b-and|b-or|b-xor|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
        lookbehind: !0
      }, /[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/],
      punctuation: /[()\[\]{}:.,]/
    }, r.hooks.add("before-tokenize", function(a) {
      if (a.language === "twig") {
        var o = /\{(?:#[\s\S]*?#|%[\s\S]*?%|\{[\s\S]*?\})\}/g;
        r.languages["markup-templating"].buildPlaceholders(a, "twig", o);
      }
    }), r.hooks.add("after-tokenize", function(a) {
      r.languages["markup-templating"].tokenizePlaceholders(a, "twig");
    });
  }
  return twig_1;
}
var typoscript_1, hasRequiredTyposcript;
function requireTyposcript() {
  if (hasRequiredTyposcript) return typoscript_1;
  hasRequiredTyposcript = 1, typoscript_1 = e, e.displayName = "typoscript", e.aliases = ["tsconfig"];
  function e(t) {
    (function(r) {
      var a = /\b(?:ACT|ACTIFSUB|CARRAY|CASE|CLEARGIF|COA|COA_INT|CONSTANTS|CONTENT|CUR|EDITPANEL|EFFECT|EXT|FILE|FLUIDTEMPLATE|FORM|FRAME|FRAMESET|GIFBUILDER|GMENU|GMENU_FOLDOUT|GMENU_LAYERS|GP|HMENU|HRULER|HTML|IENV|IFSUB|IMAGE|IMGMENU|IMGMENUITEM|IMGTEXT|IMG_RESOURCE|INCLUDE_TYPOSCRIPT|JSMENU|JSMENUITEM|LLL|LOAD_REGISTER|NO|PAGE|RECORDS|RESTORE_REGISTER|TEMPLATE|TEXT|TMENU|TMENUITEM|TMENU_LAYERS|USER|USER_INT|_GIFBUILDER|global|globalString|globalVar)\b/;
      r.languages.typoscript = {
        comment: [{
          // multiline comments /* */
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: !0
        }, {
          // double-slash comments - ignored when backslashes or colon is found in front
          // also ignored whenever directly after an equal-sign, because it would probably be an url without protocol
          pattern: /(^|[^\\:= \t]|(?:^|[^= \t])[ \t]+)\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }, {
          // hash comments - ignored when leading quote is found for hex colors in strings
          pattern: /(^|[^"'])#.*/,
          lookbehind: !0,
          greedy: !0
        }],
        function: [{
          // old include style
          pattern: /<INCLUDE_TYPOSCRIPT:\s*source\s*=\s*(?:"[^"\r\n]*"|'[^'\r\n]*')\s*>/,
          inside: {
            string: {
              pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
              inside: {
                keyword: a
              }
            },
            keyword: {
              pattern: /INCLUDE_TYPOSCRIPT/
            }
          }
        }, {
          // new include style
          pattern: /@import\s*(?:"[^"\r\n]*"|'[^'\r\n]*')/,
          inside: {
            string: /"[^"\r\n]*"|'[^'\r\n]*'/
          }
        }],
        string: {
          pattern: /^([^=]*=[< ]?)(?:(?!\]\n).)*/,
          lookbehind: !0,
          inside: {
            function: /\{\$.*\}/,
            // constants include
            keyword: a,
            number: /^\d+$/,
            punctuation: /[,|:]/
          }
        },
        keyword: a,
        number: {
          // special highlighting for indexes of arrays in tags
          pattern: /\b\d+\s*[.{=]/,
          inside: {
            operator: /[.{=]/
          }
        },
        tag: {
          pattern: /\.?[-\w\\]+\.?/,
          inside: {
            punctuation: /\./
          }
        },
        punctuation: /[{}[\];(),.:|]/,
        operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/
      }, r.languages.tsconfig = r.languages.typoscript;
    })(t);
  }
  return typoscript_1;
}
var unrealscript_1, hasRequiredUnrealscript;
function requireUnrealscript() {
  if (hasRequiredUnrealscript) return unrealscript_1;
  hasRequiredUnrealscript = 1, unrealscript_1 = e, e.displayName = "unrealscript", e.aliases = ["uc", "uscript"];
  function e(t) {
    t.languages.unrealscript = {
      comment: /\/\/.*|\/\*[\s\S]*?\*\//,
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      category: {
        pattern: /(\b(?:(?:autoexpand|hide|show)categories|var)\s*\()[^()]+(?=\))/,
        lookbehind: !0,
        greedy: !0,
        alias: "property"
      },
      metadata: {
        pattern: /(\w\s*)<\s*\w+\s*=[^<>|=\r\n]+(?:\|\s*\w+\s*=[^<>|=\r\n]+)*>/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          property: /\b\w+(?=\s*=)/,
          operator: /=/,
          punctuation: /[<>|]/
        }
      },
      macro: {
        pattern: /`\w+/,
        alias: "property"
      },
      "class-name": {
        pattern: /(\b(?:class|enum|extends|interface|state(?:\(\))?|struct|within)\s+)\w+/,
        lookbehind: !0
      },
      keyword: /\b(?:abstract|actor|array|auto|autoexpandcategories|bool|break|byte|case|class|classgroup|client|coerce|collapsecategories|config|const|continue|default|defaultproperties|delegate|dependson|deprecated|do|dontcollapsecategories|editconst|editinlinenew|else|enum|event|exec|export|extends|final|float|for|forcescriptorder|foreach|function|goto|guid|hidecategories|hidedropdown|if|ignores|implements|inherits|input|int|interface|iterator|latent|local|material|name|native|nativereplication|noexport|nontransient|noteditinlinenew|notplaceable|operator|optional|out|pawn|perobjectconfig|perobjectlocalized|placeable|postoperator|preoperator|private|protected|reliable|replication|return|server|showcategories|simulated|singular|state|static|string|struct|structdefault|structdefaultproperties|switch|texture|transient|travel|unreliable|until|var|vector|while|within)\b/,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      boolean: /\b(?:false|true)\b/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      // https://docs.unrealengine.com/udk/Three/UnrealScriptExpressions.html
      operator: />>|<<|--|\+\+|\*\*|[-+*/~!=<>$@]=?|&&?|\|\|?|\^\^?|[?:%]|\b(?:ClockwiseFrom|Cross|Dot)\b/,
      punctuation: /[()[\]{};,.]/
    }, t.languages.uc = t.languages.uscript = t.languages.unrealscript;
  }
  return unrealscript_1;
}
var uorazor_1, hasRequiredUorazor;
function requireUorazor() {
  if (hasRequiredUorazor) return uorazor_1;
  hasRequiredUorazor = 1, uorazor_1 = e, e.displayName = "uorazor", e.aliases = [];
  function e(t) {
    t.languages.uorazor = {
      "comment-hash": {
        pattern: /#.*/,
        alias: "comment",
        greedy: !0
      },
      "comment-slash": {
        pattern: /\/\/.*/,
        alias: "comment",
        greedy: !0
      },
      string: {
        pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        inside: {
          punctuation: /^['"]|['"]$/
        },
        greedy: !0
      },
      "source-layers": {
        pattern: /\b(?:arms|backpack|blue|bracelet|cancel|clear|cloak|criminal|earrings|enemy|facialhair|friend|friendly|gloves|gray|grey|ground|hair|head|innerlegs|innertorso|innocent|lefthand|middletorso|murderer|neck|nonfriendly|onehandedsecondary|outerlegs|outertorso|pants|red|righthand|ring|self|shirt|shoes|talisman|waist)\b/i,
        alias: "function"
      },
      "source-commands": {
        pattern: /\b(?:alliance|attack|cast|clearall|clearignore|clearjournal|clearlist|clearsysmsg|createlist|createtimer|dclick|dclicktype|dclickvar|dress|dressconfig|drop|droprelloc|emote|getlabel|guild|gumpclose|gumpresponse|hotkey|ignore|lasttarget|lift|lifttype|menu|menuresponse|msg|org|organize|organizer|overhead|pause|poplist|potion|promptresponse|pushlist|removelist|removetimer|rename|restock|say|scav|scavenger|script|setability|setlasttarget|setskill|settimer|setvar|sysmsg|target|targetloc|targetrelloc|targettype|undress|unignore|unsetvar|useobject|useonce|useskill|usetype|virtue|wait|waitforgump|waitformenu|waitforprompt|waitforstat|waitforsysmsg|waitfortarget|walk|wfsysmsg|wft|whisper|yell)\b/,
        alias: "function"
      },
      "tag-name": {
        pattern: /(^\{%-?\s*)\w+/,
        lookbehind: !0,
        alias: "keyword"
      },
      delimiter: {
        pattern: /^\{[{%]-?|-?[%}]\}$/,
        alias: "punctuation"
      },
      function: /\b(?:atlist|close|closest|count|counter|counttype|dead|dex|diffhits|diffmana|diffstam|diffweight|find|findbuff|finddebuff|findlayer|findtype|findtypelist|followers|gumpexists|hidden|hits|hp|hue|human|humanoid|ingump|inlist|insysmessage|insysmsg|int|invul|lhandempty|list|listexists|mana|maxhits|maxhp|maxmana|maxstam|maxweight|monster|mounted|name|next|noto|paralyzed|poisoned|position|prev|previous|queued|rand|random|rhandempty|skill|stam|str|targetexists|timer|timerexists|varexist|warmode|weight)\b/,
      keyword: /\b(?:and|as|break|continue|else|elseif|endfor|endif|endwhile|for|if|loop|not|or|replay|stop|while)\b/,
      boolean: /\b(?:false|null|true)\b/,
      number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
      operator: [{
        pattern: /(\s)(?:and|b-and|b-or|b-xor|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
        lookbehind: !0
      }, /[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/],
      punctuation: /[()\[\]{}:.,]/
    };
  }
  return uorazor_1;
}
var uri_1, hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri_1;
  hasRequiredUri = 1, uri_1 = e, e.displayName = "uri", e.aliases = ["url"];
  function e(t) {
    t.languages.uri = {
      scheme: {
        pattern: /^[a-z][a-z0-9+.-]*:/im,
        greedy: !0,
        inside: {
          "scheme-delimiter": /:$/
        }
      },
      fragment: {
        pattern: /#[\w\-.~!$&'()*+,;=%:@/?]*/,
        inside: {
          "fragment-delimiter": /^#/
        }
      },
      query: {
        pattern: /\?[\w\-.~!$&'()*+,;=%:@/?]*/,
        inside: {
          "query-delimiter": {
            pattern: /^\?/,
            greedy: !0
          },
          "pair-delimiter": /[&;]/,
          pair: {
            pattern: /^[^=][\s\S]*/,
            inside: {
              key: /^[^=]+/,
              value: {
                pattern: /(^=)[\s\S]+/,
                lookbehind: !0
              }
            }
          }
        }
      },
      authority: {
        pattern: RegExp(/^\/\//.source + // [ userinfo "@" ]
        /(?:[\w\-.~!$&'()*+,;=%:]*@)?/.source + // host
        ("(?:" + // IP-literal
        /\[(?:[0-9a-fA-F:.]{2,48}|v[0-9a-fA-F]+\.[\w\-.~!$&'()*+,;=]+)\]/.source + "|" + // IPv4address or registered name
        /[\w\-.~!$&'()*+,;=%]*/.source + ")") + // [ ":" port ]
        /(?::\d*)?/.source, "m"),
        inside: {
          "authority-delimiter": /^\/\//,
          "user-info-segment": {
            pattern: /^[\w\-.~!$&'()*+,;=%:]*@/,
            inside: {
              "user-info-delimiter": /@$/,
              "user-info": /^[\w\-.~!$&'()*+,;=%:]+/
            }
          },
          "port-segment": {
            pattern: /:\d*$/,
            inside: {
              "port-delimiter": /^:/,
              port: /^\d+/
            }
          },
          host: {
            pattern: /[\s\S]+/,
            inside: {
              "ip-literal": {
                pattern: /^\[[\s\S]+\]$/,
                inside: {
                  "ip-literal-delimiter": /^\[|\]$/,
                  "ipv-future": /^v[\s\S]+/,
                  "ipv6-address": /^[\s\S]+/
                }
              },
              "ipv4-address": /^(?:(?:[03-9]\d?|[12]\d{0,2})\.){3}(?:[03-9]\d?|[12]\d{0,2})$/
            }
          }
        }
      },
      path: {
        pattern: /^[\w\-.~!$&'()*+,;=%:@/]+/m,
        inside: {
          "path-separator": /\//
        }
      }
    }, t.languages.url = t.languages.uri;
  }
  return uri_1;
}
var v_1, hasRequiredV;
function requireV() {
  if (hasRequiredV) return v_1;
  hasRequiredV = 1, v_1 = e, e.displayName = "v", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = {
        pattern: /[\s\S]+/,
        inside: null
      };
      r.languages.v = r.languages.extend("clike", {
        string: {
          pattern: /r?(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
          alias: "quoted-string",
          greedy: !0,
          inside: {
            interpolation: {
              pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\{[^{}]*\}|\w+(?:\.\w+(?:\([^\(\)]*\))?|\[[^\[\]]+\])*)/,
              lookbehind: !0,
              inside: {
                "interpolation-variable": {
                  pattern: /^\$\w[\s\S]*$/,
                  alias: "variable"
                },
                "interpolation-punctuation": {
                  pattern: /^\$\{|\}$/,
                  alias: "punctuation"
                },
                "interpolation-expression": a
              }
            }
          }
        },
        "class-name": {
          pattern: /(\b(?:enum|interface|struct|type)\s+)(?:C\.)?\w+/,
          lookbehind: !0
        },
        keyword: /(?:\b(?:__global|as|asm|assert|atomic|break|chan|const|continue|defer|else|embed|enum|fn|for|go(?:to)?|if|import|in|interface|is|lock|match|module|mut|none|or|pub|return|rlock|select|shared|sizeof|static|struct|type(?:of)?|union|unsafe)|\$(?:else|for|if)|#(?:flag|include))\b/,
        number: /\b(?:0x[a-f\d]+(?:_[a-f\d]+)*|0b[01]+(?:_[01]+)*|0o[0-7]+(?:_[0-7]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?)\b/i,
        operator: /~|\?|[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\.?/,
        builtin: /\b(?:any(?:_float|_int)?|bool|byte(?:ptr)?|charptr|f(?:32|64)|i(?:8|16|64|128|nt)|rune|size_t|string|u(?:16|32|64|128)|voidptr)\b/
      }), a.inside = r.languages.v, r.languages.insertBefore("v", "string", {
        char: {
          pattern: /`(?:\\`|\\?[^`]{1,2})`/,
          // using {1,2} instead of `u` flag for compatibility
          alias: "rune"
        }
      }), r.languages.insertBefore("v", "operator", {
        attribute: {
          pattern: /(^[\t ]*)\[(?:deprecated|direct_array_access|flag|inline|live|ref_only|typedef|unsafe_fn|windows_stdcall)\]/m,
          lookbehind: !0,
          alias: "annotation",
          inside: {
            punctuation: /[\[\]]/,
            keyword: /\w+/
          }
        },
        generic: {
          pattern: /<\w+>(?=\s*[\)\{])/,
          inside: {
            punctuation: /[<>]/,
            "class-name": /\w+/
          }
        }
      }), r.languages.insertBefore("v", "function", {
        "generic-function": {
          // e.g. foo<T>( ...
          pattern: /\b\w+\s*<\w+>(?=\()/,
          inside: {
            function: /^\w+/,
            generic: {
              pattern: /<\w+>/,
              inside: r.languages.v.generic.inside
            }
          }
        }
      });
    })(t);
  }
  return v_1;
}
var vala_1, hasRequiredVala;
function requireVala() {
  if (hasRequiredVala) return vala_1;
  hasRequiredVala = 1, vala_1 = e, e.displayName = "vala", e.aliases = [];
  function e(t) {
    t.languages.vala = t.languages.extend("clike", {
      // Classes copied from prism-csharp
      "class-name": [{
        // (Foo bar, Bar baz)
        pattern: /\b[A-Z]\w*(?:\.\w+)*\b(?=(?:\?\s+|\*?\s+\*?)\w)/,
        inside: {
          punctuation: /\./
        }
      }, {
        // [Foo]
        pattern: /(\[)[A-Z]\w*(?:\.\w+)*\b/,
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      }, {
        // class Foo : Bar
        pattern: /(\b(?:class|interface)\s+[A-Z]\w*(?:\.\w+)*\s*:\s*)[A-Z]\w*(?:\.\w+)*\b/,
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      }, {
        // class Foo
        pattern: /((?:\b(?:class|enum|interface|new|struct)\s+)|(?:catch\s+\())[A-Z]\w*(?:\.\w+)*\b/,
        lookbehind: !0,
        inside: {
          punctuation: /\./
        }
      }],
      keyword: /\b(?:abstract|as|assert|async|base|bool|break|case|catch|char|class|const|construct|continue|default|delegate|delete|do|double|dynamic|else|ensures|enum|errordomain|extern|finally|float|for|foreach|get|if|in|inline|int|int16|int32|int64|int8|interface|internal|is|lock|long|namespace|new|null|out|override|owned|params|private|protected|public|ref|requires|return|set|short|signal|sizeof|size_t|ssize_t|static|string|struct|switch|this|throw|throws|try|typeof|uchar|uint|uint16|uint32|uint64|uint8|ulong|unichar|unowned|ushort|using|value|var|virtual|void|volatile|weak|while|yield)\b/i,
      function: /\b\w+(?=\s*\()/,
      number: /(?:\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?:f|u?l?)?/i,
      operator: /\+\+|--|&&|\|\||<<=?|>>=?|=>|->|~|[+\-*\/%&^|=!<>]=?|\?\??|\.\.\./,
      punctuation: /[{}[\];(),.:]/,
      constant: /\b[A-Z0-9_]+\b/
    }), t.languages.insertBefore("vala", "string", {
      "raw-string": {
        pattern: /"""[\s\S]*?"""/,
        greedy: !0,
        alias: "string"
      },
      "template-string": {
        pattern: /@"[\s\S]*?"/,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /\$(?:\([^)]*\)|[a-zA-Z]\w*)/,
            inside: {
              delimiter: {
                pattern: /^\$\(?|\)$/,
                alias: "punctuation"
              },
              rest: t.languages.vala
            }
          },
          string: /[\s\S]+/
        }
      }
    }), t.languages.insertBefore("vala", "keyword", {
      regex: {
        pattern: /\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[imsx]{0,4}(?=\s*(?:$|[\r\n,.;})\]]))/,
        greedy: !0,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: !0,
            alias: "language-regex",
            inside: t.languages.regex
          },
          "regex-delimiter": /^\//,
          "regex-flags": /^[a-z]+$/
        }
      }
    });
  }
  return vala_1;
}
var velocity_1, hasRequiredVelocity;
function requireVelocity() {
  if (hasRequiredVelocity) return velocity_1;
  hasRequiredVelocity = 1, velocity_1 = e, e.displayName = "velocity", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.velocity = r.languages.extend("markup", {});
      var a = {
        variable: {
          pattern: /(^|[^\\](?:\\\\)*)\$!?(?:[a-z][\w-]*(?:\([^)]*\))?(?:\.[a-z][\w-]*(?:\([^)]*\))?|\[[^\]]+\])*|\{[^}]+\})/i,
          lookbehind: !0,
          inside: {}
          // See below
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: !0
        },
        number: /\b\d+\b/,
        boolean: /\b(?:false|true)\b/,
        operator: /[=!<>]=?|[+*/%-]|&&|\|\||\.\.|\b(?:eq|g[et]|l[et]|n(?:e|ot))\b/,
        punctuation: /[(){}[\]:,.]/
      };
      a.variable.inside = {
        string: a.string,
        function: {
          pattern: /([^\w-])[a-z][\w-]*(?=\()/,
          lookbehind: !0
        },
        number: a.number,
        boolean: a.boolean,
        punctuation: a.punctuation
      }, r.languages.insertBefore("velocity", "comment", {
        unparsed: {
          pattern: /(^|[^\\])#\[\[[\s\S]*?\]\]#/,
          lookbehind: !0,
          greedy: !0,
          inside: {
            punctuation: /^#\[\[|\]\]#$/
          }
        },
        "velocity-comment": [{
          pattern: /(^|[^\\])#\*[\s\S]*?\*#/,
          lookbehind: !0,
          greedy: !0,
          alias: "comment"
        }, {
          pattern: /(^|[^\\])##.*/,
          lookbehind: !0,
          greedy: !0,
          alias: "comment"
        }],
        directive: {
          pattern: /(^|[^\\](?:\\\\)*)#@?(?:[a-z][\w-]*|\{[a-z][\w-]*\})(?:\s*\((?:[^()]|\([^()]*\))*\))?/i,
          lookbehind: !0,
          inside: {
            keyword: {
              pattern: /^#@?(?:[a-z][\w-]*|\{[a-z][\w-]*\})|\bin\b/,
              inside: {
                punctuation: /[{}]/
              }
            },
            rest: a
          }
        },
        variable: a.variable
      }), r.languages.velocity.tag.inside["attr-value"].inside.rest = r.languages.velocity;
    })(t);
  }
  return velocity_1;
}
var verilog_1, hasRequiredVerilog;
function requireVerilog() {
  if (hasRequiredVerilog) return verilog_1;
  hasRequiredVerilog = 1, verilog_1 = e, e.displayName = "verilog", e.aliases = [];
  function e(t) {
    t.languages.verilog = {
      comment: {
        pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
        greedy: !0
      },
      string: {
        pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
        greedy: !0
      },
      "kernel-function": {
        // support for any kernel function (ex: $display())
        pattern: /\B\$\w+\b/,
        alias: "property"
      },
      // support for user defined constants (ex: `define)
      constant: /\B`\w+\b/,
      function: /\b\w+(?=\()/,
      // support for verilog and system verilog keywords
      keyword: /\b(?:alias|and|assert|assign|assume|automatic|before|begin|bind|bins|binsof|bit|break|buf|bufif0|bufif1|byte|case|casex|casez|cell|chandle|class|clocking|cmos|config|const|constraint|context|continue|cover|covergroup|coverpoint|cross|deassign|default|defparam|design|disable|dist|do|edge|else|end|endcase|endclass|endclocking|endconfig|endfunction|endgenerate|endgroup|endinterface|endmodule|endpackage|endprimitive|endprogram|endproperty|endsequence|endspecify|endtable|endtask|enum|event|expect|export|extends|extern|final|first_match|for|force|foreach|forever|fork|forkjoin|function|generate|genvar|highz0|highz1|if|iff|ifnone|ignore_bins|illegal_bins|import|incdir|include|initial|inout|input|inside|instance|int|integer|interface|intersect|join|join_any|join_none|large|liblist|library|local|localparam|logic|longint|macromodule|matches|medium|modport|module|nand|negedge|new|nmos|nor|noshowcancelled|not|notif0|notif1|null|or|output|package|packed|parameter|pmos|posedge|primitive|priority|program|property|protected|pull0|pull1|pulldown|pullup|pulsestyle_ondetect|pulsestyle_onevent|pure|rand|randc|randcase|randsequence|rcmos|real|realtime|ref|reg|release|repeat|return|rnmos|rpmos|rtran|rtranif0|rtranif1|scalared|sequence|shortint|shortreal|showcancelled|signed|small|solve|specify|specparam|static|string|strong0|strong1|struct|super|supply0|supply1|table|tagged|task|this|throughout|time|timeprecision|timeunit|tran|tranif0|tranif1|tri|tri0|tri1|triand|trior|trireg|type|typedef|union|unique|unsigned|use|uwire|var|vectored|virtual|void|wait|wait_order|wand|weak0|weak1|while|wildcard|wire|with|within|wor|xnor|xor)\b/,
      // bold highlighting for all verilog and system verilog logic blocks
      important: /\b(?:always|always_comb|always_ff|always_latch)\b(?: *@)?/,
      // support for time ticks, vectors, and real numbers
      number: /\B##?\d+|(?:\b\d+)?'[odbh] ?[\da-fzx_?]+|\b(?:\d*[._])?\d+(?:e[-+]?\d+)?/i,
      operator: /[-+{}^~%*\/?=!<>&|]+/,
      punctuation: /[[\];(),.:]/
    };
  }
  return verilog_1;
}
var vhdl_1, hasRequiredVhdl;
function requireVhdl() {
  if (hasRequiredVhdl) return vhdl_1;
  hasRequiredVhdl = 1, vhdl_1 = e, e.displayName = "vhdl", e.aliases = [];
  function e(t) {
    t.languages.vhdl = {
      comment: /--.+/,
      // support for all logic vectors
      "vhdl-vectors": {
        pattern: /\b[oxb]"[\da-f_]+"|"[01uxzwlh-]+"/i,
        alias: "number"
      },
      // support for operator overloading included
      "quoted-function": {
        pattern: /"\S+?"(?=\()/,
        alias: "function"
      },
      string: /"(?:[^\\"\r\n]|\\(?:\r\n|[\s\S]))*"/,
      constant: /\b(?:library|use)\b/i,
      // support for predefined attributes included
      keyword: /\b(?:'active|'ascending|'base|'delayed|'driving|'driving_value|'event|'high|'image|'instance_name|'last_active|'last_event|'last_value|'left|'leftof|'length|'low|'path_name|'pos|'pred|'quiet|'range|'reverse_range|'right|'rightof|'simple_name|'stable|'succ|'transaction|'val|'value|access|after|alias|all|architecture|array|assert|attribute|begin|block|body|buffer|bus|case|component|configuration|constant|disconnect|downto|else|elsif|end|entity|exit|file|for|function|generate|generic|group|guarded|if|impure|in|inertial|inout|is|label|library|linkage|literal|loop|map|new|next|null|of|on|open|others|out|package|port|postponed|procedure|process|pure|range|record|register|reject|report|return|select|severity|shared|signal|subtype|then|to|transport|type|unaffected|units|until|use|variable|wait|when|while|with)\b/i,
      boolean: /\b(?:false|true)\b/i,
      function: /\w+(?=\()/,
      // decimal, based, physical, and exponential numbers supported
      number: /'[01uxzwlh-]'|\b(?:\d+#[\da-f_.]+#|\d[\d_.]*)(?:e[-+]?\d+)?/i,
      operator: /[<>]=?|:=|[-+*/&=]|\b(?:abs|and|mod|nand|nor|not|or|rem|rol|ror|sla|sll|sra|srl|xnor|xor)\b/i,
      punctuation: /[{}[\];(),.:]/
    };
  }
  return vhdl_1;
}
var vim_1, hasRequiredVim;
function requireVim() {
  if (hasRequiredVim) return vim_1;
  hasRequiredVim = 1, vim_1 = e, e.displayName = "vim", e.aliases = [];
  function e(t) {
    t.languages.vim = {
      string: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\r\n]|'')*'/,
      comment: /".*/,
      function: /\b\w+(?=\()/,
      keyword: /\b(?:N|Next|P|Print|X|XMLent|XMLns|ab|abbreviate|abc|abclear|abo|aboveleft|al|all|ar|arga|argadd|argd|argdelete|argdo|arge|argedit|argg|argglobal|argl|arglocal|args|argu|argument|as|ascii|b|bN|bNext|ba|bad|badd|ball|bd|bdelete|be|bel|belowright|bf|bfirst|bl|blast|bm|bmodified|bn|bnext|bo|botright|bp|bprevious|br|brea|break|breaka|breakadd|breakd|breakdel|breakl|breaklist|brewind|bro|browse|bufdo|buffer|buffers|bun|bunload|bw|bwipeout|c|cN|cNext|cNfcNfile|ca|cabbrev|cabc|cabclear|cad|caddb|caddbuffer|caddexpr|caddf|caddfile|cal|call|cat|catch|cb|cbuffer|cc|ccl|cclose|cd|ce|center|cex|cexpr|cf|cfile|cfir|cfirst|cg|cgetb|cgetbuffer|cgete|cgetexpr|cgetfile|change|changes|chd|chdir|che|checkpath|checkt|checktime|cl|cla|clast|clist|clo|close|cmapc|cmapclear|cn|cnew|cnewer|cnext|cnf|cnfile|cnorea|cnoreabbrev|co|col|colder|colo|colorscheme|comc|comclear|comp|compiler|con|conf|confirm|continue|cope|copen|copy|cp|cpf|cpfile|cprevious|cq|cquit|cr|crewind|cu|cuna|cunabbrev|cunmap|cw|cwindow|d|debugg|debuggreedy|delc|delcommand|delete|delf|delfunction|delm|delmarks|di|diffg|diffget|diffoff|diffpatch|diffpu|diffput|diffsplit|diffthis|diffu|diffupdate|dig|digraphs|display|dj|djump|dl|dlist|dr|drop|ds|dsearch|dsp|dsplit|e|earlier|echoe|echoerr|echom|echomsg|echon|edit|el|else|elsei|elseif|em|emenu|en|endf|endfo|endfor|endfun|endfunction|endif|endt|endtry|endw|endwhile|ene|enew|ex|exi|exit|exu|exusage|f|file|files|filetype|fin|fina|finally|find|fini|finish|fir|first|fix|fixdel|fo|fold|foldc|foldclose|foldd|folddoc|folddoclosed|folddoopen|foldo|foldopen|for|fu|fun|function|go|goto|gr|grep|grepa|grepadd|h|ha|hardcopy|help|helpf|helpfind|helpg|helpgrep|helpt|helptags|hid|hide|his|history|ia|iabbrev|iabc|iabclear|if|ij|ijump|il|ilist|imapc|imapclear|in|inorea|inoreabbrev|isearch|isp|isplit|iu|iuna|iunabbrev|iunmap|j|join|ju|jumps|k|kee|keepalt|keepj|keepjumps|keepmarks|l|lN|lNext|lNf|lNfile|la|lad|laddb|laddbuffer|laddexpr|laddf|laddfile|lan|language|last|later|lb|lbuffer|lc|lcd|lch|lchdir|lcl|lclose|left|lefta|leftabove|let|lex|lexpr|lf|lfile|lfir|lfirst|lg|lgetb|lgetbuffer|lgete|lgetexpr|lgetfile|lgr|lgrep|lgrepa|lgrepadd|lh|lhelpgrep|list|ll|lla|llast|lli|llist|lm|lmak|lmake|lmap|lmapc|lmapclear|ln|lne|lnew|lnewer|lnext|lnf|lnfile|lnoremap|lo|loadview|loc|lockmarks|lockv|lockvar|lol|lolder|lop|lopen|lp|lpf|lpfile|lprevious|lr|lrewind|ls|lt|ltag|lu|lunmap|lv|lvimgrep|lvimgrepa|lvimgrepadd|lw|lwindow|m|ma|mak|make|mark|marks|mat|match|menut|menutranslate|mk|mkexrc|mks|mksession|mksp|mkspell|mkv|mkvie|mkview|mkvimrc|mod|mode|move|mz|mzf|mzfile|mzscheme|n|nbkey|new|next|nmapc|nmapclear|noh|nohlsearch|norea|noreabbrev|nu|number|nun|nunmap|o|omapc|omapclear|on|only|open|opt|options|ou|ounmap|p|pc|pclose|pe|ped|pedit|perl|perld|perldo|po|pop|popu|popup|pp|ppop|pre|preserve|prev|previous|print|prof|profd|profdel|profile|promptf|promptfind|promptr|promptrepl|ps|psearch|ptN|ptNext|pta|ptag|ptf|ptfirst|ptj|ptjump|ptl|ptlast|ptn|ptnext|ptp|ptprevious|ptr|ptrewind|pts|ptselect|pu|put|pw|pwd|py|pyf|pyfile|python|q|qa|qall|quit|quita|quitall|r|read|rec|recover|red|redi|redir|redo|redr|redraw|redraws|redrawstatus|reg|registers|res|resize|ret|retab|retu|return|rew|rewind|ri|right|rightb|rightbelow|ru|rub|ruby|rubyd|rubydo|rubyf|rubyfile|runtime|rv|rviminfo|sN|sNext|sa|sal|sall|san|sandbox|sargument|sav|saveas|sb|sbN|sbNext|sba|sball|sbf|sbfirst|sbl|sblast|sbm|sbmodified|sbn|sbnext|sbp|sbprevious|sbr|sbrewind|sbuffer|scrip|scripte|scriptencoding|scriptnames|se|set|setf|setfiletype|setg|setglobal|setl|setlocal|sf|sfind|sfir|sfirst|sh|shell|sign|sil|silent|sim|simalt|sl|sla|slast|sleep|sm|smagic|smap|smapc|smapclear|sme|smenu|sn|snext|sni|sniff|sno|snomagic|snor|snoremap|snoreme|snoremenu|so|sor|sort|source|sp|spe|spelld|spelldump|spellgood|spelli|spellinfo|spellr|spellrepall|spellu|spellundo|spellw|spellwrong|split|spr|sprevious|sre|srewind|st|sta|stag|star|startg|startgreplace|startinsert|startr|startreplace|stj|stjump|stop|stopi|stopinsert|sts|stselect|sun|sunhide|sunm|sunmap|sus|suspend|sv|sview|syncbind|t|tN|tNext|ta|tab|tabN|tabNext|tabc|tabclose|tabd|tabdo|tabe|tabedit|tabf|tabfind|tabfir|tabfirst|tabl|tablast|tabm|tabmove|tabn|tabnew|tabnext|tabo|tabonly|tabp|tabprevious|tabr|tabrewind|tabs|tag|tags|tc|tcl|tcld|tcldo|tclf|tclfile|te|tearoff|tf|tfirst|th|throw|tj|tjump|tl|tlast|tm|tmenu|tn|tnext|to|topleft|tp|tprevious|tr|trewind|try|ts|tselect|tu|tunmenu|u|una|unabbreviate|undo|undoj|undojoin|undol|undolist|unh|unhide|unlet|unlo|unlockvar|unm|unmap|up|update|ve|verb|verbose|version|vert|vertical|vi|vie|view|vim|vimgrep|vimgrepa|vimgrepadd|visual|viu|viusage|vmapc|vmapclear|vne|vnew|vs|vsplit|vu|vunmap|w|wN|wNext|wa|wall|wh|while|win|winc|wincmd|windo|winp|winpos|winsize|wn|wnext|wp|wprevious|wq|wqa|wqall|write|ws|wsverb|wv|wviminfo|x|xa|xall|xit|xm|xmap|xmapc|xmapclear|xme|xmenu|xn|xnoremap|xnoreme|xnoremenu|xu|xunmap|y|yank)\b/,
      builtin: /\b(?:acd|ai|akm|aleph|allowrevins|altkeymap|ambiwidth|ambw|anti|antialias|arab|arabic|arabicshape|ari|arshape|autochdir|autocmd|autoindent|autoread|autowrite|autowriteall|aw|awa|background|backspace|backup|backupcopy|backupdir|backupext|backupskip|balloondelay|ballooneval|balloonexpr|bdir|bdlay|beval|bex|bexpr|bg|bh|bin|binary|biosk|bioskey|bk|bkc|bomb|breakat|brk|browsedir|bs|bsdir|bsk|bt|bufhidden|buflisted|buftype|casemap|ccv|cdpath|cedit|cfu|ch|charconvert|ci|cin|cindent|cink|cinkeys|cino|cinoptions|cinw|cinwords|clipboard|cmdheight|cmdwinheight|cmp|cms|columns|com|comments|commentstring|compatible|complete|completefunc|completeopt|consk|conskey|copyindent|cot|cpo|cpoptions|cpt|cscopepathcomp|cscopeprg|cscopequickfix|cscopetag|cscopetagorder|cscopeverbose|cspc|csprg|csqf|cst|csto|csverb|cuc|cul|cursorcolumn|cursorline|cwh|debug|deco|def|define|delcombine|dex|dg|dict|dictionary|diff|diffexpr|diffopt|digraph|dip|dir|directory|dy|ea|ead|eadirection|eb|ed|edcompatible|ef|efm|ei|ek|enc|encoding|endofline|eol|ep|equalalways|equalprg|errorbells|errorfile|errorformat|esckeys|et|eventignore|expandtab|exrc|fcl|fcs|fdc|fde|fdi|fdl|fdls|fdm|fdn|fdo|fdt|fen|fenc|fencs|fex|ff|ffs|fileencoding|fileencodings|fileformat|fileformats|fillchars|fk|fkmap|flp|fml|fmr|foldcolumn|foldenable|foldexpr|foldignore|foldlevel|foldlevelstart|foldmarker|foldmethod|foldminlines|foldnestmax|foldtext|formatexpr|formatlistpat|formatoptions|formatprg|fp|fs|fsync|ft|gcr|gd|gdefault|gfm|gfn|gfs|gfw|ghr|gp|grepformat|grepprg|gtl|gtt|guicursor|guifont|guifontset|guifontwide|guiheadroom|guioptions|guipty|guitablabel|guitabtooltip|helpfile|helpheight|helplang|hf|hh|hi|hidden|highlight|hk|hkmap|hkmapp|hkp|hl|hlg|hls|hlsearch|ic|icon|iconstring|ignorecase|im|imactivatekey|imak|imc|imcmdline|imd|imdisable|imi|iminsert|ims|imsearch|inc|include|includeexpr|incsearch|inde|indentexpr|indentkeys|indk|inex|inf|infercase|insertmode|invacd|invai|invakm|invallowrevins|invaltkeymap|invanti|invantialias|invar|invarab|invarabic|invarabicshape|invari|invarshape|invautochdir|invautoindent|invautoread|invautowrite|invautowriteall|invaw|invawa|invbackup|invballooneval|invbeval|invbin|invbinary|invbiosk|invbioskey|invbk|invbl|invbomb|invbuflisted|invcf|invci|invcin|invcindent|invcompatible|invconfirm|invconsk|invconskey|invcopyindent|invcp|invcscopetag|invcscopeverbose|invcst|invcsverb|invcuc|invcul|invcursorcolumn|invcursorline|invdeco|invdelcombine|invdg|invdiff|invdigraph|invdisable|invea|inveb|inved|invedcompatible|invek|invendofline|inveol|invequalalways|inverrorbells|invesckeys|invet|invex|invexpandtab|invexrc|invfen|invfk|invfkmap|invfoldenable|invgd|invgdefault|invguipty|invhid|invhidden|invhk|invhkmap|invhkmapp|invhkp|invhls|invhlsearch|invic|invicon|invignorecase|invim|invimc|invimcmdline|invimd|invincsearch|invinf|invinfercase|invinsertmode|invis|invjoinspaces|invjs|invlazyredraw|invlbr|invlinebreak|invlisp|invlist|invloadplugins|invlpl|invlz|invma|invmacatsui|invmagic|invmh|invml|invmod|invmodeline|invmodifiable|invmodified|invmore|invmousef|invmousefocus|invmousehide|invnu|invnumber|invodev|invopendevice|invpaste|invpi|invpreserveindent|invpreviewwindow|invprompt|invpvw|invreadonly|invremap|invrestorescreen|invrevins|invri|invrightleft|invrightleftcmd|invrl|invrlc|invro|invrs|invru|invruler|invsb|invsc|invscb|invscrollbind|invscs|invsecure|invsft|invshellslash|invshelltemp|invshiftround|invshortname|invshowcmd|invshowfulltag|invshowmatch|invshowmode|invsi|invsm|invsmartcase|invsmartindent|invsmarttab|invsmd|invsn|invsol|invspell|invsplitbelow|invsplitright|invspr|invsr|invssl|invsta|invstartofline|invstmp|invswapfile|invswf|invta|invtagbsearch|invtagrelative|invtagstack|invtbi|invtbidi|invtbs|invtermbidi|invterse|invtextauto|invtextmode|invtf|invtgst|invtildeop|invtimeout|invtitle|invto|invtop|invtr|invttimeout|invttybuiltin|invttyfast|invtx|invvb|invvisualbell|invwa|invwarn|invwb|invweirdinvert|invwfh|invwfw|invwildmenu|invwinfixheight|invwinfixwidth|invwiv|invwmnu|invwrap|invwrapscan|invwrite|invwriteany|invwritebackup|invws|isf|isfname|isi|isident|isk|iskeyword|isprint|joinspaces|js|key|keymap|keymodel|keywordprg|km|kmp|kp|langmap|langmenu|laststatus|lazyredraw|lbr|lcs|linebreak|lines|linespace|lisp|lispwords|listchars|loadplugins|lpl|lsp|lz|macatsui|magic|makeef|makeprg|matchpairs|matchtime|maxcombine|maxfuncdepth|maxmapdepth|maxmem|maxmempattern|maxmemtot|mco|mef|menuitems|mfd|mh|mis|mkspellmem|ml|mls|mm|mmd|mmp|mmt|modeline|modelines|modifiable|modified|more|mouse|mousef|mousefocus|mousehide|mousem|mousemodel|mouses|mouseshape|mouset|mousetime|mp|mps|msm|mzq|mzquantum|nf|noacd|noai|noakm|noallowrevins|noaltkeymap|noanti|noantialias|noar|noarab|noarabic|noarabicshape|noari|noarshape|noautochdir|noautoindent|noautoread|noautowrite|noautowriteall|noaw|noawa|nobackup|noballooneval|nobeval|nobin|nobinary|nobiosk|nobioskey|nobk|nobl|nobomb|nobuflisted|nocf|noci|nocin|nocindent|nocompatible|noconfirm|noconsk|noconskey|nocopyindent|nocp|nocscopetag|nocscopeverbose|nocst|nocsverb|nocuc|nocul|nocursorcolumn|nocursorline|nodeco|nodelcombine|nodg|nodiff|nodigraph|nodisable|noea|noeb|noed|noedcompatible|noek|noendofline|noeol|noequalalways|noerrorbells|noesckeys|noet|noex|noexpandtab|noexrc|nofen|nofk|nofkmap|nofoldenable|nogd|nogdefault|noguipty|nohid|nohidden|nohk|nohkmap|nohkmapp|nohkp|nohls|noic|noicon|noignorecase|noim|noimc|noimcmdline|noimd|noincsearch|noinf|noinfercase|noinsertmode|nois|nojoinspaces|nojs|nolazyredraw|nolbr|nolinebreak|nolisp|nolist|noloadplugins|nolpl|nolz|noma|nomacatsui|nomagic|nomh|noml|nomod|nomodeline|nomodifiable|nomodified|nomore|nomousef|nomousefocus|nomousehide|nonu|nonumber|noodev|noopendevice|nopaste|nopi|nopreserveindent|nopreviewwindow|noprompt|nopvw|noreadonly|noremap|norestorescreen|norevins|nori|norightleft|norightleftcmd|norl|norlc|noro|nors|noru|noruler|nosb|nosc|noscb|noscrollbind|noscs|nosecure|nosft|noshellslash|noshelltemp|noshiftround|noshortname|noshowcmd|noshowfulltag|noshowmatch|noshowmode|nosi|nosm|nosmartcase|nosmartindent|nosmarttab|nosmd|nosn|nosol|nospell|nosplitbelow|nosplitright|nospr|nosr|nossl|nosta|nostartofline|nostmp|noswapfile|noswf|nota|notagbsearch|notagrelative|notagstack|notbi|notbidi|notbs|notermbidi|noterse|notextauto|notextmode|notf|notgst|notildeop|notimeout|notitle|noto|notop|notr|nottimeout|nottybuiltin|nottyfast|notx|novb|novisualbell|nowa|nowarn|nowb|noweirdinvert|nowfh|nowfw|nowildmenu|nowinfixheight|nowinfixwidth|nowiv|nowmnu|nowrap|nowrapscan|nowrite|nowriteany|nowritebackup|nows|nrformats|numberwidth|nuw|odev|oft|ofu|omnifunc|opendevice|operatorfunc|opfunc|osfiletype|pa|para|paragraphs|paste|pastetoggle|patchexpr|patchmode|path|pdev|penc|pex|pexpr|pfn|ph|pheader|pi|pm|pmbcs|pmbfn|popt|preserveindent|previewheight|previewwindow|printdevice|printencoding|printexpr|printfont|printheader|printmbcharset|printmbfont|printoptions|prompt|pt|pumheight|pvh|pvw|qe|quoteescape|readonly|remap|report|restorescreen|revins|rightleft|rightleftcmd|rl|rlc|ro|rs|rtp|ruf|ruler|rulerformat|runtimepath|sbo|sc|scb|scr|scroll|scrollbind|scrolljump|scrolloff|scrollopt|scs|sect|sections|secure|sel|selection|selectmode|sessionoptions|sft|shcf|shellcmdflag|shellpipe|shellquote|shellredir|shellslash|shelltemp|shelltype|shellxquote|shiftround|shiftwidth|shm|shortmess|shortname|showbreak|showcmd|showfulltag|showmatch|showmode|showtabline|shq|si|sidescroll|sidescrolloff|siso|sj|slm|smartcase|smartindent|smarttab|smc|smd|softtabstop|sol|spc|spell|spellcapcheck|spellfile|spelllang|spellsuggest|spf|spl|splitbelow|splitright|sps|sr|srr|ss|ssl|ssop|stal|startofline|statusline|stl|stmp|su|sua|suffixes|suffixesadd|sw|swapfile|swapsync|swb|swf|switchbuf|sws|sxq|syn|synmaxcol|syntax|t_AB|t_AF|t_AL|t_CS|t_CV|t_Ce|t_Co|t_Cs|t_DL|t_EI|t_F1|t_F2|t_F3|t_F4|t_F5|t_F6|t_F7|t_F8|t_F9|t_IE|t_IS|t_K1|t_K3|t_K4|t_K5|t_K6|t_K7|t_K8|t_K9|t_KA|t_KB|t_KC|t_KD|t_KE|t_KF|t_KG|t_KH|t_KI|t_KJ|t_KK|t_KL|t_RI|t_RV|t_SI|t_Sb|t_Sf|t_WP|t_WS|t_ZH|t_ZR|t_al|t_bc|t_cd|t_ce|t_cl|t_cm|t_cs|t_da|t_db|t_dl|t_fs|t_k1|t_k2|t_k3|t_k4|t_k5|t_k6|t_k7|t_k8|t_k9|t_kB|t_kD|t_kI|t_kN|t_kP|t_kb|t_kd|t_ke|t_kh|t_kl|t_kr|t_ks|t_ku|t_le|t_mb|t_md|t_me|t_mr|t_ms|t_nd|t_op|t_se|t_so|t_sr|t_te|t_ti|t_ts|t_ue|t_us|t_ut|t_vb|t_ve|t_vi|t_vs|t_xs|tabline|tabpagemax|tabstop|tagbsearch|taglength|tagrelative|tagstack|tal|tb|tbi|tbidi|tbis|tbs|tenc|term|termbidi|termencoding|terse|textauto|textmode|textwidth|tgst|thesaurus|tildeop|timeout|timeoutlen|title|titlelen|titleold|titlestring|toolbar|toolbariconsize|top|tpm|tsl|tsr|ttimeout|ttimeoutlen|ttm|tty|ttybuiltin|ttyfast|ttym|ttymouse|ttyscroll|ttytype|tw|tx|uc|ul|undolevels|updatecount|updatetime|ut|vb|vbs|vdir|verbosefile|vfile|viewdir|viewoptions|viminfo|virtualedit|visualbell|vop|wak|warn|wb|wc|wcm|wd|weirdinvert|wfh|wfw|whichwrap|wi|wig|wildchar|wildcharm|wildignore|wildmenu|wildmode|wildoptions|wim|winaltkeys|window|winfixheight|winfixwidth|winheight|winminheight|winminwidth|winwidth|wiv|wiw|wm|wmh|wmnu|wmw|wop|wrap|wrapmargin|wrapscan|writeany|writebackup|writedelay|ww)\b/,
      number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?)\b/i,
      operator: /\|\||&&|[-+.]=?|[=!](?:[=~][#?]?)?|[<>]=?[#?]?|[*\/%?]|\b(?:is(?:not)?)\b/,
      punctuation: /[{}[\](),;:]/
    };
  }
  return vim_1;
}
var visualBasic_1, hasRequiredVisualBasic;
function requireVisualBasic() {
  if (hasRequiredVisualBasic) return visualBasic_1;
  hasRequiredVisualBasic = 1, visualBasic_1 = e, e.displayName = "visualBasic", e.aliases = [];
  function e(t) {
    t.languages["visual-basic"] = {
      comment: {
        pattern: /(?:[']|REM\b)(?:[^\r\n_]|_(?:\r\n?|\n)?)*/i,
        inside: {
          keyword: /^REM/i
        }
      },
      directive: {
        pattern: /#(?:Const|Else|ElseIf|End|ExternalChecksum|ExternalSource|If|Region)(?:\b_[ \t]*(?:\r\n?|\n)|.)+/i,
        alias: "property",
        greedy: !0
      },
      string: {
        pattern: /\$?["](?:["]{2}|[^"])*["]C?/i,
        greedy: !0
      },
      date: {
        pattern: /#[ \t]*(?:\d+([/-])\d+\1\d+(?:[ \t]+(?:\d+[ \t]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[ \t]*(?:AM|PM))?))?|\d+[ \t]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[ \t]*(?:AM|PM))?)[ \t]*#/i,
        alias: "number"
      },
      number: /(?:(?:\b\d+(?:\.\d+)?|\.\d+)(?:E[+-]?\d+)?|&[HO][\dA-F]+)(?:[FRD]|U?[ILS])?/i,
      boolean: /\b(?:False|Nothing|True)\b/i,
      keyword: /\b(?:AddHandler|AddressOf|Alias|And(?:Also)?|As|Boolean|ByRef|Byte|ByVal|Call|Case|Catch|C(?:Bool|Byte|Char|Date|Dbl|Dec|Int|Lng|Obj|SByte|Short|Sng|Str|Type|UInt|ULng|UShort)|Char|Class|Const|Continue|Currency|Date|Decimal|Declare|Default|Delegate|Dim|DirectCast|Do|Double|Each|Else(?:If)?|End(?:If)?|Enum|Erase|Error|Event|Exit|Finally|For|Friend|Function|Get(?:Type|XMLNamespace)?|Global|GoSub|GoTo|Handles|If|Implements|Imports|In|Inherits|Integer|Interface|Is|IsNot|Let|Lib|Like|Long|Loop|Me|Mod|Module|Must(?:Inherit|Override)|My(?:Base|Class)|Namespace|Narrowing|New|Next|Not(?:Inheritable|Overridable)?|Object|Of|On|Operator|Option(?:al)?|Or(?:Else)?|Out|Overloads|Overridable|Overrides|ParamArray|Partial|Private|Property|Protected|Public|RaiseEvent|ReadOnly|ReDim|RemoveHandler|Resume|Return|SByte|Select|Set|Shadows|Shared|short|Single|Static|Step|Stop|String|Structure|Sub|SyncLock|Then|Throw|To|Try|TryCast|Type|TypeOf|U(?:Integer|Long|Short)|Until|Using|Variant|Wend|When|While|Widening|With(?:Events)?|WriteOnly|Xor)\b/i,
      operator: /[+\-*/\\^<=>&#@$%!]|\b_(?=[ \t]*[\r\n])/,
      punctuation: /[{}().,:?]/
    }, t.languages.vb = t.languages["visual-basic"], t.languages.vba = t.languages["visual-basic"];
  }
  return visualBasic_1;
}
var warpscript_1, hasRequiredWarpscript;
function requireWarpscript() {
  if (hasRequiredWarpscript) return warpscript_1;
  hasRequiredWarpscript = 1, warpscript_1 = e, e.displayName = "warpscript", e.aliases = [];
  function e(t) {
    t.languages.warpscript = {
      comment: /#.*|\/\/.*|\/\*[\s\S]*?\*\//,
      string: {
        pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'|<'(?:[^\\']|'(?!>)|\\.)*'>/,
        greedy: !0
      },
      variable: /\$\S+/,
      macro: {
        pattern: /@\S+/,
        alias: "property"
      },
      // WarpScript doesn't have any keywords, these are all functions under the control category
      // https://www.warp10.io/tags/control
      keyword: /\b(?:BREAK|CHECKMACRO|CONTINUE|CUDF|DEFINED|DEFINEDMACRO|EVAL|FAIL|FOR|FOREACH|FORSTEP|IFT|IFTE|MSGFAIL|NRETURN|RETHROW|RETURN|SWITCH|TRY|UDF|UNTIL|WHILE)\b/,
      number: /[+-]?\b(?:NaN|Infinity|\d+(?:\.\d*)?(?:[Ee][+-]?\d+)?|0x[\da-fA-F]+|0b[01]+)\b/,
      boolean: /\b(?:F|T|false|true)\b/,
      punctuation: /<%|%>|[{}[\]()]/,
      // Some operators from the "operators" category
      // https://www.warp10.io/tags/operators
      operator: /==|&&?|\|\|?|\*\*?|>>>?|<<|[<>!~]=?|[-/%^]|\+!?|\b(?:AND|NOT|OR)\b/
    };
  }
  return warpscript_1;
}
var wasm_1, hasRequiredWasm;
function requireWasm() {
  if (hasRequiredWasm) return wasm_1;
  hasRequiredWasm = 1, wasm_1 = e, e.displayName = "wasm", e.aliases = [];
  function e(t) {
    t.languages.wasm = {
      comment: [/\(;[\s\S]*?;\)/, {
        pattern: /;;.*/,
        greedy: !0
      }],
      string: {
        pattern: /"(?:\\[\s\S]|[^"\\])*"/,
        greedy: !0
      },
      keyword: [{
        pattern: /\b(?:align|offset)=/,
        inside: {
          operator: /=/
        }
      }, {
        pattern: /\b(?:(?:f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|neg?|nearest|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|sqrt|store(?:8|16|32)?|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))?|memory\.(?:grow|size))\b/,
        inside: {
          punctuation: /\./
        }
      }, /\b(?:anyfunc|block|br(?:_if|_table)?|call(?:_indirect)?|data|drop|elem|else|end|export|func|get_(?:global|local)|global|if|import|local|loop|memory|module|mut|nop|offset|param|result|return|select|set_(?:global|local)|start|table|tee_local|then|type|unreachable)\b/],
      variable: /\$[\w!#$%&'*+\-./:<=>?@\\^`|~]+/,
      number: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/,
      punctuation: /[()]/
    };
  }
  return wasm_1;
}
var webIdl_1, hasRequiredWebIdl;
function requireWebIdl() {
  if (hasRequiredWebIdl) return webIdl_1;
  hasRequiredWebIdl = 1, webIdl_1 = e, e.displayName = "webIdl", e.aliases = [];
  function e(t) {
    (function(r) {
      var a = /(?:\B-|\b_|\b)[A-Za-z][\w-]*(?![\w-])/.source, o = "(?:" + /\b(?:unsigned\s+)?long\s+long(?![\w-])/.source + "|" + /\b(?:unrestricted|unsigned)\s+[a-z]+(?![\w-])/.source + "|" + /(?!(?:unrestricted|unsigned)\b)/.source + a + /(?:\s*<(?:[^<>]|<[^<>]*>)*>)?/.source + ")" + /(?:\s*\?)?/.source, u = {};
      r.languages["web-idl"] = {
        comment: {
          pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
          greedy: !0
        },
        string: {
          pattern: /"[^"]*"/,
          greedy: !0
        },
        namespace: {
          pattern: RegExp(/(\bnamespace\s+)/.source + a),
          lookbehind: !0
        },
        "class-name": [
          {
            pattern: /(^|[^\w-])(?:iterable|maplike|setlike)\s*<(?:[^<>]|<[^<>]*>)*>/,
            lookbehind: !0,
            inside: u
          },
          {
            pattern: RegExp(/(\b(?:attribute|const|deleter|getter|optional|setter)\s+)/.source + o),
            lookbehind: !0,
            inside: u
          },
          {
            // callback return type
            pattern: RegExp("(" + /\bcallback\s+/.source + a + /\s*=\s*/.source + ")" + o),
            lookbehind: !0,
            inside: u
          },
          {
            // typedef
            pattern: RegExp(/(\btypedef\b\s*)/.source + o),
            lookbehind: !0,
            inside: u
          },
          {
            pattern: RegExp(/(\b(?:callback|dictionary|enum|interface(?:\s+mixin)?)\s+)(?!(?:interface|mixin)\b)/.source + a),
            lookbehind: !0
          },
          {
            // inheritance
            pattern: RegExp(/(:\s*)/.source + a),
            lookbehind: !0
          },
          // includes and implements
          RegExp(a + /(?=\s+(?:implements|includes)\b)/.source),
          {
            pattern: RegExp(/(\b(?:implements|includes)\s+)/.source + a),
            lookbehind: !0
          },
          {
            // function return type, parameter types, and dictionary members
            pattern: RegExp(o + "(?=" + /\s*(?:\.{3}\s*)?/.source + a + /\s*[(),;=]/.source + ")"),
            inside: u
          }
        ],
        builtin: /\b(?:ArrayBuffer|BigInt64Array|BigUint64Array|ByteString|DOMString|DataView|Float32Array|Float64Array|FrozenArray|Int16Array|Int32Array|Int8Array|ObservableArray|Promise|USVString|Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray)\b/,
        keyword: [
          /\b(?:async|attribute|callback|const|constructor|deleter|dictionary|enum|getter|implements|includes|inherit|interface|mixin|namespace|null|optional|or|partial|readonly|required|setter|static|stringifier|typedef|unrestricted)\b/,
          // type keywords
          /\b(?:any|bigint|boolean|byte|double|float|iterable|long|maplike|object|octet|record|sequence|setlike|short|symbol|undefined|unsigned|void)\b/
        ],
        boolean: /\b(?:false|true)\b/,
        number: {
          pattern: /(^|[^\w-])-?(?:0x[0-9a-f]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|NaN|Infinity)(?![\w-])/i,
          lookbehind: !0
        },
        operator: /\.{3}|[=:?<>-]/,
        punctuation: /[(){}[\].,;]/
      };
      for (var c in r.languages["web-idl"])
        c !== "class-name" && (u[c] = r.languages["web-idl"][c]);
      r.languages.webidl = r.languages["web-idl"];
    })(t);
  }
  return webIdl_1;
}
var wiki_1, hasRequiredWiki;
function requireWiki() {
  if (hasRequiredWiki) return wiki_1;
  hasRequiredWiki = 1, wiki_1 = e, e.displayName = "wiki", e.aliases = [];
  function e(t) {
    t.languages.wiki = t.languages.extend("markup", {
      "block-comment": {
        pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
        lookbehind: !0,
        alias: "comment"
      },
      heading: {
        pattern: /^(=+)[^=\r\n].*?\1/m,
        inside: {
          punctuation: /^=+|=+$/,
          important: /.+/
        }
      },
      emphasis: {
        // TODO Multi-line
        pattern: /('{2,5}).+?\1/,
        inside: {
          "bold-italic": {
            pattern: /(''''').+?(?=\1)/,
            lookbehind: !0,
            alias: ["bold", "italic"]
          },
          bold: {
            pattern: /(''')[^'](?:.*?[^'])?(?=\1)/,
            lookbehind: !0
          },
          italic: {
            pattern: /('')[^'](?:.*?[^'])?(?=\1)/,
            lookbehind: !0
          },
          punctuation: /^''+|''+$/
        }
      },
      hr: {
        pattern: /^-{4,}/m,
        alias: "punctuation"
      },
      url: [/ISBN +(?:97[89][ -]?)?(?:\d[ -]?){9}[\dx]\b|(?:PMID|RFC) +\d+/i, /\[\[.+?\]\]|\[.+?\]/],
      variable: [
        /__[A-Z]+__/,
        // FIXME Nested structures should be handled
        // {{formatnum:{{#expr:{{{3}}}}}}}
        /\{{3}.+?\}{3}/,
        /\{\{.+?\}\}/
      ],
      symbol: [/^#redirect/im, /~{3,5}/],
      // Handle table attrs:
      // {|
      // ! style="text-align:left;"| Item
      // |}
      "table-tag": {
        pattern: /((?:^|[|!])[|!])[^|\r\n]+\|(?!\|)/m,
        lookbehind: !0,
        inside: {
          "table-bar": {
            pattern: /\|$/,
            alias: "punctuation"
          },
          rest: t.languages.markup.tag.inside
        }
      },
      punctuation: /^(?:\{\||\|\}|\|-|[*#:;!|])|\|\||!!/m
    }), t.languages.insertBefore("wiki", "tag", {
      // Prevent highlighting inside <nowiki>, <source> and <pre> tags
      nowiki: {
        pattern: /<(nowiki|pre|source)\b[^>]*>[\s\S]*?<\/\1>/i,
        inside: {
          tag: {
            pattern: /<(?:nowiki|pre|source)\b[^>]*>|<\/(?:nowiki|pre|source)>/i,
            inside: t.languages.markup.tag.inside
          }
        }
      }
    });
  }
  return wiki_1;
}
var wolfram_1, hasRequiredWolfram;
function requireWolfram() {
  if (hasRequiredWolfram) return wolfram_1;
  hasRequiredWolfram = 1, wolfram_1 = e, e.displayName = "wolfram", e.aliases = ["mathematica", "wl", "nb"];
  function e(t) {
    t.languages.wolfram = {
      // Allow one level of nesting - note: regex taken from applescipt
      comment: /\(\*(?:\(\*(?:[^*]|\*(?!\)))*\*\)|(?!\(\*)[\s\S])*?\*\)/,
      string: {
        pattern: /"(?:\\.|[^"\\\r\n])*"/,
        greedy: !0
      },
      keyword: /\b(?:Abs|AbsArg|Accuracy|Block|Do|For|Function|If|Manipulate|Module|Nest|NestList|None|Return|Switch|Table|Which|While)\b/,
      context: {
        pattern: /\b\w+`+\w*/,
        alias: "class-name"
      },
      blank: {
        pattern: /\b\w+_\b/,
        alias: "regex"
      },
      "global-variable": {
        pattern: /\$\w+/,
        alias: "variable"
      },
      boolean: /\b(?:False|True)\b/,
      number: /(?:\b(?=\d)|\B(?=\.))(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?j?\b/i,
      operator: /\/\.|;|=\.|\^=|\^:=|:=|<<|>>|<\||\|>|:>|\|->|->|<-|@@@|@@|@|\/@|=!=|===|==|=|\+|-|\^|\[\/-+%=\]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
      punctuation: /[{}[\];(),.:]/
    }, t.languages.mathematica = t.languages.wolfram, t.languages.wl = t.languages.wolfram, t.languages.nb = t.languages.wolfram;
  }
  return wolfram_1;
}
var wren_1, hasRequiredWren;
function requireWren() {
  if (hasRequiredWren) return wren_1;
  hasRequiredWren = 1, wren_1 = e, e.displayName = "wren", e.aliases = [];
  function e(t) {
    t.languages.wren = {
      // Multiline comments in Wren can have nested multiline comments
      // Comments: // and /* */
      comment: [{
        // support 3 levels of nesting
        // regex: \/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\/
        pattern: /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*))*\*\/)*\*\/)*\*\//,
        greedy: !0
      }, {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }],
      // Triple quoted strings are multiline but cannot have interpolation (raw strings)
      // Based on prism-python.js
      "triple-quoted-string": {
        pattern: /"""[\s\S]*?"""/,
        greedy: !0,
        alias: "string"
      },
      // see below
      "string-literal": null,
      // #!/usr/bin/env wren on the first line
      hashbang: {
        pattern: /^#!\/.+/,
        greedy: !0,
        alias: "comment"
      },
      // Attributes are special keywords to add meta data to classes
      attribute: {
        // #! attributes are stored in class properties
        // #!myvar = true
        // #attributes are not stored and dismissed at compilation
        pattern: /#!?[ \t\u3000]*\w+/,
        alias: "keyword"
      },
      "class-name": [
        {
          // class definition
          // class Meta {}
          pattern: /(\bclass\s+)\w+/,
          lookbehind: !0
        },
        // A class must always start with an uppercase.
        // File.read
        /\b[A-Z][a-z\d_]*\b/
      ],
      // A constant can be a variable, class, property or method. Just named in all uppercase letters
      constant: /\b[A-Z][A-Z\d_]*\b/,
      null: {
        pattern: /\bnull\b/,
        alias: "keyword"
      },
      keyword: /\b(?:as|break|class|construct|continue|else|for|foreign|if|import|in|is|return|static|super|this|var|while)\b/,
      boolean: /\b(?:false|true)\b/,
      number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,
      // Functions can be Class.method()
      function: /\b[a-z_]\w*(?=\s*[({])/i,
      operator: /<<|>>|[=!<>]=?|&&|\|\||[-+*/%~^&|?:]|\.{2,3}/,
      punctuation: /[\[\](){}.,;]/
    }, t.languages.wren["string-literal"] = {
      // A single quote string is multiline and can have interpolation (similar to JS backticks ``)
      pattern: /(^|[^\\"])"(?:[^\\"%]|\\[\s\S]|%(?!\()|%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\))*"/,
      lookbehind: !0,
      greedy: !0,
      inside: {
        interpolation: {
          // "%(interpolation)"
          pattern: /((?:^|[^\\])(?:\\{2})*)%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\)/,
          lookbehind: !0,
          inside: {
            expression: {
              pattern: /^(%\()[\s\S]+(?=\)$)/,
              lookbehind: !0,
              inside: t.languages.wren
            },
            "interpolation-punctuation": {
              pattern: /^%\(|\)$/,
              alias: "punctuation"
            }
          }
        },
        string: /[\s\S]+/
      }
    };
  }
  return wren_1;
}
var xeora_1, hasRequiredXeora;
function requireXeora() {
  if (hasRequiredXeora) return xeora_1;
  hasRequiredXeora = 1, xeora_1 = e, e.displayName = "xeora", e.aliases = ["xeoracube"];
  function e(t) {
    (function(r) {
      r.languages.xeora = r.languages.extend("markup", {
        constant: {
          pattern: /\$(?:DomainContents|PageRenderDuration)\$/,
          inside: {
            punctuation: {
              pattern: /\$/
            }
          }
        },
        variable: {
          pattern: /\$@?(?:#+|[-+*~=^])?[\w.]+\$/,
          inside: {
            punctuation: {
              pattern: /[$.]/
            },
            operator: {
              pattern: /#+|[-+*~=^@]/
            }
          }
        },
        "function-inline": {
          pattern: /\$F:[-\w.]+\?[-\w.]+(?:,(?:(?:@[-#]*\w+\.[\w+.]\.*)*\|)*(?:(?:[\w+]|[-#*.~^]+[\w+]|=\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\w+\.[\w+.]\.*)+(?:(?:[\w+]|[-#*~^][-#*.~^]*[\w+]|=\S)(?:[^$=]|=+[^=])*=*)?)?)?\$/,
          inside: {
            variable: {
              pattern: /(?:[,|])@?(?:#+|[-+*~=^])?[\w.]+/,
              inside: {
                punctuation: {
                  pattern: /[,.|]/
                },
                operator: {
                  pattern: /#+|[-+*~=^@]/
                }
              }
            },
            punctuation: {
              pattern: /\$\w:|[$:?.,|]/
            }
          },
          alias: "function"
        },
        "function-block": {
          pattern: /\$XF:\{[-\w.]+\?[-\w.]+(?:,(?:(?:@[-#]*\w+\.[\w+.]\.*)*\|)*(?:(?:[\w+]|[-#*.~^]+[\w+]|=\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\w+\.[\w+.]\.*)+(?:(?:[\w+]|[-#*~^][-#*.~^]*[\w+]|=\S)(?:[^$=]|=+[^=])*=*)?)?)?\}:XF\$/,
          inside: {
            punctuation: {
              pattern: /[$:{}?.,|]/
            }
          },
          alias: "function"
        },
        "directive-inline": {
          pattern: /\$\w(?:#\d+\+?)?(?:\[[-\w.]+\])?:[-\/\w.]+\$/,
          inside: {
            punctuation: {
              pattern: /\$(?:\w:|C(?:\[|#\d))?|[:{[\]]/,
              inside: {
                tag: {
                  pattern: /#\d/
                }
              }
            }
          },
          alias: "function"
        },
        "directive-block-open": {
          pattern: /\$\w+:\{|\$\w(?:#\d+\+?)?(?:\[[-\w.]+\])?:[-\w.]+:\{(?:![A-Z]+)?/,
          inside: {
            punctuation: {
              pattern: /\$(?:\w:|C(?:\[|#\d))?|[:{[\]]/,
              inside: {
                tag: {
                  pattern: /#\d/
                }
              }
            },
            attribute: {
              pattern: /![A-Z]+$/,
              inside: {
                punctuation: {
                  pattern: /!/
                }
              },
              alias: "keyword"
            }
          },
          alias: "function"
        },
        "directive-block-separator": {
          pattern: /\}:[-\w.]+:\{/,
          inside: {
            punctuation: {
              pattern: /[:{}]/
            }
          },
          alias: "function"
        },
        "directive-block-close": {
          pattern: /\}:[-\w.]+\$/,
          inside: {
            punctuation: {
              pattern: /[:{}$]/
            }
          },
          alias: "function"
        }
      }), r.languages.insertBefore("inside", "punctuation", {
        variable: r.languages.xeora["function-inline"].inside.variable
      }, r.languages.xeora["function-block"]), r.languages.xeoracube = r.languages.xeora;
    })(t);
  }
  return xeora_1;
}
var xmlDoc_1, hasRequiredXmlDoc;
function requireXmlDoc() {
  if (hasRequiredXmlDoc) return xmlDoc_1;
  hasRequiredXmlDoc = 1, xmlDoc_1 = e, e.displayName = "xmlDoc", e.aliases = [];
  function e(t) {
    (function(r) {
      function a(d, g) {
        r.languages[d] && r.languages.insertBefore(d, "comment", {
          "doc-comment": g
        });
      }
      var o = r.languages.markup.tag, u = {
        pattern: /\/\/\/.*/,
        greedy: !0,
        alias: "comment",
        inside: {
          tag: o
        }
      }, c = {
        pattern: /'''.*/,
        greedy: !0,
        alias: "comment",
        inside: {
          tag: o
        }
      };
      a("csharp", u), a("fsharp", u), a("vbnet", c);
    })(t);
  }
  return xmlDoc_1;
}
var xojo_1, hasRequiredXojo;
function requireXojo() {
  if (hasRequiredXojo) return xojo_1;
  hasRequiredXojo = 1, xojo_1 = e, e.displayName = "xojo", e.aliases = [];
  function e(t) {
    t.languages.xojo = {
      comment: {
        pattern: /(?:'|\/\/|Rem\b).+/i,
        greedy: !0
      },
      string: {
        pattern: /"(?:""|[^"])*"/,
        greedy: !0
      },
      number: [/(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i, /&[bchou][a-z\d]+/i],
      directive: {
        pattern: /#(?:Else|ElseIf|Endif|If|Pragma)\b/i,
        alias: "property"
      },
      keyword: /\b(?:AddHandler|App|Array|As(?:signs)?|Auto|Boolean|Break|By(?:Ref|Val)|Byte|Call|Case|Catch|CFStringRef|CGFloat|Class|Color|Const|Continue|CString|Currency|CurrentMethodName|Declare|Delegate|Dim|Do(?:uble|wnTo)?|Each|Else(?:If)?|End|Enumeration|Event|Exception|Exit|Extends|False|Finally|For|Function|Get|GetTypeInfo|Global|GOTO|If|Implements|In|Inherits|Int(?:8|16|32|64|eger|erface)?|Lib|Loop|Me|Module|Next|Nil|Object|Optional|OSType|ParamArray|Private|Property|Protected|PString|Ptr|Raise(?:Event)?|ReDim|RemoveHandler|Return|Select(?:or)?|Self|Set|Shared|Short|Single|Soft|Static|Step|String|Sub|Super|Text|Then|To|True|Try|Ubound|UInt(?:8|16|32|64|eger)?|Until|Using|Var(?:iant)?|Wend|While|WindowPtr|WString)\b/i,
      operator: /<[=>]?|>=?|[+\-*\/\\^=]|\b(?:AddressOf|And|Ctype|IsA?|Mod|New|Not|Or|WeakAddressOf|Xor)\b/i,
      punctuation: /[.,;:()]/
    };
  }
  return xojo_1;
}
var xquery_1, hasRequiredXquery;
function requireXquery() {
  if (hasRequiredXquery) return xquery_1;
  hasRequiredXquery = 1, xquery_1 = e, e.displayName = "xquery", e.aliases = [];
  function e(t) {
    (function(r) {
      r.languages.xquery = r.languages.extend("markup", {
        "xquery-comment": {
          pattern: /\(:[\s\S]*?:\)/,
          greedy: !0,
          alias: "comment"
        },
        string: {
          pattern: /(["'])(?:\1\1|(?!\1)[\s\S])*\1/,
          greedy: !0
        },
        extension: {
          pattern: /\(#.+?#\)/,
          alias: "symbol"
        },
        variable: /\$[-\w:]+/,
        axis: {
          pattern: /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,
          lookbehind: !0,
          alias: "operator"
        },
        "keyword-operator": {
          pattern: /(^|[^:-])\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\b(?=$|[^:-])/,
          lookbehind: !0,
          alias: "operator"
        },
        keyword: {
          pattern: /(^|[^:-])\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\b(?=$|[^:-])/,
          lookbehind: !0
        },
        function: /[\w-]+(?::[\w-]+)*(?=\s*\()/,
        "xquery-element": {
          pattern: /(element\s+)[\w-]+(?::[\w-]+)*/,
          lookbehind: !0,
          alias: "tag"
        },
        "xquery-attribute": {
          pattern: /(attribute\s+)[\w-]+(?::[\w-]+)*/,
          lookbehind: !0,
          alias: "attr-name"
        },
        builtin: {
          pattern: /(^|[^:-])\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:ENTITIES|ENTITY|ID|IDREFS?|NCName|NMTOKENS?|NOTATION|Name|QName|anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|int|integer|language|long|negativeInteger|nonNegativeInteger|nonPositiveInteger|normalizedString|positiveInteger|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\b(?=$|[^:-])/,
          lookbehind: !0
        },
        number: /\b\d+(?:\.\d+)?(?:E[+-]?\d+)?/,
        operator: [/[+*=?|@]|\.\.?|:=|!=|<[=<]?|>[=>]?/, {
          pattern: /(\s)-(?=\s)/,
          lookbehind: !0
        }],
        punctuation: /[[\](){},;:/]/
      }), r.languages.xquery.tag.pattern = /<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/, r.languages.xquery.tag.inside["attr-value"].pattern = /=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+)/, r.languages.xquery.tag.inside["attr-value"].inside.punctuation = /^="|"$/, r.languages.xquery.tag.inside["attr-value"].inside.expression = {
        // Allow for two levels of nesting
        pattern: /\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}/,
        inside: r.languages.xquery,
        alias: "language-xquery"
      };
      var a = function(u) {
        return typeof u == "string" ? u : typeof u.content == "string" ? u.content : u.content.map(a).join("");
      }, o = function(u) {
        for (var c = [], d = 0; d < u.length; d++) {
          var g = u[d], b = !1;
          if (typeof g != "string" && (g.type === "tag" && g.content[0] && g.content[0].type === "tag" ? g.content[0].content[0].content === "</" ? c.length > 0 && c[c.length - 1].tagName === a(g.content[0].content[1]) && c.pop() : g.content[g.content.length - 1].content === "/>" || c.push({
            tagName: a(g.content[0].content[1]),
            openedBraces: 0
          }) : c.length > 0 && g.type === "punctuation" && g.content === "{" && // Ignore `{{`
          (!u[d + 1] || u[d + 1].type !== "punctuation" || u[d + 1].content !== "{") && (!u[d - 1] || u[d - 1].type !== "plain-text" || u[d - 1].content !== "{") ? c[c.length - 1].openedBraces++ : c.length > 0 && c[c.length - 1].openedBraces > 0 && g.type === "punctuation" && g.content === "}" ? c[c.length - 1].openedBraces-- : g.type !== "comment" && (b = !0)), (b || typeof g == "string") && c.length > 0 && c[c.length - 1].openedBraces === 0) {
            var _ = a(g);
            d < u.length - 1 && (typeof u[d + 1] == "string" || u[d + 1].type === "plain-text") && (_ += a(u[d + 1]), u.splice(d + 1, 1)), d > 0 && (typeof u[d - 1] == "string" || u[d - 1].type === "plain-text") && (_ = a(u[d - 1]) + _, u.splice(d - 1, 1), d--), /^\s+$/.test(_) ? u[d] = _ : u[d] = new r.Token("plain-text", _, null, _);
          }
          g.content && typeof g.content != "string" && o(g.content);
        }
      };
      r.hooks.add("after-tokenize", function(u) {
        u.language === "xquery" && o(u.tokens);
      });
    })(t);
  }
  return xquery_1;
}
var yang_1, hasRequiredYang;
function requireYang() {
  if (hasRequiredYang) return yang_1;
  hasRequiredYang = 1, yang_1 = e, e.displayName = "yang", e.aliases = [];
  function e(t) {
    t.languages.yang = {
      // https://tools.ietf.org/html/rfc6020#page-34
      // http://www.yang-central.org/twiki/bin/view/Main/YangExamples
      comment: /\/\*[\s\S]*?\*\/|\/\/.*/,
      string: {
        pattern: /"(?:[^\\"]|\\.)*"|'[^']*'/,
        greedy: !0
      },
      keyword: {
        pattern: /(^|[{};\r\n][ \t]*)[a-z_][\w.-]*/i,
        lookbehind: !0
      },
      namespace: {
        pattern: /(\s)[a-z_][\w.-]*(?=:)/i,
        lookbehind: !0
      },
      boolean: /\b(?:false|true)\b/,
      operator: /\+/,
      punctuation: /[{};:]/
    };
  }
  return yang_1;
}
var zig_1, hasRequiredZig;
function requireZig() {
  if (hasRequiredZig) return zig_1;
  hasRequiredZig = 1, zig_1 = e, e.displayName = "zig", e.aliases = [];
  function e(t) {
    (function(r) {
      function a(_) {
        return function() {
          return _;
        };
      }
      var o = /\b(?:align|allowzero|and|anyframe|anytype|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|nosuspend|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\b/, u = "\\b(?!" + o.source + ")(?!\\d)\\w+\\b", c = /align\s*\((?:[^()]|\([^()]*\))*\)/.source, d = /(?:\?|\bpromise->|(?:\[[^[\]]*\]|\*(?!\*)|\*\*)(?:\s*<ALIGN>|\s*const\b|\s*volatile\b|\s*allowzero\b)*)/.source.replace(/<ALIGN>/g, a(c)), g = /(?:\bpromise\b|(?:\berror\.)?<ID>(?:\.<ID>)*(?!\s+<ID>))/.source.replace(/<ID>/g, a(u)), b = "(?!\\s)(?:!?\\s*(?:" + d + "\\s*)*" + g + ")+";
      r.languages.zig = {
        comment: [{
          pattern: /\/\/[/!].*/,
          alias: "doc-comment"
        }, /\/{2}.*/],
        string: [{
          // "string" and c"string"
          pattern: /(^|[^\\@])c?"(?:[^"\\\r\n]|\\.)*"/,
          lookbehind: !0,
          greedy: !0
        }, {
          // multiline strings and c-strings
          pattern: /([\r\n])([ \t]+c?\\{2}).*(?:(?:\r\n?|\n)\2.*)*/,
          lookbehind: !0,
          greedy: !0
        }],
        char: {
          // characters 'a', '\n', '\xFF', '\u{10FFFF}'
          pattern: /(^|[^\\])'(?:[^'\\\r\n]|[\uD800-\uDFFF]{2}|\\(?:.|x[a-fA-F\d]{2}|u\{[a-fA-F\d]{1,6}\}))'/,
          lookbehind: !0,
          greedy: !0
        },
        builtin: /\B@(?!\d)\w+(?=\s*\()/,
        label: {
          pattern: /(\b(?:break|continue)\s*:\s*)\w+\b|\b(?!\d)\w+\b(?=\s*:\s*(?:\{|while\b))/,
          lookbehind: !0
        },
        "class-name": [
          // const Foo = struct {};
          /\b(?!\d)\w+(?=\s*=\s*(?:(?:extern|packed)\s+)?(?:enum|struct|union)\s*[({])/,
          {
            // const x: i32 = 9;
            // var x: Bar;
            // fn foo(x: bool, y: f32) void {}
            pattern: RegExp(/(:\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?[=;,)])|<TYPE>(?=\s*(?:<ALIGN>\s*)?\{)/.source.replace(/<TYPE>/g, a(b)).replace(/<ALIGN>/g, a(c))),
            lookbehind: !0,
            inside: null
            // see below
          },
          {
            // extern fn foo(x: f64) f64; (optional alignment)
            pattern: RegExp(/(\)\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?;)/.source.replace(/<TYPE>/g, a(b)).replace(/<ALIGN>/g, a(c))),
            lookbehind: !0,
            inside: null
            // see below
          }
        ],
        "builtin-type": {
          pattern: /\b(?:anyerror|bool|c_u?(?:int|long|longlong|short)|c_longdouble|c_void|comptime_(?:float|int)|f(?:16|32|64|128)|[iu](?:8|16|32|64|128|size)|noreturn|type|void)\b/,
          alias: "keyword"
        },
        keyword: o,
        function: /\b(?!\d)\w+(?=\s*\()/,
        number: /\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\d]+(?:\.[a-fA-F\d]*)?(?:[pP][+-]?[a-fA-F\d]+)?|\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)\b/,
        boolean: /\b(?:false|true)\b/,
        operator: /\.[*?]|\.{2,3}|[-=]>|\*\*|\+\+|\|\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,
        punctuation: /[.:,;(){}[\]]/
      }, r.languages.zig["class-name"].forEach(function(_) {
        _.inside === null && (_.inside = r.languages.zig);
      });
    })(t);
  }
  return zig_1;
}
var refractor = core, refractor_1 = refractor;
refractor.register(requireAbap());
refractor.register(requireAbnf());
refractor.register(requireActionscript());
refractor.register(requireAda());
refractor.register(requireAgda());
refractor.register(requireAl());
refractor.register(requireAntlr4());
refractor.register(requireApacheconf());
refractor.register(requireApex());
refractor.register(requireApl());
refractor.register(requireApplescript());
refractor.register(requireAql());
refractor.register(requireArduino());
refractor.register(requireArff());
refractor.register(requireAsciidoc());
refractor.register(requireAsm6502());
refractor.register(requireAsmatmel());
refractor.register(requireAspnet());
refractor.register(requireAutohotkey());
refractor.register(requireAutoit());
refractor.register(requireAvisynth());
refractor.register(requireAvroIdl());
refractor.register(requireBash());
refractor.register(requireBasic());
refractor.register(requireBatch());
refractor.register(requireBbcode());
refractor.register(requireBicep());
refractor.register(requireBirb());
refractor.register(requireBison());
refractor.register(requireBnf());
refractor.register(requireBrainfuck());
refractor.register(requireBrightscript());
refractor.register(requireBro());
refractor.register(requireBsl());
refractor.register(requireC());
refractor.register(requireCfscript());
refractor.register(requireChaiscript());
refractor.register(requireCil());
refractor.register(requireClojure());
refractor.register(requireCmake());
refractor.register(requireCobol());
refractor.register(requireCoffeescript());
refractor.register(requireConcurnas());
refractor.register(requireCoq());
refractor.register(requireCpp());
refractor.register(requireCrystal());
refractor.register(requireCsharp());
refractor.register(requireCshtml());
refractor.register(requireCsp());
refractor.register(requireCssExtras());
refractor.register(requireCsv());
refractor.register(requireCypher());
refractor.register(requireD());
refractor.register(requireDart());
refractor.register(requireDataweave());
refractor.register(requireDax());
refractor.register(requireDhall());
refractor.register(requireDiff());
refractor.register(requireDjango());
refractor.register(requireDnsZoneFile());
refractor.register(requireDocker());
refractor.register(requireDot());
refractor.register(requireEbnf());
refractor.register(requireEditorconfig());
refractor.register(requireEiffel());
refractor.register(requireEjs());
refractor.register(requireElixir());
refractor.register(requireElm());
refractor.register(requireErb());
refractor.register(requireErlang());
refractor.register(requireEtlua());
refractor.register(requireExcelFormula());
refractor.register(requireFactor());
refractor.register(require_false());
refractor.register(requireFirestoreSecurityRules());
refractor.register(requireFlow());
refractor.register(requireFortran());
refractor.register(requireFsharp());
refractor.register(requireFtl());
refractor.register(requireGap());
refractor.register(requireGcode());
refractor.register(requireGdscript());
refractor.register(requireGedcom());
refractor.register(requireGherkin());
refractor.register(requireGit());
refractor.register(requireGlsl());
refractor.register(requireGml());
refractor.register(requireGn());
refractor.register(requireGoModule());
refractor.register(requireGo());
refractor.register(requireGraphql());
refractor.register(requireGroovy());
refractor.register(requireHaml());
refractor.register(requireHandlebars());
refractor.register(requireHaskell());
refractor.register(requireHaxe());
refractor.register(requireHcl());
refractor.register(requireHlsl());
refractor.register(requireHoon());
refractor.register(requireHpkp());
refractor.register(requireHsts());
refractor.register(requireHttp());
refractor.register(requireIchigojam());
refractor.register(requireIcon());
refractor.register(requireIcuMessageFormat());
refractor.register(requireIdris());
refractor.register(requireIecst());
refractor.register(requireIgnore());
refractor.register(requireInform7());
refractor.register(requireIni());
refractor.register(requireIo());
refractor.register(requireJ());
refractor.register(requireJava());
refractor.register(requireJavadoc());
refractor.register(requireJavadoclike());
refractor.register(requireJavastacktrace());
refractor.register(requireJexl());
refractor.register(requireJolie());
refractor.register(requireJq());
refractor.register(requireJsExtras());
refractor.register(requireJsTemplates());
refractor.register(requireJsdoc());
refractor.register(requireJson());
refractor.register(requireJson5());
refractor.register(requireJsonp());
refractor.register(requireJsstacktrace());
refractor.register(requireJsx());
refractor.register(requireJulia());
refractor.register(requireKeepalived());
refractor.register(requireKeyman());
refractor.register(requireKotlin());
refractor.register(requireKumir());
refractor.register(requireKusto());
refractor.register(requireLatex());
refractor.register(requireLatte());
refractor.register(requireLess());
refractor.register(requireLilypond());
refractor.register(requireLiquid());
refractor.register(requireLisp());
refractor.register(requireLivescript());
refractor.register(requireLlvm());
refractor.register(requireLog());
refractor.register(requireLolcode());
refractor.register(requireLua());
refractor.register(requireMagma());
refractor.register(requireMakefile());
refractor.register(requireMarkdown());
refractor.register(requireMarkupTemplating());
refractor.register(requireMatlab());
refractor.register(requireMaxscript());
refractor.register(requireMel());
refractor.register(requireMermaid());
refractor.register(requireMizar());
refractor.register(requireMongodb());
refractor.register(requireMonkey());
refractor.register(requireMoonscript());
refractor.register(requireN1ql());
refractor.register(requireN4js());
refractor.register(requireNand2tetrisHdl());
refractor.register(requireNaniscript());
refractor.register(requireNasm());
refractor.register(requireNeon());
refractor.register(requireNevod());
refractor.register(requireNginx());
refractor.register(requireNim());
refractor.register(requireNix());
refractor.register(requireNsis());
refractor.register(requireObjectivec());
refractor.register(requireOcaml());
refractor.register(requireOpencl());
refractor.register(requireOpenqasm());
refractor.register(requireOz());
refractor.register(requireParigp());
refractor.register(requireParser());
refractor.register(requirePascal());
refractor.register(requirePascaligo());
refractor.register(requirePcaxis());
refractor.register(requirePeoplecode());
refractor.register(requirePerl());
refractor.register(requirePhpExtras());
refractor.register(requirePhp());
refractor.register(requirePhpdoc());
refractor.register(requirePlsql());
refractor.register(requirePowerquery());
refractor.register(requirePowershell());
refractor.register(requireProcessing());
refractor.register(requireProlog());
refractor.register(requirePromql());
refractor.register(requireProperties());
refractor.register(requireProtobuf());
refractor.register(requirePsl());
refractor.register(requirePug());
refractor.register(requirePuppet());
refractor.register(requirePure());
refractor.register(requirePurebasic());
refractor.register(requirePurescript());
refractor.register(requirePython());
refractor.register(requireQ());
refractor.register(requireQml());
refractor.register(requireQore());
refractor.register(requireQsharp());
refractor.register(requireR());
refractor.register(requireRacket());
refractor.register(requireReason());
refractor.register(requireRegex());
refractor.register(requireRego());
refractor.register(requireRenpy());
refractor.register(requireRest());
refractor.register(requireRip());
refractor.register(requireRoboconf());
refractor.register(requireRobotframework());
refractor.register(requireRuby());
refractor.register(requireRust());
refractor.register(requireSas());
refractor.register(requireSass());
refractor.register(requireScala());
refractor.register(requireScheme());
refractor.register(requireScss());
refractor.register(requireShellSession());
refractor.register(requireSmali());
refractor.register(requireSmalltalk());
refractor.register(requireSmarty());
refractor.register(requireSml());
refractor.register(requireSolidity());
refractor.register(requireSolutionFile());
refractor.register(requireSoy());
refractor.register(requireSparql());
refractor.register(requireSplunkSpl());
refractor.register(requireSqf());
refractor.register(requireSql());
refractor.register(requireSquirrel());
refractor.register(requireStan());
refractor.register(requireStylus());
refractor.register(requireSwift());
refractor.register(requireSystemd());
refractor.register(requireT4Cs());
refractor.register(requireT4Templating());
refractor.register(requireT4Vb());
refractor.register(requireTap());
refractor.register(requireTcl());
refractor.register(requireTextile());
refractor.register(requireToml());
refractor.register(requireTremor());
refractor.register(requireTsx());
refractor.register(requireTt2());
refractor.register(requireTurtle());
refractor.register(requireTwig());
refractor.register(requireTypescript());
refractor.register(requireTyposcript());
refractor.register(requireUnrealscript());
refractor.register(requireUorazor());
refractor.register(requireUri());
refractor.register(requireV());
refractor.register(requireVala());
refractor.register(requireVbnet());
refractor.register(requireVelocity());
refractor.register(requireVerilog());
refractor.register(requireVhdl());
refractor.register(requireVim());
refractor.register(requireVisualBasic());
refractor.register(requireWarpscript());
refractor.register(requireWasm());
refractor.register(requireWebIdl());
refractor.register(requireWiki());
refractor.register(requireWolfram());
refractor.register(requireWren());
refractor.register(requireXeora());
refractor.register(requireXmlDoc());
refractor.register(requireXojo());
refractor.register(requireXquery());
refractor.register(requireYaml());
refractor.register(requireYang());
refractor.register(requireZig());
const refractor$1 = /* @__PURE__ */ getDefaultExportFromCjs(refractor_1);
var highlighter = highlight$1(refractor$1, defaultStyle);
highlighter.supportedLanguages = supportedLanguages;
const oneDark = {
  'code[class*="language-"]': {
    background: "hsl(220, 13%, 18%)",
    color: "hsl(220, 14%, 71%)",
    textShadow: "0 1px rgba(0, 0, 0, 0.3)",
    fontFamily: '"Fira Code", "Fira Mono", Menlo, Consolas, "DejaVu Sans Mono", monospace',
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "2",
    OTabSize: "2",
    tabSize: "2",
    WebkitHyphens: "none",
    MozHyphens: "none",
    msHyphens: "none",
    hyphens: "none"
  },
  'pre[class*="language-"]': {
    background: "hsl(220, 13%, 18%)",
    color: "hsl(220, 14%, 71%)",
    textShadow: "0 1px rgba(0, 0, 0, 0.3)",
    fontFamily: '"Fira Code", "Fira Mono", Menlo, Consolas, "DejaVu Sans Mono", monospace',
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "2",
    OTabSize: "2",
    tabSize: "2",
    WebkitHyphens: "none",
    MozHyphens: "none",
    msHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: "0.5em 0",
    overflow: "auto",
    borderRadius: "0.3em"
  },
  'code[class*="language-"]::-moz-selection': {
    background: "hsl(220, 13%, 28%)",
    color: "inherit",
    textShadow: "none"
  },
  'code[class*="language-"] *::-moz-selection': {
    background: "hsl(220, 13%, 28%)",
    color: "inherit",
    textShadow: "none"
  },
  'pre[class*="language-"] *::-moz-selection': {
    background: "hsl(220, 13%, 28%)",
    color: "inherit",
    textShadow: "none"
  },
  'code[class*="language-"]::selection': {
    background: "hsl(220, 13%, 28%)",
    color: "inherit",
    textShadow: "none"
  },
  'code[class*="language-"] *::selection': {
    background: "hsl(220, 13%, 28%)",
    color: "inherit",
    textShadow: "none"
  },
  'pre[class*="language-"] *::selection': {
    background: "hsl(220, 13%, 28%)",
    color: "inherit",
    textShadow: "none"
  },
  ':not(pre) > code[class*="language-"]': {
    padding: "0.2em 0.3em",
    borderRadius: "0.3em",
    whiteSpace: "normal"
  },
  comment: {
    color: "hsl(220, 10%, 40%)",
    fontStyle: "italic"
  },
  prolog: {
    color: "hsl(220, 10%, 40%)"
  },
  cdata: {
    color: "hsl(220, 10%, 40%)"
  },
  doctype: {
    color: "hsl(220, 14%, 71%)"
  },
  punctuation: {
    color: "hsl(220, 14%, 71%)"
  },
  entity: {
    color: "hsl(220, 14%, 71%)",
    cursor: "help"
  },
  "attr-name": {
    color: "hsl(29, 54%, 61%)"
  },
  "class-name": {
    color: "hsl(29, 54%, 61%)"
  },
  boolean: {
    color: "hsl(29, 54%, 61%)"
  },
  constant: {
    color: "hsl(29, 54%, 61%)"
  },
  number: {
    color: "hsl(29, 54%, 61%)"
  },
  atrule: {
    color: "hsl(29, 54%, 61%)"
  },
  keyword: {
    color: "hsl(286, 60%, 67%)"
  },
  property: {
    color: "hsl(355, 65%, 65%)"
  },
  tag: {
    color: "hsl(355, 65%, 65%)"
  },
  symbol: {
    color: "hsl(355, 65%, 65%)"
  },
  deleted: {
    color: "hsl(355, 65%, 65%)"
  },
  important: {
    color: "hsl(355, 65%, 65%)"
  },
  selector: {
    color: "hsl(95, 38%, 62%)"
  },
  string: {
    color: "hsl(95, 38%, 62%)"
  },
  char: {
    color: "hsl(95, 38%, 62%)"
  },
  builtin: {
    color: "hsl(95, 38%, 62%)"
  },
  inserted: {
    color: "hsl(95, 38%, 62%)"
  },
  regex: {
    color: "hsl(95, 38%, 62%)"
  },
  "attr-value": {
    color: "hsl(95, 38%, 62%)"
  },
  "attr-value > .token.punctuation": {
    color: "hsl(95, 38%, 62%)"
  },
  variable: {
    color: "hsl(207, 82%, 66%)"
  },
  operator: {
    color: "hsl(207, 82%, 66%)"
  },
  function: {
    color: "hsl(207, 82%, 66%)"
  },
  url: {
    color: "hsl(187, 47%, 55%)"
  },
  "attr-value > .token.punctuation.attr-equals": {
    color: "hsl(220, 14%, 71%)"
  },
  "special-attr > .token.attr-value > .token.value.css": {
    color: "hsl(220, 14%, 71%)"
  },
  ".language-css .token.selector": {
    color: "hsl(355, 65%, 65%)"
  },
  ".language-css .token.property": {
    color: "hsl(220, 14%, 71%)"
  },
  ".language-css .token.function": {
    color: "hsl(187, 47%, 55%)"
  },
  ".language-css .token.url > .token.function": {
    color: "hsl(187, 47%, 55%)"
  },
  ".language-css .token.url > .token.string.url": {
    color: "hsl(95, 38%, 62%)"
  },
  ".language-css .token.important": {
    color: "hsl(286, 60%, 67%)"
  },
  ".language-css .token.atrule .token.rule": {
    color: "hsl(286, 60%, 67%)"
  },
  ".language-javascript .token.operator": {
    color: "hsl(286, 60%, 67%)"
  },
  ".language-javascript .token.template-string > .token.interpolation > .token.interpolation-punctuation.punctuation": {
    color: "hsl(5, 48%, 51%)"
  },
  ".language-json .token.operator": {
    color: "hsl(220, 14%, 71%)"
  },
  ".language-json .token.null.keyword": {
    color: "hsl(29, 54%, 61%)"
  },
  ".language-markdown .token.url": {
    color: "hsl(220, 14%, 71%)"
  },
  ".language-markdown .token.url > .token.operator": {
    color: "hsl(220, 14%, 71%)"
  },
  ".language-markdown .token.url-reference.url > .token.string": {
    color: "hsl(220, 14%, 71%)"
  },
  ".language-markdown .token.url > .token.content": {
    color: "hsl(207, 82%, 66%)"
  },
  ".language-markdown .token.url > .token.url": {
    color: "hsl(187, 47%, 55%)"
  },
  ".language-markdown .token.url-reference.url": {
    color: "hsl(187, 47%, 55%)"
  },
  ".language-markdown .token.blockquote.punctuation": {
    color: "hsl(220, 10%, 40%)",
    fontStyle: "italic"
  },
  ".language-markdown .token.hr.punctuation": {
    color: "hsl(220, 10%, 40%)",
    fontStyle: "italic"
  },
  ".language-markdown .token.code-snippet": {
    color: "hsl(95, 38%, 62%)"
  },
  ".language-markdown .token.bold .token.content": {
    color: "hsl(29, 54%, 61%)"
  },
  ".language-markdown .token.italic .token.content": {
    color: "hsl(286, 60%, 67%)"
  },
  ".language-markdown .token.strike .token.content": {
    color: "hsl(355, 65%, 65%)"
  },
  ".language-markdown .token.strike .token.punctuation": {
    color: "hsl(355, 65%, 65%)"
  },
  ".language-markdown .token.list.punctuation": {
    color: "hsl(355, 65%, 65%)"
  },
  ".language-markdown .token.title.important > .token.punctuation": {
    color: "hsl(355, 65%, 65%)"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  },
  namespace: {
    Opacity: "0.8"
  },
  "token.tab:not(:empty):before": {
    color: "hsla(220, 14%, 71%, 0.15)",
    textShadow: "none"
  },
  "token.cr:before": {
    color: "hsla(220, 14%, 71%, 0.15)",
    textShadow: "none"
  },
  "token.lf:before": {
    color: "hsla(220, 14%, 71%, 0.15)",
    textShadow: "none"
  },
  "token.space:before": {
    color: "hsla(220, 14%, 71%, 0.15)",
    textShadow: "none"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item": {
    marginRight: "0.4em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button": {
    background: "hsl(220, 13%, 26%)",
    color: "hsl(220, 9%, 55%)",
    padding: "0.1em 0.4em",
    borderRadius: "0.3em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a": {
    background: "hsl(220, 13%, 26%)",
    color: "hsl(220, 9%, 55%)",
    padding: "0.1em 0.4em",
    borderRadius: "0.3em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span": {
    background: "hsl(220, 13%, 26%)",
    color: "hsl(220, 9%, 55%)",
    padding: "0.1em 0.4em",
    borderRadius: "0.3em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button:hover": {
    background: "hsl(220, 13%, 28%)",
    color: "hsl(220, 14%, 71%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button:focus": {
    background: "hsl(220, 13%, 28%)",
    color: "hsl(220, 14%, 71%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a:hover": {
    background: "hsl(220, 13%, 28%)",
    color: "hsl(220, 14%, 71%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a:focus": {
    background: "hsl(220, 13%, 28%)",
    color: "hsl(220, 14%, 71%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span:hover": {
    background: "hsl(220, 13%, 28%)",
    color: "hsl(220, 14%, 71%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span:focus": {
    background: "hsl(220, 13%, 28%)",
    color: "hsl(220, 14%, 71%)"
  },
  ".line-highlight.line-highlight": {
    background: "hsla(220, 100%, 80%, 0.04)"
  },
  ".line-highlight.line-highlight:before": {
    background: "hsl(220, 13%, 26%)",
    color: "hsl(220, 14%, 71%)",
    padding: "0.1em 0.6em",
    borderRadius: "0.3em",
    boxShadow: "0 2px 0 0 rgba(0, 0, 0, 0.2)"
  },
  ".line-highlight.line-highlight[data-end]:after": {
    background: "hsl(220, 13%, 26%)",
    color: "hsl(220, 14%, 71%)",
    padding: "0.1em 0.6em",
    borderRadius: "0.3em",
    boxShadow: "0 2px 0 0 rgba(0, 0, 0, 0.2)"
  },
  "pre[id].linkable-line-numbers.linkable-line-numbers span.line-numbers-rows > span:hover:before": {
    backgroundColor: "hsla(220, 100%, 80%, 0.04)"
  },
  ".line-numbers.line-numbers .line-numbers-rows": {
    borderRightColor: "hsla(220, 14%, 71%, 0.15)"
  },
  ".command-line .command-line-prompt": {
    borderRightColor: "hsla(220, 14%, 71%, 0.15)"
  },
  ".line-numbers .line-numbers-rows > span:before": {
    color: "hsl(220, 14%, 45%)"
  },
  ".command-line .command-line-prompt > span:before": {
    color: "hsl(220, 14%, 45%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-1": {
    color: "hsl(355, 65%, 65%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-5": {
    color: "hsl(355, 65%, 65%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-9": {
    color: "hsl(355, 65%, 65%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-2": {
    color: "hsl(95, 38%, 62%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-6": {
    color: "hsl(95, 38%, 62%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-10": {
    color: "hsl(95, 38%, 62%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-3": {
    color: "hsl(207, 82%, 66%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-7": {
    color: "hsl(207, 82%, 66%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-11": {
    color: "hsl(207, 82%, 66%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-4": {
    color: "hsl(286, 60%, 67%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-8": {
    color: "hsl(286, 60%, 67%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-12": {
    color: "hsl(286, 60%, 67%)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix)": {
    backgroundColor: "hsla(353, 100%, 66%, 0.15)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix)": {
    backgroundColor: "hsla(353, 100%, 66%, 0.15)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix)::-moz-selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix) *::-moz-selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix)::-moz-selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix) *::-moz-selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix)::selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix) *::selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix)::selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix) *::selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix)": {
    backgroundColor: "hsla(137, 100%, 55%, 0.15)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix)": {
    backgroundColor: "hsla(137, 100%, 55%, 0.15)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix)::-moz-selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix) *::-moz-selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix)::-moz-selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix) *::-moz-selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix)::selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix) *::selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix)::selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix) *::selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  ".prism-previewer.prism-previewer:before": {
    borderColor: "hsl(224, 13%, 17%)"
  },
  ".prism-previewer-gradient.prism-previewer-gradient div": {
    borderColor: "hsl(224, 13%, 17%)",
    borderRadius: "0.3em"
  },
  ".prism-previewer-color.prism-previewer-color:before": {
    borderRadius: "0.3em"
  },
  ".prism-previewer-easing.prism-previewer-easing:before": {
    borderRadius: "0.3em"
  },
  ".prism-previewer.prism-previewer:after": {
    borderTopColor: "hsl(224, 13%, 17%)"
  },
  ".prism-previewer-flipped.prism-previewer-flipped.after": {
    borderBottomColor: "hsl(224, 13%, 17%)"
  },
  ".prism-previewer-angle.prism-previewer-angle:before": {
    background: "hsl(219, 13%, 22%)"
  },
  ".prism-previewer-time.prism-previewer-time:before": {
    background: "hsl(219, 13%, 22%)"
  },
  ".prism-previewer-easing.prism-previewer-easing": {
    background: "hsl(219, 13%, 22%)"
  },
  ".prism-previewer-angle.prism-previewer-angle circle": {
    stroke: "hsl(220, 14%, 71%)",
    strokeOpacity: "1"
  },
  ".prism-previewer-time.prism-previewer-time circle": {
    stroke: "hsl(220, 14%, 71%)",
    strokeOpacity: "1"
  },
  ".prism-previewer-easing.prism-previewer-easing circle": {
    stroke: "hsl(220, 14%, 71%)",
    fill: "transparent"
  },
  ".prism-previewer-easing.prism-previewer-easing path": {
    stroke: "hsl(220, 14%, 71%)"
  },
  ".prism-previewer-easing.prism-previewer-easing line": {
    stroke: "hsl(220, 14%, 71%)"
  }
}, oneLight = {
  'code[class*="language-"]': {
    background: "hsl(230, 1%, 98%)",
    color: "hsl(230, 8%, 24%)",
    fontFamily: '"Fira Code", "Fira Mono", Menlo, Consolas, "DejaVu Sans Mono", monospace',
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "2",
    OTabSize: "2",
    tabSize: "2",
    WebkitHyphens: "none",
    MozHyphens: "none",
    msHyphens: "none",
    hyphens: "none"
  },
  'pre[class*="language-"]': {
    background: "hsl(230, 1%, 98%)",
    color: "hsl(230, 8%, 24%)",
    fontFamily: '"Fira Code", "Fira Mono", Menlo, Consolas, "DejaVu Sans Mono", monospace',
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "2",
    OTabSize: "2",
    tabSize: "2",
    WebkitHyphens: "none",
    MozHyphens: "none",
    msHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: "0.5em 0",
    overflow: "auto",
    borderRadius: "0.3em"
  },
  'code[class*="language-"]::-moz-selection': {
    background: "hsl(230, 1%, 90%)",
    color: "inherit"
  },
  'code[class*="language-"] *::-moz-selection': {
    background: "hsl(230, 1%, 90%)",
    color: "inherit"
  },
  'pre[class*="language-"] *::-moz-selection': {
    background: "hsl(230, 1%, 90%)",
    color: "inherit"
  },
  'code[class*="language-"]::selection': {
    background: "hsl(230, 1%, 90%)",
    color: "inherit"
  },
  'code[class*="language-"] *::selection': {
    background: "hsl(230, 1%, 90%)",
    color: "inherit"
  },
  'pre[class*="language-"] *::selection': {
    background: "hsl(230, 1%, 90%)",
    color: "inherit"
  },
  ':not(pre) > code[class*="language-"]': {
    padding: "0.2em 0.3em",
    borderRadius: "0.3em",
    whiteSpace: "normal"
  },
  comment: {
    color: "hsl(230, 4%, 64%)",
    fontStyle: "italic"
  },
  prolog: {
    color: "hsl(230, 4%, 64%)"
  },
  cdata: {
    color: "hsl(230, 4%, 64%)"
  },
  doctype: {
    color: "hsl(230, 8%, 24%)"
  },
  punctuation: {
    color: "hsl(230, 8%, 24%)"
  },
  entity: {
    color: "hsl(230, 8%, 24%)",
    cursor: "help"
  },
  "attr-name": {
    color: "hsl(35, 99%, 36%)"
  },
  "class-name": {
    color: "hsl(35, 99%, 36%)"
  },
  boolean: {
    color: "hsl(35, 99%, 36%)"
  },
  constant: {
    color: "hsl(35, 99%, 36%)"
  },
  number: {
    color: "hsl(35, 99%, 36%)"
  },
  atrule: {
    color: "hsl(35, 99%, 36%)"
  },
  keyword: {
    color: "hsl(301, 63%, 40%)"
  },
  property: {
    color: "hsl(5, 74%, 59%)"
  },
  tag: {
    color: "hsl(5, 74%, 59%)"
  },
  symbol: {
    color: "hsl(5, 74%, 59%)"
  },
  deleted: {
    color: "hsl(5, 74%, 59%)"
  },
  important: {
    color: "hsl(5, 74%, 59%)"
  },
  selector: {
    color: "hsl(119, 34%, 47%)"
  },
  string: {
    color: "hsl(119, 34%, 47%)"
  },
  char: {
    color: "hsl(119, 34%, 47%)"
  },
  builtin: {
    color: "hsl(119, 34%, 47%)"
  },
  inserted: {
    color: "hsl(119, 34%, 47%)"
  },
  regex: {
    color: "hsl(119, 34%, 47%)"
  },
  "attr-value": {
    color: "hsl(119, 34%, 47%)"
  },
  "attr-value > .token.punctuation": {
    color: "hsl(119, 34%, 47%)"
  },
  variable: {
    color: "hsl(221, 87%, 60%)"
  },
  operator: {
    color: "hsl(221, 87%, 60%)"
  },
  function: {
    color: "hsl(221, 87%, 60%)"
  },
  url: {
    color: "hsl(198, 99%, 37%)"
  },
  "attr-value > .token.punctuation.attr-equals": {
    color: "hsl(230, 8%, 24%)"
  },
  "special-attr > .token.attr-value > .token.value.css": {
    color: "hsl(230, 8%, 24%)"
  },
  ".language-css .token.selector": {
    color: "hsl(5, 74%, 59%)"
  },
  ".language-css .token.property": {
    color: "hsl(230, 8%, 24%)"
  },
  ".language-css .token.function": {
    color: "hsl(198, 99%, 37%)"
  },
  ".language-css .token.url > .token.function": {
    color: "hsl(198, 99%, 37%)"
  },
  ".language-css .token.url > .token.string.url": {
    color: "hsl(119, 34%, 47%)"
  },
  ".language-css .token.important": {
    color: "hsl(301, 63%, 40%)"
  },
  ".language-css .token.atrule .token.rule": {
    color: "hsl(301, 63%, 40%)"
  },
  ".language-javascript .token.operator": {
    color: "hsl(301, 63%, 40%)"
  },
  ".language-javascript .token.template-string > .token.interpolation > .token.interpolation-punctuation.punctuation": {
    color: "hsl(344, 84%, 43%)"
  },
  ".language-json .token.operator": {
    color: "hsl(230, 8%, 24%)"
  },
  ".language-json .token.null.keyword": {
    color: "hsl(35, 99%, 36%)"
  },
  ".language-markdown .token.url": {
    color: "hsl(230, 8%, 24%)"
  },
  ".language-markdown .token.url > .token.operator": {
    color: "hsl(230, 8%, 24%)"
  },
  ".language-markdown .token.url-reference.url > .token.string": {
    color: "hsl(230, 8%, 24%)"
  },
  ".language-markdown .token.url > .token.content": {
    color: "hsl(221, 87%, 60%)"
  },
  ".language-markdown .token.url > .token.url": {
    color: "hsl(198, 99%, 37%)"
  },
  ".language-markdown .token.url-reference.url": {
    color: "hsl(198, 99%, 37%)"
  },
  ".language-markdown .token.blockquote.punctuation": {
    color: "hsl(230, 4%, 64%)",
    fontStyle: "italic"
  },
  ".language-markdown .token.hr.punctuation": {
    color: "hsl(230, 4%, 64%)",
    fontStyle: "italic"
  },
  ".language-markdown .token.code-snippet": {
    color: "hsl(119, 34%, 47%)"
  },
  ".language-markdown .token.bold .token.content": {
    color: "hsl(35, 99%, 36%)"
  },
  ".language-markdown .token.italic .token.content": {
    color: "hsl(301, 63%, 40%)"
  },
  ".language-markdown .token.strike .token.content": {
    color: "hsl(5, 74%, 59%)"
  },
  ".language-markdown .token.strike .token.punctuation": {
    color: "hsl(5, 74%, 59%)"
  },
  ".language-markdown .token.list.punctuation": {
    color: "hsl(5, 74%, 59%)"
  },
  ".language-markdown .token.title.important > .token.punctuation": {
    color: "hsl(5, 74%, 59%)"
  },
  bold: {
    fontWeight: "bold"
  },
  italic: {
    fontStyle: "italic"
  },
  namespace: {
    Opacity: "0.8"
  },
  "token.tab:not(:empty):before": {
    color: "hsla(230, 8%, 24%, 0.2)"
  },
  "token.cr:before": {
    color: "hsla(230, 8%, 24%, 0.2)"
  },
  "token.lf:before": {
    color: "hsla(230, 8%, 24%, 0.2)"
  },
  "token.space:before": {
    color: "hsla(230, 8%, 24%, 0.2)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item": {
    marginRight: "0.4em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button": {
    background: "hsl(230, 1%, 90%)",
    color: "hsl(230, 6%, 44%)",
    padding: "0.1em 0.4em",
    borderRadius: "0.3em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a": {
    background: "hsl(230, 1%, 90%)",
    color: "hsl(230, 6%, 44%)",
    padding: "0.1em 0.4em",
    borderRadius: "0.3em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span": {
    background: "hsl(230, 1%, 90%)",
    color: "hsl(230, 6%, 44%)",
    padding: "0.1em 0.4em",
    borderRadius: "0.3em"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button:hover": {
    background: "hsl(230, 1%, 78%)",
    color: "hsl(230, 8%, 24%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > button:focus": {
    background: "hsl(230, 1%, 78%)",
    color: "hsl(230, 8%, 24%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a:hover": {
    background: "hsl(230, 1%, 78%)",
    color: "hsl(230, 8%, 24%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > a:focus": {
    background: "hsl(230, 1%, 78%)",
    color: "hsl(230, 8%, 24%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span:hover": {
    background: "hsl(230, 1%, 78%)",
    color: "hsl(230, 8%, 24%)"
  },
  "div.code-toolbar > .toolbar.toolbar > .toolbar-item > span:focus": {
    background: "hsl(230, 1%, 78%)",
    color: "hsl(230, 8%, 24%)"
  },
  ".line-highlight.line-highlight": {
    background: "hsla(230, 8%, 24%, 0.05)"
  },
  ".line-highlight.line-highlight:before": {
    background: "hsl(230, 1%, 90%)",
    color: "hsl(230, 8%, 24%)",
    padding: "0.1em 0.6em",
    borderRadius: "0.3em",
    boxShadow: "0 2px 0 0 rgba(0, 0, 0, 0.2)"
  },
  ".line-highlight.line-highlight[data-end]:after": {
    background: "hsl(230, 1%, 90%)",
    color: "hsl(230, 8%, 24%)",
    padding: "0.1em 0.6em",
    borderRadius: "0.3em",
    boxShadow: "0 2px 0 0 rgba(0, 0, 0, 0.2)"
  },
  "pre[id].linkable-line-numbers.linkable-line-numbers span.line-numbers-rows > span:hover:before": {
    backgroundColor: "hsla(230, 8%, 24%, 0.05)"
  },
  ".line-numbers.line-numbers .line-numbers-rows": {
    borderRightColor: "hsla(230, 8%, 24%, 0.2)"
  },
  ".command-line .command-line-prompt": {
    borderRightColor: "hsla(230, 8%, 24%, 0.2)"
  },
  ".line-numbers .line-numbers-rows > span:before": {
    color: "hsl(230, 1%, 62%)"
  },
  ".command-line .command-line-prompt > span:before": {
    color: "hsl(230, 1%, 62%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-1": {
    color: "hsl(5, 74%, 59%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-5": {
    color: "hsl(5, 74%, 59%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-9": {
    color: "hsl(5, 74%, 59%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-2": {
    color: "hsl(119, 34%, 47%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-6": {
    color: "hsl(119, 34%, 47%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-10": {
    color: "hsl(119, 34%, 47%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-3": {
    color: "hsl(221, 87%, 60%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-7": {
    color: "hsl(221, 87%, 60%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-11": {
    color: "hsl(221, 87%, 60%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-4": {
    color: "hsl(301, 63%, 40%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-8": {
    color: "hsl(301, 63%, 40%)"
  },
  ".rainbow-braces .token.token.punctuation.brace-level-12": {
    color: "hsl(301, 63%, 40%)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix)": {
    backgroundColor: "hsla(353, 100%, 66%, 0.15)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix)": {
    backgroundColor: "hsla(353, 100%, 66%, 0.15)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix)::-moz-selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix) *::-moz-selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix)::-moz-selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix) *::-moz-selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix)::selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.deleted:not(.prefix) *::selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix)::selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.deleted:not(.prefix) *::selection": {
    backgroundColor: "hsla(353, 95%, 66%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix)": {
    backgroundColor: "hsla(137, 100%, 55%, 0.15)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix)": {
    backgroundColor: "hsla(137, 100%, 55%, 0.15)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix)::-moz-selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix) *::-moz-selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix)::-moz-selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix) *::-moz-selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix)::selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre.diff-highlight > code .token.token.inserted:not(.prefix) *::selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix)::selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  "pre > code.diff-highlight .token.token.inserted:not(.prefix) *::selection": {
    backgroundColor: "hsla(135, 73%, 55%, 0.25)"
  },
  ".prism-previewer.prism-previewer:before": {
    borderColor: "hsl(0, 0, 95%)"
  },
  ".prism-previewer-gradient.prism-previewer-gradient div": {
    borderColor: "hsl(0, 0, 95%)",
    borderRadius: "0.3em"
  },
  ".prism-previewer-color.prism-previewer-color:before": {
    borderRadius: "0.3em"
  },
  ".prism-previewer-easing.prism-previewer-easing:before": {
    borderRadius: "0.3em"
  },
  ".prism-previewer.prism-previewer:after": {
    borderTopColor: "hsl(0, 0, 95%)"
  },
  ".prism-previewer-flipped.prism-previewer-flipped.after": {
    borderBottomColor: "hsl(0, 0, 95%)"
  },
  ".prism-previewer-angle.prism-previewer-angle:before": {
    background: "hsl(0, 0%, 100%)"
  },
  ".prism-previewer-time.prism-previewer-time:before": {
    background: "hsl(0, 0%, 100%)"
  },
  ".prism-previewer-easing.prism-previewer-easing": {
    background: "hsl(0, 0%, 100%)"
  },
  ".prism-previewer-angle.prism-previewer-angle circle": {
    stroke: "hsl(230, 8%, 24%)",
    strokeOpacity: "1"
  },
  ".prism-previewer-time.prism-previewer-time circle": {
    stroke: "hsl(230, 8%, 24%)",
    strokeOpacity: "1"
  },
  ".prism-previewer-easing.prism-previewer-easing circle": {
    stroke: "hsl(230, 8%, 24%)",
    fill: "transparent"
  },
  ".prism-previewer-easing.prism-previewer-easing path": {
    stroke: "hsl(230, 8%, 24%)"
  },
  ".prism-previewer-easing.prism-previewer-easing line": {
    stroke: "hsl(230, 8%, 24%)"
  }
}, MarkdownContext = React.createContext({
  text: "",
  theme: "light",
  locale: "en-US",
  on_custom: () => {
  },
  custom_components: {}
}), useMarkdownContext = () => React.useContext(MarkdownContext), CopyButton = ({
  value: e
}) => {
  const [t, r] = useState(!1), a = async () => {
    const o = () => {
      r(!0), setTimeout(() => {
        r(!1);
      }, 2e3);
    };
    if ("clipboard" in navigator)
      await navigator.clipboard.writeText(e), o();
    else {
      const u = document.createElement("textarea");
      u.value = e, u.style.position = "absolute", u.style.left = "-999999px", document.body.prepend(u), u.select();
      try {
        document.execCommand("copy"), o();
      } catch (c) {
        console.error(c);
      } finally {
        u.remove();
      }
    }
  };
  return t ? /* @__PURE__ */ jsxRuntimeExports.jsx(CheckOutlined, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(CopyOutlined, {
    onClick: a
  });
}, Code = ({
  children: e,
  className: t,
  ...r
}) => {
  const {
    theme: a
  } = useMarkdownContext(), o = /language-(\w+)/.exec(t || ""), u = o && o[1] ? o[1].toLowerCase() : "", c = React.Children.toArray(e), d = c.length === 1 && typeof c[0] == "string";
  if (r.inline || !d)
    return /* @__PURE__ */ jsxRuntimeExports.jsx("code", {
      className: t,
      ...r,
      children: e
    });
  const g = String(e).replace(/\n$/, "");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
    className: cls("ms-markdown-code", a === "dark" && "ms-markdown-code-dark"),
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
      className: "ms-markdown-code-header",
      style: {
        borderTopLeftRadius: "0.3em",
        borderTopRightRadius: "0.3em"
      },
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: "ms-markdown-code-header-lang",
        children: u || "code"
      }), /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: "ms-markdown-code-header-copy",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(CopyButton, {
          value: g
        })
      })]
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(highlighter, {
      customStyle: {
        borderRadius: 0,
        borderBottomLeftRadius: "0.3em",
        borderBottomRightRadius: "0.3em",
        width: "100%",
        marginTop: 0,
        overflow: "auto"
      },
      language: u,
      showLineNumbers: !1,
      PreTag: "div",
      style: a === "dark" ? oneDark : oneLight,
      children: g
    })]
  });
};
function useCustomProps(e) {
  const {
    text: t
  } = useMarkdownContext(), r = useMemo(() => {
    var u, c, d;
    const a = e.node, o = t == null ? void 0 : t.slice(0, (c = (u = a == null ? void 0 : a.position) == null ? void 0 : u.start) == null ? void 0 : c.offset).match(new RegExp(`<${a == null ? void 0 : a.tagName}`, "g"));
    return {
      tagIndex: (o == null ? void 0 : o.length) || 0,
      tagEnd: typeof t[((d = a == null ? void 0 : a.position) == null ? void 0 : d.end.offset) || 0] == "string" || t.endsWith(`</${a == null ? void 0 : a.tagName}>`)
    };
  }, [e.node, t]);
  return [getCustomProps(e), r];
}
const AccordionTitle = ({
  children: e,
  onClick: t
}) => {
  const r = React.Children.count(e), a = typeof React.Children.toArray(e)[r - 1] == "string";
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
    onClick: t,
    className: cls("ms-markdown-accordion-title", a && "ms-markdown-accordion-title-typing-string"),
    children: e
  });
}, AccordionBody = ({
  children: e
}) => {
  const t = React.Children.count(e), r = typeof React.Children.toArray(e)[t - 1] == "string";
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
    className: cls("ms-markdown-accordion-body", r && "ms-markdown-accordion-body-typing-string"),
    children: e
  });
}, Accordion = (e) => {
  var R;
  const {
    flushing: t,
    end: r,
    last_flushing_end_index: a
  } = useMarkdownContext(), [{
    children: o,
    title: u,
    node: c
  }, {
    tagEnd: d
  }] = useCustomProps(e), g = typeof r == "boolean" ? (a || 0) > (((R = c.position) == null ? void 0 : R.end.offset) || 0) || r : !0, b = t ? d : !0, _ = b && g, [y, A] = useState(!_);
  let E = null;
  const v = [];
  React.Children.forEach(o, (I) => {
    var w, N;
    if (React.isValidElement(I) && ((N = (w = I.props) == null ? void 0 : w.node) == null ? void 0 : N.tagName) === "accordion-title") {
      E = I;
      return;
    }
    v.push(I);
  });
  const C = /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionBody, {
    children: v
  });
  return useEffect(() => {
    A(!_);
  }, [_]), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
    className: cls("ms-markdown-accordion", !b && "ms-markdown-accordion-typing"),
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collapse, {
      onChange: () => {
        A(!y);
      },
      activeKey: y ? ["default"] : [],
      expandIcon: ({
        isActive: I
      }) => /* @__PURE__ */ jsxRuntimeExports.jsx(CaretRightOutlined, {
        rotate: I ? 90 : 0
      }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collapse.Panel, {
        header: E || u,
        children: C
      }, "default")
    })
  });
}, langs$1 = {
  "en-US": "en",
  "zh-CN": "zh"
};
let echarts;
const Chart = (e) => {
  const {
    options: t = "",
    style: r,
    className: a
  } = e, {
    theme: o,
    locale: u
  } = useMarkdownContext(), [c, d] = useState(echarts), g = useRef(null), b = useMemo(() => safeParseJSON(t, {}), [t]);
  return useEffect(() => {
    if (!echarts) {
      import("./index-CpiCr89N.js").then((v) => {
        echarts = v, d(echarts);
      });
      return;
    }
    const _ = g.current;
    if (!_ || !c)
      return;
    const y = c.init(_, o, {
      locale: langs$1[u] || "en"
    });
    y.setOption(b, !0);
    let A;
    const E = new ResizeObserver((v) => {
      v[0] && (A && clearTimeout(A), A = setTimeout(() => {
        y.resize();
      }, 500));
    });
    return E.observe(_), () => {
      y.dispose(), E.disconnect();
    };
  }, [c, u, b, o]), /* @__PURE__ */ jsxRuntimeExports.jsx(Spin, {
    spinning: !c,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      style: r,
      className: cls("ms-markdown-chart", a),
      ref: g
    })
  });
}, File = (e) => {
  const [{
    title: t = "",
    src: r,
    children: a = [],
    viewable: o,
    type: u,
    ...c
  }] = useCustomProps(e), d = typeof o == "string";
  let g = r || a[0];
  if (React.isValidElement(g) && g.props.node.tagName === "a" && (g = g.props.href), typeof g != "string")
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
      children: g
    });
  let b = /* @__PURE__ */ jsxRuntimeExports.jsx(FileOutlined, {}), _ = null;
  if (d) {
    const y = (A) => (Array.isArray(A) ? A : [A]).some((E) => t && t.endsWith(`.${E}`) || !t && getURLFileExtension(g) === E);
    u === "pdf" || y("pdf") ? (b = /* @__PURE__ */ jsxRuntimeExports.jsx(FilePdfOutlined, {}), _ = /* @__PURE__ */ jsxRuntimeExports.jsx(FileView, {
      ...c,
      type: "pdf",
      url: g
    })) : (u === "image" || y(["png", "jpg", "jpeg", "webp", "gif"])) && (b = /* @__PURE__ */ jsxRuntimeExports.jsx(FileImageOutlined, {}), _ = /* @__PURE__ */ jsxRuntimeExports.jsx(FileView, {
      ...c,
      type: "image",
      url: g,
      alt: t
    }));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(FileView, {
      type: "link",
      filename: t || g,
      url: g,
      icon: b
    }), _]
  });
}, FlushingEnd = () => null, custom_tag = "select-box", SelectBox = (e) => {
  const [{
    direction: t,
    shape: r = "default",
    type: a = "radio",
    "img-height": o = "160px",
    "item-height": u,
    "item-width": c,
    "submit-text": d,
    "select-once": g,
    "equal-height": b,
    columns: _,
    ...y
  }, {
    tagIndex: A
  }] = useCustomProps(e), E = typeof g == "string", v = typeof b == "string", {
    on_custom: C,
    preview: R,
    disabled: I
  } = useMarkdownContext(), w = useMemo(() => {
    if (t !== "vertical" && _) {
      if (!Number.isNaN(Number(_)))
        return {
          span: Math.round(24 / Number(_))
        };
      const B = safeParseJSON(_ || "", {}), V = Object.keys(B).reduce((X, de) => (["xs", "sm", "md", "lg", "xl", "xxl"].includes(de) && (X[de] = Math.round(24 / Number(B[de]))), X), {});
      if (Object.keys(V).length)
        return V;
    }
    return c ? {
      span: t === "vertical" ? 24 : void 0
    } : {
      xs: 24,
      sm: t === "vertical" ? 24 : 12,
      md: t === "vertical" ? 24 : 12,
      lg: t === "vertical" ? 24 : 6
    };
  }, [_, t, c]), N = useMemo(() => a === "radio" ? y.value : safeParseJSON(y.value || "", []), [y.value, a]), [F, M] = useState(I || !!y.disabled);
  useEffect(() => {
    M(I || !!y.disabled);
  }, [I, y.disabled]);
  const x = useMemo(() => safeParseJSON(y.options || "", []).map((B) => isObject(B) ? B : {
    value: B,
    label: B
  }), [y.options]), [P, U] = useState(N);
  useEffect(() => {
    U(N);
  }, [N]);
  let L = null;
  const H = (B) => {
    C(custom_tag, A, B);
  };
  return r === "card" ? L = /* @__PURE__ */ jsxRuntimeExports.jsx(Row, {
    gutter: [8, 8],
    children: x.map((B, V) => {
      const X = B.label || B.value, de = a === "checkbox" ? P == null ? void 0 : P.includes(B.value) : B.value === P;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Col, {
        ...w,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, {
          style: {
            width: c,
            height: u
          },
          onClick: () => {
            if (F)
              return;
            let Y = B.value;
            a === "checkbox" && Array.isArray(P) && (P.includes(B.value) ? Y = P.filter((se) => se !== B.value) : Y = [...P, B.value]), U(Y), E && !d && (H(Y), M(!0));
          },
          className: cls("ms-markdown-select-box-card", v && "ms-markdown-select-box-card-equal-height", de && "ms-markdown-select-box-card-selected", F && "ms-markdown-select-box-card-disabled"),
          size: "small",
          cover: B.imgSrc ? /* @__PURE__ */ jsxRuntimeExports.jsx(FileView, {
            style: {
              maxWidth: "100%",
              maxHeight: o,
              height: o
            },
            preview: R,
            type: "image",
            url: B.imgSrc,
            alt: `${X}`
          }) : null,
          children: X
        })
      }, V);
    })
  }) : a === "radio" ? L = /* @__PURE__ */ jsxRuntimeExports.jsx(Radio.Group, {
    disabled: F,
    onChange: (B) => {
      U(B.target.value), E && !d && (H(B.target.value), M(!0));
    },
    value: P,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Space, {
      direction: t,
      wrap: !0,
      children: x.map((B, V) => /* @__PURE__ */ jsxRuntimeExports.jsx(Radio, {
        value: B.value,
        children: B.label || B.value
      }, V))
    })
  }) : a === "checkbox" && (L = /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox.Group, {
    disabled: F,
    value: P,
    onChange: (B) => {
      U(B), E && !d && (H(B), M(!0));
    },
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Space, {
      direction: t,
      wrap: !0,
      children: x.map((B, V) => /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, {
        value: B.value,
        children: B.label || B.value
      }, V))
    })
  })), /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [L, d && !F && /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      className: "ms-markdown-select-box-submit-btn",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, {
        type: "primary",
        onClick: () => {
          P && (H(P), E && M(!0));
        },
        children: d
      })
    })]
  });
}, CustomComponent = (e) => {
  const [{
    node: t,
    ...r
  }, {
    tagIndex: a,
    tagEnd: o
  }] = useCustomProps(e), u = useRef(null), c = t.tagName, {
    on_custom: d,
    custom_components: g,
    theme: b,
    locale: _
  } = useMarkdownContext(), y = (E) => {
    d(c, a, E);
  }, A = useMemo(() => ({
    children: t.children
  }), [t.children]);
  return useCustomComponent({
    target: u,
    component: g[c],
    componentProps: r,
    extraProps: A,
    onCustom: y,
    theme: b,
    locale: _,
    onBeforeRender: () => o
  }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
    ref: u
  });
}, regex = /[\0-\x1F!-,\.\/:-@\[-\^`\{-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0378\u0379\u037E\u0380-\u0385\u0387\u038B\u038D\u03A2\u03F6\u0482\u0530\u0557\u0558\u055A-\u055F\u0589-\u0590\u05BE\u05C0\u05C3\u05C6\u05C8-\u05CF\u05EB-\u05EE\u05F3-\u060F\u061B-\u061F\u066A-\u066D\u06D4\u06DD\u06DE\u06E9\u06FD\u06FE\u0700-\u070F\u074B\u074C\u07B2-\u07BF\u07F6-\u07F9\u07FB\u07FC\u07FE\u07FF\u082E-\u083F\u085C-\u085F\u086B-\u089F\u08B5\u08C8-\u08D2\u08E2\u0964\u0965\u0970\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09F2-\u09FB\u09FD\u09FF\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF0-\u0AF8\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B54\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B70\u0B72-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BF0-\u0BFF\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C7F\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0CFF\u0D0D\u0D11\u0D45\u0D49\u0D4F-\u0D53\u0D58-\u0D5E\u0D64\u0D65\u0D70-\u0D79\u0D80\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF4-\u0E00\u0E3B-\u0E3F\u0E4F\u0E5A-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F01-\u0F17\u0F1A-\u0F1F\u0F2A-\u0F34\u0F36\u0F38\u0F3A-\u0F3D\u0F48\u0F6D-\u0F70\u0F85\u0F98\u0FBD-\u0FC5\u0FC7-\u0FFF\u104A-\u104F\u109E\u109F\u10C6\u10C8-\u10CC\u10CE\u10CF\u10FB\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u1360-\u137F\u1390-\u139F\u13F6\u13F7\u13FE-\u1400\u166D\u166E\u1680\u169B-\u169F\u16EB-\u16ED\u16F9-\u16FF\u170D\u1715-\u171F\u1735-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17D4-\u17D6\u17D8-\u17DB\u17DE\u17DF\u17EA-\u180A\u180E\u180F\u181A-\u181F\u1879-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u1945\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DA-\u19FF\u1A1C-\u1A1F\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1AA6\u1AA8-\u1AAF\u1AC1-\u1AFF\u1B4C-\u1B4F\u1B5A-\u1B6A\u1B74-\u1B7F\u1BF4-\u1BFF\u1C38-\u1C3F\u1C4A-\u1C4C\u1C7E\u1C7F\u1C89-\u1C8F\u1CBB\u1CBC\u1CC0-\u1CCF\u1CD3\u1CFB-\u1CFF\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FBD\u1FBF-\u1FC1\u1FC5\u1FCD-\u1FCF\u1FD4\u1FD5\u1FDC-\u1FDF\u1FED-\u1FF1\u1FF5\u1FFD-\u203E\u2041-\u2053\u2055-\u2070\u2072-\u207E\u2080-\u208F\u209D-\u20CF\u20F1-\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F-\u215F\u2189-\u24B5\u24EA-\u2BFF\u2C2F\u2C5F\u2CE5-\u2CEA\u2CF4-\u2CFF\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D70-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E00-\u2E2E\u2E30-\u3004\u3008-\u3020\u3030\u3036\u3037\u303D-\u3040\u3097\u3098\u309B\u309C\u30A0\u30FB\u3100-\u3104\u3130\u318F-\u319F\u31C0-\u31EF\u3200-\u33FF\u4DC0-\u4DFF\u9FFD-\u9FFF\uA48D-\uA4CF\uA4FE\uA4FF\uA60D-\uA60F\uA62C-\uA63F\uA673\uA67E\uA6F2-\uA716\uA720\uA721\uA789\uA78A\uA7C0\uA7C1\uA7CB-\uA7F4\uA828-\uA82B\uA82D-\uA83F\uA874-\uA87F\uA8C6-\uA8CF\uA8DA-\uA8DF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA954-\uA95F\uA97D-\uA97F\uA9C1-\uA9CE\uA9DA-\uA9DF\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A-\uAA5F\uAA77-\uAA79\uAAC3-\uAADA\uAADE\uAADF\uAAF0\uAAF1\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB5B\uAB6A-\uAB6F\uABEB\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uE000-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB29\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBB2-\uFBD2\uFD3E-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFC-\uFDFF\uFE10-\uFE1F\uFE30-\uFE32\uFE35-\uFE4C\uFE50-\uFE6F\uFE75\uFEFD-\uFF0F\uFF1A-\uFF20\uFF3B-\uFF3E\uFF40\uFF5B-\uFF65\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDD3F\uDD75-\uDDFC\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEE1-\uDEFF\uDF20-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDF9F\uDFC4-\uDFC7\uDFD0\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56-\uDC5F\uDC77-\uDC7F\uDC9F-\uDCDF\uDCF3\uDCF6-\uDCFF\uDD16-\uDD1F\uDD3A-\uDD7F\uDDB8-\uDDBD\uDDC0-\uDDFF\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE40-\uDE5F\uDE7D-\uDE7F\uDE9D-\uDEBF\uDEC8\uDEE7-\uDEFF\uDF36-\uDF3F\uDF56-\uDF5F\uDF73-\uDF7F\uDF92-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCFF\uDD28-\uDD2F\uDD3A-\uDE7F\uDEAA\uDEAD-\uDEAF\uDEB2-\uDEFF\uDF1D-\uDF26\uDF28-\uDF2F\uDF51-\uDFAF\uDFC5-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC47-\uDC65\uDC70-\uDC7E\uDCBB-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD40-\uDD43\uDD48-\uDD4F\uDD74\uDD75\uDD77-\uDD7F\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDFF\uDE12\uDE38-\uDE3D\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEA9-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC4B-\uDC4F\uDC5A-\uDC5D\uDC62-\uDC7F\uDCC6\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDC1-\uDDD7\uDDDE-\uDDFF\uDE41-\uDE43\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB9-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF3A-\uDFFF]|\uD806[\uDC3B-\uDC9F\uDCEA-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD44-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE2\uDDE5-\uDDFF\uDE3F-\uDE46\uDE48-\uDE4F\uDE9A-\uDE9C\uDE9E-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC41-\uDC4F\uDC5A-\uDC71\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF7-\uDFAF\uDFB1-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD824-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83D\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDECF\uDEEE\uDEEF\uDEF5-\uDEFF\uDF37-\uDF3F\uDF44-\uDF4F\uDF5A-\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE80-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE2\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82C[\uDD1F-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A-\uDC9C\uDC9F-\uDFFF]|\uD834[\uDC00-\uDD64\uDD6A-\uDD6C\uDD73-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDE41\uDE45-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3\uDFCC\uDFCD]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD4F-\uDEBF\uDEFA-\uDFFF]|\uD83A[\uDCC5-\uDCCF\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDFFF]|\uD83C[\uDC00-\uDD2F\uDD4A-\uDD4F\uDD6A-\uDD6F\uDD8A-\uDFFF]|\uD83E[\uDC00-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEDE-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]/g, own$2 = Object.hasOwnProperty;
class BananaSlug {
  /**
   * Create a new slug class.
   */
  constructor() {
    this.occurrences, this.reset();
  }
  /**
   * Generate a unique slug.
  *
  * Tracks previously generated slugs: repeated calls with the same value
  * will result in different slugs.
  * Use the `slug` function to get same slugs.
   *
   * @param  {string} value
   *   String of text to slugify
   * @param  {boolean} [maintainCase=false]
   *   Keep the current case, otherwise make all lowercase
   * @return {string}
   *   A unique slug string
   */
  slug(t, r) {
    const a = this;
    let o = slug(t, r === !0);
    const u = o;
    for (; own$2.call(a.occurrences, o); )
      a.occurrences[u]++, o = u + "-" + a.occurrences[u];
    return a.occurrences[o] = 0, o;
  }
  /**
   * Reset - Forget all previous slugs
   *
   * @return void
   */
  reset() {
    this.occurrences = /* @__PURE__ */ Object.create(null);
  }
}
function slug(e, t) {
  return typeof e != "string" ? "" : (t || (e = e.toLowerCase()), e.replace(regex, "").replace(/ /g, "-"));
}
const LINK_ICON_CODE = '<svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true" fill="currentColor"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>', slugger = new BananaSlug(), Heading = ({
  children: e,
  node: t,
  ...r
}) => {
  const {
    header_links: a,
    text: o
  } = useMarkdownContext(), u = useMemo(() => {
    var c, d;
    if (!a)
      return "";
    if (t) {
      if (t.children[0].type === "text")
        return "h-" + slugger.slug(t.children[0].value);
      const g = o.slice((c = t.position) == null ? void 0 : c.start.offset, (d = t.position) == null ? void 0 : d.end.offset);
      return "h-" + slugger.slug(g.replace(/^#*/gi, "").replace(/<[!/a-z].*?>/gi, "").trim());
    }
    return "h-" + slugger.slug(String(e));
  }, [e, a, t, o]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: React.createElement((t == null ? void 0 : t.tagName) || "h1", {
      ...r,
      className: cls(r.className, "ms-markdown-heading")
    }, /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [a ? /* @__PURE__ */ jsxRuntimeExports.jsx("a", {
        className: "ms-markdown-heading-anchor",
        id: u,
        href: `#${u}`,
        dangerouslySetInnerHTML: {
          __html: LINK_ICON_CODE
        }
      }) : null, e]
    }))
  });
}, Image$1 = (e) => {
  const {
    preview: t
  } = useMarkdownContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FileView, {
    type: "image",
    ...e,
    url: e.src,
    preview: t
  });
}, Video = (e) => /* @__PURE__ */ jsxRuntimeExports.jsx(FileView, {
  type: "video",
  ...e,
  url: e.src
});
function rehypeInlineCodeProperty() {
  return function(e) {
    visit(e, function(t, r, a) {
      t.tagName === "code" && (a && a.tagName === "pre" ? t.properties.inline = !1 : t.properties.inline = !0);
    });
  };
}
const aria = ["ariaDescribedBy", "ariaLabel", "ariaLabelledBy"], defaultSchema = {
  ancestors: {
    tbody: ["table"],
    td: ["table"],
    th: ["table"],
    thead: ["table"],
    tfoot: ["table"],
    tr: ["table"]
  },
  attributes: {
    a: [
      ...aria,
      // Note: these 3 are used by GFM footnotes, they do work on all links.
      "dataFootnoteBackref",
      "dataFootnoteRef",
      ["className", "data-footnote-backref"],
      "href"
    ],
    blockquote: ["cite"],
    // Note: this class is not normally allowed by GH, when manually writing
    // `code` as HTML in markdown, they adds it some other way.
    // We cant do that, so we have to allow it.
    code: [["className", /^language-./]],
    del: ["cite"],
    div: ["itemScope", "itemType"],
    dl: [...aria],
    // Note: this is used by GFM footnotes.
    h2: [["className", "sr-only"]],
    img: [...aria, "longDesc", "src"],
    // Note: `input` is not normally allowed by GH, when manually writing
    // it in markdown, they add it from tasklists some other way.
    // We cant do that, so we have to allow it.
    input: [["disabled", !0], ["type", "checkbox"]],
    ins: ["cite"],
    // Note: this class is not normally allowed by GH, when manually writing
    // `li` as HTML in markdown, they adds it some other way.
    // We cant do that, so we have to allow it.
    li: [["className", "task-list-item"]],
    // Note: this class is not normally allowed by GH, when manually writing
    // `ol` as HTML in markdown, they adds it some other way.
    // We cant do that, so we have to allow it.
    ol: [...aria, ["className", "contains-task-list"]],
    q: ["cite"],
    section: ["dataFootnotes", ["className", "footnotes"]],
    source: ["srcSet"],
    summary: [...aria],
    table: [...aria],
    // Note: this class is not normally allowed by GH, when manually writing
    // `ol` as HTML in markdown, they adds it some other way.
    // We cant do that, so we have to allow it.
    ul: [...aria, ["className", "contains-task-list"]],
    "*": [
      "abbr",
      "accept",
      "acceptCharset",
      "accessKey",
      "action",
      "align",
      "alt",
      "axis",
      "border",
      "cellPadding",
      "cellSpacing",
      "char",
      "charOff",
      "charSet",
      "checked",
      "clear",
      "colSpan",
      "color",
      "cols",
      "compact",
      "coords",
      "dateTime",
      "dir",
      // Note: `disabled` is technically allowed on all elements by GH.
      // But it is useless on everything except `input`.
      // Because `input`s are normally not allowed, but we allow them for
      // checkboxes due to tasklists, we allow `disabled` only there.
      "encType",
      "frame",
      "hSpace",
      "headers",
      "height",
      "hrefLang",
      "htmlFor",
      "id",
      "isMap",
      "itemProp",
      "label",
      "lang",
      "maxLength",
      "media",
      "method",
      "multiple",
      "name",
      "noHref",
      "noShade",
      "noWrap",
      "open",
      "prompt",
      "readOnly",
      "rev",
      "rowSpan",
      "rows",
      "rules",
      "scope",
      "selected",
      "shape",
      "size",
      "span",
      "start",
      "summary",
      "tabIndex",
      "title",
      "useMap",
      "vAlign",
      "value",
      "width"
    ]
  },
  clobber: ["ariaDescribedBy", "ariaLabelledBy", "id", "name"],
  clobberPrefix: "user-content-",
  protocols: {
    cite: ["http", "https"],
    href: ["http", "https", "irc", "ircs", "mailto", "xmpp"],
    longDesc: ["http", "https"],
    src: ["http", "https"]
  },
  required: {
    input: {
      disabled: !0,
      type: "checkbox"
    }
  },
  strip: ["script"],
  tagNames: [
    "a",
    "b",
    "blockquote",
    "br",
    "code",
    "dd",
    "del",
    "details",
    "div",
    "dl",
    "dt",
    "em",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hr",
    "i",
    "img",
    // Note: `input` is not normally allowed by GH, when manually writing
    // it in markdown, they add it from tasklists some other way.
    // We cant do that, so we have to allow it.
    "input",
    "ins",
    "kbd",
    "li",
    "ol",
    "p",
    "picture",
    "pre",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "section",
    "source",
    "span",
    "strike",
    "strong",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "tr",
    "tt",
    "ul",
    "var"
  ]
}, own$1 = {}.hasOwnProperty;
function sanitize(e, t) {
  let r = {
    type: "root",
    children: []
  };
  const a = {
    schema: t ? {
      ...defaultSchema,
      ...t
    } : defaultSchema,
    stack: []
  }, o = transform(a, e);
  return o && (Array.isArray(o) ? o.length === 1 ? r = o[0] : r.children = o : r = o), r;
}
function transform(e, t) {
  if (t && typeof t == "object") {
    const r = (
      /** @type {Record<string, Readonly<unknown>>} */
      t
    );
    switch (typeof r.type == "string" ? r.type : "") {
      case "comment":
        return comment(e, r);
      case "doctype":
        return doctype(e, r);
      case "element":
        return element$6(e, r);
      case "root":
        return root(e, r);
      case "text":
        return text$1(e, r);
      default:
        return r;
    }
  }
}
function comment(e, t) {
  if (e.schema.allowComments) {
    const r = typeof t.value == "string" ? t.value : "", a = r.indexOf("-->"), u = {
      type: "comment",
      value: a < 0 ? r : r.slice(0, a)
    };
    return patch(u, t), u;
  }
}
function doctype(e, t) {
  if (e.schema.allowDoctypes) {
    const r = {
      type: "doctype"
    };
    return patch(r, t), r;
  }
}
function element$6(e, t) {
  const r = typeof t.tagName == "string" ? t.tagName : "";
  e.stack.push(r);
  const a = (
    /** @type {Array<ElementContent>} */
    children$5(e, t.children)
  ), o = properties(e, t.properties);
  e.stack.pop();
  let u = !1;
  if (r && r !== "*" && (!e.schema.tagNames || e.schema.tagNames.includes(r)) && (u = !0, e.schema.ancestors && own$1.call(e.schema.ancestors, r))) {
    const d = e.schema.ancestors[r];
    let g = -1;
    for (u = !1; ++g < d.length; )
      e.stack.includes(d[g]) && (u = !0);
  }
  if (!u)
    return e.schema.strip && !e.schema.strip.includes(r) ? a : void 0;
  const c = {
    type: "element",
    tagName: r,
    properties: o,
    children: a
  };
  return patch(c, t), c;
}
function root(e, t) {
  const a = {
    type: "root",
    children: (
      /** @type {Array<RootContent>} */
      children$5(e, t.children)
    )
  };
  return patch(a, t), a;
}
function text$1(e, t) {
  const a = {
    type: "text",
    value: typeof t.value == "string" ? t.value : ""
  };
  return patch(a, t), a;
}
function children$5(e, t) {
  const r = [];
  if (Array.isArray(t)) {
    const a = (
      /** @type {Array<Readonly<unknown>>} */
      t
    );
    let o = -1;
    for (; ++o < a.length; ) {
      const u = transform(e, a[o]);
      u && (Array.isArray(u) ? r.push(...u) : r.push(u));
    }
  }
  return r;
}
function properties(e, t) {
  const r = e.stack[e.stack.length - 1], a = e.schema.attributes, o = e.schema.required, u = a && own$1.call(a, r) ? a[r] : void 0, c = a && own$1.call(a, "*") ? a["*"] : void 0, d = (
    /** @type {Readonly<Record<string, Readonly<unknown>>>} */
    t && typeof t == "object" ? t : {}
  ), g = {};
  let b;
  for (b in d)
    if (own$1.call(d, b)) {
      const _ = d[b];
      let y = propertyValue(e, findDefinition(u, b), b, _);
      y == null && (y = propertyValue(e, findDefinition(c, b), b, _)), y != null && (g[b] = y);
    }
  if (o && own$1.call(o, r)) {
    const _ = o[r];
    for (b in _)
      own$1.call(_, b) && !own$1.call(g, b) && (g[b] = _[b]);
  }
  return g;
}
function propertyValue(e, t, r, a) {
  return t ? Array.isArray(a) ? propertyValueMany(e, t, r, a) : propertyValuePrimitive(e, t, r, a) : void 0;
}
function propertyValueMany(e, t, r, a) {
  let o = -1;
  const u = [];
  for (; ++o < a.length; ) {
    const c = propertyValuePrimitive(e, t, r, a[o]);
    (typeof c == "number" || typeof c == "string") && u.push(c);
  }
  return u;
}
function propertyValuePrimitive(e, t, r, a) {
  if (!(typeof a != "boolean" && typeof a != "number" && typeof a != "string") && safeProtocol(e, r, a)) {
    if (typeof t == "object" && t.length > 1) {
      let o = !1, u = 0;
      for (; ++u < t.length; ) {
        const c = t[u];
        if (c && typeof c == "object" && "flags" in c) {
          if (c.test(String(a))) {
            o = !0;
            break;
          }
        } else if (c === a) {
          o = !0;
          break;
        }
      }
      if (!o) return;
    }
    return e.schema.clobber && e.schema.clobberPrefix && e.schema.clobber.includes(r) ? e.schema.clobberPrefix + a : a;
  }
}
function safeProtocol(e, t, r) {
  const a = e.schema.protocols && own$1.call(e.schema.protocols, t) ? e.schema.protocols[t] : void 0;
  if (!a || a.length === 0)
    return !0;
  const o = String(r), u = o.indexOf(":"), c = o.indexOf("?"), d = o.indexOf("#"), g = o.indexOf("/");
  if (u < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
  g > -1 && u > g || c > -1 && u > c || d > -1 && u > d)
    return !0;
  let b = -1;
  for (; ++b < a.length; ) {
    const _ = a[b];
    if (u === _.length && o.slice(0, _.length) === _)
      return !0;
  }
  return !1;
}
function patch(e, t) {
  const r = position$2(
    // @ts-expect-error: looks like a node.
    t
  );
  t.data && (e.data = structuredClone$1(t.data)), r && (e.position = r);
}
function findDefinition(e, t) {
  let r, a = -1;
  if (e)
    for (; ++a < e.length; ) {
      const o = e[a], u = typeof o == "string" ? o : o[0];
      if (u === t)
        return o;
      u === "data*" && (r = o);
    }
  if (t.length > 4 && t.slice(0, 4).toLowerCase() === "data")
    return r;
}
function rehypeSanitize(e) {
  return function(t) {
    return (
      /** @type {Root} */
      sanitize(t, e)
    );
  };
}
const own = {}.hasOwnProperty;
function createH(e, t, r) {
  const a = r && createAdjustMap(r);
  function o(u, c, ...d) {
    let g = -1, b;
    if (u == null) {
      b = {
        type: "root",
        children: []
      };
      const _ = (
        /** @type {Child} */
        c
      );
      d.unshift(_);
    } else if (b = parseSelector$1(u, t), b.tagName = b.tagName.toLowerCase(), a && own.call(a, b.tagName) && (b.tagName = a[b.tagName]), isChild(c))
      d.unshift(c);
    else {
      let _;
      for (_ in c)
        own.call(c, _) && addProperty(e, b.properties, _, c[_]);
    }
    for (; ++g < d.length; )
      addChild(b.children, d[g]);
    return b.type === "element" && b.tagName === "template" && (b.content = {
      type: "root",
      children: b.children
    }, b.children = []), b;
  }
  return o;
}
function isChild(e) {
  if (e === null || typeof e != "object" || Array.isArray(e))
    return !0;
  if (typeof e.type != "string") return !1;
  const t = (
    /** @type {Record<string, unknown>} */
    e
  ), r = Object.keys(e);
  for (const a of r) {
    const o = t[a];
    if (o && typeof o == "object") {
      if (!Array.isArray(o)) return !0;
      const u = (
        /** @type {Array<unknown>} */
        o
      );
      for (const c of u)
        if (typeof c != "number" && typeof c != "string")
          return !0;
    }
  }
  return !!("children" in e && Array.isArray(e.children));
}
function addProperty(e, t, r, a) {
  const o = find$2(e, r);
  let u = -1, c;
  if (a != null) {
    if (typeof a == "number") {
      if (Number.isNaN(a)) return;
      c = a;
    } else typeof a == "boolean" ? c = a : typeof a == "string" ? o.spaceSeparated ? c = parse$6(a) : o.commaSeparated ? c = parse$7(a) : o.commaOrSpaceSeparated ? c = parse$6(parse$7(a).join(" ")) : c = parsePrimitive(o, o.property, a) : Array.isArray(a) ? c = a.concat() : c = o.property === "style" ? style(a) : String(a);
    if (Array.isArray(c)) {
      const d = [];
      for (; ++u < c.length; ) {
        const g = (
          /** @type {number | string} */
          parsePrimitive(o, o.property, c[u])
        );
        d[u] = g;
      }
      c = d;
    }
    if (o.property === "className" && Array.isArray(t.className)) {
      const d = (
        /** @type {number | string} */
        c
      );
      c = t.className.concat(d);
    }
    t[o.property] = c;
  }
}
function addChild(e, t) {
  let r = -1;
  if (t != null) if (typeof t == "string" || typeof t == "number")
    e.push({
      type: "text",
      value: String(t)
    });
  else if (Array.isArray(t))
    for (; ++r < t.length; )
      addChild(e, t[r]);
  else if (typeof t == "object" && "type" in t)
    t.type === "root" ? addChild(e, t.children) : e.push(t);
  else
    throw new Error("Expected node, nodes, or string, got `" + t + "`");
}
function parsePrimitive(e, t, r) {
  if (typeof r == "string") {
    if (e.number && r && !Number.isNaN(Number(r)))
      return Number(r);
    if ((e.boolean || e.overloadedBoolean) && (r === "" || normalize$4(r) === normalize$4(t)))
      return !0;
  }
  return r;
}
function style(e) {
  const t = [];
  let r;
  for (r in e)
    own.call(e, r) && t.push([r, e[r]].join(": "));
  return t.join("; ");
}
function createAdjustMap(e) {
  const t = {};
  let r = -1;
  for (; ++r < e.length; )
    t[e[r].toLowerCase()] = e[r];
  return t;
}
const svgCaseSensitiveTagNames = ["altGlyph", "altGlyphDef", "altGlyphItem", "animateColor", "animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "glyphRef", "linearGradient", "radialGradient", "solidColor", "textArea", "textPath"], h = createH(html$4, "div");
createH(svg, "g", svgCaseSensitiveTagNames);
const directiveTagsMap = {
  "llm-thinking": "accordion",
  "llm-thinking-title": "accordion-title",
  accordion: "accordion",
  "accordion-title": "accordion-title",
  "flushing-end": "flushing-end"
}, transformNodeTree = (e, t) => visit(e, (r) => {
  var a, o, u, c;
  if (r.type === "containerDirective" || r.type === "leafDirective" || r.type === "textDirective") {
    if (!directiveTagsMap[r.name]) {
      const b = t.value;
      r.value = b.slice((o = (a = r.position) == null ? void 0 : a.start) == null ? void 0 : o.offset, (c = (u = r.position) == null ? void 0 : u.end) == null ? void 0 : c.offset), r.type = "text";
      return;
    }
    const d = r.data || (r.data = {}), g = h(directiveTagsMap[r.name] || r.name, r.attributes || {});
    d.hName = g.tagName, d.hProperties = g.properties;
  }
}), remarkDirectiveRehype = () => transformNodeTree, findEndOfMath = function(e, t, r) {
  let a = r, o = 0;
  const u = e.length;
  for (; a < t.length; ) {
    const c = t[a];
    if (o <= 0 && t.slice(a, a + u) === e)
      return a;
    c === "\\" ? a++ : c === "{" ? o++ : c === "}" && o--, a++;
  }
  return -1;
}, escapeRegex = function(e) {
  return e.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}, amsRegex = /^\\begin{/, resolveDelimiters = function(e, t = []) {
  if (!t || Array.isArray(t) && t.length === 0)
    return e;
  let r, a = "";
  const o = new RegExp("(" + t.map((u) => escapeRegex(u.left)).join("|") + ")");
  for (; r = e.search(o), r !== -1; ) {
    r > 0 && (a += e.slice(0, r), e = e.slice(r));
    const u = t.findIndex((g) => e.startsWith(g.left));
    if (r = findEndOfMath(t[u].right, e, t[u].left.length), r === -1)
      break;
    const c = e.slice(0, r + t[u].right.length), d = amsRegex.test(c) ? c : e.slice(t[u].left.length, r);
    if (e = e.slice(r + t[u].right.length), t[u].display) {
      const g = t[u].inline ? "$" : "$$";
      a += g + d + g;
    } else
      a += d;
  }
  return e !== "" && (a += e), a;
}, buildInCustomComponents = {
  "select-box": SelectBox,
  "accordion-title": AccordionTitle,
  accordion: Accordion,
  "flushing-end": FlushingEnd,
  file: File,
  chart: Chart
}, defaultCustomComponents = {}, Markdown = (e) => {
  const {
    render_markdown: t = !0,
    sanitize_html: r = !0,
    text: a = "",
    line_breaks: o = !0,
    flushing: u,
    className: c,
    disabled: d,
    style: g,
    preview: b = !0,
    theme: _ = "light",
    locale: y,
    end: A = !0,
    on_load: E,
    last_flushing_end_index: v,
    latex_single_dollar_delimiter: C = !0,
    latex_delimiters: R,
    enable_base64: I,
    enable_latex: w = !0,
    on_custom: N,
    header_links: F = !1,
    custom_components: M = defaultCustomComponents
  } = e, x = useMemo(() => {
    const L = a.trim();
    return w ? resolveDelimiters(L, R) : L;
  }, [a, R, w]);
  useEffect(() => {
    const L = "$MODELSCOPE_STUDIO_MARKDOWN_THEME";
    if (document.getElementById(L))
      return;
    const H = document.createElement("style");
    H.id = L;
    const B = _ === "dark" ? dark : light;
    return H.styleSheet ? H.styleSheet.cssText = B : H.appendChild(document.createTextNode(B)), document.head.appendChild(H), () => {
      document.head.removeChild(H);
    };
  }, [_]);
  const P = useMemo(() => Object.keys(M || {}), [M]), U = useMemo(() => deepmerge$1(defaultSchema, {
    // deepmerge to https://github.com/syntax-tree/hast-util-sanitize/blob/main/lib/schema.js
    tagNames: ["video", "audio", ...Object.keys(buildInCustomComponents), ...P],
    attributes: {
      "*": ["className", "style", "id", "type"],
      code: ["inline"],
      source: ["src"],
      file: ["src", "viewable", "title", "type"],
      video: ["src", "loop", "autoplay", "autoPlay", "muted", "controls"],
      audio: ["src", "loop", "autoplay", "autoPlay", "muted", "controls"],
      accordion: ["title"],
      chart: ["options"],
      "select-box": ["value", "options", "direction", "type", "shape", "disabled", "submit-text", "select-once", "img-height", "item-height", "item-width", "columns", "equal-height"],
      ...P.reduce((L, H) => (L[H] = M[H].props || [], L), {})
    },
    clobberPrefix: "",
    protocols: I ? {
      src: ["data"]
    } : {}
  }), [M, P, I]);
  return t ? /* @__PURE__ */ jsxRuntimeExports.jsx(MarkdownContext.Provider, {
    value: {
      text: x,
      end: A,
      preview: b,
      flushing: u,
      theme: _,
      locale: y,
      disabled: d,
      header_links: F,
      last_flushing_end_index: v,
      on_custom: N,
      custom_components: M
    },
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Markdown$1, {
      remarkPlugins: [remarkDirective, remarkDirectiveRehype, [remarkGfm, {
        singleTilde: !1
      }], o ? remarkBreaks : null, w ? [remarkMath, {
        singleDollarTextMath: C
      }] : null].filter(Boolean),
      remarkRehypeOptions: {
        clobberPrefix: ""
      },
      rehypePlugins: [w ? rehypeKatex : null, rehypeRaw, rehypeInlineCodeProperty, r ? [rehypeSanitize, U] : null].filter(Boolean),
      className: cls("ms-markdown", "markdown-body", {
        "ms-markdown-flushing": u,
        "ms-markdown-flushing-empty": !x && u
      }, c),
      urlTransform: I ? (L) => L.startsWith("data:") ? L : defaultUrlTransform(L) : void 0,
      components: {
        a: Anchor,
        audio: Audio,
        video: Video,
        code: Code,
        h1: Heading,
        h2: Heading,
        h3: Heading,
        h4: Heading,
        h5: Heading,
        h6: Heading,
        img: Image$1,
        ...buildInCustomComponents,
        ...P.reduce((L, H) => (L[H] = CustomComponent, L), {})
      },
      children: x
    })
  }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    className: c,
    style: g,
    children: x
  });
};
var en_US$7 = {}, interopRequireDefault = {
  exports: {}
};
(function(e) {
  function t(r) {
    return r && r.__esModule ? r : {
      default: r
    };
  }
  e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
})(interopRequireDefault);
var interopRequireDefaultExports = interopRequireDefault.exports, en_US$6 = {};
Object.defineProperty(en_US$6, "__esModule", {
  value: !0
});
en_US$6.default = void 0;
var locale$7 = {
  // Options
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "Page",
  // Pagination
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages",
  page_size: "Page Size"
};
en_US$6.default = locale$7;
var en_US$5 = {}, en_US$4 = {}, en_US$3 = {}, objectSpread2 = {
  exports: {}
}, defineProperty = {
  exports: {}
}, toPropertyKey = {
  exports: {}
}, _typeof = {
  exports: {}
};
(function(e) {
  function t(r) {
    "@babel/helpers - typeof";
    return e.exports = t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(a) {
      return typeof a;
    } : function(a) {
      return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
    }, e.exports.__esModule = !0, e.exports.default = e.exports, t(r);
  }
  e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
})(_typeof);
var _typeofExports = _typeof.exports, toPrimitive = {
  exports: {}
};
(function(e) {
  var t = _typeofExports.default;
  function r(a, o) {
    if (t(a) != "object" || !a) return a;
    var u = a[Symbol.toPrimitive];
    if (u !== void 0) {
      var c = u.call(a, o || "default");
      if (t(c) != "object") return c;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (o === "string" ? String : Number)(a);
  }
  e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
})(toPrimitive);
var toPrimitiveExports = toPrimitive.exports;
(function(e) {
  var t = _typeofExports.default, r = toPrimitiveExports;
  function a(o) {
    var u = r(o, "string");
    return t(u) == "symbol" ? u : u + "";
  }
  e.exports = a, e.exports.__esModule = !0, e.exports.default = e.exports;
})(toPropertyKey);
var toPropertyKeyExports = toPropertyKey.exports;
(function(e) {
  var t = toPropertyKeyExports;
  function r(a, o, u) {
    return (o = t(o)) in a ? Object.defineProperty(a, o, {
      value: u,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : a[o] = u, a;
  }
  e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
})(defineProperty);
var definePropertyExports = defineProperty.exports;
(function(e) {
  var t = definePropertyExports;
  function r(o, u) {
    var c = Object.keys(o);
    if (Object.getOwnPropertySymbols) {
      var d = Object.getOwnPropertySymbols(o);
      u && (d = d.filter(function(g) {
        return Object.getOwnPropertyDescriptor(o, g).enumerable;
      })), c.push.apply(c, d);
    }
    return c;
  }
  function a(o) {
    for (var u = 1; u < arguments.length; u++) {
      var c = arguments[u] != null ? arguments[u] : {};
      u % 2 ? r(Object(c), !0).forEach(function(d) {
        t(o, d, c[d]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(c)) : r(Object(c)).forEach(function(d) {
        Object.defineProperty(o, d, Object.getOwnPropertyDescriptor(c, d));
      });
    }
    return o;
  }
  e.exports = a, e.exports.__esModule = !0, e.exports.default = e.exports;
})(objectSpread2);
var objectSpread2Exports = objectSpread2.exports, common = {};
Object.defineProperty(common, "__esModule", {
  value: !0
});
common.commonLocale = void 0;
common.commonLocale = {
  yearFormat: "YYYY",
  dayFormat: "D",
  cellMeridiemFormat: "A",
  monthBeforeYear: !0
};
var _interopRequireDefault$7 = interopRequireDefaultExports.default;
Object.defineProperty(en_US$3, "__esModule", {
  value: !0
});
en_US$3.default = void 0;
var _objectSpread2$1 = _interopRequireDefault$7(objectSpread2Exports), _common$1 = common, locale$6 = (0, _objectSpread2$1.default)((0, _objectSpread2$1.default)({}, _common$1.commonLocale), {}, {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "OK",
  clear: "Clear",
  week: "Week",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  dateFormat: "M/D/YYYY",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
});
en_US$3.default = locale$6;
var en_US$2 = {};
Object.defineProperty(en_US$2, "__esModule", {
  value: !0
});
en_US$2.default = void 0;
const locale$5 = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
};
en_US$2.default = locale$5;
var _interopRequireDefault$6 = interopRequireDefaultExports.default;
Object.defineProperty(en_US$4, "__esModule", {
  value: !0
});
en_US$4.default = void 0;
var _en_US$2 = _interopRequireDefault$6(en_US$3), _en_US2$1 = _interopRequireDefault$6(en_US$2);
const locale$4 = {
  lang: Object.assign({
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"]
  }, _en_US$2.default),
  timePickerLocale: Object.assign({}, _en_US2$1.default)
};
en_US$4.default = locale$4;
var _interopRequireDefault$5 = interopRequireDefaultExports.default;
Object.defineProperty(en_US$5, "__esModule", {
  value: !0
});
en_US$5.default = void 0;
var _en_US$1 = _interopRequireDefault$5(en_US$4);
en_US$5.default = _en_US$1.default;
var _interopRequireDefault$4 = interopRequireDefaultExports.default;
Object.defineProperty(en_US$7, "__esModule", {
  value: !0
});
en_US$7.default = void 0;
var _en_US = _interopRequireDefault$4(en_US$6), _en_US2 = _interopRequireDefault$4(en_US$5), _en_US3 = _interopRequireDefault$4(en_US$4), _en_US4 = _interopRequireDefault$4(en_US$2);
const typeTemplate$1 = "${label} is not a valid ${type}", localeValues$1 = {
  locale: "en",
  Pagination: _en_US.default,
  DatePicker: _en_US3.default,
  TimePicker: _en_US4.default,
  Calendar: _en_US2.default,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckAll: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Tour: {
    Next: "Next",
    Previous: "Previous",
    Finish: "Finish"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    deselectAll: "Deselect all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand",
    collapse: "Collapse"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: typeTemplate$1,
        method: typeTemplate$1,
        array: typeTemplate$1,
        object: typeTemplate$1,
        number: typeTemplate$1,
        date: typeTemplate$1,
        boolean: typeTemplate$1,
        integer: typeTemplate$1,
        float: typeTemplate$1,
        regexp: typeTemplate$1,
        email: typeTemplate$1,
        url: typeTemplate$1,
        hex: typeTemplate$1
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  },
  QRCode: {
    expired: "QR code expired",
    refresh: "Refresh",
    scanned: "Scanned"
  },
  ColorPicker: {
    presetEmpty: "Empty",
    transparent: "Transparent",
    singleColor: "Single",
    gradientColor: "Gradient"
  }
};
en_US$7.default = localeValues$1;
var en_US = en_US$7;
const en_US$1 = /* @__PURE__ */ getDefaultExportFromCjs(en_US);
var zh_CN$7 = {}, zh_CN$6 = {};
Object.defineProperty(zh_CN$6, "__esModule", {
  value: !0
});
zh_CN$6.default = void 0;
var locale$3 = {
  // Options
  items_per_page: "/",
  jump_to: "",
  jump_to_confirm: "",
  page: "",
  // Pagination
  prev_page: "",
  next_page: "",
  prev_5: " 5 ",
  next_5: " 5 ",
  prev_3: " 3 ",
  next_3: " 3 ",
  page_size: ""
};
zh_CN$6.default = locale$3;
var zh_CN$5 = {}, zh_CN$4 = {}, zh_CN$3 = {}, _interopRequireDefault$3 = interopRequireDefaultExports.default;
Object.defineProperty(zh_CN$3, "__esModule", {
  value: !0
});
zh_CN$3.default = void 0;
var _objectSpread2 = _interopRequireDefault$3(objectSpread2Exports), _common = common, locale$2 = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, _common.commonLocale), {}, {
  locale: "zh_CN",
  today: "",
  now: "",
  backToToday: "",
  ok: "",
  timeSelect: "",
  dateSelect: "",
  weekSelect: "",
  clear: "",
  week: "",
  month: "",
  year: "",
  previousMonth: " ()",
  nextMonth: " ()",
  monthSelect: "",
  yearSelect: "",
  decadeSelect: "",
  previousYear: " (Control)",
  nextYear: " (Control)",
  previousDecade: "",
  nextDecade: "",
  previousCentury: "",
  nextCentury: "",
  yearFormat: "YYYY",
  cellDateFormat: "D",
  monthBeforeYear: !1
});
zh_CN$3.default = locale$2;
var zh_CN$2 = {};
Object.defineProperty(zh_CN$2, "__esModule", {
  value: !0
});
zh_CN$2.default = void 0;
const locale$1 = {
  placeholder: "",
  rangePlaceholder: ["", ""]
};
zh_CN$2.default = locale$1;
var _interopRequireDefault$2 = interopRequireDefaultExports.default;
Object.defineProperty(zh_CN$4, "__esModule", {
  value: !0
});
zh_CN$4.default = void 0;
var _zh_CN$2 = _interopRequireDefault$2(zh_CN$3), _zh_CN2$1 = _interopRequireDefault$2(zh_CN$2);
const locale = {
  lang: Object.assign({
    placeholder: "",
    yearPlaceholder: "",
    quarterPlaceholder: "",
    monthPlaceholder: "",
    weekPlaceholder: "",
    rangePlaceholder: ["", ""],
    rangeYearPlaceholder: ["", ""],
    rangeMonthPlaceholder: ["", ""],
    rangeQuarterPlaceholder: ["", ""],
    rangeWeekPlaceholder: ["", ""]
  }, _zh_CN$2.default),
  timePickerLocale: Object.assign({}, _zh_CN2$1.default)
};
locale.lang.ok = "";
zh_CN$4.default = locale;
var _interopRequireDefault$1 = interopRequireDefaultExports.default;
Object.defineProperty(zh_CN$5, "__esModule", {
  value: !0
});
zh_CN$5.default = void 0;
var _zh_CN$1 = _interopRequireDefault$1(zh_CN$4);
zh_CN$5.default = _zh_CN$1.default;
var _interopRequireDefault = interopRequireDefaultExports.default;
Object.defineProperty(zh_CN$7, "__esModule", {
  value: !0
});
zh_CN$7.default = void 0;
var _zh_CN = _interopRequireDefault(zh_CN$6), _zh_CN2 = _interopRequireDefault(zh_CN$5), _zh_CN3 = _interopRequireDefault(zh_CN$4), _zh_CN4 = _interopRequireDefault(zh_CN$2);
const typeTemplate = "${label}${type}", localeValues = {
  locale: "zh-cn",
  Pagination: _zh_CN.default,
  DatePicker: _zh_CN3.default,
  TimePicker: _zh_CN4.default,
  Calendar: _zh_CN2.default,
  // locales for all components
  global: {
    placeholder: ""
  },
  Table: {
    filterTitle: "",
    filterConfirm: "",
    filterReset: "",
    filterEmptyText: "",
    filterCheckAll: "",
    filterSearchPlaceholder: "",
    emptyText: "",
    selectAll: "",
    selectInvert: "",
    selectNone: "",
    selectionAll: "",
    sortTitle: "",
    expand: "",
    collapse: "",
    triggerDesc: "",
    triggerAsc: "",
    cancelSort: ""
  },
  Modal: {
    okText: "",
    cancelText: "",
    justOkText: ""
  },
  Tour: {
    Next: "",
    Previous: "",
    Finish: ""
  },
  Popconfirm: {
    cancelText: "",
    okText: ""
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "",
    itemUnit: "",
    itemsUnit: "",
    remove: "",
    selectCurrent: "",
    removeCurrent: "",
    selectAll: "",
    deselectAll: "",
    removeAll: "",
    selectInvert: ""
  },
  Upload: {
    uploading: "",
    removeFile: "",
    uploadError: "",
    previewFile: "",
    downloadFile: ""
  },
  Empty: {
    description: ""
  },
  Icon: {
    icon: ""
  },
  Text: {
    edit: "",
    copy: "",
    copied: "",
    expand: "",
    collapse: ""
  },
  Form: {
    optional: "",
    defaultValidateMessages: {
      default: "${label}",
      required: "${label}",
      enum: "${label}[${enum}]",
      whitespace: "${label}",
      date: {
        format: "${label}",
        parse: "${label}",
        invalid: "${label}"
      },
      types: {
        string: typeTemplate,
        method: typeTemplate,
        array: typeTemplate,
        object: typeTemplate,
        number: typeTemplate,
        date: typeTemplate,
        boolean: typeTemplate,
        integer: typeTemplate,
        float: typeTemplate,
        regexp: typeTemplate,
        email: typeTemplate,
        url: typeTemplate,
        hex: typeTemplate
      },
      string: {
        len: "${label}${len}",
        min: "${label}${min}",
        max: "${label}${max}",
        range: "${label}${min}-${max}"
      },
      number: {
        len: "${label}${len}",
        min: "${label}${min}",
        max: "${label}${max}",
        range: "${label}${min}-${max}"
      },
      array: {
        len: "${len}${label}",
        min: "${min}${label}",
        max: "${max}${label}",
        range: "${label}${min}-${max}"
      },
      pattern: {
        mismatch: "${label}${pattern}"
      }
    }
  },
  Image: {
    preview: ""
  },
  QRCode: {
    expired: "",
    refresh: "",
    scanned: ""
  },
  ColorPicker: {
    presetEmpty: "",
    transparent: "",
    singleColor: "",
    gradientColor: ""
  }
};
zh_CN$7.default = localeValues;
var zh_CN = zh_CN$7;
const zh_CN$1 = /* @__PURE__ */ getDefaultExportFromCjs(zh_CN), langs = {
  "en-US": en_US$1,
  "zh-CN": zh_CN$1
}, primaryColor = window.getComputedStyle(document.documentElement).getPropertyValue("--color-accent"), ComponentConfigProvider = (e) => {
  const {
    locale: t,
    theme: r,
    children: a
  } = e, [o, u] = useState();
  return useEffect(() => {
    t && u(langs[t]);
  }, [t]), /* @__PURE__ */ jsxRuntimeExports.jsx(ConfigProvider, {
    theme: useMemo(() => ({
      cssVar: !0,
      token: {
        colorPrimary: primaryColor
      },
      algorithm: r === "dark" ? theme.darkAlgorithm : theme.defaultAlgorithm
    }), [r]),
    locale: o,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(StyleProvider, {
      hashPriority: "high",
      transformers: useMemo(() => [legacyLogicalPropertiesTransformer], []),
      children: a
    })
  });
};
function mount(e, t, r, a) {
  const o = a || ReactDOM.createRoot(e);
  return o.render(/* @__PURE__ */ jsxRuntimeExports.jsx(ComponentConfigProvider, {
    locale: r.locale,
    theme: r.theme,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(t, {
      ...r
    })
  })), o;
}
var extendStatics = function(e, t) {
  return extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(r, a) {
    r.__proto__ = a;
  } || function(r, a) {
    for (var o in a) Object.prototype.hasOwnProperty.call(a, o) && (r[o] = a[o]);
  }, extendStatics(e, t);
};
function __extends(e, t) {
  if (typeof t != "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  extendStatics(e, t);
  function r() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype, new r());
}
var __assign = function() {
  return __assign = Object.assign || function(t) {
    for (var r, a = 1, o = arguments.length; a < o; a++) {
      r = arguments[a];
      for (var u in r) Object.prototype.hasOwnProperty.call(r, u) && (t[u] = r[u]);
    }
    return t;
  }, __assign.apply(this, arguments);
};
function __rest(e, t) {
  var r = {};
  for (var a in e) Object.prototype.hasOwnProperty.call(e, a) && t.indexOf(a) < 0 && (r[a] = e[a]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, a = Object.getOwnPropertySymbols(e); o < a.length; o++)
    t.indexOf(a[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, a[o]) && (r[a[o]] = e[a[o]]);
  return r;
}
function __spreadArray(e, t, r) {
  if (r || arguments.length === 2) for (var a = 0, o = t.length, u; a < o; a++)
    (u || !(a in t)) && (u || (u = Array.prototype.slice.call(t, 0, a)), u[a] = t[a]);
  return e.concat(u || Array.prototype.slice.call(t));
}
typeof SuppressedError == "function" && SuppressedError;
function memoize(e, t) {
  var r = t && t.cache ? t.cache : cacheDefault, a = t && t.serializer ? t.serializer : serializerDefault, o = t && t.strategy ? t.strategy : strategyDefault;
  return o(e, {
    cache: r,
    serializer: a
  });
}
function isPrimitive(e) {
  return e == null || typeof e == "number" || typeof e == "boolean";
}
function monadic(e, t, r, a) {
  var o = isPrimitive(a) ? a : r(a), u = t.get(o);
  return typeof u > "u" && (u = e.call(this, a), t.set(o, u)), u;
}
function variadic(e, t, r) {
  var a = Array.prototype.slice.call(arguments, 3), o = r(a), u = t.get(o);
  return typeof u > "u" && (u = e.apply(this, a), t.set(o, u)), u;
}
function assemble(e, t, r, a, o) {
  return r.bind(t, e, a, o);
}
function strategyDefault(e, t) {
  var r = e.length === 1 ? monadic : variadic;
  return assemble(e, this, r, t.cache.create(), t.serializer);
}
function strategyVariadic(e, t) {
  return assemble(e, this, variadic, t.cache.create(), t.serializer);
}
var serializerDefault = function() {
  return JSON.stringify(arguments);
};
function ObjectWithoutPrototypeCache() {
  this.cache = /* @__PURE__ */ Object.create(null);
}
ObjectWithoutPrototypeCache.prototype.get = function(e) {
  return this.cache[e];
};
ObjectWithoutPrototypeCache.prototype.set = function(e, t) {
  this.cache[e] = t;
};
var cacheDefault = {
  create: function e() {
    return new ObjectWithoutPrototypeCache();
  }
}, strategies = {
  variadic: strategyVariadic
}, ErrorKind;
(function(e) {
  e[e.EXPECT_ARGUMENT_CLOSING_BRACE = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE", e[e.EMPTY_ARGUMENT = 2] = "EMPTY_ARGUMENT", e[e.MALFORMED_ARGUMENT = 3] = "MALFORMED_ARGUMENT", e[e.EXPECT_ARGUMENT_TYPE = 4] = "EXPECT_ARGUMENT_TYPE", e[e.INVALID_ARGUMENT_TYPE = 5] = "INVALID_ARGUMENT_TYPE", e[e.EXPECT_ARGUMENT_STYLE = 6] = "EXPECT_ARGUMENT_STYLE", e[e.INVALID_NUMBER_SKELETON = 7] = "INVALID_NUMBER_SKELETON", e[e.INVALID_DATE_TIME_SKELETON = 8] = "INVALID_DATE_TIME_SKELETON", e[e.EXPECT_NUMBER_SKELETON = 9] = "EXPECT_NUMBER_SKELETON", e[e.EXPECT_DATE_TIME_SKELETON = 10] = "EXPECT_DATE_TIME_SKELETON", e[e.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE", e[e.EXPECT_SELECT_ARGUMENT_OPTIONS = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS", e[e.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE", e[e.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE", e[e.EXPECT_SELECT_ARGUMENT_SELECTOR = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR", e[e.EXPECT_PLURAL_ARGUMENT_SELECTOR = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR", e[e.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT", e[e.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT", e[e.INVALID_PLURAL_ARGUMENT_SELECTOR = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR", e[e.DUPLICATE_PLURAL_ARGUMENT_SELECTOR = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR", e[e.DUPLICATE_SELECT_ARGUMENT_SELECTOR = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR", e[e.MISSING_OTHER_CLAUSE = 22] = "MISSING_OTHER_CLAUSE", e[e.INVALID_TAG = 23] = "INVALID_TAG", e[e.INVALID_TAG_NAME = 25] = "INVALID_TAG_NAME", e[e.UNMATCHED_CLOSING_TAG = 26] = "UNMATCHED_CLOSING_TAG", e[e.UNCLOSED_TAG = 27] = "UNCLOSED_TAG";
})(ErrorKind || (ErrorKind = {}));
var TYPE;
(function(e) {
  e[e.literal = 0] = "literal", e[e.argument = 1] = "argument", e[e.number = 2] = "number", e[e.date = 3] = "date", e[e.time = 4] = "time", e[e.select = 5] = "select", e[e.plural = 6] = "plural", e[e.pound = 7] = "pound", e[e.tag = 8] = "tag";
})(TYPE || (TYPE = {}));
var SKELETON_TYPE;
(function(e) {
  e[e.number = 0] = "number", e[e.dateTime = 1] = "dateTime";
})(SKELETON_TYPE || (SKELETON_TYPE = {}));
function isLiteralElement(e) {
  return e.type === TYPE.literal;
}
function isArgumentElement(e) {
  return e.type === TYPE.argument;
}
function isNumberElement(e) {
  return e.type === TYPE.number;
}
function isDateElement(e) {
  return e.type === TYPE.date;
}
function isTimeElement(e) {
  return e.type === TYPE.time;
}
function isSelectElement(e) {
  return e.type === TYPE.select;
}
function isPluralElement(e) {
  return e.type === TYPE.plural;
}
function isPoundElement(e) {
  return e.type === TYPE.pound;
}
function isTagElement(e) {
  return e.type === TYPE.tag;
}
function isNumberSkeleton(e) {
  return !!(e && typeof e == "object" && e.type === SKELETON_TYPE.number);
}
function isDateTimeSkeleton(e) {
  return !!(e && typeof e == "object" && e.type === SKELETON_TYPE.dateTime);
}
var SPACE_SEPARATOR_REGEX = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/, DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
function parseDateTimeSkeleton(e) {
  var t = {};
  return e.replace(DATE_TIME_REGEX, function(r) {
    var a = r.length;
    switch (r[0]) {
      case "G":
        t.era = a === 4 ? "long" : a === 5 ? "narrow" : "short";
        break;
      case "y":
        t.year = a === 2 ? "2-digit" : "numeric";
        break;
      case "Y":
      case "u":
      case "U":
      case "r":
        throw new RangeError("`Y/u/U/r` (year) patterns are not supported, use `y` instead");
      case "q":
      case "Q":
        throw new RangeError("`q/Q` (quarter) patterns are not supported");
      case "M":
      case "L":
        t.month = ["numeric", "2-digit", "short", "long", "narrow"][a - 1];
        break;
      case "w":
      case "W":
        throw new RangeError("`w/W` (week) patterns are not supported");
      case "d":
        t.day = ["numeric", "2-digit"][a - 1];
        break;
      case "D":
      case "F":
      case "g":
        throw new RangeError("`D/F/g` (day) patterns are not supported, use `d` instead");
      case "E":
        t.weekday = a === 4 ? "long" : a === 5 ? "narrow" : "short";
        break;
      case "e":
        if (a < 4)
          throw new RangeError("`e..eee` (weekday) patterns are not supported");
        t.weekday = ["short", "long", "narrow", "short"][a - 4];
        break;
      case "c":
        if (a < 4)
          throw new RangeError("`c..ccc` (weekday) patterns are not supported");
        t.weekday = ["short", "long", "narrow", "short"][a - 4];
        break;
      case "a":
        t.hour12 = !0;
        break;
      case "b":
      case "B":
        throw new RangeError("`b/B` (period) patterns are not supported, use `a` instead");
      case "h":
        t.hourCycle = "h12", t.hour = ["numeric", "2-digit"][a - 1];
        break;
      case "H":
        t.hourCycle = "h23", t.hour = ["numeric", "2-digit"][a - 1];
        break;
      case "K":
        t.hourCycle = "h11", t.hour = ["numeric", "2-digit"][a - 1];
        break;
      case "k":
        t.hourCycle = "h24", t.hour = ["numeric", "2-digit"][a - 1];
        break;
      case "j":
      case "J":
      case "C":
        throw new RangeError("`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead");
      case "m":
        t.minute = ["numeric", "2-digit"][a - 1];
        break;
      case "s":
        t.second = ["numeric", "2-digit"][a - 1];
        break;
      case "S":
      case "A":
        throw new RangeError("`S/A` (second) patterns are not supported, use `s` instead");
      case "z":
        t.timeZoneName = a < 4 ? "short" : "long";
        break;
      case "Z":
      case "O":
      case "v":
      case "V":
      case "X":
      case "x":
        throw new RangeError("`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead");
    }
    return "";
  }), t;
}
var WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;
function parseNumberSkeletonFromString(e) {
  if (e.length === 0)
    throw new Error("Number skeleton cannot be empty");
  for (var t = e.split(WHITE_SPACE_REGEX).filter(function(A) {
    return A.length > 0;
  }), r = [], a = 0, o = t; a < o.length; a++) {
    var u = o[a], c = u.split("/");
    if (c.length === 0)
      throw new Error("Invalid number skeleton");
    for (var d = c[0], g = c.slice(1), b = 0, _ = g; b < _.length; b++) {
      var y = _[b];
      if (y.length === 0)
        throw new Error("Invalid number skeleton");
    }
    r.push({
      stem: d,
      options: g
    });
  }
  return r;
}
function icuUnitToEcma(e) {
  return e.replace(/^(.*?)-/, "");
}
var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g, SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?[rs]?$/g, INTEGER_WIDTH_REGEX = /(\*)(0+)|(#+)(0+)|(0+)/g, CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;
function parseSignificantPrecision(e) {
  var t = {};
  return e[e.length - 1] === "r" ? t.roundingPriority = "morePrecision" : e[e.length - 1] === "s" && (t.roundingPriority = "lessPrecision"), e.replace(SIGNIFICANT_PRECISION_REGEX, function(r, a, o) {
    return typeof o != "string" ? (t.minimumSignificantDigits = a.length, t.maximumSignificantDigits = a.length) : o === "+" ? t.minimumSignificantDigits = a.length : a[0] === "#" ? t.maximumSignificantDigits = a.length : (t.minimumSignificantDigits = a.length, t.maximumSignificantDigits = a.length + (typeof o == "string" ? o.length : 0)), "";
  }), t;
}
function parseSign(e) {
  switch (e) {
    case "sign-auto":
      return {
        signDisplay: "auto"
      };
    case "sign-accounting":
    case "()":
      return {
        currencySign: "accounting"
      };
    case "sign-always":
    case "+!":
      return {
        signDisplay: "always"
      };
    case "sign-accounting-always":
    case "()!":
      return {
        signDisplay: "always",
        currencySign: "accounting"
      };
    case "sign-except-zero":
    case "+?":
      return {
        signDisplay: "exceptZero"
      };
    case "sign-accounting-except-zero":
    case "()?":
      return {
        signDisplay: "exceptZero",
        currencySign: "accounting"
      };
    case "sign-never":
    case "+_":
      return {
        signDisplay: "never"
      };
  }
}
function parseConciseScientificAndEngineeringStem(e) {
  var t;
  if (e[0] === "E" && e[1] === "E" ? (t = {
    notation: "engineering"
  }, e = e.slice(2)) : e[0] === "E" && (t = {
    notation: "scientific"
  }, e = e.slice(1)), t) {
    var r = e.slice(0, 2);
    if (r === "+!" ? (t.signDisplay = "always", e = e.slice(2)) : r === "+?" && (t.signDisplay = "exceptZero", e = e.slice(2)), !CONCISE_INTEGER_WIDTH_REGEX.test(e))
      throw new Error("Malformed concise eng/scientific notation");
    t.minimumIntegerDigits = e.length;
  }
  return t;
}
function parseNotationOptions(e) {
  var t = {}, r = parseSign(e);
  return r || t;
}
function parseNumberSkeleton(e) {
  for (var t = {}, r = 0, a = e; r < a.length; r++) {
    var o = a[r];
    switch (o.stem) {
      case "percent":
      case "%":
        t.style = "percent";
        continue;
      case "%x100":
        t.style = "percent", t.scale = 100;
        continue;
      case "currency":
        t.style = "currency", t.currency = o.options[0];
        continue;
      case "group-off":
      case ",_":
        t.useGrouping = !1;
        continue;
      case "precision-integer":
      case ".":
        t.maximumFractionDigits = 0;
        continue;
      case "measure-unit":
      case "unit":
        t.style = "unit", t.unit = icuUnitToEcma(o.options[0]);
        continue;
      case "compact-short":
      case "K":
        t.notation = "compact", t.compactDisplay = "short";
        continue;
      case "compact-long":
      case "KK":
        t.notation = "compact", t.compactDisplay = "long";
        continue;
      case "scientific":
        t = __assign(__assign(__assign({}, t), {
          notation: "scientific"
        }), o.options.reduce(function(g, b) {
          return __assign(__assign({}, g), parseNotationOptions(b));
        }, {}));
        continue;
      case "engineering":
        t = __assign(__assign(__assign({}, t), {
          notation: "engineering"
        }), o.options.reduce(function(g, b) {
          return __assign(__assign({}, g), parseNotationOptions(b));
        }, {}));
        continue;
      case "notation-simple":
        t.notation = "standard";
        continue;
      case "unit-width-narrow":
        t.currencyDisplay = "narrowSymbol", t.unitDisplay = "narrow";
        continue;
      case "unit-width-short":
        t.currencyDisplay = "code", t.unitDisplay = "short";
        continue;
      case "unit-width-full-name":
        t.currencyDisplay = "name", t.unitDisplay = "long";
        continue;
      case "unit-width-iso-code":
        t.currencyDisplay = "symbol";
        continue;
      case "scale":
        t.scale = parseFloat(o.options[0]);
        continue;
      case "rounding-mode-floor":
        t.roundingMode = "floor";
        continue;
      case "rounding-mode-ceiling":
        t.roundingMode = "ceil";
        continue;
      case "rounding-mode-down":
        t.roundingMode = "trunc";
        continue;
      case "rounding-mode-up":
        t.roundingMode = "expand";
        continue;
      case "rounding-mode-half-even":
        t.roundingMode = "halfEven";
        continue;
      case "rounding-mode-half-down":
        t.roundingMode = "halfTrunc";
        continue;
      case "rounding-mode-half-up":
        t.roundingMode = "halfExpand";
        continue;
      case "integer-width":
        if (o.options.length > 1)
          throw new RangeError("integer-width stems only accept a single optional option");
        o.options[0].replace(INTEGER_WIDTH_REGEX, function(g, b, _, y, A, E) {
          if (b)
            t.minimumIntegerDigits = _.length;
          else {
            if (y && A)
              throw new Error("We currently do not support maximum integer digits");
            if (E)
              throw new Error("We currently do not support exact integer digits");
          }
          return "";
        });
        continue;
    }
    if (CONCISE_INTEGER_WIDTH_REGEX.test(o.stem)) {
      t.minimumIntegerDigits = o.stem.length;
      continue;
    }
    if (FRACTION_PRECISION_REGEX.test(o.stem)) {
      if (o.options.length > 1)
        throw new RangeError("Fraction-precision stems only accept a single optional option");
      o.stem.replace(FRACTION_PRECISION_REGEX, function(g, b, _, y, A, E) {
        return _ === "*" ? t.minimumFractionDigits = b.length : y && y[0] === "#" ? t.maximumFractionDigits = y.length : A && E ? (t.minimumFractionDigits = A.length, t.maximumFractionDigits = A.length + E.length) : (t.minimumFractionDigits = b.length, t.maximumFractionDigits = b.length), "";
      });
      var u = o.options[0];
      u === "w" ? t = __assign(__assign({}, t), {
        trailingZeroDisplay: "stripIfInteger"
      }) : u && (t = __assign(__assign({}, t), parseSignificantPrecision(u)));
      continue;
    }
    if (SIGNIFICANT_PRECISION_REGEX.test(o.stem)) {
      t = __assign(__assign({}, t), parseSignificantPrecision(o.stem));
      continue;
    }
    var c = parseSign(o.stem);
    c && (t = __assign(__assign({}, t), c));
    var d = parseConciseScientificAndEngineeringStem(o.stem);
    d && (t = __assign(__assign({}, t), d));
  }
  return t;
}
var timeData = {
  "001": ["H", "h"],
  419: ["h", "H", "hB", "hb"],
  AC: ["H", "h", "hb", "hB"],
  AD: ["H", "hB"],
  AE: ["h", "hB", "hb", "H"],
  AF: ["H", "hb", "hB", "h"],
  AG: ["h", "hb", "H", "hB"],
  AI: ["H", "h", "hb", "hB"],
  AL: ["h", "H", "hB"],
  AM: ["H", "hB"],
  AO: ["H", "hB"],
  AR: ["h", "H", "hB", "hb"],
  AS: ["h", "H"],
  AT: ["H", "hB"],
  AU: ["h", "hb", "H", "hB"],
  AW: ["H", "hB"],
  AX: ["H"],
  AZ: ["H", "hB", "h"],
  BA: ["H", "hB", "h"],
  BB: ["h", "hb", "H", "hB"],
  BD: ["h", "hB", "H"],
  BE: ["H", "hB"],
  BF: ["H", "hB"],
  BG: ["H", "hB", "h"],
  BH: ["h", "hB", "hb", "H"],
  BI: ["H", "h"],
  BJ: ["H", "hB"],
  BL: ["H", "hB"],
  BM: ["h", "hb", "H", "hB"],
  BN: ["hb", "hB", "h", "H"],
  BO: ["h", "H", "hB", "hb"],
  BQ: ["H"],
  BR: ["H", "hB"],
  BS: ["h", "hb", "H", "hB"],
  BT: ["h", "H"],
  BW: ["H", "h", "hb", "hB"],
  BY: ["H", "h"],
  BZ: ["H", "h", "hb", "hB"],
  CA: ["h", "hb", "H", "hB"],
  CC: ["H", "h", "hb", "hB"],
  CD: ["hB", "H"],
  CF: ["H", "h", "hB"],
  CG: ["H", "hB"],
  CH: ["H", "hB", "h"],
  CI: ["H", "hB"],
  CK: ["H", "h", "hb", "hB"],
  CL: ["h", "H", "hB", "hb"],
  CM: ["H", "h", "hB"],
  CN: ["H", "hB", "hb", "h"],
  CO: ["h", "H", "hB", "hb"],
  CP: ["H"],
  CR: ["h", "H", "hB", "hb"],
  CU: ["h", "H", "hB", "hb"],
  CV: ["H", "hB"],
  CW: ["H", "hB"],
  CX: ["H", "h", "hb", "hB"],
  CY: ["h", "H", "hb", "hB"],
  CZ: ["H"],
  DE: ["H", "hB"],
  DG: ["H", "h", "hb", "hB"],
  DJ: ["h", "H"],
  DK: ["H"],
  DM: ["h", "hb", "H", "hB"],
  DO: ["h", "H", "hB", "hb"],
  DZ: ["h", "hB", "hb", "H"],
  EA: ["H", "h", "hB", "hb"],
  EC: ["h", "H", "hB", "hb"],
  EE: ["H", "hB"],
  EG: ["h", "hB", "hb", "H"],
  EH: ["h", "hB", "hb", "H"],
  ER: ["h", "H"],
  ES: ["H", "hB", "h", "hb"],
  ET: ["hB", "hb", "h", "H"],
  FI: ["H"],
  FJ: ["h", "hb", "H", "hB"],
  FK: ["H", "h", "hb", "hB"],
  FM: ["h", "hb", "H", "hB"],
  FO: ["H", "h"],
  FR: ["H", "hB"],
  GA: ["H", "hB"],
  GB: ["H", "h", "hb", "hB"],
  GD: ["h", "hb", "H", "hB"],
  GE: ["H", "hB", "h"],
  GF: ["H", "hB"],
  GG: ["H", "h", "hb", "hB"],
  GH: ["h", "H"],
  GI: ["H", "h", "hb", "hB"],
  GL: ["H", "h"],
  GM: ["h", "hb", "H", "hB"],
  GN: ["H", "hB"],
  GP: ["H", "hB"],
  GQ: ["H", "hB", "h", "hb"],
  GR: ["h", "H", "hb", "hB"],
  GT: ["h", "H", "hB", "hb"],
  GU: ["h", "hb", "H", "hB"],
  GW: ["H", "hB"],
  GY: ["h", "hb", "H", "hB"],
  HK: ["h", "hB", "hb", "H"],
  HN: ["h", "H", "hB", "hb"],
  HR: ["H", "hB"],
  HU: ["H", "h"],
  IC: ["H", "h", "hB", "hb"],
  ID: ["H"],
  IE: ["H", "h", "hb", "hB"],
  IL: ["H", "hB"],
  IM: ["H", "h", "hb", "hB"],
  IN: ["h", "H"],
  IO: ["H", "h", "hb", "hB"],
  IQ: ["h", "hB", "hb", "H"],
  IR: ["hB", "H"],
  IS: ["H"],
  IT: ["H", "hB"],
  JE: ["H", "h", "hb", "hB"],
  JM: ["h", "hb", "H", "hB"],
  JO: ["h", "hB", "hb", "H"],
  JP: ["H", "K", "h"],
  KE: ["hB", "hb", "H", "h"],
  KG: ["H", "h", "hB", "hb"],
  KH: ["hB", "h", "H", "hb"],
  KI: ["h", "hb", "H", "hB"],
  KM: ["H", "h", "hB", "hb"],
  KN: ["h", "hb", "H", "hB"],
  KP: ["h", "H", "hB", "hb"],
  KR: ["h", "H", "hB", "hb"],
  KW: ["h", "hB", "hb", "H"],
  KY: ["h", "hb", "H", "hB"],
  KZ: ["H", "hB"],
  LA: ["H", "hb", "hB", "h"],
  LB: ["h", "hB", "hb", "H"],
  LC: ["h", "hb", "H", "hB"],
  LI: ["H", "hB", "h"],
  LK: ["H", "h", "hB", "hb"],
  LR: ["h", "hb", "H", "hB"],
  LS: ["h", "H"],
  LT: ["H", "h", "hb", "hB"],
  LU: ["H", "h", "hB"],
  LV: ["H", "hB", "hb", "h"],
  LY: ["h", "hB", "hb", "H"],
  MA: ["H", "h", "hB", "hb"],
  MC: ["H", "hB"],
  MD: ["H", "hB"],
  ME: ["H", "hB", "h"],
  MF: ["H", "hB"],
  MG: ["H", "h"],
  MH: ["h", "hb", "H", "hB"],
  MK: ["H", "h", "hb", "hB"],
  ML: ["H"],
  MM: ["hB", "hb", "H", "h"],
  MN: ["H", "h", "hb", "hB"],
  MO: ["h", "hB", "hb", "H"],
  MP: ["h", "hb", "H", "hB"],
  MQ: ["H", "hB"],
  MR: ["h", "hB", "hb", "H"],
  MS: ["H", "h", "hb", "hB"],
  MT: ["H", "h"],
  MU: ["H", "h"],
  MV: ["H", "h"],
  MW: ["h", "hb", "H", "hB"],
  MX: ["h", "H", "hB", "hb"],
  MY: ["hb", "hB", "h", "H"],
  MZ: ["H", "hB"],
  NA: ["h", "H", "hB", "hb"],
  NC: ["H", "hB"],
  NE: ["H"],
  NF: ["H", "h", "hb", "hB"],
  NG: ["H", "h", "hb", "hB"],
  NI: ["h", "H", "hB", "hb"],
  NL: ["H", "hB"],
  NO: ["H", "h"],
  NP: ["H", "h", "hB"],
  NR: ["H", "h", "hb", "hB"],
  NU: ["H", "h", "hb", "hB"],
  NZ: ["h", "hb", "H", "hB"],
  OM: ["h", "hB", "hb", "H"],
  PA: ["h", "H", "hB", "hb"],
  PE: ["h", "H", "hB", "hb"],
  PF: ["H", "h", "hB"],
  PG: ["h", "H"],
  PH: ["h", "hB", "hb", "H"],
  PK: ["h", "hB", "H"],
  PL: ["H", "h"],
  PM: ["H", "hB"],
  PN: ["H", "h", "hb", "hB"],
  PR: ["h", "H", "hB", "hb"],
  PS: ["h", "hB", "hb", "H"],
  PT: ["H", "hB"],
  PW: ["h", "H"],
  PY: ["h", "H", "hB", "hb"],
  QA: ["h", "hB", "hb", "H"],
  RE: ["H", "hB"],
  RO: ["H", "hB"],
  RS: ["H", "hB", "h"],
  RU: ["H"],
  RW: ["H", "h"],
  SA: ["h", "hB", "hb", "H"],
  SB: ["h", "hb", "H", "hB"],
  SC: ["H", "h", "hB"],
  SD: ["h", "hB", "hb", "H"],
  SE: ["H"],
  SG: ["h", "hb", "H", "hB"],
  SH: ["H", "h", "hb", "hB"],
  SI: ["H", "hB"],
  SJ: ["H"],
  SK: ["H"],
  SL: ["h", "hb", "H", "hB"],
  SM: ["H", "h", "hB"],
  SN: ["H", "h", "hB"],
  SO: ["h", "H"],
  SR: ["H", "hB"],
  SS: ["h", "hb", "H", "hB"],
  ST: ["H", "hB"],
  SV: ["h", "H", "hB", "hb"],
  SX: ["H", "h", "hb", "hB"],
  SY: ["h", "hB", "hb", "H"],
  SZ: ["h", "hb", "H", "hB"],
  TA: ["H", "h", "hb", "hB"],
  TC: ["h", "hb", "H", "hB"],
  TD: ["h", "H", "hB"],
  TF: ["H", "h", "hB"],
  TG: ["H", "hB"],
  TH: ["H", "h"],
  TJ: ["H", "h"],
  TL: ["H", "hB", "hb", "h"],
  TM: ["H", "h"],
  TN: ["h", "hB", "hb", "H"],
  TO: ["h", "H"],
  TR: ["H", "hB"],
  TT: ["h", "hb", "H", "hB"],
  TW: ["hB", "hb", "h", "H"],
  TZ: ["hB", "hb", "H", "h"],
  UA: ["H", "hB", "h"],
  UG: ["hB", "hb", "H", "h"],
  UM: ["h", "hb", "H", "hB"],
  US: ["h", "hb", "H", "hB"],
  UY: ["h", "H", "hB", "hb"],
  UZ: ["H", "hB", "h"],
  VA: ["H", "h", "hB"],
  VC: ["h", "hb", "H", "hB"],
  VE: ["h", "H", "hB", "hb"],
  VG: ["h", "hb", "H", "hB"],
  VI: ["h", "hb", "H", "hB"],
  VN: ["H", "h"],
  VU: ["h", "H"],
  WF: ["H", "hB"],
  WS: ["h", "H"],
  XK: ["H", "hB", "h"],
  YE: ["h", "hB", "hb", "H"],
  YT: ["H", "hB"],
  ZA: ["H", "h", "hb", "hB"],
  ZM: ["h", "hb", "H", "hB"],
  ZW: ["H", "h"],
  "af-ZA": ["H", "h", "hB", "hb"],
  "ar-001": ["h", "hB", "hb", "H"],
  "ca-ES": ["H", "h", "hB"],
  "en-001": ["h", "hb", "H", "hB"],
  "en-HK": ["h", "hb", "H", "hB"],
  "en-IL": ["H", "h", "hb", "hB"],
  "en-MY": ["h", "hb", "H", "hB"],
  "es-BR": ["H", "h", "hB", "hb"],
  "es-ES": ["H", "h", "hB", "hb"],
  "es-GQ": ["H", "h", "hB", "hb"],
  "fr-CA": ["H", "h", "hB"],
  "gl-ES": ["H", "h", "hB"],
  "gu-IN": ["hB", "hb", "h", "H"],
  "hi-IN": ["hB", "h", "H"],
  "it-CH": ["H", "h", "hB"],
  "it-IT": ["H", "h", "hB"],
  "kn-IN": ["hB", "h", "H"],
  "ml-IN": ["hB", "h", "H"],
  "mr-IN": ["hB", "hb", "h", "H"],
  "pa-IN": ["hB", "hb", "h", "H"],
  "ta-IN": ["hB", "h", "hb", "H"],
  "te-IN": ["hB", "h", "H"],
  "zu-ZA": ["H", "hB", "hb", "h"]
};
function getBestPattern(e, t) {
  for (var r = "", a = 0; a < e.length; a++) {
    var o = e.charAt(a);
    if (o === "j") {
      for (var u = 0; a + 1 < e.length && e.charAt(a + 1) === o; )
        u++, a++;
      var c = 1 + (u & 1), d = u < 2 ? 1 : 3 + (u >> 1), g = "a", b = getDefaultHourSymbolFromLocale(t);
      for ((b == "H" || b == "k") && (d = 0); d-- > 0; )
        r += g;
      for (; c-- > 0; )
        r = b + r;
    } else o === "J" ? r += "H" : r += o;
  }
  return r;
}
function getDefaultHourSymbolFromLocale(e) {
  var t = e.hourCycle;
  if (t === void 0 && // @ts-ignore hourCycle(s) is not identified yet
  e.hourCycles && // @ts-ignore
  e.hourCycles.length && (t = e.hourCycles[0]), t)
    switch (t) {
      case "h24":
        return "k";
      case "h23":
        return "H";
      case "h12":
        return "h";
      case "h11":
        return "K";
      default:
        throw new Error("Invalid hourCycle");
    }
  var r = e.language, a;
  r !== "root" && (a = e.maximize().region);
  var o = timeData[a || ""] || timeData[r || ""] || timeData["".concat(r, "-001")] || timeData["001"];
  return o[0];
}
var _a, SPACE_SEPARATOR_START_REGEX = new RegExp("^".concat(SPACE_SEPARATOR_REGEX.source, "*")), SPACE_SEPARATOR_END_REGEX = new RegExp("".concat(SPACE_SEPARATOR_REGEX.source, "*$"));
function createLocation(e, t) {
  return {
    start: e,
    end: t
  };
}
var hasNativeStartsWith = !!String.prototype.startsWith && "_a".startsWith("a", 1), hasNativeFromCodePoint = !!String.fromCodePoint, hasNativeFromEntries = !!Object.fromEntries, hasNativeCodePointAt = !!String.prototype.codePointAt, hasTrimStart = !!String.prototype.trimStart, hasTrimEnd = !!String.prototype.trimEnd, hasNativeIsSafeInteger = !!Number.isSafeInteger, isSafeInteger = hasNativeIsSafeInteger ? Number.isSafeInteger : function(e) {
  return typeof e == "number" && isFinite(e) && Math.floor(e) === e && Math.abs(e) <= 9007199254740991;
}, REGEX_SUPPORTS_U_AND_Y = !0;
try {
  var re = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec("a")) === null || _a === void 0 ? void 0 : _a[0]) === "a";
} catch (e) {
  REGEX_SUPPORTS_U_AND_Y = !1;
}
var startsWith = hasNativeStartsWith ? (
  // Native
  function e(t, r, a) {
    return t.startsWith(r, a);
  }
) : (
  // For IE11
  function e(t, r, a) {
    return t.slice(a, a + r.length) === r;
  }
), fromCodePoint = hasNativeFromCodePoint ? String.fromCodePoint : (
  // IE11
  function e() {
    for (var t = [], r = 0; r < arguments.length; r++)
      t[r] = arguments[r];
    for (var a = "", o = t.length, u = 0, c; o > u; ) {
      if (c = t[u++], c > 1114111) throw RangeError(c + " is not a valid code point");
      a += c < 65536 ? String.fromCharCode(c) : String.fromCharCode(((c -= 65536) >> 10) + 55296, c % 1024 + 56320);
    }
    return a;
  }
), fromEntries = (
  // native
  hasNativeFromEntries ? Object.fromEntries : (
    // Ponyfill
    function e(t) {
      for (var r = {}, a = 0, o = t; a < o.length; a++) {
        var u = o[a], c = u[0], d = u[1];
        r[c] = d;
      }
      return r;
    }
  )
), codePointAt = hasNativeCodePointAt ? (
  // Native
  function e(t, r) {
    return t.codePointAt(r);
  }
) : (
  // IE 11
  function e(t, r) {
    var a = t.length;
    if (!(r < 0 || r >= a)) {
      var o = t.charCodeAt(r), u;
      return o < 55296 || o > 56319 || r + 1 === a || (u = t.charCodeAt(r + 1)) < 56320 || u > 57343 ? o : (o - 55296 << 10) + (u - 56320) + 65536;
    }
  }
), trimStart = hasTrimStart ? (
  // Native
  function e(t) {
    return t.trimStart();
  }
) : (
  // Ponyfill
  function e(t) {
    return t.replace(SPACE_SEPARATOR_START_REGEX, "");
  }
), trimEnd = hasTrimEnd ? (
  // Native
  function e(t) {
    return t.trimEnd();
  }
) : (
  // Ponyfill
  function e(t) {
    return t.replace(SPACE_SEPARATOR_END_REGEX, "");
  }
);
function RE(e, t) {
  return new RegExp(e, t);
}
var matchIdentifierAtIndex;
if (REGEX_SUPPORTS_U_AND_Y) {
  var IDENTIFIER_PREFIX_RE_1 = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  matchIdentifierAtIndex = function(t, r) {
    var a;
    IDENTIFIER_PREFIX_RE_1.lastIndex = r;
    var o = IDENTIFIER_PREFIX_RE_1.exec(t);
    return (a = o[1]) !== null && a !== void 0 ? a : "";
  };
} else
  matchIdentifierAtIndex = function(t, r) {
    for (var a = []; ; ) {
      var o = codePointAt(t, r);
      if (o === void 0 || _isWhiteSpace(o) || _isPatternSyntax(o))
        break;
      a.push(o), r += o >= 65536 ? 2 : 1;
    }
    return fromCodePoint.apply(void 0, a);
  };
var Parser = (
  /** @class */
  function() {
    function e(t, r) {
      r === void 0 && (r = {}), this.message = t, this.position = {
        offset: 0,
        line: 1,
        column: 1
      }, this.ignoreTag = !!r.ignoreTag, this.locale = r.locale, this.requiresOtherClause = !!r.requiresOtherClause, this.shouldParseSkeletons = !!r.shouldParseSkeletons;
    }
    return e.prototype.parse = function() {
      if (this.offset() !== 0)
        throw Error("parser can only be used once");
      return this.parseMessage(0, "", !1);
    }, e.prototype.parseMessage = function(t, r, a) {
      for (var o = []; !this.isEOF(); ) {
        var u = this.char();
        if (u === 123) {
          var c = this.parseArgument(t, a);
          if (c.err)
            return c;
          o.push(c.val);
        } else {
          if (u === 125 && t > 0)
            break;
          if (u === 35 && (r === "plural" || r === "selectordinal")) {
            var d = this.clonePosition();
            this.bump(), o.push({
              type: TYPE.pound,
              location: createLocation(d, this.clonePosition())
            });
          } else if (u === 60 && !this.ignoreTag && this.peek() === 47) {
            if (a)
              break;
            return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));
          } else if (u === 60 && !this.ignoreTag && _isAlpha(this.peek() || 0)) {
            var c = this.parseTag(t, r);
            if (c.err)
              return c;
            o.push(c.val);
          } else {
            var c = this.parseLiteral(t, r);
            if (c.err)
              return c;
            o.push(c.val);
          }
        }
      }
      return {
        val: o,
        err: null
      };
    }, e.prototype.parseTag = function(t, r) {
      var a = this.clonePosition();
      this.bump();
      var o = this.parseTagName();
      if (this.bumpSpace(), this.bumpIf("/>"))
        return {
          val: {
            type: TYPE.literal,
            value: "<".concat(o, "/>"),
            location: createLocation(a, this.clonePosition())
          },
          err: null
        };
      if (this.bumpIf(">")) {
        var u = this.parseMessage(t + 1, r, !0);
        if (u.err)
          return u;
        var c = u.val, d = this.clonePosition();
        if (this.bumpIf("</")) {
          if (this.isEOF() || !_isAlpha(this.char()))
            return this.error(ErrorKind.INVALID_TAG, createLocation(d, this.clonePosition()));
          var g = this.clonePosition(), b = this.parseTagName();
          return o !== b ? this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(g, this.clonePosition())) : (this.bumpSpace(), this.bumpIf(">") ? {
            val: {
              type: TYPE.tag,
              value: o,
              children: c,
              location: createLocation(a, this.clonePosition())
            },
            err: null
          } : this.error(ErrorKind.INVALID_TAG, createLocation(d, this.clonePosition())));
        } else
          return this.error(ErrorKind.UNCLOSED_TAG, createLocation(a, this.clonePosition()));
      } else
        return this.error(ErrorKind.INVALID_TAG, createLocation(a, this.clonePosition()));
    }, e.prototype.parseTagName = function() {
      var t = this.offset();
      for (this.bump(); !this.isEOF() && _isPotentialElementNameChar(this.char()); )
        this.bump();
      return this.message.slice(t, this.offset());
    }, e.prototype.parseLiteral = function(t, r) {
      for (var a = this.clonePosition(), o = ""; ; ) {
        var u = this.tryParseQuote(r);
        if (u) {
          o += u;
          continue;
        }
        var c = this.tryParseUnquoted(t, r);
        if (c) {
          o += c;
          continue;
        }
        var d = this.tryParseLeftAngleBracket();
        if (d) {
          o += d;
          continue;
        }
        break;
      }
      var g = createLocation(a, this.clonePosition());
      return {
        val: {
          type: TYPE.literal,
          value: o,
          location: g
        },
        err: null
      };
    }, e.prototype.tryParseLeftAngleBracket = function() {
      return !this.isEOF() && this.char() === 60 && (this.ignoreTag || // If at the opening tag or closing tag position, bail.
      !_isAlphaOrSlash(this.peek() || 0)) ? (this.bump(), "<") : null;
    }, e.prototype.tryParseQuote = function(t) {
      if (this.isEOF() || this.char() !== 39)
        return null;
      switch (this.peek()) {
        case 39:
          return this.bump(), this.bump(), "'";
        case 123:
        case 60:
        case 62:
        case 125:
          break;
        case 35:
          if (t === "plural" || t === "selectordinal")
            break;
          return null;
        default:
          return null;
      }
      this.bump();
      var r = [this.char()];
      for (this.bump(); !this.isEOF(); ) {
        var a = this.char();
        if (a === 39)
          if (this.peek() === 39)
            r.push(39), this.bump();
          else {
            this.bump();
            break;
          }
        else
          r.push(a);
        this.bump();
      }
      return fromCodePoint.apply(void 0, r);
    }, e.prototype.tryParseUnquoted = function(t, r) {
      if (this.isEOF())
        return null;
      var a = this.char();
      return a === 60 || a === 123 || a === 35 && (r === "plural" || r === "selectordinal") || a === 125 && t > 0 ? null : (this.bump(), fromCodePoint(a));
    }, e.prototype.parseArgument = function(t, r) {
      var a = this.clonePosition();
      if (this.bump(), this.bumpSpace(), this.isEOF())
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(a, this.clonePosition()));
      if (this.char() === 125)
        return this.bump(), this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(a, this.clonePosition()));
      var o = this.parseIdentifierIfPossible().value;
      if (!o)
        return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(a, this.clonePosition()));
      if (this.bumpSpace(), this.isEOF())
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(a, this.clonePosition()));
      switch (this.char()) {
        case 125:
          return this.bump(), {
            val: {
              type: TYPE.argument,
              // value does not include the opening and closing braces.
              value: o,
              location: createLocation(a, this.clonePosition())
            },
            err: null
          };
        case 44:
          return this.bump(), this.bumpSpace(), this.isEOF() ? this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(a, this.clonePosition())) : this.parseArgumentOptions(t, r, o, a);
        default:
          return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(a, this.clonePosition()));
      }
    }, e.prototype.parseIdentifierIfPossible = function() {
      var t = this.clonePosition(), r = this.offset(), a = matchIdentifierAtIndex(this.message, r), o = r + a.length;
      this.bumpTo(o);
      var u = this.clonePosition(), c = createLocation(t, u);
      return {
        value: a,
        location: c
      };
    }, e.prototype.parseArgumentOptions = function(t, r, a, o) {
      var u, c = this.clonePosition(), d = this.parseIdentifierIfPossible().value, g = this.clonePosition();
      switch (d) {
        case "":
          return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(c, g));
        case "number":
        case "date":
        case "time": {
          this.bumpSpace();
          var b = null;
          if (this.bumpIf(",")) {
            this.bumpSpace();
            var _ = this.clonePosition(), y = this.parseSimpleArgStyleIfPossible();
            if (y.err)
              return y;
            var A = trimEnd(y.val);
            if (A.length === 0)
              return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));
            var E = createLocation(_, this.clonePosition());
            b = {
              style: A,
              styleLocation: E
            };
          }
          var v = this.tryParseArgumentClose(o);
          if (v.err)
            return v;
          var C = createLocation(o, this.clonePosition());
          if (b && startsWith(b == null ? void 0 : b.style, "::", 0)) {
            var R = trimStart(b.style.slice(2));
            if (d === "number") {
              var y = this.parseNumberSkeletonFromString(R, b.styleLocation);
              return y.err ? y : {
                val: {
                  type: TYPE.number,
                  value: a,
                  location: C,
                  style: y.val
                },
                err: null
              };
            } else {
              if (R.length === 0)
                return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, C);
              var I = R;
              this.locale && (I = getBestPattern(R, this.locale));
              var A = {
                type: SKELETON_TYPE.dateTime,
                pattern: I,
                location: b.styleLocation,
                parsedOptions: this.shouldParseSkeletons ? parseDateTimeSkeleton(I) : {}
              }, w = d === "date" ? TYPE.date : TYPE.time;
              return {
                val: {
                  type: w,
                  value: a,
                  location: C,
                  style: A
                },
                err: null
              };
            }
          }
          return {
            val: {
              type: d === "number" ? TYPE.number : d === "date" ? TYPE.date : TYPE.time,
              value: a,
              location: C,
              style: (u = b == null ? void 0 : b.style) !== null && u !== void 0 ? u : null
            },
            err: null
          };
        }
        case "plural":
        case "selectordinal":
        case "select": {
          var N = this.clonePosition();
          if (this.bumpSpace(), !this.bumpIf(","))
            return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(N, __assign({}, N)));
          this.bumpSpace();
          var F = this.parseIdentifierIfPossible(), M = 0;
          if (d !== "select" && F.value === "offset") {
            if (!this.bumpIf(":"))
              return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));
            this.bumpSpace();
            var y = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
            if (y.err)
              return y;
            this.bumpSpace(), F = this.parseIdentifierIfPossible(), M = y.val;
          }
          var x = this.tryParsePluralOrSelectOptions(t, d, r, F);
          if (x.err)
            return x;
          var v = this.tryParseArgumentClose(o);
          if (v.err)
            return v;
          var P = createLocation(o, this.clonePosition());
          return d === "select" ? {
            val: {
              type: TYPE.select,
              value: a,
              options: fromEntries(x.val),
              location: P
            },
            err: null
          } : {
            val: {
              type: TYPE.plural,
              value: a,
              options: fromEntries(x.val),
              offset: M,
              pluralType: d === "plural" ? "cardinal" : "ordinal",
              location: P
            },
            err: null
          };
        }
        default:
          return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(c, g));
      }
    }, e.prototype.tryParseArgumentClose = function(t) {
      return this.isEOF() || this.char() !== 125 ? this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(t, this.clonePosition())) : (this.bump(), {
        val: !0,
        err: null
      });
    }, e.prototype.parseSimpleArgStyleIfPossible = function() {
      for (var t = 0, r = this.clonePosition(); !this.isEOF(); ) {
        var a = this.char();
        switch (a) {
          case 39: {
            this.bump();
            var o = this.clonePosition();
            if (!this.bumpUntil("'"))
              return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(o, this.clonePosition()));
            this.bump();
            break;
          }
          case 123: {
            t += 1, this.bump();
            break;
          }
          case 125: {
            if (t > 0)
              t -= 1;
            else
              return {
                val: this.message.slice(r.offset, this.offset()),
                err: null
              };
            break;
          }
          default:
            this.bump();
            break;
        }
      }
      return {
        val: this.message.slice(r.offset, this.offset()),
        err: null
      };
    }, e.prototype.parseNumberSkeletonFromString = function(t, r) {
      var a = [];
      try {
        a = parseNumberSkeletonFromString(t);
      } catch {
        return this.error(ErrorKind.INVALID_NUMBER_SKELETON, r);
      }
      return {
        val: {
          type: SKELETON_TYPE.number,
          tokens: a,
          location: r,
          parsedOptions: this.shouldParseSkeletons ? parseNumberSkeleton(a) : {}
        },
        err: null
      };
    }, e.prototype.tryParsePluralOrSelectOptions = function(t, r, a, o) {
      for (var u, c = !1, d = [], g = /* @__PURE__ */ new Set(), b = o.value, _ = o.location; ; ) {
        if (b.length === 0) {
          var y = this.clonePosition();
          if (r !== "select" && this.bumpIf("=")) {
            var A = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);
            if (A.err)
              return A;
            _ = createLocation(y, this.clonePosition()), b = this.message.slice(y.offset, this.offset());
          } else
            break;
        }
        if (g.has(b))
          return this.error(r === "select" ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, _);
        b === "other" && (c = !0), this.bumpSpace();
        var E = this.clonePosition();
        if (!this.bumpIf("{"))
          return this.error(r === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));
        var v = this.parseMessage(t + 1, r, a);
        if (v.err)
          return v;
        var C = this.tryParseArgumentClose(E);
        if (C.err)
          return C;
        d.push([b, {
          value: v.val,
          location: createLocation(E, this.clonePosition())
        }]), g.add(b), this.bumpSpace(), u = this.parseIdentifierIfPossible(), b = u.value, _ = u.location;
      }
      return d.length === 0 ? this.error(r === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition())) : this.requiresOtherClause && !c ? this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition())) : {
        val: d,
        err: null
      };
    }, e.prototype.tryParseDecimalInteger = function(t, r) {
      var a = 1, o = this.clonePosition();
      this.bumpIf("+") || this.bumpIf("-") && (a = -1);
      for (var u = !1, c = 0; !this.isEOF(); ) {
        var d = this.char();
        if (d >= 48 && d <= 57)
          u = !0, c = c * 10 + (d - 48), this.bump();
        else
          break;
      }
      var g = createLocation(o, this.clonePosition());
      return u ? (c *= a, isSafeInteger(c) ? {
        val: c,
        err: null
      } : this.error(r, g)) : this.error(t, g);
    }, e.prototype.offset = function() {
      return this.position.offset;
    }, e.prototype.isEOF = function() {
      return this.offset() === this.message.length;
    }, e.prototype.clonePosition = function() {
      return {
        offset: this.position.offset,
        line: this.position.line,
        column: this.position.column
      };
    }, e.prototype.char = function() {
      var t = this.position.offset;
      if (t >= this.message.length)
        throw Error("out of bound");
      var r = codePointAt(this.message, t);
      if (r === void 0)
        throw Error("Offset ".concat(t, " is at invalid UTF-16 code unit boundary"));
      return r;
    }, e.prototype.error = function(t, r) {
      return {
        val: null,
        err: {
          kind: t,
          message: this.message,
          location: r
        }
      };
    }, e.prototype.bump = function() {
      if (!this.isEOF()) {
        var t = this.char();
        t === 10 ? (this.position.line += 1, this.position.column = 1, this.position.offset += 1) : (this.position.column += 1, this.position.offset += t < 65536 ? 1 : 2);
      }
    }, e.prototype.bumpIf = function(t) {
      if (startsWith(this.message, t, this.offset())) {
        for (var r = 0; r < t.length; r++)
          this.bump();
        return !0;
      }
      return !1;
    }, e.prototype.bumpUntil = function(t) {
      var r = this.offset(), a = this.message.indexOf(t, r);
      return a >= 0 ? (this.bumpTo(a), !0) : (this.bumpTo(this.message.length), !1);
    }, e.prototype.bumpTo = function(t) {
      if (this.offset() > t)
        throw Error("targetOffset ".concat(t, " must be greater than or equal to the current offset ").concat(this.offset()));
      for (t = Math.min(t, this.message.length); ; ) {
        var r = this.offset();
        if (r === t)
          break;
        if (r > t)
          throw Error("targetOffset ".concat(t, " is at invalid UTF-16 code unit boundary"));
        if (this.bump(), this.isEOF())
          break;
      }
    }, e.prototype.bumpSpace = function() {
      for (; !this.isEOF() && _isWhiteSpace(this.char()); )
        this.bump();
    }, e.prototype.peek = function() {
      if (this.isEOF())
        return null;
      var t = this.char(), r = this.offset(), a = this.message.charCodeAt(r + (t >= 65536 ? 2 : 1));
      return a ?? null;
    }, e;
  }()
);
function _isAlpha(e) {
  return e >= 97 && e <= 122 || e >= 65 && e <= 90;
}
function _isAlphaOrSlash(e) {
  return _isAlpha(e) || e === 47;
}
function _isPotentialElementNameChar(e) {
  return e === 45 || e === 46 || e >= 48 && e <= 57 || e === 95 || e >= 97 && e <= 122 || e >= 65 && e <= 90 || e == 183 || e >= 192 && e <= 214 || e >= 216 && e <= 246 || e >= 248 && e <= 893 || e >= 895 && e <= 8191 || e >= 8204 && e <= 8205 || e >= 8255 && e <= 8256 || e >= 8304 && e <= 8591 || e >= 11264 && e <= 12271 || e >= 12289 && e <= 55295 || e >= 63744 && e <= 64975 || e >= 65008 && e <= 65533 || e >= 65536 && e <= 983039;
}
function _isWhiteSpace(e) {
  return e >= 9 && e <= 13 || e === 32 || e === 133 || e >= 8206 && e <= 8207 || e === 8232 || e === 8233;
}
function _isPatternSyntax(e) {
  return e >= 33 && e <= 35 || e === 36 || e >= 37 && e <= 39 || e === 40 || e === 41 || e === 42 || e === 43 || e === 44 || e === 45 || e >= 46 && e <= 47 || e >= 58 && e <= 59 || e >= 60 && e <= 62 || e >= 63 && e <= 64 || e === 91 || e === 92 || e === 93 || e === 94 || e === 96 || e === 123 || e === 124 || e === 125 || e === 126 || e === 161 || e >= 162 && e <= 165 || e === 166 || e === 167 || e === 169 || e === 171 || e === 172 || e === 174 || e === 176 || e === 177 || e === 182 || e === 187 || e === 191 || e === 215 || e === 247 || e >= 8208 && e <= 8213 || e >= 8214 && e <= 8215 || e === 8216 || e === 8217 || e === 8218 || e >= 8219 && e <= 8220 || e === 8221 || e === 8222 || e === 8223 || e >= 8224 && e <= 8231 || e >= 8240 && e <= 8248 || e === 8249 || e === 8250 || e >= 8251 && e <= 8254 || e >= 8257 && e <= 8259 || e === 8260 || e === 8261 || e === 8262 || e >= 8263 && e <= 8273 || e === 8274 || e === 8275 || e >= 8277 && e <= 8286 || e >= 8592 && e <= 8596 || e >= 8597 && e <= 8601 || e >= 8602 && e <= 8603 || e >= 8604 && e <= 8607 || e === 8608 || e >= 8609 && e <= 8610 || e === 8611 || e >= 8612 && e <= 8613 || e === 8614 || e >= 8615 && e <= 8621 || e === 8622 || e >= 8623 && e <= 8653 || e >= 8654 && e <= 8655 || e >= 8656 && e <= 8657 || e === 8658 || e === 8659 || e === 8660 || e >= 8661 && e <= 8691 || e >= 8692 && e <= 8959 || e >= 8960 && e <= 8967 || e === 8968 || e === 8969 || e === 8970 || e === 8971 || e >= 8972 && e <= 8991 || e >= 8992 && e <= 8993 || e >= 8994 && e <= 9e3 || e === 9001 || e === 9002 || e >= 9003 && e <= 9083 || e === 9084 || e >= 9085 && e <= 9114 || e >= 9115 && e <= 9139 || e >= 9140 && e <= 9179 || e >= 9180 && e <= 9185 || e >= 9186 && e <= 9254 || e >= 9255 && e <= 9279 || e >= 9280 && e <= 9290 || e >= 9291 && e <= 9311 || e >= 9472 && e <= 9654 || e === 9655 || e >= 9656 && e <= 9664 || e === 9665 || e >= 9666 && e <= 9719 || e >= 9720 && e <= 9727 || e >= 9728 && e <= 9838 || e === 9839 || e >= 9840 && e <= 10087 || e === 10088 || e === 10089 || e === 10090 || e === 10091 || e === 10092 || e === 10093 || e === 10094 || e === 10095 || e === 10096 || e === 10097 || e === 10098 || e === 10099 || e === 10100 || e === 10101 || e >= 10132 && e <= 10175 || e >= 10176 && e <= 10180 || e === 10181 || e === 10182 || e >= 10183 && e <= 10213 || e === 10214 || e === 10215 || e === 10216 || e === 10217 || e === 10218 || e === 10219 || e === 10220 || e === 10221 || e === 10222 || e === 10223 || e >= 10224 && e <= 10239 || e >= 10240 && e <= 10495 || e >= 10496 && e <= 10626 || e === 10627 || e === 10628 || e === 10629 || e === 10630 || e === 10631 || e === 10632 || e === 10633 || e === 10634 || e === 10635 || e === 10636 || e === 10637 || e === 10638 || e === 10639 || e === 10640 || e === 10641 || e === 10642 || e === 10643 || e === 10644 || e === 10645 || e === 10646 || e === 10647 || e === 10648 || e >= 10649 && e <= 10711 || e === 10712 || e === 10713 || e === 10714 || e === 10715 || e >= 10716 && e <= 10747 || e === 10748 || e === 10749 || e >= 10750 && e <= 11007 || e >= 11008 && e <= 11055 || e >= 11056 && e <= 11076 || e >= 11077 && e <= 11078 || e >= 11079 && e <= 11084 || e >= 11085 && e <= 11123 || e >= 11124 && e <= 11125 || e >= 11126 && e <= 11157 || e === 11158 || e >= 11159 && e <= 11263 || e >= 11776 && e <= 11777 || e === 11778 || e === 11779 || e === 11780 || e === 11781 || e >= 11782 && e <= 11784 || e === 11785 || e === 11786 || e === 11787 || e === 11788 || e === 11789 || e >= 11790 && e <= 11798 || e === 11799 || e >= 11800 && e <= 11801 || e === 11802 || e === 11803 || e === 11804 || e === 11805 || e >= 11806 && e <= 11807 || e === 11808 || e === 11809 || e === 11810 || e === 11811 || e === 11812 || e === 11813 || e === 11814 || e === 11815 || e === 11816 || e === 11817 || e >= 11818 && e <= 11822 || e === 11823 || e >= 11824 && e <= 11833 || e >= 11834 && e <= 11835 || e >= 11836 && e <= 11839 || e === 11840 || e === 11841 || e === 11842 || e >= 11843 && e <= 11855 || e >= 11856 && e <= 11857 || e === 11858 || e >= 11859 && e <= 11903 || e >= 12289 && e <= 12291 || e === 12296 || e === 12297 || e === 12298 || e === 12299 || e === 12300 || e === 12301 || e === 12302 || e === 12303 || e === 12304 || e === 12305 || e >= 12306 && e <= 12307 || e === 12308 || e === 12309 || e === 12310 || e === 12311 || e === 12312 || e === 12313 || e === 12314 || e === 12315 || e === 12316 || e === 12317 || e >= 12318 && e <= 12319 || e === 12320 || e === 12336 || e === 64830 || e === 64831 || e >= 65093 && e <= 65094;
}
function pruneLocation(e) {
  e.forEach(function(t) {
    if (delete t.location, isSelectElement(t) || isPluralElement(t))
      for (var r in t.options)
        delete t.options[r].location, pruneLocation(t.options[r].value);
    else isNumberElement(t) && isNumberSkeleton(t.style) || (isDateElement(t) || isTimeElement(t)) && isDateTimeSkeleton(t.style) ? delete t.style.location : isTagElement(t) && pruneLocation(t.children);
  });
}
function parse(e, t) {
  t === void 0 && (t = {}), t = __assign({
    shouldParseSkeletons: !0,
    requiresOtherClause: !0
  }, t);
  var r = new Parser(e, t).parse();
  if (r.err) {
    var a = SyntaxError(ErrorKind[r.err.kind]);
    throw a.location = r.err.location, a.originalMessage = r.err.message, a;
  }
  return t != null && t.captureLocation || pruneLocation(r.val), r.val;
}
var ErrorCode;
(function(e) {
  e.MISSING_VALUE = "MISSING_VALUE", e.INVALID_VALUE = "INVALID_VALUE", e.MISSING_INTL_API = "MISSING_INTL_API";
})(ErrorCode || (ErrorCode = {}));
var FormatError = (
  /** @class */
  function(e) {
    __extends(t, e);
    function t(r, a, o) {
      var u = e.call(this, r) || this;
      return u.code = a, u.originalMessage = o, u;
    }
    return t.prototype.toString = function() {
      return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
    }, t;
  }(Error)
), InvalidValueError = (
  /** @class */
  function(e) {
    __extends(t, e);
    function t(r, a, o, u) {
      return e.call(this, 'Invalid values for "'.concat(r, '": "').concat(a, '". Options are "').concat(Object.keys(o).join('", "'), '"'), ErrorCode.INVALID_VALUE, u) || this;
    }
    return t;
  }(FormatError)
), InvalidValueTypeError = (
  /** @class */
  function(e) {
    __extends(t, e);
    function t(r, a, o) {
      return e.call(this, 'Value for "'.concat(r, '" must be of type ').concat(a), ErrorCode.INVALID_VALUE, o) || this;
    }
    return t;
  }(FormatError)
), MissingValueError = (
  /** @class */
  function(e) {
    __extends(t, e);
    function t(r, a) {
      return e.call(this, 'The intl string context variable "'.concat(r, '" was not provided to the string "').concat(a, '"'), ErrorCode.MISSING_VALUE, a) || this;
    }
    return t;
  }(FormatError)
), PART_TYPE;
(function(e) {
  e[e.literal = 0] = "literal", e[e.object = 1] = "object";
})(PART_TYPE || (PART_TYPE = {}));
function mergeLiteral(e) {
  return e.length < 2 ? e : e.reduce(function(t, r) {
    var a = t[t.length - 1];
    return !a || a.type !== PART_TYPE.literal || r.type !== PART_TYPE.literal ? t.push(r) : a.value += r.value, t;
  }, []);
}
function isFormatXMLElementFn(e) {
  return typeof e == "function";
}
function formatToParts(e, t, r, a, o, u, c) {
  if (e.length === 1 && isLiteralElement(e[0]))
    return [{
      type: PART_TYPE.literal,
      value: e[0].value
    }];
  for (var d = [], g = 0, b = e; g < b.length; g++) {
    var _ = b[g];
    if (isLiteralElement(_)) {
      d.push({
        type: PART_TYPE.literal,
        value: _.value
      });
      continue;
    }
    if (isPoundElement(_)) {
      typeof u == "number" && d.push({
        type: PART_TYPE.literal,
        value: r.getNumberFormat(t).format(u)
      });
      continue;
    }
    var y = _.value;
    if (!(o && y in o))
      throw new MissingValueError(y, c);
    var A = o[y];
    if (isArgumentElement(_)) {
      (!A || typeof A == "string" || typeof A == "number") && (A = typeof A == "string" || typeof A == "number" ? String(A) : ""), d.push({
        type: typeof A == "string" ? PART_TYPE.literal : PART_TYPE.object,
        value: A
      });
      continue;
    }
    if (isDateElement(_)) {
      var E = typeof _.style == "string" ? a.date[_.style] : isDateTimeSkeleton(_.style) ? _.style.parsedOptions : void 0;
      d.push({
        type: PART_TYPE.literal,
        value: r.getDateTimeFormat(t, E).format(A)
      });
      continue;
    }
    if (isTimeElement(_)) {
      var E = typeof _.style == "string" ? a.time[_.style] : isDateTimeSkeleton(_.style) ? _.style.parsedOptions : a.time.medium;
      d.push({
        type: PART_TYPE.literal,
        value: r.getDateTimeFormat(t, E).format(A)
      });
      continue;
    }
    if (isNumberElement(_)) {
      var E = typeof _.style == "string" ? a.number[_.style] : isNumberSkeleton(_.style) ? _.style.parsedOptions : void 0;
      E && E.scale && (A = A * (E.scale || 1)), d.push({
        type: PART_TYPE.literal,
        value: r.getNumberFormat(t, E).format(A)
      });
      continue;
    }
    if (isTagElement(_)) {
      var v = _.children, C = _.value, R = o[C];
      if (!isFormatXMLElementFn(R))
        throw new InvalidValueTypeError(C, "function", c);
      var I = formatToParts(v, t, r, a, o, u), w = R(I.map(function(M) {
        return M.value;
      }));
      Array.isArray(w) || (w = [w]), d.push.apply(d, w.map(function(M) {
        return {
          type: typeof M == "string" ? PART_TYPE.literal : PART_TYPE.object,
          value: M
        };
      }));
    }
    if (isSelectElement(_)) {
      var N = _.options[A] || _.options.other;
      if (!N)
        throw new InvalidValueError(_.value, A, Object.keys(_.options), c);
      d.push.apply(d, formatToParts(N.value, t, r, a, o));
      continue;
    }
    if (isPluralElement(_)) {
      var N = _.options["=".concat(A)];
      if (!N) {
        if (!Intl.PluralRules)
          throw new FormatError(`Intl.PluralRules is not available in this environment.
Try polyfilling it using "@formatjs/intl-pluralrules"
`, ErrorCode.MISSING_INTL_API, c);
        var F = r.getPluralRules(t, {
          type: _.pluralType
        }).select(A - (_.offset || 0));
        N = _.options[F] || _.options.other;
      }
      if (!N)
        throw new InvalidValueError(_.value, A, Object.keys(_.options), c);
      d.push.apply(d, formatToParts(N.value, t, r, a, o, A - (_.offset || 0)));
      continue;
    }
  }
  return mergeLiteral(d);
}
function mergeConfig(e, t) {
  return t ? __assign(__assign(__assign({}, e || {}), t || {}), Object.keys(e).reduce(function(r, a) {
    return r[a] = __assign(__assign({}, e[a]), t[a] || {}), r;
  }, {})) : e;
}
function mergeConfigs(e, t) {
  return t ? Object.keys(e).reduce(function(r, a) {
    return r[a] = mergeConfig(e[a], t[a]), r;
  }, __assign({}, e)) : e;
}
function createFastMemoizeCache(e) {
  return {
    create: function() {
      return {
        get: function(t) {
          return e[t];
        },
        set: function(t, r) {
          e[t] = r;
        }
      };
    }
  };
}
function createDefaultFormatters(e) {
  return e === void 0 && (e = {
    number: {},
    dateTime: {},
    pluralRules: {}
  }), {
    getNumberFormat: memoize(function() {
      for (var t, r = [], a = 0; a < arguments.length; a++)
        r[a] = arguments[a];
      return new ((t = Intl.NumberFormat).bind.apply(t, __spreadArray([void 0], r, !1)))();
    }, {
      cache: createFastMemoizeCache(e.number),
      strategy: strategies.variadic
    }),
    getDateTimeFormat: memoize(function() {
      for (var t, r = [], a = 0; a < arguments.length; a++)
        r[a] = arguments[a];
      return new ((t = Intl.DateTimeFormat).bind.apply(t, __spreadArray([void 0], r, !1)))();
    }, {
      cache: createFastMemoizeCache(e.dateTime),
      strategy: strategies.variadic
    }),
    getPluralRules: memoize(function() {
      for (var t, r = [], a = 0; a < arguments.length; a++)
        r[a] = arguments[a];
      return new ((t = Intl.PluralRules).bind.apply(t, __spreadArray([void 0], r, !1)))();
    }, {
      cache: createFastMemoizeCache(e.pluralRules),
      strategy: strategies.variadic
    })
  };
}
var IntlMessageFormat = (
  /** @class */
  function() {
    function e(t, r, a, o) {
      r === void 0 && (r = e.defaultLocale);
      var u = this;
      if (this.formatterCache = {
        number: {},
        dateTime: {},
        pluralRules: {}
      }, this.format = function(g) {
        var b = u.formatToParts(g);
        if (b.length === 1)
          return b[0].value;
        var _ = b.reduce(function(y, A) {
          return !y.length || A.type !== PART_TYPE.literal || typeof y[y.length - 1] != "string" ? y.push(A.value) : y[y.length - 1] += A.value, y;
        }, []);
        return _.length <= 1 ? _[0] || "" : _;
      }, this.formatToParts = function(g) {
        return formatToParts(u.ast, u.locales, u.formatters, u.formats, g, void 0, u.message);
      }, this.resolvedOptions = function() {
        var g;
        return {
          locale: ((g = u.resolvedLocale) === null || g === void 0 ? void 0 : g.toString()) || Intl.NumberFormat.supportedLocalesOf(u.locales)[0]
        };
      }, this.getAst = function() {
        return u.ast;
      }, this.locales = r, this.resolvedLocale = e.resolveLocale(r), typeof t == "string") {
        if (this.message = t, !e.__parse)
          throw new TypeError("IntlMessageFormat.__parse must be set to process `message` of type `string`");
        var c = o || {};
        c.formatters;
        var d = __rest(c, ["formatters"]);
        this.ast = e.__parse(t, __assign(__assign({}, d), {
          locale: this.resolvedLocale
        }));
      } else
        this.ast = t;
      if (!Array.isArray(this.ast))
        throw new TypeError("A message must be provided as a String or AST.");
      this.formats = mergeConfigs(e.formats, a), this.formatters = o && o.formatters || createDefaultFormatters(this.formatterCache);
    }
    return Object.defineProperty(e, "defaultLocale", {
      get: function() {
        return e.memoizedDefaultLocale || (e.memoizedDefaultLocale = new Intl.NumberFormat().resolvedOptions().locale), e.memoizedDefaultLocale;
      },
      enumerable: !1,
      configurable: !0
    }), e.memoizedDefaultLocale = null, e.resolveLocale = function(t) {
      if (!(typeof Intl.Locale > "u")) {
        var r = Intl.NumberFormat.supportedLocalesOf(t);
        return r.length > 0 ? new Intl.Locale(r[0]) : new Intl.Locale(typeof t == "string" ? t : t[0]);
      }
    }, e.__parse = parse, e.formats = {
      number: {
        integer: {
          maximumFractionDigits: 0
        },
        currency: {
          style: "currency"
        },
        percent: {
          style: "percent"
        }
      },
      date: {
        short: {
          month: "numeric",
          day: "numeric",
          year: "2-digit"
        },
        medium: {
          month: "short",
          day: "numeric",
          year: "numeric"
        },
        long: {
          month: "long",
          day: "numeric",
          year: "numeric"
        },
        full: {
          weekday: "long",
          month: "long",
          day: "numeric",
          year: "numeric"
        }
      },
      time: {
        short: {
          hour: "numeric",
          minute: "numeric"
        },
        medium: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric"
        },
        long: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short"
        },
        full: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short"
        }
      }
    }, e;
  }()
);
function delve(e, t) {
  if (t == null) return;
  if (t in e)
    return e[t];
  const r = t.split(".");
  let a = e;
  for (let o = 0; o < r.length; o++)
    if (typeof a == "object") {
      if (o > 0) {
        const u = r.slice(o, r.length).join(".");
        if (u in a) {
          a = a[u];
          break;
        }
      }
      a = a[r[o]];
    } else
      a = void 0;
  return a;
}
const lookupCache = {}, addToCache = (e, t, r) => r && (t in lookupCache || (lookupCache[t] = {}), e in lookupCache[t] || (lookupCache[t][e] = r), r), lookup = (e, t) => {
  if (t == null) return;
  if (t in lookupCache && e in lookupCache[t])
    return lookupCache[t][e];
  const r = getPossibleLocales(t);
  for (let a = 0; a < r.length; a++) {
    const o = r[a], u = getMessageFromDictionary(o, e);
    if (u)
      return addToCache(e, t, u);
  }
};
let dictionary;
const $dictionary = writable({});
function getLocaleDictionary(e) {
  return dictionary[e] || null;
}
function hasLocaleDictionary(e) {
  return e in dictionary;
}
function getMessageFromDictionary(e, t) {
  if (!hasLocaleDictionary(e))
    return null;
  const r = getLocaleDictionary(e);
  return delve(r, t);
}
function getClosestAvailableLocale(e) {
  if (e == null) return;
  const t = getPossibleLocales(e);
  for (let r = 0; r < t.length; r++) {
    const a = t[r];
    if (hasLocaleDictionary(a))
      return a;
  }
}
function addMessages(e, ...t) {
  delete lookupCache[e], $dictionary.update((r) => (r[e] = deepmerge$1.all([r[e] || {}, ...t]), r));
}
derived([$dictionary], ([e]) => Object.keys(e));
$dictionary.subscribe((e) => dictionary = e);
const queue = {};
function removeLoaderFromQueue(e, t) {
  queue[e].delete(t), queue[e].size === 0 && delete queue[e];
}
function getLocaleQueue(e) {
  return queue[e];
}
function getLocalesQueues(e) {
  return getPossibleLocales(e).map((t) => {
    const r = getLocaleQueue(t);
    return [t, r ? [...r] : []];
  }).filter(([, t]) => t.length > 0);
}
function hasLocaleQueue(e) {
  return e == null ? !1 : getPossibleLocales(e).some((t) => {
    var r;
    return (r = getLocaleQueue(t)) == null ? void 0 : r.size;
  });
}
function loadLocaleQueue(e, t) {
  return Promise.all(t.map((a) => (removeLoaderFromQueue(e, a), a().then((o) => o.default || o)))).then((a) => addMessages(e, ...a));
}
const activeFlushes = {};
function flush(e) {
  if (!hasLocaleQueue(e))
    return e in activeFlushes ? activeFlushes[e] : Promise.resolve();
  const t = getLocalesQueues(e);
  return activeFlushes[e] = Promise.all(t.map(([r, a]) => loadLocaleQueue(r, a))).then(() => {
    if (hasLocaleQueue(e))
      return flush(e);
    delete activeFlushes[e];
  }), activeFlushes[e];
}
const defaultFormats = {
  number: {
    scientific: {
      notation: "scientific"
    },
    engineering: {
      notation: "engineering"
    },
    compactLong: {
      notation: "compact",
      compactDisplay: "long"
    },
    compactShort: {
      notation: "compact",
      compactDisplay: "short"
    }
  },
  date: {
    short: {
      month: "numeric",
      day: "numeric",
      year: "2-digit"
    },
    medium: {
      month: "short",
      day: "numeric",
      year: "numeric"
    },
    long: {
      month: "long",
      day: "numeric",
      year: "numeric"
    },
    full: {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    }
  },
  time: {
    short: {
      hour: "numeric",
      minute: "numeric"
    },
    medium: {
      hour: "numeric",
      minute: "numeric",
      second: "numeric"
    },
    long: {
      hour: "numeric",
      minute: "numeric",
      second: "numeric",
      timeZoneName: "short"
    },
    full: {
      hour: "numeric",
      minute: "numeric",
      second: "numeric",
      timeZoneName: "short"
    }
  }
}, defaultOptions = {
  fallbackLocale: null,
  loadingDelay: 200,
  formats: defaultFormats,
  warnOnMissingMessages: !0,
  handleMissingMessage: void 0,
  ignoreTag: !0
}, options = defaultOptions;
function getOptions() {
  return options;
}
const $isLoading = writable(!1);
var __defProp$1 = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (e, t, r) => t in e ? __defProp$1(e, t, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: r
}) : e[t] = r, __spreadValues$1 = (e, t) => {
  for (var r in t || (t = {})) __hasOwnProp$1.call(t, r) && __defNormalProp$1(e, r, t[r]);
  if (__getOwnPropSymbols$1) for (var r of __getOwnPropSymbols$1(t))
    __propIsEnum$1.call(t, r) && __defNormalProp$1(e, r, t[r]);
  return e;
}, __spreadProps = (e, t) => __defProps(e, __getOwnPropDescs(t));
let current;
const internalLocale = writable(null);
function getSubLocales(e) {
  return e.split("-").map((t, r, a) => a.slice(0, r + 1).join("-")).reverse();
}
function getPossibleLocales(e, t = getOptions().fallbackLocale) {
  const r = getSubLocales(e);
  return t ? [.../* @__PURE__ */ new Set([...r, ...getSubLocales(t)])] : r;
}
function getCurrentLocale() {
  return current ?? void 0;
}
internalLocale.subscribe((e) => {
  current = e ?? void 0, typeof window < "u" && e != null && document.documentElement.setAttribute("lang", e);
});
const set = (e) => {
  if (e && getClosestAvailableLocale(e) && hasLocaleQueue(e)) {
    const {
      loadingDelay: t
    } = getOptions();
    let r;
    return typeof window < "u" && getCurrentLocale() != null && t ? r = window.setTimeout(() => $isLoading.set(!0), t) : $isLoading.set(!0), flush(e).then(() => {
      internalLocale.set(e);
    }).finally(() => {
      clearTimeout(r), $isLoading.set(!1);
    });
  }
  return internalLocale.set(e);
}, $locale = __spreadProps(__spreadValues$1({}, internalLocale), {
  set
}), getLocaleFromNavigator = () => typeof window > "u" ? null : window.navigator.language || window.navigator.languages[0], monadicMemoize = (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (a) => {
    const o = JSON.stringify(a);
    return o in t ? t[o] : t[o] = e(a);
  };
};
var __defProp = Object.defineProperty, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (e, t, r) => t in e ? __defProp(e, t, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: r
}) : e[t] = r, __spreadValues = (e, t) => {
  for (var r in t || (t = {})) __hasOwnProp.call(t, r) && __defNormalProp(e, r, t[r]);
  if (__getOwnPropSymbols) for (var r of __getOwnPropSymbols(t))
    __propIsEnum.call(t, r) && __defNormalProp(e, r, t[r]);
  return e;
}, __objRest = (e, t) => {
  var r = {};
  for (var a in e) __hasOwnProp.call(e, a) && t.indexOf(a) < 0 && (r[a] = e[a]);
  if (e != null && __getOwnPropSymbols) for (var a of __getOwnPropSymbols(e))
    t.indexOf(a) < 0 && __propIsEnum.call(e, a) && (r[a] = e[a]);
  return r;
};
const getIntlFormatterOptions = (e, t) => {
  const {
    formats: r
  } = getOptions();
  if (e in r && t in r[e])
    return r[e][t];
  throw new Error(`[svelte-i18n] Unknown "${t}" ${e} format.`);
}, createNumberFormatter = monadicMemoize((e) => {
  var t = e, {
    locale: r,
    format: a
  } = t, o = __objRest(t, ["locale", "format"]);
  if (r == null)
    throw new Error('[svelte-i18n] A "locale" must be set to format numbers');
  return a && (o = getIntlFormatterOptions("number", a)), new Intl.NumberFormat(r, o);
}), createDateFormatter = monadicMemoize((e) => {
  var t = e, {
    locale: r,
    format: a
  } = t, o = __objRest(t, ["locale", "format"]);
  if (r == null)
    throw new Error('[svelte-i18n] A "locale" must be set to format dates');
  return a ? o = getIntlFormatterOptions("date", a) : Object.keys(o).length === 0 && (o = getIntlFormatterOptions("date", "short")), new Intl.DateTimeFormat(r, o);
}), createTimeFormatter = monadicMemoize((e) => {
  var t = e, {
    locale: r,
    format: a
  } = t, o = __objRest(t, ["locale", "format"]);
  if (r == null)
    throw new Error('[svelte-i18n] A "locale" must be set to format time values');
  return a ? o = getIntlFormatterOptions("time", a) : Object.keys(o).length === 0 && (o = getIntlFormatterOptions("time", "short")), new Intl.DateTimeFormat(r, o);
}), getNumberFormatter = (e = {}) => {
  var t = e, {
    locale: r = getCurrentLocale()
  } = t, a = __objRest(t, ["locale"]);
  return createNumberFormatter(__spreadValues({
    locale: r
  }, a));
}, getDateFormatter = (e = {}) => {
  var t = e, {
    locale: r = getCurrentLocale()
  } = t, a = __objRest(t, ["locale"]);
  return createDateFormatter(__spreadValues({
    locale: r
  }, a));
}, getTimeFormatter = (e = {}) => {
  var t = e, {
    locale: r = getCurrentLocale()
  } = t, a = __objRest(t, ["locale"]);
  return createTimeFormatter(__spreadValues({
    locale: r
  }, a));
}, getMessageFormatter = monadicMemoize(
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  (e, t = getCurrentLocale()) => new IntlMessageFormat(e, t, getOptions().formats, {
    ignoreTag: getOptions().ignoreTag
  })
), formatMessage = (e, t = {}) => {
  var r, a, o, u;
  let c = t;
  typeof e == "object" && (c = e, e = c.id);
  const {
    values: d,
    locale: g = getCurrentLocale(),
    default: b
  } = c;
  if (g == null)
    throw new Error("[svelte-i18n] Cannot format a message without first setting the initial locale.");
  let _ = lookup(e, g);
  if (!_)
    _ = (u = (o = (a = (r = getOptions()).handleMissingMessage) == null ? void 0 : a.call(r, {
      locale: g,
      id: e,
      defaultValue: b
    })) != null ? o : b) != null ? u : e;
  else if (typeof _ != "string")
    return console.warn(`[svelte-i18n] Message with id "${e}" must be of type "string", found: "${typeof _}". Gettin its value through the "$format" method is deprecated; use the "json" method instead.`), _;
  if (!d)
    return _;
  let y = _;
  try {
    y = getMessageFormatter(_, g).format(d);
  } catch (A) {
    A instanceof Error && console.warn(`[svelte-i18n] Message "${e}" has syntax error:`, A.message);
  }
  return y;
}, formatTime = (e, t) => getTimeFormatter(t).format(e), formatDate = (e, t) => getDateFormatter(t).format(e), formatNumber = (e, t) => getNumberFormatter(t).format(e), getJSON = (e, t = getCurrentLocale()) => lookup(e, t);
derived([$locale, $dictionary], () => formatMessage);
derived([$locale], () => formatTime);
derived([$locale], () => formatDate);
derived([$locale], () => formatNumber);
derived([$locale, $dictionary], () => getJSON);
const {
  SvelteComponent: SvelteComponent$9,
  assign: assign$5,
  attr: attr$5,
  binding_callbacks: binding_callbacks$1,
  children: children$4,
  claim_element: claim_element$5,
  compute_rest_props: compute_rest_props$4,
  detach: detach$5,
  element: element$5,
  exclude_internal_props: exclude_internal_props$4,
  init: init$9,
  insert_hydration: insert_hydration$5,
  noop: noop$1,
  safe_not_equal: safe_not_equal$9
} = window.__gradio__svelte__internal, {
  afterUpdate: afterUpdate$2,
  onDestroy: onDestroy$2
} = window.__gradio__svelte__internal;
function create_fragment$9(e) {
  let t, r;
  return {
    c() {
      t = element$5("div"), this.h();
    },
    l(a) {
      t = claim_element$5(a, "DIV", {
        class: !0,
        style: !0
      }), children$4(t).forEach(detach$5), this.h();
    },
    h() {
      attr$5(t, "class", r = /*elem_classes*/
      e[1].join(" ")), attr$5(
        t,
        "style",
        /*elem_style*/
        e[0]
      );
    },
    m(a, o) {
      insert_hydration$5(a, t, o), e[5](t);
    },
    p(a, [o]) {
      o & /*elem_classes*/
      2 && r !== (r = /*elem_classes*/
      a[1].join(" ")) && attr$5(t, "class", r), o & /*elem_style*/
      1 && attr$5(
        t,
        "style",
        /*elem_style*/
        a[0]
      );
    },
    i: noop$1,
    o: noop$1,
    d(a) {
      a && detach$5(t), e[5](null);
    }
  };
}
function instance$9(e, t, r) {
  const a = ["component", "elem_style", "elem_classes", "theme"];
  let o = compute_rest_props$4(t, a), {
    component: u
  } = t, {
    elem_style: c = ""
  } = t, {
    elem_classes: d = []
  } = t, {
    theme: g = "light"
  } = t, b = null, _;
  const y = getLocaleFromNavigator();
  afterUpdate$2(() => {
    b && (_ = mount(b, u, {
      children: null,
      ...o,
      theme: g,
      locale: y
    }, _));
  }), onDestroy$2(() => {
    _ == null || _.unmount();
  });
  function A(E) {
    binding_callbacks$1[E ? "unshift" : "push"](() => {
      b = E, r(2, b);
    });
  }
  return e.$$set = (E) => {
    t = assign$5(assign$5({}, t), exclude_internal_props$4(E)), r(8, o = compute_rest_props$4(t, a)), "component" in E && r(3, u = E.component), "elem_style" in E && r(0, c = E.elem_style), "elem_classes" in E && r(1, d = E.elem_classes), "theme" in E && r(4, g = E.theme);
  }, [c, d, b, u, g, A];
}
class ReactComponent extends SvelteComponent$9 {
  constructor(t) {
    super(), init$9(this, t, instance$9, create_fragment$9, safe_not_equal$9, {
      component: 3,
      elem_style: 0,
      elem_classes: 1,
      theme: 4
    });
  }
}
const {
  SvelteComponent: SvelteComponent$8,
  assign: assign$4,
  claim_component: claim_component$7,
  compute_rest_props: compute_rest_props$3,
  create_component: create_component$7,
  destroy_component: destroy_component$7,
  exclude_internal_props: exclude_internal_props$3,
  get_spread_object: get_spread_object$4,
  get_spread_update: get_spread_update$4,
  init: init$8,
  mount_component: mount_component$7,
  safe_not_equal: safe_not_equal$8,
  transition_in: transition_in$7,
  transition_out: transition_out$7
} = window.__gradio__svelte__internal;
function create_fragment$8(e) {
  let t, r;
  const a = [
    /*$$restProps*/
    e[2],
    {
      component: FileView
    },
    {
      elem_classes: (
        /*elem_classes*/
        e[1]
      )
    },
    {
      elem_style: (
        /*elem_style*/
        e[0]
      )
    }
  ];
  let o = {};
  for (let u = 0; u < a.length; u += 1)
    o = assign$4(o, a[u]);
  return t = new ReactComponent({
    props: o
  }), {
    c() {
      create_component$7(t.$$.fragment);
    },
    l(u) {
      claim_component$7(t.$$.fragment, u);
    },
    m(u, c) {
      mount_component$7(t, u, c), r = !0;
    },
    p(u, [c]) {
      const d = c & /*$$restProps, elem_classes, elem_style*/
      7 ? get_spread_update$4(a, [c & /*$$restProps*/
      4 && get_spread_object$4(
        /*$$restProps*/
        u[2]
      ), a[1], c & /*elem_classes*/
      2 && {
        elem_classes: (
          /*elem_classes*/
          u[1]
        )
      }, c & /*elem_style*/
      1 && {
        elem_style: (
          /*elem_style*/
          u[0]
        )
      }]) : {};
      t.$set(d);
    },
    i(u) {
      r || (transition_in$7(t.$$.fragment, u), r = !0);
    },
    o(u) {
      transition_out$7(t.$$.fragment, u), r = !1;
    },
    d(u) {
      destroy_component$7(t, u);
    }
  };
}
function instance$8(e, t, r) {
  const a = ["elem_style", "elem_classes"];
  let o = compute_rest_props$3(t, a), {
    elem_style: u = ""
  } = t, {
    elem_classes: c = []
  } = t;
  return e.$$set = (d) => {
    t = assign$4(assign$4({}, t), exclude_internal_props$3(d)), r(2, o = compute_rest_props$3(t, a)), "elem_style" in d && r(0, u = d.elem_style), "elem_classes" in d && r(1, c = d.elem_classes);
  }, [u, c, o];
}
let FileView_1$1 = class extends SvelteComponent$8 {
  constructor(t) {
    super(), init$8(this, t, instance$8, create_fragment$8, safe_not_equal$8, {
      elem_style: 0,
      elem_classes: 1
    });
  }
};
const {
  SvelteComponent: SvelteComponent$7,
  assign: assign$3,
  claim_component: claim_component$6,
  compute_rest_props: compute_rest_props$2,
  create_component: create_component$6,
  destroy_component: destroy_component$6,
  exclude_internal_props: exclude_internal_props$2,
  get_spread_object: get_spread_object$3,
  get_spread_update: get_spread_update$3,
  init: init$7,
  mount_component: mount_component$6,
  safe_not_equal: safe_not_equal$7,
  transition_in: transition_in$6,
  transition_out: transition_out$6
} = window.__gradio__svelte__internal;
function create_fragment$7(e) {
  let t, r;
  const a = [
    /*$$restProps*/
    e[7],
    {
      theme: (
        /*theme*/
        e[0]
      )
    },
    {
      disabled: (
        /*type*/
        e[6] === "link" ? (
          /*link_disabled*/
          e[2]
        ) : void 0
      )
    },
    {
      elem_classes: (
        /*elem_classes*/
        e[4]
      )
    },
    {
      elem_style: (
        /*elem_style*/
        e[3]
      )
    },
    {
      type: (
        /*type*/
        e[6]
      )
    },
    {
      url: (
        /*file*/
        e[1].url
      )
    },
    {
      title: (
        /*alt_text*/
        e[5]
      )
    },
    {
      filename: window.__is_colab__ ? null : (
        /*file*/
        e[1].orig_name || /*file*/
        e[1].path
      )
    }
  ];
  let o = {};
  for (let u = 0; u < a.length; u += 1)
    o = assign$3(o, a[u]);
  return t = new FileView_1$1({
    props: o
  }), {
    c() {
      create_component$6(t.$$.fragment);
    },
    l(u) {
      claim_component$6(t.$$.fragment, u);
    },
    m(u, c) {
      mount_component$6(t, u, c), r = !0;
    },
    p(u, [c]) {
      const d = c & /*$$restProps, theme, type, link_disabled, undefined, elem_classes, elem_style, file, alt_text, window*/
      255 ? get_spread_update$3(a, [c & /*$$restProps*/
      128 && get_spread_object$3(
        /*$$restProps*/
        u[7]
      ), c & /*theme*/
      1 && {
        theme: (
          /*theme*/
          u[0]
        )
      }, c & /*type, link_disabled, undefined*/
      68 && {
        disabled: (
          /*type*/
          u[6] === "link" ? (
            /*link_disabled*/
            u[2]
          ) : void 0
        )
      }, c & /*elem_classes*/
      16 && {
        elem_classes: (
          /*elem_classes*/
          u[4]
        )
      }, c & /*elem_style*/
      8 && {
        elem_style: (
          /*elem_style*/
          u[3]
        )
      }, c & /*type*/
      64 && {
        type: (
          /*type*/
          u[6]
        )
      }, c & /*file*/
      2 && {
        url: (
          /*file*/
          u[1].url
        )
      }, c & /*alt_text*/
      32 && {
        title: (
          /*alt_text*/
          u[5]
        )
      }, c & /*window, file*/
      2 && {
        filename: window.__is_colab__ ? null : (
          /*file*/
          u[1].orig_name || /*file*/
          u[1].path
        )
      }]) : {};
      t.$set(d);
    },
    i(u) {
      r || (transition_in$6(t.$$.fragment, u), r = !0);
    },
    o(u) {
      transition_out$6(t.$$.fragment, u), r = !1;
    },
    d(u) {
      destroy_component$6(t, u);
    }
  };
}
function instance$7(e, t, r) {
  let a;
  const o = ["theme", "file", "link_disabled", "excludes", "elem_style", "elem_classes", "alt_text"];
  let u = compute_rest_props$2(t, o), {
    theme: c = "light"
  } = t, {
    file: d
  } = t, {
    link_disabled: g = !1
  } = t, {
    excludes: b = []
  } = t, {
    elem_style: _ = ""
  } = t, {
    elem_classes: y = []
  } = t, {
    alt_text: A = d.alt_text || d.orig_name
  } = t;
  function E(v = "") {
    let C = "link";
    return v.includes("audio") ? C = "audio" : v.includes("video") ? C = "video" : v.includes("image") && (C = "image"), b.includes(C) ? "link" : C;
  }
  return e.$$set = (v) => {
    t = assign$3(assign$3({}, t), exclude_internal_props$2(v)), r(7, u = compute_rest_props$2(t, o)), "theme" in v && r(0, c = v.theme), "file" in v && r(1, d = v.file), "link_disabled" in v && r(2, g = v.link_disabled), "excludes" in v && r(8, b = v.excludes), "elem_style" in v && r(3, _ = v.elem_style), "elem_classes" in v && r(4, y = v.elem_classes), "alt_text" in v && r(5, A = v.alt_text);
  }, e.$$.update = () => {
    e.$$.dirty & /*file*/
    2 && r(6, a = E(d.mime_type || ""));
  }, [c, d, g, _, y, A, a, u, b];
}
class FileView_1 extends SvelteComponent$7 {
  constructor(t) {
    super(), init$7(this, t, instance$7, create_fragment$7, safe_not_equal$7, {
      theme: 0,
      file: 1,
      link_disabled: 2,
      excludes: 8,
      elem_style: 3,
      elem_classes: 4,
      alt_text: 5
    });
  }
}
const {
  SvelteComponent: SvelteComponent$6,
  assign: assign$2,
  claim_component: claim_component$5,
  compute_rest_props: compute_rest_props$1,
  create_component: create_component$5,
  destroy_component: destroy_component$5,
  exclude_internal_props: exclude_internal_props$1,
  get_spread_object: get_spread_object$2,
  get_spread_update: get_spread_update$2,
  init: init$6,
  mount_component: mount_component$5,
  safe_not_equal: safe_not_equal$6,
  transition_in: transition_in$5,
  transition_out: transition_out$5
} = window.__gradio__svelte__internal;
function create_fragment$6(e) {
  let t, r;
  const a = [
    /*$$restProps*/
    e[3],
    {
      component: Markdown
    },
    {
      elem_classes: (
        /*elem_classes*/
        e[1]
      )
    },
    {
      elem_style: (
        /*elem_style*/
        e[0]
      )
    },
    {
      theme: (
        /*theme*/
        e[2]
      )
    }
  ];
  let o = {};
  for (let u = 0; u < a.length; u += 1)
    o = assign$2(o, a[u]);
  return t = new ReactComponent({
    props: o
  }), {
    c() {
      create_component$5(t.$$.fragment);
    },
    l(u) {
      claim_component$5(t.$$.fragment, u);
    },
    m(u, c) {
      mount_component$5(t, u, c), r = !0;
    },
    p(u, [c]) {
      const d = c & /*$$restProps, elem_classes, elem_style, theme*/
      15 ? get_spread_update$2(a, [c & /*$$restProps*/
      8 && get_spread_object$2(
        /*$$restProps*/
        u[3]
      ), a[1], c & /*elem_classes*/
      2 && {
        elem_classes: (
          /*elem_classes*/
          u[1]
        )
      }, c & /*elem_style*/
      1 && {
        elem_style: (
          /*elem_style*/
          u[0]
        )
      }, c & /*theme*/
      4 && {
        theme: (
          /*theme*/
          u[2]
        )
      }]) : {};
      t.$set(d);
    },
    i(u) {
      r || (transition_in$5(t.$$.fragment, u), r = !0);
    },
    o(u) {
      transition_out$5(t.$$.fragment, u), r = !1;
    },
    d(u) {
      destroy_component$5(t, u);
    }
  };
}
function instance$6(e, t, r) {
  const a = ["elem_style", "elem_classes", "theme"];
  let o = compute_rest_props$1(t, a), {
    elem_style: u = ""
  } = t, {
    elem_classes: c = []
  } = t, {
    theme: d = "light"
  } = t;
  return e.$$set = (g) => {
    t = assign$2(assign$2({}, t), exclude_internal_props$1(g)), r(3, o = compute_rest_props$1(t, a)), "elem_style" in g && r(0, u = g.elem_style), "elem_classes" in g && r(1, c = g.elem_classes), "theme" in g && r(2, d = g.theme);
  }, [u, c, d, o];
}
class Markdown_1 extends SvelteComponent$6 {
  constructor(t) {
    super(), init$6(this, t, instance$6, create_fragment$6, safe_not_equal$6, {
      elem_style: 0,
      elem_classes: 1,
      theme: 2
    });
  }
}
var has = Object.prototype.hasOwnProperty;
function dequal(e, t) {
  var r, a;
  if (e === t) return !0;
  if (e && t && (r = e.constructor) === t.constructor) {
    if (r === Date) return e.getTime() === t.getTime();
    if (r === RegExp) return e.toString() === t.toString();
    if (r === Array) {
      if ((a = e.length) === t.length)
        for (; a-- && dequal(e[a], t[a]); ) ;
      return a === -1;
    }
    if (!r || typeof e == "object") {
      a = 0;
      for (r in e)
        if (has.call(e, r) && ++a && !has.call(t, r) || !(r in t) || !dequal(e[r], t[r])) return !1;
      return Object.keys(t).length === a;
    }
  }
  return e !== e && t !== t;
}
const trimString = (e) => e.replace(/^\s+|\s+$/g, ""), findNextPattern = (e, t, r = 0) => {
  const a = e.indexOf(t, r);
  return a < 0 ? {
    found: !1,
    pos: -1
  } : {
    found: !0,
    pos: a
  };
}, consumePattern = (e, t, r, a = 0) => {
  const o = findNextPattern(e, t, a);
  if (o.found) {
    const u = findNextPattern(e, r, o.pos);
    return u.found ? {
      pos: u.pos,
      content: e.substring(o.pos + t.length, u.pos),
      finish: !0
    } : {
      pos: e.length - 1,
      content: e.substring(o.pos + t.length),
      finish: !1
    };
  } else
    return !1;
}, find_json_pattern = /{[\s\S]+}/, qwen = (e, t) => {
  var _;
  let r = 0, a = "";
  const o = "Action:", u = "Action Input:", c = "Observation:", d = "<result>", g = "</result>", b = (y, A) => {
    let E = A, v = "", C = "", R = "", I = !1;
    const w = findNextPattern(y, o, E);
    if (!w.found)
      return {
        found: !1,
        pos: E
      };
    const N = consumePattern(y, o, u, E);
    if (N && (v = trimString(N.content), E = N.pos, N.finish)) {
      const F = consumePattern(y, u, c, E);
      if (F && (C = trimString(F.content), E = F.pos, F.finish && findNextPattern(y, c, E))) {
        const x = consumePattern(y, d, g, E);
        x && (R = x.content, E = x.pos + g.length, I = !0);
      }
    }
    return {
      beforeContent: y.substring(A, w.pos),
      found: !0,
      finished: I,
      pos: E,
      actionName: v,
      actionBody: C,
      resultBody: R
    };
  };
  do {
    const {
      found: y,
      finished: A,
      beforeContent: E,
      actionName: v,
      actionBody: C,
      resultBody: R,
      pos: I
    } = b(e, r);
    if (r = I, E && (a += E), y) {
      if (v) {
        let w = "";
        C && (find_json_pattern.exec(C) ? w = `\`\`\`json
${C}

\`\`\`` : w = C), a += [`
:::llm-thinking`, `::llm-thinking-title[${(_ = t == null ? void 0 : t.action_input_title) == null ? void 0 : _.replaceAll("<Action>", v)}]`, w, `:::
`].join(`
`);
      }
      R && (a += [`
:::llm-thinking`, `::llm-thinking-title[${t == null ? void 0 : t.action_output_title}]`, R, `:::
`, t != null && t.auto_end && A ? ":flushing-end" : ""].join(`
`));
    }
    if (!y || y && !A)
      break;
  } while (!0);
  return a += e.substring(r), a;
};
function ensureArray(e) {
  return Array.isArray(e) ? e : [e];
}
async function copy_to_clipboard(e) {
  if ("clipboard" in navigator)
    await navigator.clipboard.writeText(e);
  else {
    const t = document.createElement("textarea");
    t.value = e, t.style.position = "absolute", t.style.left = "-999999px", document.body.prepend(t), t.select();
    try {
      document.execCommand("copy");
    } catch (r) {
      return Promise.reject(r);
    } finally {
      t.remove();
    }
  }
}
const format_chat_for_sharing = async (e) => (await Promise.all(e.map(async (r) => await Promise.all(r.map((a, o) => {
  if (!a)
    return [];
  const u = o === 0 ? "" : "";
  return a.map((c) => {
    if (!c)
      return "";
    let d = c.text;
    return Array.isArray(c.files) && c.files.length > 0 && (d += "<br/>", c.files.forEach((g) => {
      var y, A, E;
      const b = g.file;
      if (!(b != null && b.url)) return "";
      const _ = b.url;
      (y = b.mime_type) != null && y.includes("audio") ? d += `<audio controls src="${_}"></audio>` : (A = b.mime_type) != null && A.includes("video") ? d += `<video controls src="${_}"></video>` : (E = b.mime_type) != null && E.includes("image") ? d += `<img src="${_}" />` : d += `<a target="_blank" rel="noreferrer" href="${_}">${g.alt_text || g.file.alt_text || g.file.orig_name}</a>`;
    })), `${u}${c.name ? ` ${c.name}` : ""}: ${d}`;
  });
}))))).map((r) => r.map((a) => a.join(`
`))).map((r) => r.join(r[0] !== "" && r[1] !== "" ? `
` : "")).join(`
`), should_flushing = (e, t) => {
  if (e === "chatbot")
    return t.flushing !== !1;
  if (e === "user")
    return t.flushing;
};
function resolve_llm_thinking_presets(e, t = []) {
  let r = e;
  for (const a of t)
    switch (a.type) {
      case "qwen":
        r = qwen(r, a);
        break;
    }
  return r;
}
const {
  SvelteComponent: SvelteComponent$5,
  append_hydration: append_hydration$2,
  attr: attr$4,
  check_outros: check_outros$2,
  children: children$3,
  claim_component: claim_component$4,
  claim_element: claim_element$4,
  claim_space: claim_space$2,
  create_component: create_component$4,
  destroy_component: destroy_component$4,
  detach: detach$4,
  element: element$4,
  group_outros: group_outros$2,
  init: init$5,
  insert_hydration: insert_hydration$4,
  listen: listen$2,
  mount_component: mount_component$4,
  safe_not_equal: safe_not_equal$5,
  space: space$2,
  transition_in: transition_in$4,
  transition_out: transition_out$4
} = window.__gradio__svelte__internal, {
  onDestroy: onDestroy$1
} = window.__gradio__svelte__internal;
function create_if_block_1$2(e) {
  let t, r;
  return t = new Copy({}), {
    c() {
      create_component$4(t.$$.fragment);
    },
    l(a) {
      claim_component$4(t.$$.fragment, a);
    },
    m(a, o) {
      mount_component$4(t, a, o), r = !0;
    },
    i(a) {
      r || (transition_in$4(t.$$.fragment, a), r = !0);
    },
    o(a) {
      transition_out$4(t.$$.fragment, a), r = !1;
    },
    d(a) {
      destroy_component$4(t, a);
    }
  };
}
function create_if_block$2(e) {
  let t, r;
  return t = new Check({}), {
    c() {
      create_component$4(t.$$.fragment);
    },
    l(a) {
      claim_component$4(t.$$.fragment, a);
    },
    m(a, o) {
      mount_component$4(t, a, o), r = !0;
    },
    i(a) {
      r || (transition_in$4(t.$$.fragment, a), r = !0);
    },
    o(a) {
      transition_out$4(t.$$.fragment, a), r = !1;
    },
    d(a) {
      destroy_component$4(t, a);
    }
  };
}
function create_fragment$5(e) {
  let t, r, a, o, u, c, d = !/*copied*/
  e[0] && create_if_block_1$2(), g = (
    /*copied*/
    e[0] && create_if_block$2()
  );
  return {
    c() {
      t = element$4("button"), d && d.c(), r = space$2(), g && g.c(), this.h();
    },
    l(b) {
      t = claim_element$4(b, "BUTTON", {
        title: !0,
        "aria-label": !0,
        class: !0
      });
      var _ = children$3(t);
      d && d.l(_), r = claim_space$2(_), g && g.l(_), _.forEach(detach$4), this.h();
    },
    h() {
      attr$4(t, "title", "copy"), attr$4(t, "aria-label", a = /*copied*/
      e[0] ? "Copied message" : "Copy message"), attr$4(t, "class", "svelte-19fmyfb");
    },
    m(b, _) {
      insert_hydration$4(b, t, _), d && d.m(t, null), append_hydration$2(t, r), g && g.m(t, null), o = !0, u || (c = listen$2(
        t,
        "click",
        /*handle_copy*/
        e[1]
      ), u = !0);
    },
    p(b, [_]) {
      /*copied*/
      b[0] ? d && (group_outros$2(), transition_out$4(d, 1, 1, () => {
        d = null;
      }), check_outros$2()) : d ? _ & /*copied*/
      1 && transition_in$4(d, 1) : (d = create_if_block_1$2(), d.c(), transition_in$4(d, 1), d.m(t, r)), /*copied*/
      b[0] ? g ? _ & /*copied*/
      1 && transition_in$4(g, 1) : (g = create_if_block$2(), g.c(), transition_in$4(g, 1), g.m(t, null)) : g && (group_outros$2(), transition_out$4(g, 1, 1, () => {
        g = null;
      }), check_outros$2()), (!o || _ & /*copied*/
      1 && a !== (a = /*copied*/
      b[0] ? "Copied message" : "Copy message")) && attr$4(t, "aria-label", a);
    },
    i(b) {
      o || (transition_in$4(d), transition_in$4(g), o = !0);
    },
    o(b) {
      transition_out$4(d), transition_out$4(g), o = !1;
    },
    d(b) {
      b && detach$4(t), d && d.d(), g && g.d(), u = !1, c();
    }
  };
}
function instance$5(e, t, r) {
  let a = !1, {
    value: o
  } = t, u;
  function c() {
    r(0, a = !0), u && clearTimeout(u), u = setTimeout(() => {
      r(0, a = !1);
    }, 2e3);
  }
  async function d() {
    try {
      await copy_to_clipboard(o), c();
    } catch {
    }
  }
  return onDestroy$1(() => {
    u && clearTimeout(u);
  }), e.$$set = (g) => {
    "value" in g && r(2, o = g.value);
  }, [a, d, o];
}
class Copy_1 extends SvelteComponent$5 {
  constructor(t) {
    super(), init$5(this, t, instance$5, create_fragment$5, safe_not_equal$5, {
      value: 2
    });
  }
}
const {
  SvelteComponent: SvelteComponent$4,
  assign: assign$1,
  claim_component: claim_component$3,
  compute_rest_props,
  create_component: create_component$3,
  destroy_component: destroy_component$3,
  exclude_internal_props,
  get_spread_object: get_spread_object$1,
  get_spread_update: get_spread_update$1,
  init: init$4,
  mount_component: mount_component$3,
  safe_not_equal: safe_not_equal$4,
  transition_in: transition_in$3,
  transition_out: transition_out$3
} = window.__gradio__svelte__internal, {
  afterUpdate: afterUpdate$1,
  createEventDispatcher: createEventDispatcher$1,
  onDestroy
} = window.__gradio__svelte__internal;
function create_fragment$4(e) {
  let t, r;
  const a = [
    /*$$restProps*/
    e[7],
    {
      elem_style: "width: 100%"
    },
    {
      last_flushing_end_index: (
        /*last_flushing_end_index*/
        e[5]
      )
    },
    {
      end: !/*flushing*/
      e[2] || /*complete_message*/
      e[1]
    },
    {
      flushing: (
        /*flushing*/
        e[2] && /*message*/
        (e[0] !== /*display_message*/
        e[4] || !/*complete_message*/
        e[1])
      )
    },
    {
      theme: (
        /*theme*/
        e[3]
      )
    },
    {
      text: (
        /*display_message*/
        e[4]
      )
    },
    {
      on_custom: (
        /*on_custom*/
        e[6]
      )
    }
  ];
  let o = {};
  for (let u = 0; u < a.length; u += 1)
    o = assign$1(o, a[u]);
  return t = new Markdown_1({
    props: o
  }), {
    c() {
      create_component$3(t.$$.fragment);
    },
    l(u) {
      claim_component$3(t.$$.fragment, u);
    },
    m(u, c) {
      mount_component$3(t, u, c), r = !0;
    },
    p(u, [c]) {
      const d = c & /*$$restProps, last_flushing_end_index, flushing, complete_message, message, display_message, theme, on_custom*/
      255 ? get_spread_update$1(a, [c & /*$$restProps*/
      128 && get_spread_object$1(
        /*$$restProps*/
        u[7]
      ), a[1], c & /*last_flushing_end_index*/
      32 && {
        last_flushing_end_index: (
          /*last_flushing_end_index*/
          u[5]
        )
      }, c & /*flushing, complete_message*/
      6 && {
        end: !/*flushing*/
        u[2] || /*complete_message*/
        u[1]
      }, c & /*flushing, message, display_message, complete_message*/
      23 && {
        flushing: (
          /*flushing*/
          u[2] && /*message*/
          (u[0] !== /*display_message*/
          u[4] || !/*complete_message*/
          u[1])
        )
      }, c & /*theme*/
      8 && {
        theme: (
          /*theme*/
          u[3]
        )
      }, c & /*display_message*/
      16 && {
        text: (
          /*display_message*/
          u[4]
        )
      }, c & /*on_custom*/
      64 && {
        on_custom: (
          /*on_custom*/
          u[6]
        )
      }]) : {};
      t.$set(d);
    },
    i(u) {
      r || (transition_in$3(t.$$.fragment, u), r = !0);
    },
    o(u) {
      transition_out$3(t.$$.fragment, u), r = !1;
    },
    d(u) {
      destroy_component$3(t, u);
    }
  };
}
const flushing_end_tag = ":flushing-end", skip_tag_reg = /:::llm-thinking|::llm-thinking-title|::accordion-title|:flushing-end/g;
function instance$4(e, t, r) {
  let a;
  const o = ["message", "complete_message", "flushing", "theme", "flushing_speed"];
  let u = compute_rest_props(t, o), {
    message: c = ""
  } = t, {
    complete_message: d = !1
  } = t, {
    flushing: g = !1
  } = t, {
    theme: b = "light"
  } = t, {
    flushing_speed: _ = 5
  } = t, y = "", A = [], E, v = 0, C;
  const R = createEventDispatcher$1();
  function I(w, N, F) {
    R("custom", {
      tag: w,
      tag_index: N,
      value: F
    });
  }
  return onDestroy(() => {
    clearTimeout(E);
  }), afterUpdate$1(() => {
    R("update");
  }), e.$$set = (w) => {
    t = assign$1(assign$1({}, t), exclude_internal_props(w)), r(7, u = compute_rest_props(t, o)), "message" in w && r(0, c = w.message), "complete_message" in w && r(1, d = w.complete_message), "flushing" in w && r(2, g = w.flushing), "theme" in w && r(3, b = w.theme), "flushing_speed" in w && r(8, _ = w.flushing_speed);
  }, e.$$.update = () => {
    if (e.$$.dirty & /*flushing_speed*/
    256 && r(12, a = 100 - Math.max(Math.min(_, 10), 1) * 100 / 9), e.$$.dirty & /*message*/
    1 && r(9, A = [...Array.from(c.matchAll(skip_tag_reg)).map((w) => ({
      start: w.index,
      end: w.index + w[0].length
    }))]), e.$$.dirty & /*message, display_message, timeout, flushing, last_flushing_end_index, i, _flushing_timeout, skip_message_positions*/
    7733 && c !== y)
      if (clearTimeout(E), !g)
        r(4, y = c);
      else {
        if (r(5, C = c.lastIndexOf(flushing_end_tag)), C !== -1) {
          const F = c.slice(0, C + flushing_end_tag.length);
          y.startsWith(F) || (r(4, y = F), r(11, v = C));
        }
        c.startsWith(y) || r(4, y = c.slice(0, v));
        const w = Date.now();
        r(10, E = setTimeout(() => {
          if (v >= c.length)
            return;
          const F = Math.min(Math.max(Math.round((Date.now() - w) / a), 1), c.length - y.length);
          r(4, y += c.slice(v, v + F)), r(11, v += F);
          const M = A.find((x) => x.start <= v && v < x.end);
          M && (r(4, y += c.slice(M.start, M.end)), r(11, v += M.end - M.start));
        }, a));
      }
    e.$$.dirty & /*flushing, complete_message, message, display_message*/
    23 && g && d && c === y && R("flushed", c);
  }, [c, d, g, b, y, C, I, u, _, A, E, v, a];
}
class FlushingMarkdown extends SvelteComponent$4 {
  constructor(t) {
    super(), init$4(this, t, instance$4, create_fragment$4, safe_not_equal$4, {
      message: 0,
      complete_message: 1,
      flushing: 2,
      theme: 3,
      flushing_speed: 8
    });
  }
}
const {
  SvelteComponent: SvelteComponent$3,
  attr: attr$3,
  children: children$2,
  claim_component: claim_component$2,
  claim_element: claim_element$3,
  create_component: create_component$2,
  destroy_component: destroy_component$2,
  detach: detach$3,
  element: element$3,
  init: init$3,
  insert_hydration: insert_hydration$3,
  listen: listen$1,
  mount_component: mount_component$2,
  run_all: run_all$1,
  safe_not_equal: safe_not_equal$3,
  transition_in: transition_in$2,
  transition_out: transition_out$2
} = window.__gradio__svelte__internal;
function create_fragment$3(e) {
  let t, r, a, o, u, c, d;
  return r = new /*Icon*/
  e[3]({
    props: {
      selected: (
        /*actioned*/
        e[2]
      )
    }
  }), {
    c() {
      t = element$3("button"), create_component$2(r.$$.fragment), this.h();
    },
    l(g) {
      t = claim_element$3(g, "BUTTON", {
        title: !0,
        "aria-label": !0,
        class: !0
      });
      var b = children$2(t);
      claim_component$2(r.$$.fragment, b), b.forEach(detach$3), this.h();
    },
    h() {
      attr$3(t, "title", a = /*action*/
      e[0] + " message"), attr$3(t, "aria-label", o = /*actioned*/
      e[2] ? `clicked ${/*action*/
      e[0]}` : (
        /*action*/
        e[0]
      )), attr$3(t, "class", "svelte-nqnu7n");
    },
    m(g, b) {
      insert_hydration$3(g, t, b), mount_component$2(r, t, null), u = !0, c || (d = [listen$1(
        t,
        "click",
        /*click_handler*/
        e[5]
      ), listen$1(
        t,
        "keydown",
        /*keydown_handler*/
        e[6]
      )], c = !0);
    },
    p(g, [b]) {
      const _ = {};
      b & /*actioned*/
      4 && (_.selected = /*actioned*/
      g[2]), r.$set(_), (!u || b & /*action*/
      1 && a !== (a = /*action*/
      g[0] + " message")) && attr$3(t, "title", a), (!u || b & /*actioned, action*/
      5 && o !== (o = /*actioned*/
      g[2] ? `clicked ${/*action*/
      g[0]}` : (
        /*action*/
        g[0]
      ))) && attr$3(t, "aria-label", o);
    },
    i(g) {
      u || (transition_in$2(r.$$.fragment, g), u = !0);
    },
    o(g) {
      transition_out$2(r.$$.fragment, g), u = !1;
    },
    d(g) {
      g && detach$3(t), destroy_component$2(r), c = !1, run_all$1(d);
    }
  };
}
function instance$3(e, t, r) {
  let {
    action: a
  } = t, {
    handle_action: o
  } = t, u = !1;
  const c = a === "like" ? Like : Dislike;
  function d() {
    r(2, u = !0);
  }
  const g = () => {
    d(), o();
  }, b = (_) => {
    _.key === "Enter" && (d(), o());
  };
  return e.$$set = (_) => {
    "action" in _ && r(0, a = _.action), "handle_action" in _ && r(1, o = _.handle_action);
  }, [a, o, u, c, d, g, b];
}
class LikeDislike extends SvelteComponent$3 {
  constructor(t) {
    super(), init$3(this, t, instance$3, create_fragment$3, safe_not_equal$3, {
      action: 0,
      handle_action: 1
    });
  }
}
const {
  SvelteComponent: SvelteComponent$2,
  attr: attr$2,
  claim_element: claim_element$2,
  detach: detach$2,
  element: element$2,
  get_svelte_dataset,
  init: init$2,
  insert_hydration: insert_hydration$2,
  noop,
  safe_not_equal: safe_not_equal$2,
  set_style: set_style$1
} = window.__gradio__svelte__internal;
function create_fragment$2(e) {
  let t, r = `<span class="sr-only">Loading content</span> <div class="dot-flashing svelte-18upi7b"></div>
  
  <div class="dot-flashing svelte-18upi7b"></div>
  
  <div class="dot-flashing svelte-18upi7b"></div>`;
  return {
    c() {
      t = element$2("div"), t.innerHTML = r, this.h();
    },
    l(a) {
      t = claim_element$2(a, "DIV", {
        class: !0,
        role: !0,
        "aria-label": !0,
        "aria-live": !0,
        "data-svelte-h": !0
      }), get_svelte_dataset(t) !== "svelte-lldpu7" && (t.innerHTML = r), this.h();
    },
    h() {
      attr$2(t, "class", "message pending svelte-18upi7b"), attr$2(t, "role", "status"), attr$2(t, "aria-label", "Loading response"), attr$2(t, "aria-live", "polite"), set_style$1(
        t,
        "border-radius",
        /*layout*/
        e[0] === "bubble" ? "var(--radius-xxl)" : "none"
      );
    },
    m(a, o) {
      insert_hydration$2(a, t, o);
    },
    p(a, [o]) {
      o & /*layout*/
      1 && set_style$1(
        t,
        "border-radius",
        /*layout*/
        a[0] === "bubble" ? "var(--radius-xxl)" : "none"
      );
    },
    i: noop,
    o: noop,
    d(a) {
      a && detach$2(t);
    }
  };
}
function instance$2(e, t, r) {
  let {
    layout: a = "bubble"
  } = t;
  return e.$$set = (o) => {
    "layout" in o && r(0, a = o.layout);
  }, [a];
}
class Pending extends SvelteComponent$2 {
  constructor(t) {
    super(), init$2(this, t, instance$2, create_fragment$2, safe_not_equal$2, {
      layout: 0
    });
  }
}
const {
  SvelteComponent: SvelteComponent$1,
  action_destroyer,
  append_hydration: append_hydration$1,
  attr: attr$1,
  binding_callbacks,
  bubble,
  check_outros: check_outros$1,
  children: children$1,
  claim_component: claim_component$1,
  claim_element: claim_element$1,
  claim_space: claim_space$1,
  claim_text,
  create_component: create_component$1,
  destroy_component: destroy_component$1,
  destroy_each,
  detach: detach$1,
  element: element$1,
  empty,
  ensure_array_like,
  globals,
  group_outros: group_outros$1,
  init: init$1,
  insert_hydration: insert_hydration$1,
  listen,
  mount_component: mount_component$1,
  null_to_empty,
  outro_and_destroy_block,
  run_all,
  safe_not_equal: safe_not_equal$1,
  set_data,
  set_style,
  space: space$1,
  src_url_equal,
  text,
  toggle_class,
  transition_in: transition_in$1,
  transition_out: transition_out$1,
  update_keyed_each
} = window.__gradio__svelte__internal, {
  Boolean: Boolean_1
} = globals, {
  afterUpdate,
  createEventDispatcher
} = window.__gradio__svelte__internal;
function get_each_context(e, t, r) {
  const a = e.slice();
  return a[52] = t[r], a[54] = r, a;
}
function get_each_context_1(e, t, r) {
  const a = e.slice();
  return a[55] = t[r], a[57] = r, a;
}
function get_each_context_2(e, t, r) {
  const a = e.slice();
  return a[58] = t[r], a[60] = r, a;
}
function get_each_context_3(e, t, r) {
  const a = e.slice();
  return a[61] = t[r], a;
}
function get_if_ctx(e) {
  const t = e.slice(), r = (
    /*get_message_name*/
    t[34](
      /*message*/
      t[58],
      /*j*/
      t[57],
      /*k*/
      t[60]
    )
  );
  return t[64] = r, t;
}
function create_if_block_10(e) {
  let t, r, a;
  return r = new ShareButton({
    props: {
      i18n: (
        /*i18n*/
        e[9]
      ),
      formatter: format_chat_for_sharing,
      value: (
        /*value*/
        e[0]
      )
    }
  }), r.$on(
    "error",
    /*error_handler*/
    e[38]
  ), r.$on(
    "share",
    /*share_handler*/
    e[39]
  ), {
    c() {
      t = element$1("div"), create_component$1(r.$$.fragment), this.h();
    },
    l(o) {
      t = claim_element$1(o, "DIV", {
        class: !0
      });
      var u = children$1(t);
      claim_component$1(r.$$.fragment, u), u.forEach(detach$1), this.h();
    },
    h() {
      attr$1(t, "class", "share-button svelte-nl8xgc");
    },
    m(o, u) {
      insert_hydration$1(o, t, u), mount_component$1(r, t, null), a = !0;
    },
    p(o, u) {
      const c = {};
      u[0] & /*i18n*/
      512 && (c.i18n = /*i18n*/
      o[9]), u[0] & /*value*/
      1 && (c.value = /*value*/
      o[0]), r.$set(c);
    },
    i(o) {
      a || (transition_in$1(r.$$.fragment, o), a = !0);
    },
    o(o) {
      transition_out$1(r.$$.fragment, o), a = !1;
    },
    d(o) {
      o && detach$1(t), destroy_component$1(r);
    }
  };
}
function create_if_block$1(e) {
  let t, r, a, o = ensure_array_like(
    /*value*/
    e[0]
  ), u = [];
  for (let g = 0; g < o.length; g += 1)
    u[g] = create_each_block(get_each_context(e, o, g));
  const c = (g) => transition_out$1(u[g], 1, 1, () => {
    u[g] = null;
  });
  let d = (
    /*pending_message*/
    e[4] && create_if_block_1$1(e)
  );
  return {
    c() {
      for (let g = 0; g < u.length; g += 1)
        u[g].c();
      t = space$1(), d && d.c(), r = empty();
    },
    l(g) {
      for (let b = 0; b < u.length; b += 1)
        u[b].l(g);
      t = claim_space$1(g), d && d.l(g), r = empty();
    },
    m(g, b) {
      for (let _ = 0; _ < u.length; _ += 1)
        u[_] && u[_].m(g, b);
      insert_hydration$1(g, t, b), d && d.m(g, b), insert_hydration$1(g, r, b), a = !0;
    },
    p(g, b) {
      if (b[0] & /*value, layout, bubble_full_width, render_markdown, show_copy_button, likeable, rtl, selectable, handle_select, theme, preview, custom_components, flushing, complete_message, pending_message, flushing_speed, enable_base64, enable_latex, latex_delimiters, latex_single_dollar_delimiter, sanitize_html, line_breaks, scroll, handle_custom, avatar_image_align, avatar_image_width, avatar_images*/
      1946156287 | b[1] & /*get_message_avatar, handle_like, handle_flushed, get_message_name*/
      15) {
        o = ensure_array_like(
          /*value*/
          g[0]
        );
        let _;
        for (_ = 0; _ < o.length; _ += 1) {
          const y = get_each_context(g, o, _);
          u[_] ? (u[_].p(y, b), transition_in$1(u[_], 1)) : (u[_] = create_each_block(y), u[_].c(), transition_in$1(u[_], 1), u[_].m(t.parentNode, t));
        }
        for (group_outros$1(), _ = o.length; _ < u.length; _ += 1)
          c(_);
        check_outros$1();
      }
      /*pending_message*/
      g[4] ? d ? (d.p(g, b), b[0] & /*pending_message*/
      16 && transition_in$1(d, 1)) : (d = create_if_block_1$1(g), d.c(), transition_in$1(d, 1), d.m(r.parentNode, r)) : d && (group_outros$1(), transition_out$1(d, 1, 1, () => {
        d = null;
      }), check_outros$1());
    },
    i(g) {
      if (!a) {
        for (let b = 0; b < o.length; b += 1)
          transition_in$1(u[b]);
        transition_in$1(d), a = !0;
      }
    },
    o(g) {
      u = u.filter(Boolean_1);
      for (let b = 0; b < u.length; b += 1)
        transition_out$1(u[b]);
      transition_out$1(d), a = !1;
    },
    d(g) {
      g && (detach$1(t), detach$1(r)), destroy_each(u, g), d && d.d(g);
    }
  };
}
function create_if_block_2(e) {
  let t = [], r = /* @__PURE__ */ new Map(), a, o, u = ensure_array_like(
    /*message_item*/
    e[55]
  );
  const c = (d) => {
    var g;
    return (
      /*message*/
      ((g = d[58]) == null ? void 0 : g.id) || `${/*i*/
      d[54]}-${/*j*/
      d[57]}-${/*k*/
      d[60]}`
    );
  };
  for (let d = 0; d < u.length; d += 1) {
    let g = get_each_context_2(e, u, d), b = c(g);
    r.set(b, t[d] = create_each_block_2(b, g));
  }
  return {
    c() {
      for (let d = 0; d < t.length; d += 1)
        t[d].c();
      a = empty();
    },
    l(d) {
      for (let g = 0; g < t.length; g += 1)
        t[g].l(d);
      a = empty();
    },
    m(d, g) {
      for (let b = 0; b < t.length; b += 1)
        t[b] && t[b].m(d, g);
      insert_hydration$1(d, a, g), o = !0;
    },
    p(d, g) {
      g[0] & /*value, layout, bubble_full_width, render_markdown, show_copy_button, likeable, rtl, selectable, handle_select, theme, preview, custom_components, flushing, complete_message, pending_message, flushing_speed, enable_base64, enable_latex, latex_delimiters, latex_single_dollar_delimiter, sanitize_html, line_breaks, scroll, handle_custom, avatar_image_align, avatar_image_width, avatar_images*/
      1946156287 | g[1] & /*get_message_avatar, handle_like, handle_flushed, get_message_name*/
      15 && (u = ensure_array_like(
        /*message_item*/
        d[55]
      ), group_outros$1(), t = update_keyed_each(t, g, c, 1, d, u, r, a.parentNode, outro_and_destroy_block, create_each_block_2, a, get_each_context_2), check_outros$1());
    },
    i(d) {
      if (!o) {
        for (let g = 0; g < u.length; g += 1)
          transition_in$1(t[g]);
        o = !0;
      }
    },
    o(d) {
      for (let g = 0; g < t.length; g += 1)
        transition_out$1(t[g]);
      o = !1;
    },
    d(d) {
      d && detach$1(a);
      for (let g = 0; g < t.length; g += 1)
        t[g].d(d);
    }
  };
}
function create_if_block_3(e) {
  let t, r, a, o, u, c, d, g, b, _, y, A, E, v, C = (
    /*message*/
    (e[58].avatar || /*avatar_images*/
    e[12][
      /*j*/
      e[57]
    ][
      /*k*/
      e[60]
    ]) && create_if_block_8(get_if_ctx(e))
  );
  function R(...U) {
    return (
      /*custom_handler*/
      e[40](
        /*i*/
        e[54],
        /*j*/
        e[57],
        /*k*/
        e[60],
        ...U
      )
    );
  }
  function I(...U) {
    return (
      /*flushed_handler*/
      e[41](
        /*i*/
        e[54],
        /*j*/
        e[57],
        /*k*/
        e[60],
        ...U
      )
    );
  }
  u = new FlushingMarkdown({
    props: {
      custom_components: (
        /*custom_components*/
        e[23]
      ),
      flushing: (
        /*flushing*/
        e[22] && /*i*/
        e[54] === /*value*/
        e[0].length - 1 && should_flushing(
          /*j*/
          e[57] === 0 ? "user" : "chatbot",
          /*message*/
          e[58]
        )
      ),
      complete_message: (
        /*complete_message*/
        e[5] || /*pending_message*/
        e[4]
      ),
      theme: (
        /*theme*/
        e[25]
      ),
      flushing_speed: (
        /*flushing_speed*/
        e[24]
      ),
      enable_base64: (
        /*enable_base64*/
        e[20]
      ),
      preview: (
        /*preview*/
        e[21]
      ),
      message: (
        /*message*/
        e[58].text
      ),
      enable_latex: (
        /*enable_latex*/
        e[1]
      ),
      latex_delimiters: (
        /*latex_delimiters*/
        e[3]
      ),
      latex_single_dollar_delimiter: (
        /*latex_single_dollar_delimiter*/
        e[2]
      ),
      sanitize_html: (
        /*sanitize_html*/
        e[15]
      ),
      render_markdown: (
        /*render_markdown*/
        e[17]
      ),
      line_breaks: (
        /*line_breaks*/
        e[18]
      )
    }
  }), u.$on(
    "update",
    /*scroll*/
    e[28]
  ), u.$on(
    "load",
    /*scroll*/
    e[28]
  ), u.$on("custom", R), u.$on("flushed", I);
  let w = ensure_array_like(
    /*message*/
    e[58].files || []
  ), N = [];
  for (let U = 0; U < w.length; U += 1)
    N[U] = create_each_block_3(get_each_context_3(e, w, U));
  const F = (U) => transition_out$1(N[U], 1, 1, () => {
    N[U] = null;
  });
  function M() {
    return (
      /*click_handler*/
      e[42](
        /*i*/
        e[54],
        /*j*/
        e[57],
        /*k*/
        e[60],
        /*message*/
        e[58]
      )
    );
  }
  function x(...U) {
    return (
      /*keydown_handler*/
      e[43](
        /*i*/
        e[54],
        /*j*/
        e[57],
        /*k*/
        e[60],
        /*message*/
        e[58],
        ...U
      )
    );
  }
  let P = (
    /*likeable*/
    (e[7] && /*j*/
    e[57] !== 0 || /*show_copy_button*/
    e[11] && /*message*/
    e[58] && typeof /*message*/
    e[58].text == "string") && create_if_block_4(e)
  );
  return {
    c() {
      t = element$1("div"), C && C.c(), r = space$1(), a = element$1("div"), o = element$1("button"), create_component$1(u.$$.fragment), c = space$1();
      for (let U = 0; U < N.length; U += 1)
        N[U].c();
      b = space$1(), P && P.c(), this.h();
    },
    l(U) {
      t = claim_element$1(U, "DIV", {
        id: !0,
        class: !0
      });
      var L = children$1(t);
      C && C.l(L), r = claim_space$1(L), a = claim_element$1(L, "DIV", {
        class: !0
      });
      var H = children$1(a);
      o = claim_element$1(H, "BUTTON", {
        class: !0,
        dir: !0,
        "aria-label": !0
      });
      var B = children$1(o);
      claim_component$1(u.$$.fragment, B), c = claim_space$1(B);
      for (let V = 0; V < N.length; V += 1)
        N[V].l(B);
      B.forEach(detach$1), b = claim_space$1(H), P && P.l(H), H.forEach(detach$1), L.forEach(detach$1), this.h();
    },
    h() {
      attr$1(o, "class", "message-content-button svelte-nl8xgc"), attr$1(o, "dir", d = /*rtl*/
      e[10] ? "rtl" : "ltr"), attr$1(o, "aria-label", g = /*j*/
      (e[57] == 0 ? "user" : "bot") + "'s message:' " + /*message*/
      e[58]), toggle_class(
        o,
        "latest",
        /*i*/
        e[54] === /*value*/
        e[0].length - 1
      ), toggle_class(o, "message-markdown-disabled", !/*render_markdown*/
      e[17]), toggle_class(
        o,
        "selectable",
        /*selectable*/
        e[6]
      ), set_style(o, "text-align", "left"), attr$1(a, "class", "message " + /*j*/
      (e[57] == 0 ? "user" : "bot") + " svelte-nl8xgc"), toggle_class(
        a,
        "message-fit",
        /*layout*/
        e[19] === "bubble" && !/*bubble_full_width*/
        e[16]
      ), toggle_class(
        a,
        "panel-full-width",
        /*layout*/
        e[19] === "panel"
      ), toggle_class(
        a,
        "message-bubble-border",
        /*layout*/
        e[19] === "bubble"
      ), toggle_class(a, "message-markdown-disabled", !/*render_markdown*/
      e[17]), attr$1(t, "id", _ = /*message*/
      e[58].elem_id), attr$1(t, "class", y = "message-row " + /*layout*/
      e[19] + " " + /*j*/
      (e[57] == 0 ? "user-row" : "bot-row") + " " + /*message*/
      (e[58].elem_classes ? ensureArray(
        /*message*/
        e[58].elem_classes
      ).join(" ") : "") + " svelte-nl8xgc");
    },
    m(U, L) {
      insert_hydration$1(U, t, L), C && C.m(t, null), append_hydration$1(t, r), append_hydration$1(t, a), append_hydration$1(a, o), mount_component$1(u, o, null), append_hydration$1(o, c);
      for (let H = 0; H < N.length; H += 1)
        N[H] && N[H].m(o, null);
      append_hydration$1(a, b), P && P.m(a, null), A = !0, E || (v = [listen(o, "click", M), listen(o, "keydown", x)], E = !0);
    },
    p(U, L) {
      e = U, /*message*/
      e[58].avatar || /*avatar_images*/
      e[12][
        /*j*/
        e[57]
      ][
        /*k*/
        e[60]
      ] ? C ? C.p(get_if_ctx(e), L) : (C = create_if_block_8(get_if_ctx(e)), C.c(), C.m(t, r)) : C && (C.d(1), C = null);
      const H = {};
      if (L[0] & /*custom_components*/
      8388608 && (H.custom_components = /*custom_components*/
      e[23]), L[0] & /*flushing, value*/
      4194305 && (H.flushing = /*flushing*/
      e[22] && /*i*/
      e[54] === /*value*/
      e[0].length - 1 && should_flushing(
        /*j*/
        e[57] === 0 ? "user" : "chatbot",
        /*message*/
        e[58]
      )), L[0] & /*complete_message, pending_message*/
      48 && (H.complete_message = /*complete_message*/
      e[5] || /*pending_message*/
      e[4]), L[0] & /*theme*/
      33554432 && (H.theme = /*theme*/
      e[25]), L[0] & /*flushing_speed*/
      16777216 && (H.flushing_speed = /*flushing_speed*/
      e[24]), L[0] & /*enable_base64*/
      1048576 && (H.enable_base64 = /*enable_base64*/
      e[20]), L[0] & /*preview*/
      2097152 && (H.preview = /*preview*/
      e[21]), L[0] & /*value*/
      1 && (H.message = /*message*/
      e[58].text), L[0] & /*enable_latex*/
      2 && (H.enable_latex = /*enable_latex*/
      e[1]), L[0] & /*latex_delimiters*/
      8 && (H.latex_delimiters = /*latex_delimiters*/
      e[3]), L[0] & /*latex_single_dollar_delimiter*/
      4 && (H.latex_single_dollar_delimiter = /*latex_single_dollar_delimiter*/
      e[2]), L[0] & /*sanitize_html*/
      32768 && (H.sanitize_html = /*sanitize_html*/
      e[15]), L[0] & /*render_markdown*/
      131072 && (H.render_markdown = /*render_markdown*/
      e[17]), L[0] & /*line_breaks*/
      262144 && (H.line_breaks = /*line_breaks*/
      e[18]), u.$set(H), L[0] & /*theme, preview, value*/
      35651585) {
        w = ensure_array_like(
          /*message*/
          e[58].files || []
        );
        let B;
        for (B = 0; B < w.length; B += 1) {
          const V = get_each_context_3(e, w, B);
          N[B] ? (N[B].p(V, L), transition_in$1(N[B], 1)) : (N[B] = create_each_block_3(V), N[B].c(), transition_in$1(N[B], 1), N[B].m(o, null));
        }
        for (group_outros$1(), B = w.length; B < N.length; B += 1)
          F(B);
        check_outros$1();
      }
      (!A || L[0] & /*rtl*/
      1024 && d !== (d = /*rtl*/
      e[10] ? "rtl" : "ltr")) && attr$1(o, "dir", d), (!A || L[0] & /*value*/
      1 && g !== (g = /*j*/
      (e[57] == 0 ? "user" : "bot") + "'s message:' " + /*message*/
      e[58])) && attr$1(o, "aria-label", g), (!A || L[0] & /*value*/
      1) && toggle_class(
        o,
        "latest",
        /*i*/
        e[54] === /*value*/
        e[0].length - 1
      ), (!A || L[0] & /*render_markdown*/
      131072) && toggle_class(o, "message-markdown-disabled", !/*render_markdown*/
      e[17]), (!A || L[0] & /*selectable*/
      64) && toggle_class(
        o,
        "selectable",
        /*selectable*/
        e[6]
      ), /*likeable*/
      e[7] && /*j*/
      e[57] !== 0 || /*show_copy_button*/
      e[11] && /*message*/
      e[58] && typeof /*message*/
      e[58].text == "string" ? P ? (P.p(e, L), L[0] & /*likeable, show_copy_button, value*/
      2177 && transition_in$1(P, 1)) : (P = create_if_block_4(e), P.c(), transition_in$1(P, 1), P.m(a, null)) : P && (group_outros$1(), transition_out$1(P, 1, 1, () => {
        P = null;
      }), check_outros$1()), (!A || L[0] & /*layout, bubble_full_width*/
      589824) && toggle_class(
        a,
        "message-fit",
        /*layout*/
        e[19] === "bubble" && !/*bubble_full_width*/
        e[16]
      ), (!A || L[0] & /*layout*/
      524288) && toggle_class(
        a,
        "panel-full-width",
        /*layout*/
        e[19] === "panel"
      ), (!A || L[0] & /*layout*/
      524288) && toggle_class(
        a,
        "message-bubble-border",
        /*layout*/
        e[19] === "bubble"
      ), (!A || L[0] & /*render_markdown*/
      131072) && toggle_class(a, "message-markdown-disabled", !/*render_markdown*/
      e[17]), (!A || L[0] & /*value*/
      1 && _ !== (_ = /*message*/
      e[58].elem_id)) && attr$1(t, "id", _), (!A || L[0] & /*layout, value*/
      524289 && y !== (y = "message-row " + /*layout*/
      e[19] + " " + /*j*/
      (e[57] == 0 ? "user-row" : "bot-row") + " " + /*message*/
      (e[58].elem_classes ? ensureArray(
        /*message*/
        e[58].elem_classes
      ).join(" ") : "") + " svelte-nl8xgc")) && attr$1(t, "class", y);
    },
    i(U) {
      if (!A) {
        transition_in$1(u.$$.fragment, U);
        for (let L = 0; L < w.length; L += 1)
          transition_in$1(N[L]);
        transition_in$1(P), A = !0;
      }
    },
    o(U) {
      transition_out$1(u.$$.fragment, U), N = N.filter(Boolean_1);
      for (let L = 0; L < N.length; L += 1)
        transition_out$1(N[L]);
      transition_out$1(P), A = !1;
    },
    d(U) {
      U && detach$1(t), C && C.d(), destroy_component$1(u), destroy_each(N, U), P && P.d(), E = !1, run_all(v);
    }
  };
}
function create_if_block_8(e) {
  let t, r, a, o, u, c = (
    /*message_name*/
    e[64] && create_if_block_9(e)
  );
  return {
    c() {
      t = element$1("div"), r = element$1("img"), o = space$1(), c && c.c(), this.h();
    },
    l(d) {
      t = claim_element$1(d, "DIV", {
        class: !0
      });
      var g = children$1(t);
      r = claim_element$1(g, "IMG", {
        class: !0,
        src: !0,
        alt: !0
      }), o = claim_space$1(g), c && c.l(g), g.forEach(detach$1), this.h();
    },
    h() {
      attr$1(r, "class", "avatar-image svelte-nl8xgc"), src_url_equal(r.src, a = /*get_message_avatar*/
      e[33](
        /*message*/
        e[58],
        /*j*/
        e[57],
        /*k*/
        e[60]
      )) || attr$1(r, "src", a), attr$1(
        r,
        "alt",
        /*j*/
        (e[57] == 0 ? "user" : "bot") + " avatar"
      ), attr$1(t, "class", u = "avatar-container " + /*avatar_image_align*/
      e[13] + " svelte-nl8xgc"), set_style(t, "width", `${typeof /*avatar_image_width*/
      e[14] == "number" ? (
        /*avatar_image_width*/
        e[14] + "px"
      ) : (
        /*avatar_image_width*/
        e[14]
      )}`);
    },
    m(d, g) {
      insert_hydration$1(d, t, g), append_hydration$1(t, r), append_hydration$1(t, o), c && c.m(t, null);
    },
    p(d, g) {
      g[0] & /*value*/
      1 && !src_url_equal(r.src, a = /*get_message_avatar*/
      d[33](
        /*message*/
        d[58],
        /*j*/
        d[57],
        /*k*/
        d[60]
      )) && attr$1(r, "src", a), /*message_name*/
      d[64] ? c ? c.p(d, g) : (c = create_if_block_9(d), c.c(), c.m(t, null)) : c && (c.d(1), c = null), g[0] & /*avatar_image_align*/
      8192 && u !== (u = "avatar-container " + /*avatar_image_align*/
      d[13] + " svelte-nl8xgc") && attr$1(t, "class", u), g[0] & /*avatar_image_width*/
      16384 && set_style(t, "width", `${typeof /*avatar_image_width*/
      d[14] == "number" ? (
        /*avatar_image_width*/
        d[14] + "px"
      ) : (
        /*avatar_image_width*/
        d[14]
      )}`);
    },
    d(d) {
      d && detach$1(t), c && c.d();
    }
  };
}
function create_if_block_9(e) {
  let t, r = (
    /*message_name*/
    e[64] + ""
  ), a, o;
  return {
    c() {
      t = element$1("span"), a = text(r), this.h();
    },
    l(u) {
      t = claim_element$1(u, "SPAN", {
        title: !0,
        class: !0
      });
      var c = children$1(t);
      a = claim_text(c, r), c.forEach(detach$1), this.h();
    },
    h() {
      attr$1(t, "title", o = /*message_name*/
      e[64]), attr$1(t, "class", "svelte-nl8xgc");
    },
    m(u, c) {
      insert_hydration$1(u, t, c), append_hydration$1(t, a);
    },
    p(u, c) {
      c[0] & /*value*/
      1 && r !== (r = /*message_name*/
      u[64] + "") && set_data(a, r), c[0] & /*value*/
      1 && o !== (o = /*message_name*/
      u[64]) && attr$1(t, "title", o);
    },
    d(u) {
      u && detach$1(t);
    }
  };
}
function create_if_block_7(e) {
  let t, r;
  return t = new FileView_1({
    props: {
      theme: (
        /*theme*/
        e[25]
      ),
      preview: (
        /*preview*/
        e[21]
      ),
      elem_style: "width: 100%",
      alt_text: (
        /*file*/
        e[61].alt_text
      ),
      file: (
        /*file*/
        e[61].file
      )
    }
  }), {
    c() {
      create_component$1(t.$$.fragment);
    },
    l(a) {
      claim_component$1(t.$$.fragment, a);
    },
    m(a, o) {
      mount_component$1(t, a, o), r = !0;
    },
    p(a, o) {
      const u = {};
      o[0] & /*theme*/
      33554432 && (u.theme = /*theme*/
      a[25]), o[0] & /*preview*/
      2097152 && (u.preview = /*preview*/
      a[21]), o[0] & /*value*/
      1 && (u.alt_text = /*file*/
      a[61].alt_text), o[0] & /*value*/
      1 && (u.file = /*file*/
      a[61].file), t.$set(u);
    },
    i(a) {
      r || (transition_in$1(t.$$.fragment, a), r = !0);
    },
    o(a) {
      transition_out$1(t.$$.fragment, a), r = !1;
    },
    d(a) {
      destroy_component$1(t, a);
    }
  };
}
function create_each_block_3(e) {
  let t, r, a = (
    /*message*/
    e[58] && /*file*/
    e[61].file && create_if_block_7(e)
  );
  return {
    c() {
      a && a.c(), t = empty();
    },
    l(o) {
      a && a.l(o), t = empty();
    },
    m(o, u) {
      a && a.m(o, u), insert_hydration$1(o, t, u), r = !0;
    },
    p(o, u) {
      /*message*/
      o[58] && /*file*/
      o[61].file ? a ? (a.p(o, u), u[0] & /*value*/
      1 && transition_in$1(a, 1)) : (a = create_if_block_7(o), a.c(), transition_in$1(a, 1), a.m(t.parentNode, t)) : a && (group_outros$1(), transition_out$1(a, 1, 1, () => {
        a = null;
      }), check_outros$1());
    },
    i(o) {
      r || (transition_in$1(a), r = !0);
    },
    o(o) {
      transition_out$1(a), r = !1;
    },
    d(o) {
      o && detach$1(t), a && a.d(o);
    }
  };
}
function create_if_block_4(e) {
  let t, r, a, o, u = (
    /*likeable*/
    e[7] && /*j*/
    e[57] == 1 && create_if_block_6(e)
  ), c = (
    /*show_copy_button*/
    e[11] && /*message*/
    e[58] && typeof /*message*/
    e[58].text == "string" && create_if_block_5(e)
  );
  return {
    c() {
      t = element$1("div"), u && u.c(), r = space$1(), c && c.c(), this.h();
    },
    l(d) {
      t = claim_element$1(d, "DIV", {
        class: !0
      });
      var g = children$1(t);
      u && u.l(g), r = claim_space$1(g), c && c.l(g), g.forEach(detach$1), this.h();
    },
    h() {
      attr$1(t, "class", a = "message-buttons-" + /*j*/
      (e[57] == 0 ? "user" : "bot") + " message-buttons-" + /*layout*/
      e[19] + " " + /*get_message_avatar*/
      (e[33](
        /*message*/
        e[58],
        /*j*/
        e[57],
        /*k*/
        e[60]
      ) && "with-avatar") + " svelte-nl8xgc"), toggle_class(
        t,
        "message-buttons-fit",
        /*layout*/
        e[19] === "bubble" && !/*bubble_full_width*/
        e[16]
      ), toggle_class(
        t,
        "bubble-buttons-user",
        /*layout*/
        e[19] === "bubble"
      );
    },
    m(d, g) {
      insert_hydration$1(d, t, g), u && u.m(t, null), append_hydration$1(t, r), c && c.m(t, null), o = !0;
    },
    p(d, g) {
      /*likeable*/
      d[7] && /*j*/
      d[57] == 1 ? u ? (u.p(d, g), g[0] & /*likeable*/
      128 && transition_in$1(u, 1)) : (u = create_if_block_6(d), u.c(), transition_in$1(u, 1), u.m(t, r)) : u && (group_outros$1(), transition_out$1(u, 1, 1, () => {
        u = null;
      }), check_outros$1()), /*show_copy_button*/
      d[11] && /*message*/
      d[58] && typeof /*message*/
      d[58].text == "string" ? c ? (c.p(d, g), g[0] & /*show_copy_button, value*/
      2049 && transition_in$1(c, 1)) : (c = create_if_block_5(d), c.c(), transition_in$1(c, 1), c.m(t, null)) : c && (group_outros$1(), transition_out$1(c, 1, 1, () => {
        c = null;
      }), check_outros$1()), (!o || g[0] & /*layout, value*/
      524289 && a !== (a = "message-buttons-" + /*j*/
      (d[57] == 0 ? "user" : "bot") + " message-buttons-" + /*layout*/
      d[19] + " " + /*get_message_avatar*/
      (d[33](
        /*message*/
        d[58],
        /*j*/
        d[57],
        /*k*/
        d[60]
      ) && "with-avatar") + " svelte-nl8xgc")) && attr$1(t, "class", a), (!o || g[0] & /*layout, value, layout, bubble_full_width*/
      589825) && toggle_class(
        t,
        "message-buttons-fit",
        /*layout*/
        d[19] === "bubble" && !/*bubble_full_width*/
        d[16]
      ), (!o || g[0] & /*layout, value, layout*/
      524289) && toggle_class(
        t,
        "bubble-buttons-user",
        /*layout*/
        d[19] === "bubble"
      );
    },
    i(d) {
      o || (transition_in$1(u), transition_in$1(c), o = !0);
    },
    o(d) {
      transition_out$1(u), transition_out$1(c), o = !1;
    },
    d(d) {
      d && detach$1(t), u && u.d(), c && c.d();
    }
  };
}
function create_if_block_6(e) {
  let t, r, a, o;
  function u() {
    return (
      /*func*/
      e[44](
        /*i*/
        e[54],
        /*j*/
        e[57],
        /*k*/
        e[60],
        /*message*/
        e[58]
      )
    );
  }
  t = new LikeDislike({
    props: {
      action: "like",
      handle_action: u
    }
  });
  function c() {
    return (
      /*func_1*/
      e[45](
        /*i*/
        e[54],
        /*j*/
        e[57],
        /*k*/
        e[60],
        /*message*/
        e[58]
      )
    );
  }
  return a = new LikeDislike({
    props: {
      action: "dislike",
      handle_action: c
    }
  }), {
    c() {
      create_component$1(t.$$.fragment), r = space$1(), create_component$1(a.$$.fragment);
    },
    l(d) {
      claim_component$1(t.$$.fragment, d), r = claim_space$1(d), claim_component$1(a.$$.fragment, d);
    },
    m(d, g) {
      mount_component$1(t, d, g), insert_hydration$1(d, r, g), mount_component$1(a, d, g), o = !0;
    },
    p(d, g) {
      e = d;
      const b = {};
      g[0] & /*value*/
      1 && (b.handle_action = u), t.$set(b);
      const _ = {};
      g[0] & /*value*/
      1 && (_.handle_action = c), a.$set(_);
    },
    i(d) {
      o || (transition_in$1(t.$$.fragment, d), transition_in$1(a.$$.fragment, d), o = !0);
    },
    o(d) {
      transition_out$1(t.$$.fragment, d), transition_out$1(a.$$.fragment, d), o = !1;
    },
    d(d) {
      d && detach$1(r), destroy_component$1(t, d), destroy_component$1(a, d);
    }
  };
}
function create_if_block_5(e) {
  let t, r;
  return t = new Copy_1({
    props: {
      value: (
        /*message*/
        e[58].text
      )
    }
  }), {
    c() {
      create_component$1(t.$$.fragment);
    },
    l(a) {
      claim_component$1(t.$$.fragment, a);
    },
    m(a, o) {
      mount_component$1(t, a, o), r = !0;
    },
    p(a, o) {
      const u = {};
      o[0] & /*value*/
      1 && (u.value = /*message*/
      a[58].text), t.$set(u);
    },
    i(a) {
      r || (transition_in$1(t.$$.fragment, a), r = !0);
    },
    o(a) {
      transition_out$1(t.$$.fragment, a), r = !1;
    },
    d(a) {
      destroy_component$1(t, a);
    }
  };
}
function create_each_block_2(e, t) {
  let r, a, o, u = (
    /*message*/
    t[58] && create_if_block_3(t)
  );
  return {
    key: e,
    first: null,
    c() {
      r = empty(), u && u.c(), a = empty(), this.h();
    },
    l(c) {
      r = empty(), u && u.l(c), a = empty(), this.h();
    },
    h() {
      this.first = r;
    },
    m(c, d) {
      insert_hydration$1(c, r, d), u && u.m(c, d), insert_hydration$1(c, a, d), o = !0;
    },
    p(c, d) {
      t = c, /*message*/
      t[58] ? u ? (u.p(t, d), d[0] & /*value*/
      1 && transition_in$1(u, 1)) : (u = create_if_block_3(t), u.c(), transition_in$1(u, 1), u.m(a.parentNode, a)) : u && (group_outros$1(), transition_out$1(u, 1, 1, () => {
        u = null;
      }), check_outros$1());
    },
    i(c) {
      o || (transition_in$1(u), o = !0);
    },
    o(c) {
      transition_out$1(u), o = !1;
    },
    d(c) {
      c && (detach$1(r), detach$1(a)), u && u.d(c);
    }
  };
}
function create_each_block_1(e) {
  let t, r, a = (
    /*message_item*/
    e[55] && create_if_block_2(e)
  );
  return {
    c() {
      a && a.c(), t = empty();
    },
    l(o) {
      a && a.l(o), t = empty();
    },
    m(o, u) {
      a && a.m(o, u), insert_hydration$1(o, t, u), r = !0;
    },
    p(o, u) {
      /*message_item*/
      o[55] ? a ? (a.p(o, u), u[0] & /*value*/
      1 && transition_in$1(a, 1)) : (a = create_if_block_2(o), a.c(), transition_in$1(a, 1), a.m(t.parentNode, t)) : a && (group_outros$1(), transition_out$1(a, 1, 1, () => {
        a = null;
      }), check_outros$1());
    },
    i(o) {
      r || (transition_in$1(a), r = !0);
    },
    o(o) {
      transition_out$1(a), r = !1;
    },
    d(o) {
      o && detach$1(t), a && a.d(o);
    }
  };
}
function create_each_block(e) {
  let t, r, a = ensure_array_like(
    /*message_pair*/
    e[52]
  ), o = [];
  for (let c = 0; c < a.length; c += 1)
    o[c] = create_each_block_1(get_each_context_1(e, a, c));
  const u = (c) => transition_out$1(o[c], 1, 1, () => {
    o[c] = null;
  });
  return {
    c() {
      for (let c = 0; c < o.length; c += 1)
        o[c].c();
      t = empty();
    },
    l(c) {
      for (let d = 0; d < o.length; d += 1)
        o[d].l(c);
      t = empty();
    },
    m(c, d) {
      for (let g = 0; g < o.length; g += 1)
        o[g] && o[g].m(c, d);
      insert_hydration$1(c, t, d), r = !0;
    },
    p(c, d) {
      if (d[0] & /*value, layout, bubble_full_width, render_markdown, show_copy_button, likeable, rtl, selectable, handle_select, theme, preview, custom_components, flushing, complete_message, pending_message, flushing_speed, enable_base64, enable_latex, latex_delimiters, latex_single_dollar_delimiter, sanitize_html, line_breaks, scroll, handle_custom, avatar_image_align, avatar_image_width, avatar_images*/
      1946156287 | d[1] & /*get_message_avatar, handle_like, handle_flushed, get_message_name*/
      15) {
        a = ensure_array_like(
          /*message_pair*/
          c[52]
        );
        let g;
        for (g = 0; g < a.length; g += 1) {
          const b = get_each_context_1(c, a, g);
          o[g] ? (o[g].p(b, d), transition_in$1(o[g], 1)) : (o[g] = create_each_block_1(b), o[g].c(), transition_in$1(o[g], 1), o[g].m(t.parentNode, t));
        }
        for (group_outros$1(), g = a.length; g < o.length; g += 1)
          u(g);
        check_outros$1();
      }
    },
    i(c) {
      if (!r) {
        for (let d = 0; d < a.length; d += 1)
          transition_in$1(o[d]);
        r = !0;
      }
    },
    o(c) {
      o = o.filter(Boolean_1);
      for (let d = 0; d < o.length; d += 1)
        transition_out$1(o[d]);
      r = !1;
    },
    d(c) {
      c && detach$1(t), destroy_each(o, c);
    }
  };
}
function create_if_block_1$1(e) {
  let t, r;
  return t = new Pending({
    props: {
      layout: (
        /*layout*/
        e[19]
      )
    }
  }), {
    c() {
      create_component$1(t.$$.fragment);
    },
    l(a) {
      claim_component$1(t.$$.fragment, a);
    },
    m(a, o) {
      mount_component$1(t, a, o), r = !0;
    },
    p(a, o) {
      const u = {};
      o[0] & /*layout*/
      524288 && (u.layout = /*layout*/
      a[19]), t.$set(u);
    },
    i(a) {
      r || (transition_in$1(t.$$.fragment, a), r = !0);
    },
    o(a) {
      transition_out$1(t.$$.fragment, a), r = !1;
    },
    d(a) {
      destroy_component$1(t, a);
    }
  };
}
function create_fragment$1(e) {
  let t, r, a, o, u, c, d, g = (
    /*show_share_button*/
    e[8] && /*value*/
    e[0] && /*value*/
    e[0].length > 0 && create_if_block_10(e)
  ), b = (
    /*value*/
    e[0] && create_if_block$1(e)
  );
  return {
    c() {
      g && g.c(), t = space$1(), r = element$1("div"), a = element$1("div"), b && b.c(), this.h();
    },
    l(_) {
      g && g.l(_), t = claim_space$1(_), r = claim_element$1(_, "DIV", {
        class: !0,
        role: !0,
        "aria-label": !0,
        "aria-live": !0
      });
      var y = children$1(r);
      a = claim_element$1(y, "DIV", {
        class: !0
      });
      var A = children$1(a);
      b && b.l(A), A.forEach(detach$1), y.forEach(detach$1), this.h();
    },
    h() {
      attr$1(a, "class", "message-wrap svelte-nl8xgc"), toggle_class(
        a,
        "bubble-gap",
        /*layout*/
        e[19] === "bubble"
      ), attr$1(r, "class", o = null_to_empty(
        /*layout*/
        e[19] === "bubble" ? "bubble-wrap" : "panel-wrap"
      ) + " svelte-nl8xgc"), attr$1(r, "role", "log"), attr$1(r, "aria-label", "chatbot conversation"), attr$1(r, "aria-live", "polite");
    },
    m(_, y) {
      g && g.m(_, y), insert_hydration$1(_, t, y), insert_hydration$1(_, r, y), append_hydration$1(r, a), b && b.m(a, null), e[46](r), u = !0, c || (d = [action_destroyer(copy$1.call(null, a)), listen(
        r,
        "scroll",
        /*on_container_scroll*/
        e[27]
      )], c = !0);
    },
    p(_, y) {
      /*show_share_button*/
      _[8] && /*value*/
      _[0] && /*value*/
      _[0].length > 0 ? g ? (g.p(_, y), y[0] & /*show_share_button, value*/
      257 && transition_in$1(g, 1)) : (g = create_if_block_10(_), g.c(), transition_in$1(g, 1), g.m(t.parentNode, t)) : g && (group_outros$1(), transition_out$1(g, 1, 1, () => {
        g = null;
      }), check_outros$1()), /*value*/
      _[0] ? b ? (b.p(_, y), y[0] & /*value*/
      1 && transition_in$1(b, 1)) : (b = create_if_block$1(_), b.c(), transition_in$1(b, 1), b.m(a, null)) : b && (group_outros$1(), transition_out$1(b, 1, 1, () => {
        b = null;
      }), check_outros$1()), (!u || y[0] & /*layout*/
      524288) && toggle_class(
        a,
        "bubble-gap",
        /*layout*/
        _[19] === "bubble"
      ), (!u || y[0] & /*layout*/
      524288 && o !== (o = null_to_empty(
        /*layout*/
        _[19] === "bubble" ? "bubble-wrap" : "panel-wrap"
      ) + " svelte-nl8xgc")) && attr$1(r, "class", o);
    },
    i(_) {
      u || (transition_in$1(g), transition_in$1(b), u = !0);
    },
    o(_) {
      transition_out$1(g), transition_out$1(b), u = !1;
    },
    d(_) {
      _ && (detach$1(t), detach$1(r)), g && g.d(_), b && b.d(), e[46](null), c = !1, run_all(d);
    }
  };
}
function instance$1(e, t, r) {
  let {
    value: a
  } = t, o = null, {
    enable_latex: u
  } = t, {
    latex_single_dollar_delimiter: c
  } = t, {
    latex_delimiters: d
  } = t, {
    pending_message: g = !1
  } = t, {
    complete_message: b = !1
  } = t, {
    selectable: _ = !1
  } = t, {
    likeable: y = !1
  } = t, {
    show_share_button: A = !1
  } = t, {
    i18n: E
  } = t, {
    rtl: v = !1
  } = t, {
    show_copy_button: C = !1
  } = t, {
    avatar_images: R = [[], []]
  } = t, {
    avatar_image_align: I = "bottom"
  } = t, {
    avatar_image_width: w = 45
  } = t, {
    sanitize_html: N = !0
  } = t, {
    bubble_full_width: F = !0
  } = t, {
    render_markdown: M = !0
  } = t, {
    line_breaks: x = !0
  } = t, {
    root: P
  } = t, {
    proxy_url: U
  } = t, {
    layout: L = "bubble"
  } = t, {
    enable_base64: H = !1
  } = t, {
    preview: B = !0
  } = t, {
    flushing: V = !0
  } = t, {
    custom_components: X = {}
  } = t, {
    flushing_speed: de = 3
  } = t, {
    theme: Y = "light"
  } = t, se, ue, pe = !1, J = !1, j;
  const le = createEventDispatcher(), Z = () => {
    if (pe) {
      pe = !1;
      return;
    }
    J = !0, j && clearTimeout(j), ue = !0, j = setTimeout(() => {
      ue = !1;
    }, 500);
  }, O = () => {
    (J ? se && se.offsetHeight + se.scrollTop > se.scrollHeight - 100 : !0) && !ue && (pe = !0, se.scrollTo(0, se.scrollHeight));
  };
  afterUpdate(() => {
    O(), se.querySelectorAll("img").forEach((K) => {
      K.addEventListener("load", () => {
        O();
      });
    });
  });
  function z(K, fe, be, ke) {
    le("custom", {
      index: [K, fe, be],
      ...ke
    });
  }
  function W(K, fe, be, ke) {
    le("select", {
      index: [K, fe, be],
      value: ke
    });
  }
  function ee(K, fe, be, ke) {
    le("flushed", {
      index: [K, fe, be],
      value: ke
    });
  }
  function ae(K, fe, be, ke, Fe) {
    le("like", {
      index: [K, fe, be],
      value: ke,
      liked: Fe
    });
  }
  function ie(K, fe, be) {
    const ke = R[fe][be];
    return get_fetchable_url_or_file(typeof K.avatar == "object" && K.avatar ? K.avatar.path : typeof ke == "object" ? (ke == null ? void 0 : ke.avatar) || null : ke, P, U);
  }
  function me(K, fe, be) {
    const ke = R[fe][be];
    return K.name || (typeof ke == "object" ? ke == null ? void 0 : ke.name : null);
  }
  function ye(K) {
    bubble.call(this, e, K);
  }
  const Re = (K) => {
    copy_to_clipboard(K.detail.description);
  }, De = (K, fe, be, ke) => z(K, fe, be, ke.detail), Pe = (K, fe, be, ke) => ee(K, fe, be, ke.detail), he = (K, fe, be, ke) => W(K, fe, be, ke), Le = (K, fe, be, ke, Fe) => {
    Fe.key === "Enter" && W(K, fe, be, ke);
  }, Ee = (K, fe, be, ke) => ae(K, fe, be, ke, !0), Se = (K, fe, be, ke) => ae(K, fe, be, ke, !1);
  function Q(K) {
    binding_callbacks[K ? "unshift" : "push"](() => {
      se = K, r(26, se);
    });
  }
  return e.$$set = (K) => {
    "value" in K && r(0, a = K.value), "enable_latex" in K && r(1, u = K.enable_latex), "latex_single_dollar_delimiter" in K && r(2, c = K.latex_single_dollar_delimiter), "latex_delimiters" in K && r(3, d = K.latex_delimiters), "pending_message" in K && r(4, g = K.pending_message), "complete_message" in K && r(5, b = K.complete_message), "selectable" in K && r(6, _ = K.selectable), "likeable" in K && r(7, y = K.likeable), "show_share_button" in K && r(8, A = K.show_share_button), "i18n" in K && r(9, E = K.i18n), "rtl" in K && r(10, v = K.rtl), "show_copy_button" in K && r(11, C = K.show_copy_button), "avatar_images" in K && r(12, R = K.avatar_images), "avatar_image_align" in K && r(13, I = K.avatar_image_align), "avatar_image_width" in K && r(14, w = K.avatar_image_width), "sanitize_html" in K && r(15, N = K.sanitize_html), "bubble_full_width" in K && r(16, F = K.bubble_full_width), "render_markdown" in K && r(17, M = K.render_markdown), "line_breaks" in K && r(18, x = K.line_breaks), "root" in K && r(35, P = K.root), "proxy_url" in K && r(36, U = K.proxy_url), "layout" in K && r(19, L = K.layout), "enable_base64" in K && r(20, H = K.enable_base64), "preview" in K && r(21, B = K.preview), "flushing" in K && r(22, V = K.flushing), "custom_components" in K && r(23, X = K.custom_components), "flushing_speed" in K && r(24, de = K.flushing_speed), "theme" in K && r(25, Y = K.theme);
  }, e.$$.update = () => {
    var K, fe, be, ke;
    e.$$.dirty[0] & /*value*/
    1 | e.$$.dirty[1] & /*old_value*/
    64 && (((a == null ? void 0 : a.length) !== (o == null ? void 0 : o.length) || a && o && ((fe = (K = a.at(-1)) == null ? void 0 : K.filter(Boolean)) == null ? void 0 : fe.length) !== ((ke = (be = o.at(-1)) == null ? void 0 : be.filter(Boolean)) == null ? void 0 : ke.length)) && (J = !1), dequal(a, o) || (r(37, o = a), le("change")));
  }, [a, u, c, d, g, b, _, y, A, E, v, C, R, I, w, N, F, M, x, L, H, B, V, X, de, Y, se, Z, O, z, W, ee, ae, ie, me, P, U, o, ye, Re, De, Pe, he, Le, Ee, Se, Q];
}
class ChatBot extends SvelteComponent$1 {
  constructor(t) {
    super(), init$1(this, t, instance$1, create_fragment$1, safe_not_equal$1, {
      value: 0,
      enable_latex: 1,
      latex_single_dollar_delimiter: 2,
      latex_delimiters: 3,
      pending_message: 4,
      complete_message: 5,
      selectable: 6,
      likeable: 7,
      show_share_button: 8,
      i18n: 9,
      rtl: 10,
      show_copy_button: 11,
      avatar_images: 12,
      avatar_image_align: 13,
      avatar_image_width: 14,
      sanitize_html: 15,
      bubble_full_width: 16,
      render_markdown: 17,
      line_breaks: 18,
      root: 35,
      proxy_url: 36,
      layout: 19,
      enable_base64: 20,
      preview: 21,
      flushing: 22,
      custom_components: 23,
      flushing_speed: 24,
      theme: 25
    }, null, [-1, -1, -1]);
  }
}
const {
  SvelteComponent,
  append_hydration,
  assign,
  attr,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  create_component,
  destroy_component,
  detach,
  element,
  get_spread_object,
  get_spread_update,
  group_outros,
  init,
  insert_hydration,
  mount_component,
  safe_not_equal,
  space,
  transition_in,
  transition_out
} = window.__gradio__svelte__internal;
function create_if_block_1(e) {
  let t, r;
  const a = [
    {
      autoscroll: (
        /*gradio*/
        e[23].autoscroll
      )
    },
    {
      i18n: (
        /*gradio*/
        e[23].i18n
      )
    },
    /*loading_status*/
    e[31],
    {
      show_progress: (
        /*loading_status*/
        e[31].show_progress === "hidden" ? "hidden" : "minimal"
      )
    }
  ];
  let o = {};
  for (let u = 0; u < a.length; u += 1)
    o = assign(o, a[u]);
  return t = new Static({
    props: o
  }), {
    c() {
      create_component(t.$$.fragment);
    },
    l(u) {
      claim_component(t.$$.fragment, u);
    },
    m(u, c) {
      mount_component(t, u, c), r = !0;
    },
    p(u, c) {
      const d = c[0] & /*gradio*/
      8388608 | c[1] & /*loading_status*/
      1 ? get_spread_update(a, [c[0] & /*gradio*/
      8388608 && {
        autoscroll: (
          /*gradio*/
          u[23].autoscroll
        )
      }, c[0] & /*gradio*/
      8388608 && {
        i18n: (
          /*gradio*/
          u[23].i18n
        )
      }, c[1] & /*loading_status*/
      1 && get_spread_object(
        /*loading_status*/
        u[31]
      ), c[1] & /*loading_status*/
      1 && {
        show_progress: (
          /*loading_status*/
          u[31].show_progress === "hidden" ? "hidden" : "minimal"
        )
      }]) : {};
      t.$set(d);
    },
    i(u) {
      r || (transition_in(t.$$.fragment, u), r = !0);
    },
    o(u) {
      transition_out(t.$$.fragment, u), r = !1;
    },
    d(u) {
      destroy_component(t, u);
    }
  };
}
function create_if_block(e) {
  let t, r;
  return t = new BlockLabel({
    props: {
      show_label: (
        /*show_label*/
        e[6]
      ),
      Icon: Chat,
      float: !1,
      label: (
        /*label*/
        e[5] || "Chatbot"
      )
    }
  }), {
    c() {
      create_component(t.$$.fragment);
    },
    l(a) {
      claim_component(t.$$.fragment, a);
    },
    m(a, o) {
      mount_component(t, a, o), r = !0;
    },
    p(a, o) {
      const u = {};
      o[0] & /*show_label*/
      64 && (u.show_label = /*show_label*/
      a[6]), o[0] & /*label*/
      32 && (u.label = /*label*/
      a[5] || "Chatbot"), t.$set(u);
    },
    i(a) {
      r || (transition_in(t.$$.fragment, a), r = !0);
    },
    o(a) {
      transition_out(t.$$.fragment, a), r = !1;
    },
    d(a) {
      destroy_component(t, a);
    }
  };
}
function create_default_slot(e) {
  var g, b;
  let t, r, a, o, u, c = (
    /*loading_status*/
    e[31] && create_if_block_1(e)
  ), d = (
    /*show_label*/
    e[6] && create_if_block(e)
  );
  return o = new ChatBot({
    props: {
      i18n: (
        /*gradio*/
        e[23].i18n
      ),
      selectable: (
        /*_selectable*/
        e[10]
      ),
      likeable: (
        /*likeable*/
        e[11]
      ),
      flushing: (
        /*flushing*/
        e[28]
      ),
      flushing_speed: (
        /*flushing_speed*/
        e[29]
      ),
      show_share_button: (
        /*show_share_button*/
        e[12]
      ),
      value: (
        /*_value*/
        e[33]
      ),
      enable_latex: (
        /*enable_latex*/
        e[20]
      ),
      latex_single_dollar_delimiter: (
        /*latex_single_dollar_delimiter*/
        e[21]
      ),
      latex_delimiters: (
        /*latex_delimiters*/
        e[22]
      ),
      render_markdown: (
        /*render_markdown*/
        e[18]
      ),
      complete_message: !/*loading_status*/
      e[31] || /*loading_status*/
      ((g = e[31]) == null ? void 0 : g.status) === "complete",
      pending_message: (
        /*loading_status*/
        ((b = e[31]) == null ? void 0 : b.status) === "pending"
      ),
      rtl: (
        /*rtl*/
        e[13]
      ),
      show_copy_button: (
        /*show_copy_button*/
        e[14]
      ),
      avatar_images: (
        /*_avatar_images*/
        e[34]
      ),
      avatar_image_align: (
        /*avatar_image_align*/
        e[24]
      ),
      avatar_image_width: (
        /*avatar_image_width*/
        e[25]
      ),
      sanitize_html: (
        /*sanitize_html*/
        e[15]
      ),
      enable_base64: (
        /*enable_base64*/
        e[26]
      ),
      preview: (
        /*preview*/
        e[27]
      ),
      bubble_full_width: (
        /*bubble_full_width*/
        e[16]
      ),
      line_breaks: (
        /*line_breaks*/
        e[19]
      ),
      layout: (
        /*layout*/
        e[17]
      ),
      proxy_url: (
        /*proxy_url*/
        e[8]
      ),
      root: (
        /*root*/
        e[7]
      ),
      custom_components: (
        /*custom_components*/
        e[30]
      ),
      theme: (
        /*gradio*/
        e[23].theme
      )
    }
  }), o.$on(
    "change",
    /*change_handler*/
    e[37]
  ), o.$on(
    "select",
    /*select_handler*/
    e[38]
  ), o.$on(
    "like",
    /*like_handler*/
    e[39]
  ), o.$on(
    "share",
    /*share_handler*/
    e[40]
  ), o.$on(
    "error",
    /*error_handler*/
    e[41]
  ), o.$on(
    "custom",
    /*custom_handler*/
    e[42]
  ), o.$on(
    "flushed",
    /*flushed_handler*/
    e[43]
  ), {
    c() {
      c && c.c(), t = space(), r = element("div"), d && d.c(), a = space(), create_component(o.$$.fragment), this.h();
    },
    l(_) {
      c && c.l(_), t = claim_space(_), r = claim_element(_, "DIV", {
        class: !0
      });
      var y = children(r);
      d && d.l(y), a = claim_space(y), claim_component(o.$$.fragment, y), y.forEach(detach), this.h();
    },
    h() {
      attr(r, "class", "wrapper svelte-709c50");
    },
    m(_, y) {
      c && c.m(_, y), insert_hydration(_, t, y), insert_hydration(_, r, y), d && d.m(r, null), append_hydration(r, a), mount_component(o, r, null), u = !0;
    },
    p(_, y) {
      var E, v;
      /*loading_status*/
      _[31] ? c ? (c.p(_, y), y[1] & /*loading_status*/
      1 && transition_in(c, 1)) : (c = create_if_block_1(_), c.c(), transition_in(c, 1), c.m(t.parentNode, t)) : c && (group_outros(), transition_out(c, 1, 1, () => {
        c = null;
      }), check_outros()), /*show_label*/
      _[6] ? d ? (d.p(_, y), y[0] & /*show_label*/
      64 && transition_in(d, 1)) : (d = create_if_block(_), d.c(), transition_in(d, 1), d.m(r, a)) : d && (group_outros(), transition_out(d, 1, 1, () => {
        d = null;
      }), check_outros());
      const A = {};
      y[0] & /*gradio*/
      8388608 && (A.i18n = /*gradio*/
      _[23].i18n), y[0] & /*_selectable*/
      1024 && (A.selectable = /*_selectable*/
      _[10]), y[0] & /*likeable*/
      2048 && (A.likeable = /*likeable*/
      _[11]), y[0] & /*flushing*/
      268435456 && (A.flushing = /*flushing*/
      _[28]), y[0] & /*flushing_speed*/
      536870912 && (A.flushing_speed = /*flushing_speed*/
      _[29]), y[0] & /*show_share_button*/
      4096 && (A.show_share_button = /*show_share_button*/
      _[12]), y[1] & /*_value*/
      4 && (A.value = /*_value*/
      _[33]), y[0] & /*enable_latex*/
      1048576 && (A.enable_latex = /*enable_latex*/
      _[20]), y[0] & /*latex_single_dollar_delimiter*/
      2097152 && (A.latex_single_dollar_delimiter = /*latex_single_dollar_delimiter*/
      _[21]), y[0] & /*latex_delimiters*/
      4194304 && (A.latex_delimiters = /*latex_delimiters*/
      _[22]), y[0] & /*render_markdown*/
      262144 && (A.render_markdown = /*render_markdown*/
      _[18]), y[1] & /*loading_status*/
      1 && (A.complete_message = !/*loading_status*/
      _[31] || /*loading_status*/
      ((E = _[31]) == null ? void 0 : E.status) === "complete"), y[1] & /*loading_status*/
      1 && (A.pending_message = /*loading_status*/
      ((v = _[31]) == null ? void 0 : v.status) === "pending"), y[0] & /*rtl*/
      8192 && (A.rtl = /*rtl*/
      _[13]), y[0] & /*show_copy_button*/
      16384 && (A.show_copy_button = /*show_copy_button*/
      _[14]), y[1] & /*_avatar_images*/
      8 && (A.avatar_images = /*_avatar_images*/
      _[34]), y[0] & /*avatar_image_align*/
      16777216 && (A.avatar_image_align = /*avatar_image_align*/
      _[24]), y[0] & /*avatar_image_width*/
      33554432 && (A.avatar_image_width = /*avatar_image_width*/
      _[25]), y[0] & /*sanitize_html*/
      32768 && (A.sanitize_html = /*sanitize_html*/
      _[15]), y[0] & /*enable_base64*/
      67108864 && (A.enable_base64 = /*enable_base64*/
      _[26]), y[0] & /*preview*/
      134217728 && (A.preview = /*preview*/
      _[27]), y[0] & /*bubble_full_width*/
      65536 && (A.bubble_full_width = /*bubble_full_width*/
      _[16]), y[0] & /*line_breaks*/
      524288 && (A.line_breaks = /*line_breaks*/
      _[19]), y[0] & /*layout*/
      131072 && (A.layout = /*layout*/
      _[17]), y[0] & /*proxy_url*/
      256 && (A.proxy_url = /*proxy_url*/
      _[8]), y[0] & /*root*/
      128 && (A.root = /*root*/
      _[7]), y[0] & /*custom_components*/
      1073741824 && (A.custom_components = /*custom_components*/
      _[30]), y[0] & /*gradio*/
      8388608 && (A.theme = /*gradio*/
      _[23].theme), o.$set(A);
    },
    i(_) {
      u || (transition_in(c), transition_in(d), transition_in(o.$$.fragment, _), u = !0);
    },
    o(_) {
      transition_out(c), transition_out(d), transition_out(o.$$.fragment, _), u = !1;
    },
    d(_) {
      _ && (detach(t), detach(r)), c && c.d(_), d && d.d(), destroy_component(o);
    }
  };
}
function create_fragment(e) {
  let t, r;
  return t = new Block({
    props: {
      elem_id: (
        /*elem_id*/
        e[0]
      ),
      elem_classes: (
        /*elem_classes*/
        e[1]
      ),
      visible: (
        /*visible*/
        e[2]
      ),
      padding: !1,
      scale: (
        /*scale*/
        e[3]
      ),
      min_width: (
        /*min_width*/
        e[4]
      ),
      height: (
        /*height*/
        e[32]
      ),
      allow_overflow: !1,
      $$slots: {
        default: [create_default_slot]
      },
      $$scope: {
        ctx: e
      }
    }
  }), {
    c() {
      create_component(t.$$.fragment);
    },
    l(a) {
      claim_component(t.$$.fragment, a);
    },
    m(a, o) {
      mount_component(t, a, o), r = !0;
    },
    p(a, o) {
      const u = {};
      o[0] & /*elem_id*/
      1 && (u.elem_id = /*elem_id*/
      a[0]), o[0] & /*elem_classes*/
      2 && (u.elem_classes = /*elem_classes*/
      a[1]), o[0] & /*visible*/
      4 && (u.visible = /*visible*/
      a[2]), o[0] & /*scale*/
      8 && (u.scale = /*scale*/
      a[3]), o[0] & /*min_width*/
      16 && (u.min_width = /*min_width*/
      a[4]), o[1] & /*height*/
      2 && (u.height = /*height*/
      a[32]), o[0] & /*gradio, _selectable, likeable, flushing, flushing_speed, show_share_button, enable_latex, latex_single_dollar_delimiter, latex_delimiters, render_markdown, rtl, show_copy_button, avatar_image_align, avatar_image_width, sanitize_html, enable_base64, preview, bubble_full_width, line_breaks, layout, proxy_url, root, custom_components, value, show_label, label*/
      2147483616 | o[1] & /*$$scope, _value, loading_status, _avatar_images*/
      65549 && (u.$$scope = {
        dirty: o,
        ctx: a
      }), t.$set(u);
    },
    i(a) {
      r || (transition_in(t.$$.fragment, a), r = !0);
    },
    o(a) {
      transition_out(t.$$.fragment, a), r = !1;
    },
    d(a) {
      destroy_component(t, a);
    }
  };
}
function instance(e, t, r) {
  let {
    elem_id: a = ""
  } = t, {
    elem_classes: o = []
  } = t, {
    visible: u = !0
  } = t, {
    scale: c = null
  } = t, {
    min_width: d = void 0
  } = t, {
    label: g
  } = t, {
    show_label: b = !0
  } = t, {
    root: _
  } = t, {
    proxy_url: y
  } = t, {
    value: A = []
  } = t, {
    _selectable: E = !1
  } = t, {
    likeable: v = !1
  } = t, {
    show_share_button: C = !1
  } = t, {
    rtl: R = !1
  } = t, {
    show_copy_button: I = !1
  } = t, {
    sanitize_html: w = !0
  } = t, {
    bubble_full_width: N = !0
  } = t, {
    layout: F = "bubble"
  } = t, {
    render_markdown: M = !0
  } = t, {
    line_breaks: x = !0
  } = t, {
    enable_latex: P
  } = t, {
    latex_single_dollar_delimiter: U
  } = t, {
    latex_delimiters: L
  } = t, {
    gradio: H
  } = t, {
    avatar_images: B = [null, null]
  } = t, {
    avatar_image_align: V = "bottom"
  } = t, {
    avatar_image_width: X
  } = t, {
    enable_base64: de = !1
  } = t, {
    preview: Y = !0
  } = t, {
    flushing: se = !1
  } = t, {
    flushing_speed: ue = 3
  } = t, {
    llm_thinking_presets: pe = []
  } = t, {
    custom_components: J = {}
  } = t, j, le;
  const Z = (he) => {
    const Le = `${_}${y ? `/proxy=${y.endsWith("/") ? y.slice(0, -1) : y}` : ""}${gradio_version >= 5 ? "/gradio_api" : ""}/file=`;
    return he.includes(Le) ? he : he.replaceAll("/file=", Le);
  };
  function O(he) {
    return he === null ? he : {
      file: normalise_file(he == null ? void 0 : he.file, _, y),
      alt_text: he == null ? void 0 : he.alt_text
    };
  }
  function z(he) {
    return he ? ensureArray(he).map((Le) => Le ? (Le.text = Z(Le.text), Le.text = resolve_llm_thinking_presets(Le.text, pe), Le.files = (Le.files || []).map(O), Le) : null) : null;
  }
  let {
    loading_status: W = void 0
  } = t, {
    height: ee = 400
  } = t;
  const ae = () => H.dispatch("change", A), ie = (he) => H.dispatch("select", he.detail), me = (he) => H.dispatch("like", he.detail), ye = (he) => H.dispatch("share", he.detail), Re = (he) => H.dispatch("error", he.detail), De = (he) => H.dispatch("custom", he.detail), Pe = (he) => H.dispatch("flushed", he.detail);
  return e.$$set = (he) => {
    "elem_id" in he && r(0, a = he.elem_id), "elem_classes" in he && r(1, o = he.elem_classes), "visible" in he && r(2, u = he.visible), "scale" in he && r(3, c = he.scale), "min_width" in he && r(4, d = he.min_width), "label" in he && r(5, g = he.label), "show_label" in he && r(6, b = he.show_label), "root" in he && r(7, _ = he.root), "proxy_url" in he && r(8, y = he.proxy_url), "value" in he && r(9, A = he.value), "_selectable" in he && r(10, E = he._selectable), "likeable" in he && r(11, v = he.likeable), "show_share_button" in he && r(12, C = he.show_share_button), "rtl" in he && r(13, R = he.rtl), "show_copy_button" in he && r(14, I = he.show_copy_button), "sanitize_html" in he && r(15, w = he.sanitize_html), "bubble_full_width" in he && r(16, N = he.bubble_full_width), "layout" in he && r(17, F = he.layout), "render_markdown" in he && r(18, M = he.render_markdown), "line_breaks" in he && r(19, x = he.line_breaks), "enable_latex" in he && r(20, P = he.enable_latex), "latex_single_dollar_delimiter" in he && r(21, U = he.latex_single_dollar_delimiter), "latex_delimiters" in he && r(22, L = he.latex_delimiters), "gradio" in he && r(23, H = he.gradio), "avatar_images" in he && r(35, B = he.avatar_images), "avatar_image_align" in he && r(24, V = he.avatar_image_align), "avatar_image_width" in he && r(25, X = he.avatar_image_width), "enable_base64" in he && r(26, de = he.enable_base64), "preview" in he && r(27, Y = he.preview), "flushing" in he && r(28, se = he.flushing), "flushing_speed" in he && r(29, ue = he.flushing_speed), "llm_thinking_presets" in he && r(36, pe = he.llm_thinking_presets), "custom_components" in he && r(30, J = he.custom_components), "loading_status" in he && r(31, W = he.loading_status), "height" in he && r(32, ee = he.height);
  }, e.$$.update = () => {
    e.$$.dirty[1] & /*avatar_images*/
    16 && r(34, le = B ? B.map((he) => he ? ensureArray(he) : []) : [[], []]), e.$$.dirty[0] & /*value*/
    512 && r(33, j = A ? A.map(([he, Le]) => [z(he), z(Le)]) : []);
  }, [a, o, u, c, d, g, b, _, y, A, E, v, C, R, I, w, N, F, M, x, P, U, L, H, V, X, de, Y, se, ue, J, W, ee, j, le, B, pe, ae, ie, me, ye, Re, De, Pe];
}
class Awaited extends SvelteComponent {
  constructor(t) {
    super(), init(this, t, instance, create_fragment, safe_not_equal, {
      elem_id: 0,
      elem_classes: 1,
      visible: 2,
      scale: 3,
      min_width: 4,
      label: 5,
      show_label: 6,
      root: 7,
      proxy_url: 8,
      value: 9,
      _selectable: 10,
      likeable: 11,
      show_share_button: 12,
      rtl: 13,
      show_copy_button: 14,
      sanitize_html: 15,
      bubble_full_width: 16,
      layout: 17,
      render_markdown: 18,
      line_breaks: 19,
      enable_latex: 20,
      latex_single_dollar_delimiter: 21,
      latex_delimiters: 22,
      gradio: 23,
      avatar_images: 35,
      avatar_image_align: 24,
      avatar_image_width: 25,
      enable_base64: 26,
      preview: 27,
      flushing: 28,
      flushing_speed: 29,
      llm_thinking_presets: 36,
      custom_components: 30,
      loading_status: 31,
      height: 32
    }, null, [-1, -1]);
  }
}
export {
  ChatBot as BaseChatBot,
  Awaited as default
};
